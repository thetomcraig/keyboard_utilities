
kiibohd.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000cac0  00001000  00001000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .usbdescriptortable 00000160  1fffe000  1fffe000  0001e000  2**2
                  ALLOC
  2 .dmabuffers   00000000  1fffe160  1fffe160  0000f044  2**0
                  CONTENTS
  3 .usbbuffers   00000870  1fffe160  1fffe160  0001e000  2**0
                  ALLOC
  4 .data         00000674  1fffe9d0  0000dac0  0000e9d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00001778  1ffff044  0000e134  0000f044  2**2
                  ALLOC
  6 .debug_info   0001ac1d  00000000  00000000  0000f044  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004484  00000000  00000000  00029c61  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000d10  00000000  00000000  0002e0e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00001a50  00000000  00000000  0002edf5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  00010949  00000000  00000000  00030845  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000b68c  00000000  00000000  0004118e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00034ba7  00000000  00000000  0004c81a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000007f  00000000  00000000  000813c1  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000033  00000000  00000000  00081440  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00002cc0  00000000  00000000  00081474  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000a97f  00000000  00000000  00084134  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00001000 <gVectors>:
    1000:	00 20 00 20 f9 10 00 00 49 13 00 00 71 13 00 00     . . ....I...q...
    1010:	bd 13 00 00 15 14 00 00 6d 14 00 00 f1 12 00 00     ........m.......
    1020:	f1 12 00 00 f1 12 00 00 f1 12 00 00 39 13 00 00     ............9...
    1030:	39 13 00 00 f1 12 00 00 39 13 00 00 95 12 00 00     9.......9.......
    1040:	39 13 00 00 39 13 00 00 39 13 00 00 39 13 00 00     9...9...9...9...
    1050:	39 13 00 00 39 13 00 00 39 13 00 00 39 13 00 00     9...9...9...9...
    1060:	39 13 00 00 39 13 00 00 ad 14 00 00 39 13 00 00     9...9.......9...
    1070:	39 13 00 00 39 13 00 00 39 13 00 00 39 13 00 00     9...9...9...9...
    1080:	39 13 00 00 39 13 00 00 39 13 00 00 39 13 00 00     9...9...9...9...
    1090:	39 13 00 00 39 13 00 00 39 13 00 00 39 13 00 00     9...9...9...9...
    10a0:	39 13 00 00 39 13 00 00 39 13 00 00 39 13 00 00     9...9...9...9...
    10b0:	39 13 00 00 39 13 00 00 d1 1a 00 00 39 13 00 00     9...9.......9...
    10c0:	39 13 00 00 39 13 00 00 39 13 00 00 49 75 00 00     9...9...9...Iu..
    10d0:	39 13 00 00 39 13 00 00 39 13 00 00 b5 17 00 00     9...9...9.......
    10e0:	39 13 00 00 39 13 00 00 39 13 00 00 39 13 00 00     9...9...9...9...
    10f0:	39 13 00 00 39 13 00 00                             9...9...

000010f8 <ResetHandler>:

// ----- Chip Entry Point -----

__attribute__ ((section(".startup")))
void ResetHandler()
{
    10f8:	b507      	push	{r0, r1, r2, lr}
    10fa:	4b2d      	ldr	r3, [pc, #180]	; (11b0 <ResetHandler+0xb8>)
	// Disable Watchdog
	while ( WDOG_TMROUTL < 2 ); // Must wait for WDOG timer if already running, before jumping
    10fc:	4a2d      	ldr	r2, [pc, #180]	; (11b4 <ResetHandler+0xbc>)
{
    10fe:	681b      	ldr	r3, [r3, #0]
    1100:	9301      	str	r3, [sp, #4]
	while ( WDOG_TMROUTL < 2 ); // Must wait for WDOG timer if already running, before jumping
    1102:	8813      	ldrh	r3, [r2, #0]
    1104:	2b01      	cmp	r3, #1
    1106:	d9fc      	bls.n	1102 <ResetHandler+0xa>
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
    1108:	4b2b      	ldr	r3, [pc, #172]	; (11b8 <ResetHandler+0xc0>)
    110a:	f24c 5220 	movw	r2, #50464	; 0xc520
    110e:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
    1110:	f64d 1228 	movw	r2, #55592	; 0xd928
    1114:	801a      	strh	r2, [r3, #0]
	WDOG_STCTRLH &= ~WDOG_STCTRLH_WDOGEN;
    1116:	4a29      	ldr	r2, [pc, #164]	; (11bc <ResetHandler+0xc4>)
    1118:	8813      	ldrh	r3, [r2, #0]
    111a:	f023 0301 	bic.w	r3, r3, #1
    111e:	041b      	lsls	r3, r3, #16
    1120:	0c1b      	lsrs	r3, r3, #16
    1122:	8013      	strh	r3, [r2, #0]

	uint32_t *src = (uint32_t*)&_etext;
	uint32_t *dest = (uint32_t*)&_sdata;

	// Enable clocks to always-used peripherals
	SIM_SCGC5 = 0x00043F82; // Clocks active to all GPIO
    1124:	4b26      	ldr	r3, [pc, #152]	; (11c0 <ResetHandler+0xc8>)
    1126:	4a27      	ldr	r2, [pc, #156]	; (11c4 <ResetHandler+0xcc>)
    1128:	601a      	str	r2, [r3, #0]
	SIM_SCGC6 = SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
    112a:	4a27      	ldr	r2, [pc, #156]	; (11c8 <ResetHandler+0xd0>)
    112c:	605a      	str	r2, [r3, #4]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif

	// release I/O pins hold, if we woke up from VLLS mode
	if ( PMC_REGSC & PMC_REGSC_ACKISO )
    112e:	f503 3353 	add.w	r3, r3, #216064	; 0x34c00
    1132:	f203 33ca 	addw	r3, r3, #970	; 0x3ca
    1136:	781a      	ldrb	r2, [r3, #0]
    1138:	0711      	lsls	r1, r2, #28
	{
		PMC_REGSC |= PMC_REGSC_ACKISO;
    113a:	bf48      	it	mi
    113c:	781a      	ldrbmi	r2, [r3, #0]
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
	// Prepare RAM
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    113e:	4923      	ldr	r1, [pc, #140]	; (11cc <ResetHandler+0xd4>)
		PMC_REGSC |= PMC_REGSC_ACKISO;
    1140:	bf44      	itt	mi
    1142:	f042 0208 	orrmi.w	r2, r2, #8
    1146:	701a      	strbmi	r2, [r3, #0]
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
    1148:	4b21      	ldr	r3, [pc, #132]	; (11d0 <ResetHandler+0xd8>)
    114a:	222a      	movs	r2, #42	; 0x2a
    114c:	701a      	strb	r2, [r3, #0]
    114e:	4a21      	ldr	r2, [pc, #132]	; (11d4 <ResetHandler+0xdc>)
    1150:	4b21      	ldr	r3, [pc, #132]	; (11d8 <ResetHandler+0xe0>)
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    1152:	428b      	cmp	r3, r1
    1154:	d323      	bcc.n	119e <ResetHandler+0xa6>
	dest = (uint32_t*)&_sbss;
    1156:	4b21      	ldr	r3, [pc, #132]	; (11dc <ResetHandler+0xe4>)
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;
    1158:	4a21      	ldr	r2, [pc, #132]	; (11e0 <ResetHandler+0xe8>)
    115a:	2100      	movs	r1, #0
    115c:	4293      	cmp	r3, r2
    115e:	d323      	bcc.n	11a8 <ResetHandler+0xb0>
    1160:	4b20      	ldr	r3, [pc, #128]	; (11e4 <ResetHandler+0xec>)

// MCHCK / Kiibohd-dfu
#if defined(_kii_v1_)
	// Default all interrupts to medium priority level
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
    1162:	4a21      	ldr	r2, [pc, #132]	; (11e8 <ResetHandler+0xf0>)
	{
		NVIC_SET_PRIORITY( i, 128 );
    1164:	2180      	movs	r1, #128	; 0x80
    1166:	f803 1b01 	strb.w	r1, [r3], #1
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
    116a:	4293      	cmp	r3, r2
    116c:	d1fb      	bne.n	1166 <ResetHandler+0x6e>
	}

	// FLL at 48MHz
	MCG_C4 = MCG_C4_DMX32 | MCG_C4_DRST_DRS( 1 );
    116e:	4b1f      	ldr	r3, [pc, #124]	; (11ec <ResetHandler+0xf4>)
    1170:	22a0      	movs	r2, #160	; 0xa0
    1172:	701a      	strb	r2, [r3, #0]

	// USB Clock and FLL select
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_TRACECLKSEL;
    1174:	f46f 72ff 	mvn.w	r2, #510	; 0x1fe
    1178:	f5a3 33df 	sub.w	r3, r3, #114176	; 0x1be00
    117c:	4413      	add	r3, r2
    117e:	f44f 2282 	mov.w	r2, #266240	; 0x41000
    1182:	601a      	str	r2, [r3, #0]
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL( 6 );

#endif

	// Initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
    1184:	4b1a      	ldr	r3, [pc, #104]	; (11f0 <ResetHandler+0xf8>)
    1186:	f64b 327f 	movw	r2, #47999	; 0xbb7f
    118a:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
    118c:	2207      	movs	r2, #7
    118e:	f843 2c04 	str.w	r2, [r3, #-4]

	// Enable IRQs
	__enable_irq();
    1192:	b662      	cpsie	i

	// Intialize entropy for random numbers
	rand_initialize();
    1194:	f000 fa82 	bl	169c <rand_initialize>

	// Start main
	main();
    1198:	f000 f858 	bl	124c <main>
    119c:	e7fe      	b.n	119c <ResetHandler+0xa4>
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    119e:	f852 0f04 	ldr.w	r0, [r2, #4]!
    11a2:	f843 0b04 	str.w	r0, [r3], #4
    11a6:	e7d4      	b.n	1152 <ResetHandler+0x5a>
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;
    11a8:	f843 1b04 	str.w	r1, [r3], #4
    11ac:	e7d6      	b.n	115c <ResetHandler+0x64>
    11ae:	bf00      	nop
    11b0:	1fffe9d0 	.word	0x1fffe9d0
    11b4:	40052012 	.word	0x40052012
    11b8:	4005200e 	.word	0x4005200e
    11bc:	40052000 	.word	0x40052000
    11c0:	40048038 	.word	0x40048038
    11c4:	00043f82 	.word	0x00043f82
    11c8:	0b000001 	.word	0x0b000001
    11cc:	1ffff044 	.word	0x1ffff044
    11d0:	4007e000 	.word	0x4007e000
    11d4:	0000dabc 	.word	0x0000dabc
    11d8:	1fffe9d0 	.word	0x1fffe9d0
    11dc:	1ffff044 	.word	0x1ffff044
    11e0:	200007bc 	.word	0x200007bc
    11e4:	e000e400 	.word	0xe000e400
    11e8:	e000e42e 	.word	0xe000e42e
    11ec:	40064003 	.word	0x40064003
    11f0:	e000e014 	.word	0xe000e014

000011f4 <main_periodic>:
// And have negative effect being delayed or stretched too much
//
// Returns 1 if full rotation has completed
// Returns 0 otherwise
int main_periodic()
{
    11f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    11f6:	4c13      	ldr	r4, [pc, #76]	; (1244 <main_periodic+0x50>)
	// Scan module periodic routines
	switch ( stage_tracker )
    11f8:	4d13      	ldr	r5, [pc, #76]	; (1248 <main_periodic+0x54>)
{
    11fa:	6823      	ldr	r3, [r4, #0]
    11fc:	9301      	str	r3, [sp, #4]
	switch ( stage_tracker )
    11fe:	782b      	ldrb	r3, [r5, #0]
    1200:	b2db      	uxtb	r3, r3
    1202:	2b01      	cmp	r3, #1
    1204:	d00c      	beq.n	1220 <main_periodic+0x2c>
    1206:	d303      	bcc.n	1210 <main_periodic+0x1c>
    1208:	2b02      	cmp	r3, #2
    120a:	d00d      	beq.n	1228 <main_periodic+0x34>

		// Full rotation
		return 1;
	}

	return 0;
    120c:	2000      	movs	r0, #0
    120e:	e010      	b.n	1232 <main_periodic+0x3e>
		Scan_poll();
    1210:	f001 fb0a 	bl	2828 <Scan_poll>
		if ( Scan_periodic() )
    1214:	f001 fb18 	bl	2848 <Scan_periodic>
    1218:	b158      	cbz	r0, 1232 <main_periodic+0x3e>
			stage_tracker = PeriodicStage_Macro;
    121a:	2301      	movs	r3, #1
		stage_tracker = PeriodicStage_Output;
    121c:	702b      	strb	r3, [r5, #0]
    121e:	e7f5      	b.n	120c <main_periodic+0x18>
		Macro_periodic();
    1220:	f002 fd9c 	bl	3d5c <Macro_periodic>
		stage_tracker = PeriodicStage_Output;
    1224:	2302      	movs	r3, #2
    1226:	e7f9      	b.n	121c <main_periodic+0x28>
		Output_periodic();
    1228:	f004 fd50 	bl	5ccc <Output_periodic>
		stage_tracker = PeriodicStage_Scan;
    122c:	2300      	movs	r3, #0
    122e:	702b      	strb	r3, [r5, #0]
		return 1;
    1230:	2001      	movs	r0, #1
}
    1232:	9a01      	ldr	r2, [sp, #4]
    1234:	6823      	ldr	r3, [r4, #0]
    1236:	429a      	cmp	r2, r3
    1238:	d001      	beq.n	123e <main_periodic+0x4a>
    123a:	f000 f973 	bl	1524 <__stack_chk_fail>
    123e:	b003      	add	sp, #12
    1240:	bd30      	pop	{r4, r5, pc}
    1242:	bf00      	nop
    1244:	1fffe9d0 	.word	0x1fffe9d0
    1248:	1ffff044 	.word	0x1ffff044

0000124c <main>:

// ----- MCU-only Functions -----
#if !defined(_host_)

int main()
{
    124c:	b507      	push	{r0, r1, r2, lr}
    124e:	4b0e      	ldr	r3, [pc, #56]	; (1288 <main+0x3c>)
    1250:	681b      	ldr	r3, [r3, #0]
    1252:	9301      	str	r3, [sp, #4]
	SEGGER_SYSVIEW_OnTaskCreate(TASK_MACRO_POLL);
	SEGGER_SYSVIEW_OnTaskCreate(TASK_OUTPUT_POLL);
#endif

	// Setup Latency Measurements
	Latency_init();
    1254:	f007 ff9e 	bl	9194 <Latency_init>

	// Enable CLI
	CLI_init();
    1258:	f007 fcd2 	bl	8c00 <CLI_init>

	// Setup periodic timer function
	Periodic_function( &main_periodic );
    125c:	480b      	ldr	r0, [pc, #44]	; (128c <main+0x40>)
    125e:	f000 fc0f 	bl	1a80 <Periodic_function>
#if Storage_Enable_define == 1
	Storage_init();
#endif

	// Setup Modules
	Output_setup();
    1262:	f004 fd0d 	bl	5c80 <Output_setup>
	Macro_setup();
    1266:	f002 fe3f 	bl	3ee8 <Macro_setup>
	Scan_setup();
    126a:	f001 fac1 	bl	27f0 <Scan_setup>
#if Storage_Enable_define == 1
	storage_load_settings();
#endif

	// Start scanning on first periodic loop
	stage_tracker = PeriodicStage_Scan;
    126e:	4b08      	ldr	r3, [pc, #32]	; (1290 <main+0x44>)
    1270:	2200      	movs	r2, #0
    1272:	701a      	strb	r2, [r3, #0]
		// While counter-intuitive, things such as LED/Display modules should be run as poll
		// as they need to run as quickly as possible, in case there needs to be frame drops

		// Process CLI
		SEGGER_SYSVIEW_OnTaskStartExec(TASK_CLI_PROCESS);
		CLI_process();
    1274:	f007 fde8 	bl	8e48 <CLI_process>

		//SEGGER_SYSVIEW_OnIdle();

		// Scan module poll routines
		SEGGER_SYSVIEW_OnTaskStartExec(TASK_SCAN_POLL);
		Scan_poll();
    1278:	f001 fad6 	bl	2828 <Scan_poll>

		//SEGGER_SYSVIEW_OnIdle();

		// Macro module poll routines
		SEGGER_SYSVIEW_OnTaskStartExec(TASK_MACRO_POLL);
		Macro_poll();
    127c:	f002 fd5c 	bl	3d38 <Macro_poll>
		SEGGER_SYSVIEW_OnTaskTerminate(TASK_MACRO_POLL);

		// Output module poll routines
		SEGGER_SYSVIEW_OnTaskStartExec(TASK_OUTPUT_POLL);
		Output_poll();
    1280:	f004 fd12 	bl	5ca8 <Output_poll>
    1284:	e7f6      	b.n	1274 <main+0x28>
    1286:	bf00      	nop
    1288:	1fffe9d0 	.word	0x1fffe9d0
    128c:	000011f5 	.word	0x000011f5
    1290:	1ffff044 	.word	0x1ffff044

00001294 <systick_default_isr>:
{
    1294:	b507      	push	{r0, r1, r2, lr}
    1296:	4911      	ldr	r1, [pc, #68]	; (12dc <systick_default_isr+0x48>)
	systick_millis_count++;
    1298:	4a11      	ldr	r2, [pc, #68]	; (12e0 <systick_default_isr+0x4c>)
{
    129a:	680b      	ldr	r3, [r1, #0]
    129c:	9301      	str	r3, [sp, #4]
	systick_millis_count++;
    129e:	6813      	ldr	r3, [r2, #0]
    12a0:	3301      	adds	r3, #1
    12a2:	6013      	str	r3, [r2, #0]
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    12a4:	4a0f      	ldr	r2, [pc, #60]	; (12e4 <systick_default_isr+0x50>)
    12a6:	6813      	ldr	r3, [r2, #0]
    12a8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    12ac:	6013      	str	r3, [r2, #0]
	ARM_DWT_CTRL &= ~ARM_DWT_CTRL_CYCCNTENA;
    12ae:	4b0e      	ldr	r3, [pc, #56]	; (12e8 <systick_default_isr+0x54>)
    12b0:	681a      	ldr	r2, [r3, #0]
    12b2:	f022 0201 	bic.w	r2, r2, #1
    12b6:	601a      	str	r2, [r3, #0]
	if ( ARM_DWT_CYCCNT > F_CPU / 1000 + 30 )
    12b8:	4a0c      	ldr	r2, [pc, #48]	; (12ec <systick_default_isr+0x58>)
    12ba:	6810      	ldr	r0, [r2, #0]
	ARM_DWT_CYCCNT = 0;
    12bc:	2000      	movs	r0, #0
    12be:	6010      	str	r0, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    12c0:	681a      	ldr	r2, [r3, #0]
    12c2:	f042 0201 	orr.w	r2, r2, #1
    12c6:	601a      	str	r2, [r3, #0]
}
    12c8:	9a01      	ldr	r2, [sp, #4]
    12ca:	680b      	ldr	r3, [r1, #0]
    12cc:	429a      	cmp	r2, r3
    12ce:	d001      	beq.n	12d4 <systick_default_isr+0x40>
    12d0:	f000 f928 	bl	1524 <__stack_chk_fail>
    12d4:	b003      	add	sp, #12
    12d6:	f85d fb04 	ldr.w	pc, [sp], #4
    12da:	bf00      	nop
    12dc:	1fffe9d0 	.word	0x1fffe9d0
    12e0:	1ffff048 	.word	0x1ffff048
    12e4:	e000edfc 	.word	0xe000edfc
    12e8:	e0001000 	.word	0xe0001000
    12ec:	e0001004 	.word	0xe0001004

000012f0 <fault_isr>:
{
    12f0:	b507      	push	{r0, r1, r2, lr}
    12f2:	4b0e      	ldr	r3, [pc, #56]	; (132c <fault_isr+0x3c>)
	print("Fault!" NL );
    12f4:	480e      	ldr	r0, [pc, #56]	; (1330 <fault_isr+0x40>)
{
    12f6:	681b      	ldr	r3, [r3, #0]
    12f8:	9301      	str	r3, [sp, #4]
		if ( SIM_SCGC4 & SIM_SCGC4_USBOTG ) usb_isr();
    12fa:	4d0e      	ldr	r5, [pc, #56]	; (1334 <fault_isr+0x44>)
	print("Fault!" NL );
    12fc:	f008 f8c4 	bl	9488 <_print>
    1300:	462c      	mov	r4, r5
		if ( SIM_SCGC4 & SIM_SCGC4_USBOTG ) usb_isr();
    1302:	682b      	ldr	r3, [r5, #0]
    1304:	0358      	lsls	r0, r3, #13
    1306:	d501      	bpl.n	130c <fault_isr+0x1c>
    1308:	f006 f91e 	bl	7548 <usb_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART0 )  uart0_status_isr();
    130c:	6823      	ldr	r3, [r4, #0]
    130e:	0559      	lsls	r1, r3, #21
    1310:	d501      	bpl.n	1316 <fault_isr+0x26>
    1312:	f000 f811 	bl	1338 <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART1 )  uart1_status_isr();
    1316:	6823      	ldr	r3, [r4, #0]
    1318:	051a      	lsls	r2, r3, #20
    131a:	d501      	bpl.n	1320 <fault_isr+0x30>
    131c:	f000 f80c 	bl	1338 <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART2 )  uart2_status_isr();
    1320:	6823      	ldr	r3, [r4, #0]
    1322:	04db      	lsls	r3, r3, #19
    1324:	d5ed      	bpl.n	1302 <fault_isr+0x12>
    1326:	f000 f807 	bl	1338 <unused_isr>
    132a:	e7ea      	b.n	1302 <fault_isr+0x12>
    132c:	1fffe9d0 	.word	0x1fffe9d0
    1330:	000098f2 	.word	0x000098f2
    1334:	40048034 	.word	0x40048034

00001338 <unused_isr>:
{
    1338:	b507      	push	{r0, r1, r2, lr}
    133a:	4b02      	ldr	r3, [pc, #8]	; (1344 <unused_isr+0xc>)
    133c:	681b      	ldr	r3, [r3, #0]
    133e:	9301      	str	r3, [sp, #4]
	fault_isr();
    1340:	f7ff ffd6 	bl	12f0 <fault_isr>
    1344:	1fffe9d0 	.word	0x1fffe9d0

00001348 <nmi_default_isr>:
{
    1348:	b507      	push	{r0, r1, r2, lr}
    134a:	4b07      	ldr	r3, [pc, #28]	; (1368 <nmi_default_isr+0x20>)
    134c:	681a      	ldr	r2, [r3, #0]
    134e:	9201      	str	r2, [sp, #4]
	print("NMI!" NL );
    1350:	9a01      	ldr	r2, [sp, #4]
    1352:	681b      	ldr	r3, [r3, #0]
    1354:	429a      	cmp	r2, r3
    1356:	d001      	beq.n	135c <nmi_default_isr+0x14>
    1358:	f000 f8e4 	bl	1524 <__stack_chk_fail>
    135c:	4803      	ldr	r0, [pc, #12]	; (136c <nmi_default_isr+0x24>)
}
    135e:	b003      	add	sp, #12
    1360:	f85d eb04 	ldr.w	lr, [sp], #4
	print("NMI!" NL );
    1364:	f008 b890 	b.w	9488 <_print>
    1368:	1fffe9d0 	.word	0x1fffe9d0
    136c:	0000993f 	.word	0x0000993f

00001370 <hard_fault_default_isr>:
{
    1370:	b513      	push	{r0, r1, r4, lr}
    1372:	4c0c      	ldr	r4, [pc, #48]	; (13a4 <hard_fault_default_isr+0x34>)
	print("Hard Fault! SCB_HFSR: ");
    1374:	480c      	ldr	r0, [pc, #48]	; (13a8 <hard_fault_default_isr+0x38>)
{
    1376:	6823      	ldr	r3, [r4, #0]
    1378:	9301      	str	r3, [sp, #4]
	print("Hard Fault! SCB_HFSR: ");
    137a:	f008 f885 	bl	9488 <_print>
	printHex32( SCB_HFSR );
    137e:	4b0b      	ldr	r3, [pc, #44]	; (13ac <hard_fault_default_isr+0x3c>)
    1380:	2101      	movs	r1, #1
    1382:	6818      	ldr	r0, [r3, #0]
    1384:	f008 f9f8 	bl	9778 <printHex32_op>
	print( NL );
    1388:	4809      	ldr	r0, [pc, #36]	; (13b0 <hard_fault_default_isr+0x40>)
    138a:	f008 f87d 	bl	9488 <_print>
	SOFTWARE_RESET();
    138e:	4b09      	ldr	r3, [pc, #36]	; (13b4 <hard_fault_default_isr+0x44>)
    1390:	4a09      	ldr	r2, [pc, #36]	; (13b8 <hard_fault_default_isr+0x48>)
    1392:	601a      	str	r2, [r3, #0]
}
    1394:	9a01      	ldr	r2, [sp, #4]
    1396:	6823      	ldr	r3, [r4, #0]
    1398:	429a      	cmp	r2, r3
    139a:	d001      	beq.n	13a0 <hard_fault_default_isr+0x30>
    139c:	f000 f8c2 	bl	1524 <__stack_chk_fail>
    13a0:	b002      	add	sp, #8
    13a2:	bd10      	pop	{r4, pc}
    13a4:	1fffe9d0 	.word	0x1fffe9d0
    13a8:	000098fb 	.word	0x000098fb
    13ac:	e000ed2c 	.word	0xe000ed2c
    13b0:	0000d348 	.word	0x0000d348
    13b4:	e000ed0c 	.word	0xe000ed0c
    13b8:	05fa0004 	.word	0x05fa0004

000013bc <memmanage_fault_default_isr>:
{
    13bc:	b513      	push	{r0, r1, r4, lr}
    13be:	4c0f      	ldr	r4, [pc, #60]	; (13fc <memmanage_fault_default_isr+0x40>)
	print("Memory Manager Fault! SCB_CFSR: ");
    13c0:	480f      	ldr	r0, [pc, #60]	; (1400 <memmanage_fault_default_isr+0x44>)
{
    13c2:	6823      	ldr	r3, [r4, #0]
    13c4:	9301      	str	r3, [sp, #4]
	print("Memory Manager Fault! SCB_CFSR: ");
    13c6:	f008 f85f 	bl	9488 <_print>
	printHex32( SCB_CFSR );
    13ca:	4b0e      	ldr	r3, [pc, #56]	; (1404 <memmanage_fault_default_isr+0x48>)
    13cc:	2101      	movs	r1, #1
    13ce:	6818      	ldr	r0, [r3, #0]
    13d0:	f008 f9d2 	bl	9778 <printHex32_op>
	print(" SCB_MMAR: ");
    13d4:	480c      	ldr	r0, [pc, #48]	; (1408 <memmanage_fault_default_isr+0x4c>)
    13d6:	f008 f857 	bl	9488 <_print>
	printHex32( SCB_MMAR );
    13da:	4b0c      	ldr	r3, [pc, #48]	; (140c <memmanage_fault_default_isr+0x50>)
    13dc:	2101      	movs	r1, #1
    13de:	6818      	ldr	r0, [r3, #0]
    13e0:	f008 f9ca 	bl	9778 <printHex32_op>
	print( NL );
    13e4:	9a01      	ldr	r2, [sp, #4]
    13e6:	6823      	ldr	r3, [r4, #0]
    13e8:	429a      	cmp	r2, r3
    13ea:	d001      	beq.n	13f0 <memmanage_fault_default_isr+0x34>
    13ec:	f000 f89a 	bl	1524 <__stack_chk_fail>
    13f0:	4807      	ldr	r0, [pc, #28]	; (1410 <memmanage_fault_default_isr+0x54>)
}
    13f2:	b002      	add	sp, #8
    13f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    13f8:	f008 b846 	b.w	9488 <_print>
    13fc:	1fffe9d0 	.word	0x1fffe9d0
    1400:	00009912 	.word	0x00009912
    1404:	e000ed28 	.word	0xe000ed28
    1408:	00009933 	.word	0x00009933
    140c:	e000ed34 	.word	0xe000ed34
    1410:	0000d348 	.word	0x0000d348

00001414 <bus_fault_default_isr>:
{
    1414:	b513      	push	{r0, r1, r4, lr}
    1416:	4c0f      	ldr	r4, [pc, #60]	; (1454 <bus_fault_default_isr+0x40>)
	print("Bus Fault! SCB_CFSR: ");
    1418:	480f      	ldr	r0, [pc, #60]	; (1458 <bus_fault_default_isr+0x44>)
{
    141a:	6823      	ldr	r3, [r4, #0]
    141c:	9301      	str	r3, [sp, #4]
	print("Bus Fault! SCB_CFSR: ");
    141e:	f008 f833 	bl	9488 <_print>
	printHex32( SCB_CFSR );
    1422:	4b0e      	ldr	r3, [pc, #56]	; (145c <bus_fault_default_isr+0x48>)
    1424:	2101      	movs	r1, #1
    1426:	6818      	ldr	r0, [r3, #0]
    1428:	f008 f9a6 	bl	9778 <printHex32_op>
	print(" SCB_BFAR: ");
    142c:	480c      	ldr	r0, [pc, #48]	; (1460 <bus_fault_default_isr+0x4c>)
    142e:	f008 f82b 	bl	9488 <_print>
	printHex32( SCB_BFAR );
    1432:	4b0c      	ldr	r3, [pc, #48]	; (1464 <bus_fault_default_isr+0x50>)
    1434:	2101      	movs	r1, #1
    1436:	6818      	ldr	r0, [r3, #0]
    1438:	f008 f99e 	bl	9778 <printHex32_op>
	print( NL );
    143c:	9a01      	ldr	r2, [sp, #4]
    143e:	6823      	ldr	r3, [r4, #0]
    1440:	429a      	cmp	r2, r3
    1442:	d001      	beq.n	1448 <bus_fault_default_isr+0x34>
    1444:	f000 f86e 	bl	1524 <__stack_chk_fail>
    1448:	4807      	ldr	r0, [pc, #28]	; (1468 <bus_fault_default_isr+0x54>)
}
    144a:	b002      	add	sp, #8
    144c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    1450:	f008 b81a 	b.w	9488 <_print>
    1454:	1fffe9d0 	.word	0x1fffe9d0
    1458:	000098d0 	.word	0x000098d0
    145c:	e000ed28 	.word	0xe000ed28
    1460:	000098e6 	.word	0x000098e6
    1464:	e000ed38 	.word	0xe000ed38
    1468:	0000d348 	.word	0x0000d348

0000146c <usage_fault_default_isr>:
{
    146c:	b513      	push	{r0, r1, r4, lr}
    146e:	4c0b      	ldr	r4, [pc, #44]	; (149c <usage_fault_default_isr+0x30>)
	print("Usage Fault! SCB_CFSR: ");
    1470:	480b      	ldr	r0, [pc, #44]	; (14a0 <usage_fault_default_isr+0x34>)
{
    1472:	6823      	ldr	r3, [r4, #0]
    1474:	9301      	str	r3, [sp, #4]
	print("Usage Fault! SCB_CFSR: ");
    1476:	f008 f807 	bl	9488 <_print>
	printHex32( SCB_CFSR );
    147a:	4b0a      	ldr	r3, [pc, #40]	; (14a4 <usage_fault_default_isr+0x38>)
    147c:	2101      	movs	r1, #1
    147e:	6818      	ldr	r0, [r3, #0]
    1480:	f008 f97a 	bl	9778 <printHex32_op>
	print( NL );
    1484:	9a01      	ldr	r2, [sp, #4]
    1486:	6823      	ldr	r3, [r4, #0]
    1488:	429a      	cmp	r2, r3
    148a:	d001      	beq.n	1490 <usage_fault_default_isr+0x24>
    148c:	f000 f84a 	bl	1524 <__stack_chk_fail>
    1490:	4805      	ldr	r0, [pc, #20]	; (14a8 <usage_fault_default_isr+0x3c>)
}
    1492:	b002      	add	sp, #8
    1494:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    1498:	f007 bff6 	b.w	9488 <_print>
    149c:	1fffe9d0 	.word	0x1fffe9d0
    14a0:	0000995c 	.word	0x0000995c
    14a4:	e000ed28 	.word	0xe000ed28
    14a8:	0000d348 	.word	0x0000d348

000014ac <watchdog_default_isr>:
{
    14ac:	b513      	push	{r0, r1, r4, lr}
    14ae:	4c15      	ldr	r4, [pc, #84]	; (1504 <watchdog_default_isr+0x58>)
	print("Watchdog timeout! ");
    14b0:	4815      	ldr	r0, [pc, #84]	; (1508 <watchdog_default_isr+0x5c>)
{
    14b2:	6823      	ldr	r3, [r4, #0]
    14b4:	9301      	str	r3, [sp, #4]
	print("Watchdog timeout! ");
    14b6:	f007 ffe7 	bl	9488 <_print>
	printHex( WDOG_TMROUTH );
    14ba:	4b14      	ldr	r3, [pc, #80]	; (150c <watchdog_default_isr+0x60>)
    14bc:	2101      	movs	r1, #1
    14be:	8818      	ldrh	r0, [r3, #0]
    14c0:	f008 f908 	bl	96d4 <printHex_op>
	print(" ");
    14c4:	4812      	ldr	r0, [pc, #72]	; (1510 <watchdog_default_isr+0x64>)
    14c6:	f007 ffdf 	bl	9488 <_print>
	printHex( WDOG_TMROUTL );
    14ca:	4b12      	ldr	r3, [pc, #72]	; (1514 <watchdog_default_isr+0x68>)
    14cc:	2101      	movs	r1, #1
    14ce:	8818      	ldrh	r0, [r3, #0]
    14d0:	f008 f900 	bl	96d4 <printHex_op>
	print( NL );
    14d4:	4810      	ldr	r0, [pc, #64]	; (1518 <watchdog_default_isr+0x6c>)
    14d6:	f007 ffd7 	bl	9488 <_print>
	print("Watchdog Reset Count: ");
    14da:	4810      	ldr	r0, [pc, #64]	; (151c <watchdog_default_isr+0x70>)
    14dc:	f007 ffd4 	bl	9488 <_print>
	printHex( WDOG_RSTCNT );
    14e0:	4b0f      	ldr	r3, [pc, #60]	; (1520 <watchdog_default_isr+0x74>)
    14e2:	2101      	movs	r1, #1
    14e4:	8818      	ldrh	r0, [r3, #0]
    14e6:	f008 f8f5 	bl	96d4 <printHex_op>
	print( NL );
    14ea:	9a01      	ldr	r2, [sp, #4]
    14ec:	6823      	ldr	r3, [r4, #0]
    14ee:	429a      	cmp	r2, r3
    14f0:	d001      	beq.n	14f6 <watchdog_default_isr+0x4a>
    14f2:	f000 f817 	bl	1524 <__stack_chk_fail>
    14f6:	4808      	ldr	r0, [pc, #32]	; (1518 <watchdog_default_isr+0x6c>)
}
    14f8:	b002      	add	sp, #8
    14fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    14fe:	f007 bfc3 	b.w	9488 <_print>
    1502:	bf00      	nop
    1504:	1fffe9d0 	.word	0x1fffe9d0
    1508:	00009974 	.word	0x00009974
    150c:	40052010 	.word	0x40052010
    1510:	0000d6a4 	.word	0x0000d6a4
    1514:	40052012 	.word	0x40052012
    1518:	0000d348 	.word	0x0000d348
    151c:	00009987 	.word	0x00009987
    1520:	40052014 	.word	0x40052014

00001524 <__stack_chk_fail>:
{
    1524:	b507      	push	{r0, r1, r2, lr}
    1526:	4b04      	ldr	r3, [pc, #16]	; (1538 <__stack_chk_fail+0x14>)
	print("Segfault!" NL );
    1528:	4804      	ldr	r0, [pc, #16]	; (153c <__stack_chk_fail+0x18>)
{
    152a:	681b      	ldr	r3, [r3, #0]
    152c:	9301      	str	r3, [sp, #4]
	print("Segfault!" NL );
    152e:	f007 ffab 	bl	9488 <_print>
	fault_isr();
    1532:	f7ff fedd 	bl	12f0 <fault_isr>
    1536:	bf00      	nop
    1538:	1fffe9d0 	.word	0x1fffe9d0
    153c:	000098c4 	.word	0x000098c4

00001540 <memset>:
{
    1540:	b513      	push	{r0, r1, r4, lr}
    1542:	4b09      	ldr	r3, [pc, #36]	; (1568 <memset+0x28>)
    1544:	681c      	ldr	r4, [r3, #0]
    1546:	9401      	str	r4, [sp, #4]
    1548:	4402      	add	r2, r0
	char *buf = addr;
    154a:	4604      	mov	r4, r0
	for (; len > 0; --len, ++buf)
    154c:	4294      	cmp	r4, r2
    154e:	d105      	bne.n	155c <memset+0x1c>
}
    1550:	9a01      	ldr	r2, [sp, #4]
    1552:	681b      	ldr	r3, [r3, #0]
    1554:	429a      	cmp	r2, r3
    1556:	d004      	beq.n	1562 <memset+0x22>
    1558:	f7ff ffe4 	bl	1524 <__stack_chk_fail>
		*buf = val;
    155c:	f804 1b01 	strb.w	r1, [r4], #1
    1560:	e7f4      	b.n	154c <memset+0xc>
}
    1562:	b002      	add	sp, #8
    1564:	bd10      	pop	{r4, pc}
    1566:	bf00      	nop
    1568:	1fffe9d0 	.word	0x1fffe9d0

0000156c <memcpy>:
{
    156c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    156e:	4b11      	ldr	r3, [pc, #68]	; (15b4 <memcpy+0x48>)
    1570:	681c      	ldr	r4, [r3, #0]
    1572:	9401      	str	r4, [sp, #4]
	uint32_t endLen = len & 0x03;
    1574:	f002 0403 	and.w	r4, r2, #3
    1578:	f022 0203 	bic.w	r2, r2, #3
    157c:	1f05      	subs	r5, r0, #4
    157e:	188e      	adds	r6, r1, r2
	for ( i = 0; i < numLongs; i++ )
    1580:	42b1      	cmp	r1, r6
    1582:	d10a      	bne.n	159a <memcpy+0x2e>
    1584:	4402      	add	r2, r0
    1586:	3901      	subs	r1, #1
    1588:	4414      	add	r4, r2
	for (; endLen > 0; --endLen, ++dstbuf, ++srcbuf)
    158a:	42a2      	cmp	r2, r4
    158c:	d10a      	bne.n	15a4 <memcpy+0x38>
}
    158e:	9a01      	ldr	r2, [sp, #4]
    1590:	681b      	ldr	r3, [r3, #0]
    1592:	429a      	cmp	r2, r3
    1594:	d00b      	beq.n	15ae <memcpy+0x42>
    1596:	f7ff ffc5 	bl	1524 <__stack_chk_fail>
		*pLongDest++ = *pLongSrc++;
    159a:	f851 7b04 	ldr.w	r7, [r1], #4
    159e:	f845 7f04 	str.w	r7, [r5, #4]!
    15a2:	e7ed      	b.n	1580 <memcpy+0x14>
		*dstbuf = *srcbuf;
    15a4:	f811 5f01 	ldrb.w	r5, [r1, #1]!
    15a8:	f802 5b01 	strb.w	r5, [r2], #1
    15ac:	e7ed      	b.n	158a <memcpy+0x1e>
}
    15ae:	b003      	add	sp, #12
    15b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    15b2:	bf00      	nop
    15b4:	1fffe9d0 	.word	0x1fffe9d0

000015b8 <us_now>:
// Current us count for CPU
// Uses both cycle count and systick
// TODO (HaaTa) - Make it possible to use dynamic F_CPU
//                Possibly using a table of supported frequencies?
uint32_t us_now()
{
    15b8:	b507      	push	{r0, r1, r2, lr}
    15ba:	4a12      	ldr	r2, [pc, #72]	; (1604 <us_now+0x4c>)
    15bc:	6813      	ldr	r3, [r2, #0]
    15be:	9301      	str	r3, [sp, #4]
	uint32_t count;
	uint32_t current;
	uint32_t pending;

	// Snapshot both the cycle count and ms counter
	__disable_irq();
    15c0:	b672      	cpsid	i

	count = systick_millis_count;
    15c2:	4b11      	ldr	r3, [pc, #68]	; (1608 <us_now+0x50>)
	current  = cycle_now();

	#if defined(_kinetis_)
	pending = SCB_ICSR & SCB_ICSR_PENDSTSET; // bit 26 indicates if systick exception pending
    15c4:	4811      	ldr	r0, [pc, #68]	; (160c <us_now+0x54>)
	count = systick_millis_count;
    15c6:	6819      	ldr	r1, [r3, #0]
	return SYST_CVR;
    15c8:	4b11      	ldr	r3, [pc, #68]	; (1610 <us_now+0x58>)
    15ca:	681b      	ldr	r3, [r3, #0]
	pending = SCB_ICSR & SCB_ICSR_PENDSTSET; // bit 26 indicates if systick exception pending
    15cc:	6800      	ldr	r0, [r0, #0]
	#elif defined(_sam_)
	pending = SCB->ICSR & SCB_ICSR_PENDSTSET_Msk;
	#endif

	__enable_irq();
    15ce:	b662      	cpsie	i

	// Check for pending systick, and increment if one is it was
	if ( pending && current > ( ( F_CPU / 1000 ) - 50 ) )
    15d0:	0140      	lsls	r0, r0, #5
    15d2:	d504      	bpl.n	15de <us_now+0x26>
    15d4:	f64b 304e 	movw	r0, #47950	; 0xbb4e
    15d8:	4283      	cmp	r3, r0
	{
		count++;
    15da:	bf88      	it	hi
    15dc:	3101      	addhi	r1, #1
	}
	// Determine cycles since systick (approx.)
	current = ( ( F_CPU / 1000 ) - 1 ) - current;
    15de:	f5c3 433b 	rsb	r3, r3, #47872	; 0xbb00

	// Add ms and cycles (since systick), converted as us
	return count * 1000 + current / ( F_CPU / 1000000 );
    15e2:	2030      	movs	r0, #48	; 0x30
	current = ( ( F_CPU / 1000 ) - 1 ) - current;
    15e4:	337f      	adds	r3, #127	; 0x7f
	return count * 1000 + current / ( F_CPU / 1000000 );
    15e6:	fbb3 f3f0 	udiv	r3, r3, r0
#else
#warning "us_now not implemented"
	return 0;
#endif
}
    15ea:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    15ee:	fb00 3001 	mla	r0, r0, r1, r3
    15f2:	9901      	ldr	r1, [sp, #4]
    15f4:	6813      	ldr	r3, [r2, #0]
    15f6:	4299      	cmp	r1, r3
    15f8:	d001      	beq.n	15fe <us_now+0x46>
    15fa:	f7ff ff93 	bl	1524 <__stack_chk_fail>
    15fe:	b003      	add	sp, #12
    1600:	f85d fb04 	ldr.w	pc, [sp], #4
    1604:	1fffe9d0 	.word	0x1fffe9d0
    1608:	1ffff048 	.word	0x1ffff048
    160c:	e000ed04 	.word	0xe000ed04
    1610:	e000e018 	.word	0xe000e018

00001614 <yield>:


// - Misc Functions -

void yield()
{
    1614:	b507      	push	{r0, r1, r2, lr}
    1616:	4b06      	ldr	r3, [pc, #24]	; (1630 <yield+0x1c>)
    1618:	681a      	ldr	r2, [r3, #0]
    161a:	9201      	str	r2, [sp, #4]
}
    161c:	9a01      	ldr	r2, [sp, #4]
    161e:	681b      	ldr	r3, [r3, #0]
    1620:	429a      	cmp	r2, r3
    1622:	d001      	beq.n	1628 <yield+0x14>
    1624:	f7ff ff7e 	bl	1524 <__stack_chk_fail>
    1628:	b003      	add	sp, #12
    162a:	f85d fb04 	ldr.w	pc, [sp], #4
    162e:	bf00      	nop
    1630:	1fffe9d0 	.word	0x1fffe9d0

00001634 <delay_us>:
{
    1634:	b573      	push	{r0, r1, r4, r5, r6, lr}
    1636:	4c0b      	ldr	r4, [pc, #44]	; (1664 <delay_us+0x30>)
    1638:	6823      	ldr	r3, [r4, #0]
    163a:	9301      	str	r3, [sp, #4]
    163c:	4605      	mov	r5, r0
	uint32_t start = us_now();
    163e:	f7ff ffbb 	bl	15b8 <us_now>
    1642:	4606      	mov	r6, r0
	while ( us_now() - start <= us )
    1644:	f7ff ffb8 	bl	15b8 <us_now>
    1648:	1b80      	subs	r0, r0, r6
    164a:	42a8      	cmp	r0, r5
    164c:	d905      	bls.n	165a <delay_us+0x26>
}
    164e:	9a01      	ldr	r2, [sp, #4]
    1650:	6823      	ldr	r3, [r4, #0]
    1652:	429a      	cmp	r2, r3
    1654:	d004      	beq.n	1660 <delay_us+0x2c>
    1656:	f7ff ff65 	bl	1524 <__stack_chk_fail>
		yield();
    165a:	f7ff ffdb 	bl	1614 <yield>
    165e:	e7f1      	b.n	1644 <delay_us+0x10>
}
    1660:	b002      	add	sp, #8
    1662:	bd70      	pop	{r4, r5, r6, pc}
    1664:	1fffe9d0 	.word	0x1fffe9d0

00001668 <delay_ms>:
{
    1668:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    166a:	4c0a      	ldr	r4, [pc, #40]	; (1694 <delay_ms+0x2c>)
	return systick_millis_count; // single aligned 32 bit is atomic;
    166c:	4d0a      	ldr	r5, [pc, #40]	; (1698 <delay_ms+0x30>)
{
    166e:	6822      	ldr	r2, [r4, #0]
    1670:	9201      	str	r2, [sp, #4]
	return systick_millis_count; // single aligned 32 bit is atomic;
    1672:	682f      	ldr	r7, [r5, #0]
{
    1674:	4606      	mov	r6, r0
	return systick_millis_count; // single aligned 32 bit is atomic;
    1676:	682b      	ldr	r3, [r5, #0]
	while ( ms_now() - start <= ms )
    1678:	1bdb      	subs	r3, r3, r7
    167a:	42b3      	cmp	r3, r6
    167c:	d905      	bls.n	168a <delay_ms+0x22>
}
    167e:	9a01      	ldr	r2, [sp, #4]
    1680:	6823      	ldr	r3, [r4, #0]
    1682:	429a      	cmp	r2, r3
    1684:	d004      	beq.n	1690 <delay_ms+0x28>
    1686:	f7ff ff4d 	bl	1524 <__stack_chk_fail>
		yield();
    168a:	f7ff ffc3 	bl	1614 <yield>
    168e:	e7f2      	b.n	1676 <delay_ms+0xe>
}
    1690:	b003      	add	sp, #12
    1692:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1694:	1fffe9d0 	.word	0x1fffe9d0
    1698:	1ffff048 	.word	0x1ffff048

0000169c <rand_initialize>:
// This function initializes the global variables needed to implement the circular entropy pool and
// the buffer that holds the raw Timer 1 values that are used to create the entropy pool.  It then
// Initializes the Low Power Timer (LPTMR) to perform an interrupt every 2048 clock cycles, (about
// 16 ms) which is as fast as it can be set.
void rand_initialize()
{
    169c:	b507      	push	{r0, r1, r2, lr}
    169e:	4a13      	ldr	r2, [pc, #76]	; (16ec <rand_initialize+0x50>)
	gWDT_buffer_position = 0;
    16a0:	4913      	ldr	r1, [pc, #76]	; (16f0 <rand_initialize+0x54>)
{
    16a2:	6813      	ldr	r3, [r2, #0]
    16a4:	9301      	str	r3, [sp, #4]
	gWDT_buffer_position = 0;
    16a6:	2300      	movs	r3, #0
    16a8:	700b      	strb	r3, [r1, #0]
	gWDT_pool_start = 0;
    16aa:	4912      	ldr	r1, [pc, #72]	; (16f4 <rand_initialize+0x58>)
    16ac:	700b      	strb	r3, [r1, #0]
	gWDT_pool_end = 0;
    16ae:	4912      	ldr	r1, [pc, #72]	; (16f8 <rand_initialize+0x5c>)
    16b0:	700b      	strb	r3, [r1, #0]
	gWDT_pool_count = 0;
    16b2:	4912      	ldr	r1, [pc, #72]	; (16fc <rand_initialize+0x60>)
    16b4:	700b      	strb	r3, [r1, #0]

	SIM_SCGC5 |= SIM_SCGC5_LPTIMER;
    16b6:	4912      	ldr	r1, [pc, #72]	; (1700 <rand_initialize+0x64>)
    16b8:	680b      	ldr	r3, [r1, #0]
    16ba:	f043 0301 	orr.w	r3, r3, #1
    16be:	600b      	str	r3, [r1, #0]
	LPTMR0_CSR = 0b10000100;
    16c0:	4b10      	ldr	r3, [pc, #64]	; (1704 <rand_initialize+0x68>)
    16c2:	2184      	movs	r1, #132	; 0x84
    16c4:	6019      	str	r1, [r3, #0]
	LPTMR0_PSR = 0b00000101; // PCS=01 : 1 kHz clock
    16c6:	4910      	ldr	r1, [pc, #64]	; (1708 <rand_initialize+0x6c>)
    16c8:	2005      	movs	r0, #5
    16ca:	6008      	str	r0, [r1, #0]
	LPTMR0_CMR = 0x0006;     // smaller number = faster random numbers...
    16cc:	2006      	movs	r0, #6
    16ce:	6048      	str	r0, [r1, #4]
	LPTMR0_CSR = 0b01000101;
    16d0:	2145      	movs	r1, #69	; 0x45
    16d2:	6019      	str	r1, [r3, #0]
	NVIC_ENABLE_IRQ( IRQ_LPTMR );
    16d4:	4b0d      	ldr	r3, [pc, #52]	; (170c <rand_initialize+0x70>)
    16d6:	2180      	movs	r1, #128	; 0x80
    16d8:	6019      	str	r1, [r3, #0]
}
    16da:	9901      	ldr	r1, [sp, #4]
    16dc:	6813      	ldr	r3, [r2, #0]
    16de:	4299      	cmp	r1, r3
    16e0:	d001      	beq.n	16e6 <rand_initialize+0x4a>
    16e2:	f7ff ff1f 	bl	1524 <__stack_chk_fail>
    16e6:	b003      	add	sp, #12
    16e8:	f85d fb04 	ldr.w	pc, [sp], #4
    16ec:	1fffe9d0 	.word	0x1fffe9d0
    16f0:	1ffffc04 	.word	0x1ffffc04
    16f4:	1ffffc26 	.word	0x1ffffc26
    16f8:	1ffffc27 	.word	0x1ffffc27
    16fc:	1ffffc25 	.word	0x1ffffc25
    1700:	40048038 	.word	0x40048038
    1704:	40040000 	.word	0x40040000
    1708:	40040004 	.word	0x40040004
    170c:	e000e104 	.word	0xe000e104

00001710 <rand_value32>:
// otherwise.  To ensure a proper random return the available() function
// should be called first to ensure that entropy exists.
//
// The pool is implemented as an 8 value circular buffer
uint32_t rand_value32()
{
    1710:	b537      	push	{r0, r1, r2, r4, r5, lr}
    1712:	4c1a      	ldr	r4, [pc, #104]	; (177c <rand_value32+0x6c>)
    1714:	6822      	ldr	r2, [r4, #0]
    1716:	9201      	str	r2, [sp, #4]
	uint32_t retVal = 0;
	uint8_t waiting;
	while ( gWDT_pool_count < 1 )
    1718:	4a19      	ldr	r2, [pc, #100]	; (1780 <rand_value32+0x70>)
    171a:	7813      	ldrb	r3, [r2, #0]
    171c:	2b00      	cmp	r3, #0
    171e:	d0fc      	beq.n	171a <rand_value32+0xa>

// returns 0 if interrupts enabled, 1 if disabled
static __inline__ uint32_t __get_primask()
{
	uint32_t primask = 0;
	__asm__ volatile ("MRS %[result], PRIMASK\n\t":[result]"=r"(primask)::);
    1720:	f3ef 8510 	mrs	r5, PRIMASK
	return 1;
}

static __inline__ uint32_t __iCliRetVal()
{
	__asm__ volatile ("CPSID i\n\t""dmb\n\t""dsb\n\t""isb\n\t");
    1724:	b672      	cpsid	i
    1726:	f3bf 8f5f 	dmb	sy
    172a:	f3bf 8f4f 	dsb	sy
    172e:	f3bf 8f6f 	isb	sy
		waiting += 1;
	}

	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
	{
		retVal = gWDT_entropy_pool[gWDT_pool_start];
    1732:	4914      	ldr	r1, [pc, #80]	; (1784 <rand_value32+0x74>)
    1734:	4814      	ldr	r0, [pc, #80]	; (1788 <rand_value32+0x78>)
    1736:	780b      	ldrb	r3, [r1, #0]
    1738:	b2db      	uxtb	r3, r3
    173a:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
		gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    173e:	780b      	ldrb	r3, [r1, #0]
    1740:	3301      	adds	r3, #1
    1742:	f003 0307 	and.w	r3, r3, #7
    1746:	700b      	strb	r3, [r1, #0]
		--gWDT_pool_count;
    1748:	7813      	ldrb	r3, [r2, #0]
    174a:	3b01      	subs	r3, #1
    174c:	b2db      	uxtb	r3, r3
    174e:	7013      	strb	r3, [r2, #0]
	__asm__ volatile ("MSR PRIMASK, %[value]\n\t""dmb\n\t""dsb\n\t""isb\n\t"::[value]"r"(setval):);
    1750:	f385 8810 	msr	PRIMASK, r5
    1754:	f3bf 8f5f 	dmb	sy
    1758:	f3bf 8f4f 	dsb	sy
    175c:	f3bf 8f6f 	isb	sy
	(void)__s;
}

static __inline__ void __iRestore( const  uint32_t *__s )
{
	__set_primask(*__s); __asm__ volatile ("dmb\n\t""dsb\n\t""isb\n\t");
    1760:	f3bf 8f5f 	dmb	sy
    1764:	f3bf 8f4f 	dsb	sy
    1768:	f3bf 8f6f 	isb	sy
	}

	return retVal;
}
    176c:	9a01      	ldr	r2, [sp, #4]
    176e:	6823      	ldr	r3, [r4, #0]
    1770:	429a      	cmp	r2, r3
    1772:	d001      	beq.n	1778 <rand_value32+0x68>
    1774:	f7ff fed6 	bl	1524 <__stack_chk_fail>
    1778:	b003      	add	sp, #12
    177a:	bd30      	pop	{r4, r5, pc}
    177c:	1fffe9d0 	.word	0x1fffe9d0
    1780:	1ffffc25 	.word	0x1ffffc25
    1784:	1ffffc26 	.word	0x1ffffc26
    1788:	1ffffbe4 	.word	0x1ffffbe4

0000178c <rand_available>:


// This function returns a unsigned char (8-bit) with the number of unsigned long values
// in the entropy pool
uint8_t rand_available()
{
    178c:	b507      	push	{r0, r1, r2, lr}
    178e:	4b07      	ldr	r3, [pc, #28]	; (17ac <rand_available+0x20>)
    1790:	681a      	ldr	r2, [r3, #0]
    1792:	9201      	str	r2, [sp, #4]
	return gWDT_pool_count;
    1794:	4a06      	ldr	r2, [pc, #24]	; (17b0 <rand_available+0x24>)
    1796:	7810      	ldrb	r0, [r2, #0]
}
    1798:	9a01      	ldr	r2, [sp, #4]
    179a:	681b      	ldr	r3, [r3, #0]
    179c:	429a      	cmp	r2, r3
    179e:	d001      	beq.n	17a4 <rand_available+0x18>
    17a0:	f7ff fec0 	bl	1524 <__stack_chk_fail>
    17a4:	b003      	add	sp, #12
    17a6:	f85d fb04 	ldr.w	pc, [sp], #4
    17aa:	bf00      	nop
    17ac:	1fffe9d0 	.word	0x1fffe9d0
    17b0:	1ffffc25 	.word	0x1ffffc25

000017b4 <lptmr_isr>:


// ----- Interrupts -----

void lptmr_isr()
{
    17b4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    17b8:	4e44      	ldr	r6, [pc, #272]	; (18cc <lptmr_isr+0x118>)
	gWDT_buffer[gWDT_buffer_position] = val;
    17ba:	4c45      	ldr	r4, [pc, #276]	; (18d0 <lptmr_isr+0x11c>)
{
    17bc:	6833      	ldr	r3, [r6, #0]
    17be:	9301      	str	r3, [sp, #4]
	LPTMR0_CSR = 0b10000100;
    17c0:	4b44      	ldr	r3, [pc, #272]	; (18d4 <lptmr_isr+0x120>)
    17c2:	2284      	movs	r2, #132	; 0x84
    17c4:	601a      	str	r2, [r3, #0]
	LPTMR0_CSR = 0b01000101;
    17c6:	2245      	movs	r2, #69	; 0x45
    17c8:	601a      	str	r2, [r3, #0]
	isr_hardware_neutral(SYST_CVR);
    17ca:	4b43      	ldr	r3, [pc, #268]	; (18d8 <lptmr_isr+0x124>)
	gWDT_buffer[gWDT_buffer_position] = val;
    17cc:	4a43      	ldr	r2, [pc, #268]	; (18dc <lptmr_isr+0x128>)
	isr_hardware_neutral(SYST_CVR);
    17ce:	6819      	ldr	r1, [r3, #0]
	gWDT_buffer[gWDT_buffer_position] = val;
    17d0:	7823      	ldrb	r3, [r4, #0]
	isr_hardware_neutral(SYST_CVR);
    17d2:	54d1      	strb	r1, [r2, r3]
	gWDT_buffer_position++; // every time the WDT interrupt is triggered
    17d4:	3301      	adds	r3, #1
    17d6:	b2db      	uxtb	r3, r3
	if ( gWDT_buffer_position >= gWDT_buffer_SIZE )
    17d8:	2b1f      	cmp	r3, #31
	gWDT_buffer_position++; // every time the WDT interrupt is triggered
    17da:	7023      	strb	r3, [r4, #0]
    17dc:	4694      	mov	ip, r2
	if ( gWDT_buffer_position >= gWDT_buffer_SIZE )
    17de:	d96b      	bls.n	18b8 <lptmr_isr+0x104>
		gWDT_pool_end = (gWDT_pool_start + gWDT_pool_count) % WDT_POOL_SIZE;
    17e0:	483f      	ldr	r0, [pc, #252]	; (18e0 <lptmr_isr+0x12c>)
    17e2:	4940      	ldr	r1, [pc, #256]	; (18e4 <lptmr_isr+0x130>)
    17e4:	7803      	ldrb	r3, [r0, #0]
    17e6:	780a      	ldrb	r2, [r1, #0]
    17e8:	4413      	add	r3, r2
    17ea:	4a3f      	ldr	r2, [pc, #252]	; (18e8 <lptmr_isr+0x134>)
    17ec:	f003 0307 	and.w	r3, r3, #7
    17f0:	7013      	strb	r3, [r2, #0]
			gWDT_entropy_pool[gWDT_pool_end] += gWDT_buffer[gWDT_loop_counter];
    17f2:	4b3e      	ldr	r3, [pc, #248]	; (18ec <lptmr_isr+0x138>)
		gWDT_pool_end = (gWDT_pool_start + gWDT_pool_count) % WDT_POOL_SIZE;
    17f4:	2500      	movs	r5, #0
			gWDT_entropy_pool[gWDT_pool_end] += gWDT_buffer[gWDT_loop_counter];
    17f6:	7817      	ldrb	r7, [r2, #0]
    17f8:	f81c e005 	ldrb.w	lr, [ip, r5]
    17fc:	b2ff      	uxtb	r7, r7
    17fe:	3501      	adds	r5, #1
    1800:	f853 8027 	ldr.w	r8, [r3, r7, lsl #2]
    1804:	44c6      	add	lr, r8
    1806:	f843 e027 	str.w	lr, [r3, r7, lsl #2]
			gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 10);
    180a:	7817      	ldrb	r7, [r2, #0]
    180c:	b2ff      	uxtb	r7, r7
		for ( gWDT_loop_counter = 0; gWDT_loop_counter < gWDT_buffer_SIZE; ++gWDT_loop_counter )
    180e:	2d20      	cmp	r5, #32
			gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 10);
    1810:	f853 8027 	ldr.w	r8, [r3, r7, lsl #2]
    1814:	7817      	ldrb	r7, [r2, #0]
    1816:	b2ff      	uxtb	r7, r7
    1818:	f853 e027 	ldr.w	lr, [r3, r7, lsl #2]
    181c:	eb0e 2e88 	add.w	lr, lr, r8, lsl #10
    1820:	f843 e027 	str.w	lr, [r3, r7, lsl #2]
			gWDT_entropy_pool[gWDT_pool_end] ^= (gWDT_entropy_pool[gWDT_pool_end] >> 6);
    1824:	7817      	ldrb	r7, [r2, #0]
    1826:	b2ff      	uxtb	r7, r7
    1828:	f853 8027 	ldr.w	r8, [r3, r7, lsl #2]
    182c:	7817      	ldrb	r7, [r2, #0]
    182e:	b2ff      	uxtb	r7, r7
    1830:	f853 e027 	ldr.w	lr, [r3, r7, lsl #2]
    1834:	ea8e 1e98 	eor.w	lr, lr, r8, lsr #6
    1838:	f843 e027 	str.w	lr, [r3, r7, lsl #2]
		for ( gWDT_loop_counter = 0; gWDT_loop_counter < gWDT_buffer_SIZE; ++gWDT_loop_counter )
    183c:	d1db      	bne.n	17f6 <lptmr_isr+0x42>
    183e:	4f2c      	ldr	r7, [pc, #176]	; (18f0 <lptmr_isr+0x13c>)
    1840:	703d      	strb	r5, [r7, #0]
		gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 3);
    1842:	7815      	ldrb	r5, [r2, #0]
    1844:	b2ed      	uxtb	r5, r5
    1846:	f853 c025 	ldr.w	ip, [r3, r5, lsl #2]
    184a:	7815      	ldrb	r5, [r2, #0]
    184c:	b2ed      	uxtb	r5, r5
    184e:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    1852:	eb07 07cc 	add.w	r7, r7, ip, lsl #3
    1856:	f843 7025 	str.w	r7, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] ^= (gWDT_entropy_pool[gWDT_pool_end] >> 11);
    185a:	7815      	ldrb	r5, [r2, #0]
    185c:	b2ed      	uxtb	r5, r5
    185e:	f853 c025 	ldr.w	ip, [r3, r5, lsl #2]
    1862:	7815      	ldrb	r5, [r2, #0]
    1864:	b2ed      	uxtb	r5, r5
    1866:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    186a:	ea87 27dc 	eor.w	r7, r7, ip, lsr #11
    186e:	f843 7025 	str.w	r7, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 15);
    1872:	7815      	ldrb	r5, [r2, #0]
    1874:	b2ed      	uxtb	r5, r5
    1876:	f853 c025 	ldr.w	ip, [r3, r5, lsl #2]
    187a:	7815      	ldrb	r5, [r2, #0]
    187c:	b2ed      	uxtb	r5, r5
    187e:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    1882:	eb07 37cc 	add.w	r7, r7, ip, lsl #15
    1886:	f843 7025 	str.w	r7, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] = gWDT_entropy_pool[gWDT_pool_end];
    188a:	7815      	ldrb	r5, [r2, #0]
    188c:	7812      	ldrb	r2, [r2, #0]
    188e:	b2ed      	uxtb	r5, r5
    1890:	b2d2      	uxtb	r2, r2
    1892:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
    1896:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
		gWDT_buffer_position = 0;
    189a:	2300      	movs	r3, #0
    189c:	7023      	strb	r3, [r4, #0]
		if (gWDT_pool_count == WDT_POOL_SIZE)
    189e:	780b      	ldrb	r3, [r1, #0]
    18a0:	2b08      	cmp	r3, #8
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    18a2:	bf0b      	itete	eq
    18a4:	7803      	ldrbeq	r3, [r0, #0]
			++gWDT_pool_count;
    18a6:	780b      	ldrbne	r3, [r1, #0]
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    18a8:	3301      	addeq	r3, #1
			++gWDT_pool_count;
    18aa:	3301      	addne	r3, #1
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    18ac:	bf0b      	itete	eq
    18ae:	f003 0307 	andeq.w	r3, r3, #7
			++gWDT_pool_count;
    18b2:	b2db      	uxtbne	r3, r3
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    18b4:	7003      	strbeq	r3, [r0, #0]
			++gWDT_pool_count;
    18b6:	700b      	strbne	r3, [r1, #0]
}
    18b8:	9a01      	ldr	r2, [sp, #4]
    18ba:	6833      	ldr	r3, [r6, #0]
    18bc:	429a      	cmp	r2, r3
    18be:	d001      	beq.n	18c4 <lptmr_isr+0x110>
    18c0:	f7ff fe30 	bl	1524 <__stack_chk_fail>
    18c4:	b002      	add	sp, #8
    18c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    18ca:	bf00      	nop
    18cc:	1fffe9d0 	.word	0x1fffe9d0
    18d0:	1ffffc04 	.word	0x1ffffc04
    18d4:	40040000 	.word	0x40040000
    18d8:	e000e018 	.word	0xe000e018
    18dc:	1ffffc05 	.word	0x1ffffc05
    18e0:	1ffffc26 	.word	0x1ffffc26
    18e4:	1ffffc25 	.word	0x1ffffc25
    18e8:	1ffffc27 	.word	0x1ffffc27
    18ec:	1ffffbe4 	.word	0x1ffffbe4
    18f0:	1ffffc28 	.word	0x1ffffc28

000018f4 <GPIO_Ctrl>:
// ----- Functions -----

// Pin action (Strobe, Sense, Strobe Setup, Sense Setup)
// GPIO_Config is only set with DriveSetup and ReadSetup, otherwise it is ignored
uint8_t GPIO_Ctrl( GPIO_Pin gpio, GPIO_Type type, GPIO_Config config )
{
    18f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    18f6:	4d2f      	ldr	r5, [pc, #188]	; (19b4 <GPIO_Ctrl+0xc0>)
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;

	// Assumes 0x40 between GPIO Port registers and 0x1000 between PORT pin registers
	// See Lib/kinetis.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
    18f8:	4e2f      	ldr	r6, [pc, #188]	; (19b8 <GPIO_Ctrl+0xc4>)
{
    18fa:	682b      	ldr	r3, [r5, #0]
    18fc:	b085      	sub	sp, #20
    18fe:	f8ad 0004 	strh.w	r0, [sp, #4]
    1902:	9303      	str	r3, [sp, #12]
    1904:	f89d 0005 	ldrb.w	r0, [sp, #5]
    1908:	f89d 3004 	ldrb.w	r3, [sp, #4]
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
    190c:	019c      	lsls	r4, r3, #6
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;
    190e:	eb00 2383 	add.w	r3, r0, r3, lsl #10
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
	volatile unsigned int *GPIO_PTOR = (unsigned int*)(&GPIOA_PTOR) + gpio_offset;
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
	volatile unsigned int *PORT_PCR  = (unsigned int*)(&PORTA_PCR0) + port_offset;
    1912:	009b      	lsls	r3, r3, #2
    1914:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    1918:	f503 2392 	add.w	r3, r3, #299008	; 0x49000

	// Operation depends on Type
	switch ( type )
    191c:	2905      	cmp	r1, #5
    191e:	d80b      	bhi.n	1938 <GPIO_Ctrl+0x44>
    1920:	e8df f001 	tbb	[pc, r1]
    1924:	100e0c03 	.word	0x100e0c03
    1928:	2f20      	.short	0x2f20
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
    192a:	4a24      	ldr	r2, [pc, #144]	; (19bc <GPIO_Ctrl+0xc8>)
	case GPIO_Type_DriveLow:
		*GPIO_PCOR |= (1 << gpio.pin);
		break;

	case GPIO_Type_DriveToggle:
		*GPIO_PTOR |= (1 << gpio.pin);
    192c:	58a1      	ldr	r1, [r4, r2]
    192e:	2301      	movs	r3, #1
    1930:	fa03 f000 	lsl.w	r0, r3, r0
    1934:	4308      	orrs	r0, r1
    1936:	50a0      	str	r0, [r4, r2]
		pio->PIO_PER |= (1 << gpio.pin);
		break;
	}
#endif

	return 0;
    1938:	2000      	movs	r0, #0
			break;
    193a:	e01c      	b.n	1976 <GPIO_Ctrl+0x82>
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
    193c:	4a20      	ldr	r2, [pc, #128]	; (19c0 <GPIO_Ctrl+0xcc>)
    193e:	e7f5      	b.n	192c <GPIO_Ctrl+0x38>
	volatile unsigned int *GPIO_PTOR = (unsigned int*)(&GPIOA_PTOR) + gpio_offset;
    1940:	4a20      	ldr	r2, [pc, #128]	; (19c4 <GPIO_Ctrl+0xd0>)
    1942:	e7f3      	b.n	192c <GPIO_Ctrl+0x38>
		*GPIO_PDDR |= (1 << gpio.pin);
    1944:	59a7      	ldr	r7, [r4, r6]
    1946:	2101      	movs	r1, #1
    1948:	fa01 f000 	lsl.w	r0, r1, r0
    194c:	4338      	orrs	r0, r7
		*PORT_PCR = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    194e:	f44f 71a2 	mov.w	r1, #324	; 0x144
		switch ( config )
    1952:	2a03      	cmp	r2, #3
		*GPIO_PDDR |= (1 << gpio.pin);
    1954:	51a0      	str	r0, [r4, r6]
		*PORT_PCR = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    1956:	6019      	str	r1, [r3, #0]
		switch ( config )
    1958:	d1ee      	bne.n	1938 <GPIO_Ctrl+0x44>
			*PORT_PCR |= PORT_PCR_ODE;
    195a:	681a      	ldr	r2, [r3, #0]
    195c:	f042 0220 	orr.w	r2, r2, #32
			*PORT_PCR |= PORT_PCR_PE;
    1960:	601a      	str	r2, [r3, #0]
    1962:	e7e9      	b.n	1938 <GPIO_Ctrl+0x44>
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
    1964:	4b18      	ldr	r3, [pc, #96]	; (19c8 <GPIO_Ctrl+0xd4>)
		return *GPIO_PDIR & (1 << gpio.pin) ? 1 : 0;
    1966:	58e2      	ldr	r2, [r4, r3]
    1968:	2301      	movs	r3, #1
    196a:	fa03 f000 	lsl.w	r0, r3, r0
    196e:	4210      	tst	r0, r2
    1970:	bf14      	ite	ne
    1972:	4618      	movne	r0, r3
    1974:	2000      	moveq	r0, #0
}
    1976:	9a03      	ldr	r2, [sp, #12]
    1978:	682b      	ldr	r3, [r5, #0]
    197a:	429a      	cmp	r2, r3
    197c:	d017      	beq.n	19ae <GPIO_Ctrl+0xba>
    197e:	f7ff fdd1 	bl	1524 <__stack_chk_fail>
		*GPIO_PDDR &= ~(1 << gpio.pin);
    1982:	59a1      	ldr	r1, [r4, r6]
    1984:	2701      	movs	r7, #1
    1986:	fa07 f000 	lsl.w	r0, r7, r0
    198a:	ea21 0000 	bic.w	r0, r1, r0
		switch ( config )
    198e:	42ba      	cmp	r2, r7
		*PORT_PCR = PORT_PCR_PFE | PORT_PCR_MUX(1);
    1990:	f44f 7188 	mov.w	r1, #272	; 0x110
		*GPIO_PDDR &= ~(1 << gpio.pin);
    1994:	51a0      	str	r0, [r4, r6]
		*PORT_PCR = PORT_PCR_PFE | PORT_PCR_MUX(1);
    1996:	6019      	str	r1, [r3, #0]
		switch ( config )
    1998:	d005      	beq.n	19a6 <GPIO_Ctrl+0xb2>
    199a:	2a02      	cmp	r2, #2
    199c:	d1cc      	bne.n	1938 <GPIO_Ctrl+0x44>
			*PORT_PCR |= PORT_PCR_PE;
    199e:	681a      	ldr	r2, [r3, #0]
    19a0:	f042 0202 	orr.w	r2, r2, #2
    19a4:	e7dc      	b.n	1960 <GPIO_Ctrl+0x6c>
			*PORT_PCR |= PORT_PCR_PE | PORT_PCR_PS;
    19a6:	681a      	ldr	r2, [r3, #0]
    19a8:	f042 0203 	orr.w	r2, r2, #3
    19ac:	e7d8      	b.n	1960 <GPIO_Ctrl+0x6c>
}
    19ae:	b005      	add	sp, #20
    19b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    19b2:	bf00      	nop
    19b4:	1fffe9d0 	.word	0x1fffe9d0
    19b8:	400ff014 	.word	0x400ff014
    19bc:	400ff004 	.word	0x400ff004
    19c0:	400ff008 	.word	0x400ff008
    19c4:	400ff00c 	.word	0x400ff00c
    19c8:	400ff010 	.word	0x400ff010

000019cc <Periodic_init>:
// ----- Functions -----

#if defined(_kinetis_k_)
// Must set function pointer first!!
void Periodic_init( uint32_t cycles )
{
    19cc:	b513      	push	{r0, r1, r4, lr}
    19ce:	4a10      	ldr	r2, [pc, #64]	; (1a10 <Periodic_init+0x44>)
	// Setup PIT (Programmable Interrupt Timer)
	SIM_SCGC6 |= SIM_SCGC6_PIT;;
    19d0:	4910      	ldr	r1, [pc, #64]	; (1a14 <Periodic_init+0x48>)
{
    19d2:	6813      	ldr	r3, [r2, #0]
    19d4:	9301      	str	r3, [sp, #4]
	SIM_SCGC6 |= SIM_SCGC6_PIT;;
    19d6:	680b      	ldr	r3, [r1, #0]
	PIT_TCTRL0 = 0x00; // Make sure timer is disabled first
	PIT_MCR = 0x00; // Enable module, do not freeze timers in debug mode
    19d8:	4c0f      	ldr	r4, [pc, #60]	; (1a18 <Periodic_init+0x4c>)
	SIM_SCGC6 |= SIM_SCGC6_PIT;;
    19da:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    19de:	600b      	str	r3, [r1, #0]
	PIT_TCTRL0 = 0x00; // Make sure timer is disabled first
    19e0:	4b0e      	ldr	r3, [pc, #56]	; (1a1c <Periodic_init+0x50>)
    19e2:	2100      	movs	r1, #0
    19e4:	6019      	str	r1, [r3, #0]
	PIT_MCR = 0x00; // Enable module, do not freeze timers in debug mode
    19e6:	6021      	str	r1, [r4, #0]

	// Timer Count-down value
	// Number of cycles to count from CPU clock before calling interrupt
	PIT_LDVAL0 = cycles;
    19e8:	490d      	ldr	r1, [pc, #52]	; (1a20 <Periodic_init+0x54>)
    19ea:	6008      	str	r0, [r1, #0]

	// Enable Timer, Enable interrupt
	PIT_TCTRL0 = PIT_TCTRL_TIE | PIT_TCTRL_TEN;
    19ec:	2103      	movs	r1, #3
    19ee:	6019      	str	r1, [r3, #0]

	// Enable PIT Ch0 interrupt
	NVIC_ENABLE_IRQ( IRQ_PIT_CH0 );
    19f0:	4b0c      	ldr	r3, [pc, #48]	; (1a24 <Periodic_init+0x58>)
    19f2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    19f6:	6019      	str	r1, [r3, #0]

	// Set PIT0 interrupt to a low priority
	NVIC_SET_PRIORITY( IRQ_PIT_CH0, 200 );
    19f8:	21c8      	movs	r1, #200	; 0xc8
    19fa:	f883 131e 	strb.w	r1, [r3, #798]	; 0x31e
}
    19fe:	9901      	ldr	r1, [sp, #4]
    1a00:	6813      	ldr	r3, [r2, #0]
    1a02:	4299      	cmp	r1, r3
    1a04:	d001      	beq.n	1a0a <Periodic_init+0x3e>
    1a06:	f7ff fd8d 	bl	1524 <__stack_chk_fail>
    1a0a:	b002      	add	sp, #8
    1a0c:	bd10      	pop	{r4, pc}
    1a0e:	bf00      	nop
    1a10:	1fffe9d0 	.word	0x1fffe9d0
    1a14:	4004803c 	.word	0x4004803c
    1a18:	40037000 	.word	0x40037000
    1a1c:	40037108 	.word	0x40037108
    1a20:	40037100 	.word	0x40037100
    1a24:	e000e100 	.word	0xe000e100

00001a28 <Periodic_enable>:

void Periodic_enable()
{
    1a28:	b507      	push	{r0, r1, r2, lr}
    1a2a:	4b08      	ldr	r3, [pc, #32]	; (1a4c <Periodic_enable+0x24>)
    1a2c:	681a      	ldr	r2, [r3, #0]
    1a2e:	9201      	str	r2, [sp, #4]
	// Used to re-enable IRQ
	NVIC_ENABLE_IRQ( IRQ_PIT_CH0 );
    1a30:	4a07      	ldr	r2, [pc, #28]	; (1a50 <Periodic_enable+0x28>)
    1a32:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    1a36:	6011      	str	r1, [r2, #0]
}
    1a38:	9a01      	ldr	r2, [sp, #4]
    1a3a:	681b      	ldr	r3, [r3, #0]
    1a3c:	429a      	cmp	r2, r3
    1a3e:	d001      	beq.n	1a44 <Periodic_enable+0x1c>
    1a40:	f7ff fd70 	bl	1524 <__stack_chk_fail>
    1a44:	b003      	add	sp, #12
    1a46:	f85d fb04 	ldr.w	pc, [sp], #4
    1a4a:	bf00      	nop
    1a4c:	1fffe9d0 	.word	0x1fffe9d0
    1a50:	e000e100 	.word	0xe000e100

00001a54 <Periodic_disable>:

void Periodic_disable()
{
    1a54:	b507      	push	{r0, r1, r2, lr}
    1a56:	4b08      	ldr	r3, [pc, #32]	; (1a78 <Periodic_disable+0x24>)
    1a58:	681a      	ldr	r2, [r3, #0]
    1a5a:	9201      	str	r2, [sp, #4]
	// Used to disable IRQ
	NVIC_DISABLE_IRQ( IRQ_PIT_CH0 );
    1a5c:	4a07      	ldr	r2, [pc, #28]	; (1a7c <Periodic_disable+0x28>)
    1a5e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    1a62:	6011      	str	r1, [r2, #0]
}
    1a64:	9a01      	ldr	r2, [sp, #4]
    1a66:	681b      	ldr	r3, [r3, #0]
    1a68:	429a      	cmp	r2, r3
    1a6a:	d001      	beq.n	1a70 <Periodic_disable+0x1c>
    1a6c:	f7ff fd5a 	bl	1524 <__stack_chk_fail>
    1a70:	b003      	add	sp, #12
    1a72:	f85d fb04 	ldr.w	pc, [sp], #4
    1a76:	bf00      	nop
    1a78:	1fffe9d0 	.word	0x1fffe9d0
    1a7c:	e000e180 	.word	0xe000e180

00001a80 <Periodic_function>:

void Periodic_function( void *func )
{
    1a80:	b507      	push	{r0, r1, r2, lr}
    1a82:	4b07      	ldr	r3, [pc, #28]	; (1aa0 <Periodic_function+0x20>)
    1a84:	681a      	ldr	r2, [r3, #0]
    1a86:	9201      	str	r2, [sp, #4]
	// Set function pointer
	periodic_func = func;
    1a88:	4a06      	ldr	r2, [pc, #24]	; (1aa4 <Periodic_function+0x24>)
    1a8a:	6010      	str	r0, [r2, #0]
}
    1a8c:	9a01      	ldr	r2, [sp, #4]
    1a8e:	681b      	ldr	r3, [r3, #0]
    1a90:	429a      	cmp	r2, r3
    1a92:	d001      	beq.n	1a98 <Periodic_function+0x18>
    1a94:	f7ff fd46 	bl	1524 <__stack_chk_fail>
    1a98:	b003      	add	sp, #12
    1a9a:	f85d fb04 	ldr.w	pc, [sp], #4
    1a9e:	bf00      	nop
    1aa0:	1fffe9d0 	.word	0x1fffe9d0
    1aa4:	1ffff04c 	.word	0x1ffff04c

00001aa8 <Periodic_cycles>:

uint32_t Periodic_cycles()
{
    1aa8:	b507      	push	{r0, r1, r2, lr}
    1aaa:	4b07      	ldr	r3, [pc, #28]	; (1ac8 <Periodic_cycles+0x20>)
    1aac:	681a      	ldr	r2, [r3, #0]
    1aae:	9201      	str	r2, [sp, #4]
	return PIT_LDVAL0;
    1ab0:	4a06      	ldr	r2, [pc, #24]	; (1acc <Periodic_cycles+0x24>)
    1ab2:	6810      	ldr	r0, [r2, #0]
}
    1ab4:	9a01      	ldr	r2, [sp, #4]
    1ab6:	681b      	ldr	r3, [r3, #0]
    1ab8:	429a      	cmp	r2, r3
    1aba:	d001      	beq.n	1ac0 <Periodic_cycles+0x18>
    1abc:	f7ff fd32 	bl	1524 <__stack_chk_fail>
    1ac0:	b003      	add	sp, #12
    1ac2:	f85d fb04 	ldr.w	pc, [sp], #4
    1ac6:	bf00      	nop
    1ac8:	1fffe9d0 	.word	0x1fffe9d0
    1acc:	40037100 	.word	0x40037100

00001ad0 <pit0_isr>:

void pit0_isr()
{
    1ad0:	b513      	push	{r0, r1, r4, lr}
    1ad2:	4c08      	ldr	r4, [pc, #32]	; (1af4 <pit0_isr+0x24>)
    1ad4:	6823      	ldr	r3, [r4, #0]
    1ad6:	9301      	str	r3, [sp, #4]
	// Call specified function
	(*periodic_func)();
    1ad8:	4b07      	ldr	r3, [pc, #28]	; (1af8 <pit0_isr+0x28>)
    1ada:	681b      	ldr	r3, [r3, #0]
    1adc:	4798      	blx	r3

	// Clear the interrupt
	PIT_TFLG0 = PIT_TFLG_TIF;
    1ade:	4b07      	ldr	r3, [pc, #28]	; (1afc <pit0_isr+0x2c>)
    1ae0:	2201      	movs	r2, #1
    1ae2:	601a      	str	r2, [r3, #0]
}
    1ae4:	9a01      	ldr	r2, [sp, #4]
    1ae6:	6823      	ldr	r3, [r4, #0]
    1ae8:	429a      	cmp	r2, r3
    1aea:	d001      	beq.n	1af0 <pit0_isr+0x20>
    1aec:	f7ff fd1a 	bl	1524 <__stack_chk_fail>
    1af0:	b002      	add	sp, #8
    1af2:	bd10      	pop	{r4, pc}
    1af4:	1fffe9d0 	.word	0x1fffe9d0
    1af8:	1ffff04c 	.word	0x1ffff04c
    1afc:	4003710c 	.word	0x4003710c

00001b00 <Time_now>:

// ----- Functions -----

// Get current time
Time Time_now()
{
    1b00:	b513      	push	{r0, r1, r4, lr}
    1b02:	4b08      	ldr	r3, [pc, #32]	; (1b24 <Time_now+0x24>)
    1b04:	6819      	ldr	r1, [r3, #0]
    1b06:	9101      	str	r1, [sp, #4]
#if defined(_kinetis_)
	Time time = {
    1b08:	4907      	ldr	r1, [pc, #28]	; (1b28 <Time_now+0x28>)
    1b0a:	680c      	ldr	r4, [r1, #0]
		.ms    = systick_millis_count,
		.ticks = ARM_DWT_CYCCNT,
    1b0c:	4907      	ldr	r1, [pc, #28]	; (1b2c <Time_now+0x2c>)
    1b0e:	6809      	ldr	r1, [r1, #0]
	// No time facilities...
	Time time = Time_init();
#endif

	return time;
}
    1b10:	9a01      	ldr	r2, [sp, #4]
    1b12:	681b      	ldr	r3, [r3, #0]
    1b14:	429a      	cmp	r2, r3
	return time;
    1b16:	e9c0 4100 	strd	r4, r1, [r0]
}
    1b1a:	d001      	beq.n	1b20 <Time_now+0x20>
    1b1c:	f7ff fd02 	bl	1524 <__stack_chk_fail>
    1b20:	b002      	add	sp, #8
    1b22:	bd10      	pop	{r4, pc}
    1b24:	1fffe9d0 	.word	0x1fffe9d0
    1b28:	1ffff048 	.word	0x1ffff048
    1b2c:	e0001004 	.word	0xe0001004

00001b30 <Time_init>:
// Get zero'd Time
#if !defined(_host_)
inline
#endif
Time Time_init()
{
    1b30:	b507      	push	{r0, r1, r2, lr}
    1b32:	4b07      	ldr	r3, [pc, #28]	; (1b50 <Time_init+0x20>)
    1b34:	6819      	ldr	r1, [r3, #0]
    1b36:	9101      	str	r1, [sp, #4]
	Time time = {
		.ms    = 0,
		.ticks = 0,
	};
	return time;
}
    1b38:	9a01      	ldr	r2, [sp, #4]
    1b3a:	681b      	ldr	r3, [r3, #0]
	return time;
    1b3c:	2100      	movs	r1, #0
}
    1b3e:	429a      	cmp	r2, r3
	return time;
    1b40:	e9c0 1100 	strd	r1, r1, [r0]
}
    1b44:	d001      	beq.n	1b4a <Time_init+0x1a>
    1b46:	f7ff fced 	bl	1524 <__stack_chk_fail>
    1b4a:	b003      	add	sp, #12
    1b4c:	f85d fb04 	ldr.w	pc, [sp], #4
    1b50:	1fffe9d0 	.word	0x1fffe9d0

00001b54 <Time_add>:

// Add time amount to a given variable
// Returns 1 if there was an ms rollover
uint8_t Time_add( Time *current, Time add )
{
    1b54:	b530      	push	{r4, r5, lr}
    1b56:	b085      	sub	sp, #20
    1b58:	466b      	mov	r3, sp
    1b5a:	e883 0006 	stmia.w	r3, {r1, r2}
    1b5e:	4912      	ldr	r1, [pc, #72]	; (1ba8 <Time_add+0x54>)
	Time data = Time_init();
	data.ms = 0;
	data.ticks = current->ticks + add.ticks;
    1b60:	9c01      	ldr	r4, [sp, #4]
{
    1b62:	680b      	ldr	r3, [r1, #0]
    1b64:	9303      	str	r3, [sp, #12]
	data.ticks = current->ticks + add.ticks;
    1b66:	6843      	ldr	r3, [r0, #4]
		data.ms++;
	}

	// It's ok if ms rolls over (it will eventually anyways)
	uint8_t rollover = 0;
	data.ms += current->ms + add.ms;
    1b68:	6805      	ldr	r5, [r0, #0]
    1b6a:	9a00      	ldr	r2, [sp, #0]
	data.ticks = current->ticks + add.ticks;
    1b6c:	4423      	add	r3, r4
	if ( data.ticks >= Time_maxTicks )
    1b6e:	f64b 347f 	movw	r4, #47999	; 0xbb7f
    1b72:	42a3      	cmp	r3, r4
	data.ms += current->ms + add.ms;
    1b74:	442a      	add	r2, r5
    1b76:	460c      	mov	r4, r1
		data.ms++;
    1b78:	bf8a      	itet	hi
    1b7a:	2101      	movhi	r1, #1
	data.ms = 0;
    1b7c:	2100      	movls	r1, #0
		data.ticks -= Time_maxTicks;
    1b7e:	f5a3 433b 	subhi.w	r3, r3, #47872	; 0xbb00
	data.ms += current->ms + add.ms;
    1b82:	4411      	add	r1, r2
		data.ticks -= Time_maxTicks;
    1b84:	bf88      	it	hi
    1b86:	3b80      	subhi	r3, #128	; 0x80
	if ( data.ms + current->ms + add.ms <= current->ms )
    1b88:	440a      	add	r2, r1

	// Set the time
	*current = data;

	return rollover;
}
    1b8a:	4295      	cmp	r5, r2
	*current = data;
    1b8c:	e9c0 1300 	strd	r1, r3, [r0]
}
    1b90:	9a03      	ldr	r2, [sp, #12]
    1b92:	6823      	ldr	r3, [r4, #0]
    1b94:	bf34      	ite	cc
    1b96:	2000      	movcc	r0, #0
    1b98:	2001      	movcs	r0, #1
    1b9a:	429a      	cmp	r2, r3
    1b9c:	d001      	beq.n	1ba2 <Time_add+0x4e>
    1b9e:	f7ff fcc1 	bl	1524 <__stack_chk_fail>
    1ba2:	b005      	add	sp, #20
    1ba4:	bd30      	pop	{r4, r5, pc}
    1ba6:	bf00      	nop
    1ba8:	1fffe9d0 	.word	0x1fffe9d0

00001bac <Time_compare>:
// Compares two Time variables
// -1 if compare is less than base
//  0 if compare is the same
//  1 if compare is more than base
int8_t Time_compare( Time base, Time compare )
{
    1bac:	b510      	push	{r4, lr}
    1bae:	b086      	sub	sp, #24
    1bb0:	ac02      	add	r4, sp, #8
    1bb2:	e884 0003 	stmia.w	r4, {r0, r1}
    1bb6:	4669      	mov	r1, sp
    1bb8:	e881 000c 	stmia.w	r1, {r2, r3}
	// First compare ms
	if ( base.ms > compare.ms )
    1bbc:	4604      	mov	r4, r0
{
    1bbe:	4b0e      	ldr	r3, [pc, #56]	; (1bf8 <Time_compare+0x4c>)
	if ( base.ms > compare.ms )
    1bc0:	9800      	ldr	r0, [sp, #0]
{
    1bc2:	681a      	ldr	r2, [r3, #0]
    1bc4:	9205      	str	r2, [sp, #20]
	if ( base.ms > compare.ms )
    1bc6:	4284      	cmp	r4, r0
    1bc8:	9903      	ldr	r1, [sp, #12]
    1bca:	9a01      	ldr	r2, [sp, #4]
    1bcc:	d80e      	bhi.n	1bec <Time_compare+0x40>
	{
		return -1;
	}
	else if ( base.ms < compare.ms )
    1bce:	d30b      	bcc.n	1be8 <Time_compare+0x3c>
	{
		return 1;
	}

	// Next compare ticks (ms is the same)
	if ( base.ticks > compare.ticks )
    1bd0:	4291      	cmp	r1, r2
    1bd2:	d80b      	bhi.n	1bec <Time_compare+0x40>
	{
		return -1;
	}
	else if ( base.ticks < compare.ticks )
    1bd4:	bf34      	ite	cc
    1bd6:	2001      	movcc	r0, #1
    1bd8:	2000      	movcs	r0, #0
		return -1;
    1bda:	b240      	sxtb	r0, r0
		return 1;
	}

	// Otherwise base and compare are identical
	return 0;
}
    1bdc:	9a05      	ldr	r2, [sp, #20]
    1bde:	681b      	ldr	r3, [r3, #0]
    1be0:	429a      	cmp	r2, r3
    1be2:	d006      	beq.n	1bf2 <Time_compare+0x46>
    1be4:	f7ff fc9e 	bl	1524 <__stack_chk_fail>
		return 1;
    1be8:	2001      	movs	r0, #1
    1bea:	e7f7      	b.n	1bdc <Time_compare+0x30>
		return -1;
    1bec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1bf0:	e7f4      	b.n	1bdc <Time_compare+0x30>
}
    1bf2:	b006      	add	sp, #24
    1bf4:	bd10      	pop	{r4, pc}
    1bf6:	bf00      	nop
    1bf8:	1fffe9d0 	.word	0x1fffe9d0

00001bfc <Time_us>:

#if !defined(_host_)
inline
#endif
uint32_t Time_us( Time time )
{
    1bfc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    1bfe:	466b      	mov	r3, sp
    1c00:	e883 0003 	stmia.w	r3, {r0, r1}
    1c04:	4b0d      	ldr	r3, [pc, #52]	; (1c3c <Time_us+0x40>)
    1c06:	681a      	ldr	r2, [r3, #0]
    1c08:	9203      	str	r2, [sp, #12]
	// Return max uint32_t if ms count is too high
	if ( time.ms >= (0xFFFFFFFF / 1000) )
    1c0a:	4a0d      	ldr	r2, [pc, #52]	; (1c40 <Time_us+0x44>)
    1c0c:	4290      	cmp	r0, r2
	{
		return 0xFFFFFFFF;
	}

	uint32_t us = time.ms * 1000 + time.ticks / (Time_maxTicks / 1000);
    1c0e:	bf9f      	itttt	ls
    1c10:	460a      	movls	r2, r1
    1c12:	2130      	movls	r1, #48	; 0x30
    1c14:	fbb2 f2f1 	udivls	r2, r2, r1
    1c18:	f44f 717a 	movls.w	r1, #1000	; 0x3e8
    1c1c:	bf98      	it	ls
    1c1e:	fb01 2000 	mlals	r0, r1, r0, r2
	return us;
}
    1c22:	9a03      	ldr	r2, [sp, #12]
    1c24:	681b      	ldr	r3, [r3, #0]
		return 0xFFFFFFFF;
    1c26:	bf88      	it	hi
    1c28:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
}
    1c2c:	429a      	cmp	r2, r3
    1c2e:	d001      	beq.n	1c34 <Time_us+0x38>
    1c30:	f7ff fc78 	bl	1524 <__stack_chk_fail>
    1c34:	b005      	add	sp, #20
    1c36:	f85d fb04 	ldr.w	pc, [sp], #4
    1c3a:	bf00      	nop
    1c3c:	1fffe9d0 	.word	0x1fffe9d0
    1c40:	00418936 	.word	0x00418936

00001c44 <Time_ns>:

#if !defined(_host_)
inline
#endif
uint32_t Time_ns( Time time )
{
    1c44:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    1c46:	466b      	mov	r3, sp
    1c48:	e883 0003 	stmia.w	r3, {r0, r1}
    1c4c:	4b0f      	ldr	r3, [pc, #60]	; (1c8c <Time_ns+0x48>)
    1c4e:	681a      	ldr	r2, [r3, #0]
    1c50:	9203      	str	r2, [sp, #12]
	// Return max uint32_t if ms count is too high
	if ( time.ms >= (0xFFFFFFFF / 1000000) )
    1c52:	f241 02c5 	movw	r2, #4293	; 0x10c5
    1c56:	4290      	cmp	r0, r2
    1c58:	461a      	mov	r2, r3
	//              converting to ns is more interesting.
	//              For example, 120 MHz /w 400 ticks is 8.333..ns * 400 ticks = 3333.2 ns
	//              To do this with integers only, we multiply the ns constant to us, then divide by 1000 at the end.
	//               400 * 8333 / 1000 = 3333 ns
	//              Not exact, but pretty close.
	uint32_t ns = time.ms * 1000000 + (time.ticks * Time_ticksPer_ns_x1000 / 1000);
    1c5a:	bf9f      	itttt	ls
    1c5c:	f245 1361 	movwls	r3, #20833	; 0x5161
    1c60:	434b      	mulls	r3, r1
    1c62:	f44f 717a 	movls.w	r1, #1000	; 0x3e8
    1c66:	fbb3 f3f1 	udivls	r3, r3, r1
    1c6a:	bf9c      	itt	ls
    1c6c:	4908      	ldrls	r1, [pc, #32]	; (1c90 <Time_ns+0x4c>)
    1c6e:	fb01 3000 	mlals	r0, r1, r0, r3
	return ns;
}
    1c72:	9903      	ldr	r1, [sp, #12]
    1c74:	6813      	ldr	r3, [r2, #0]
		return 0xFFFFFFFF;
    1c76:	bf88      	it	hi
    1c78:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
}
    1c7c:	4299      	cmp	r1, r3
    1c7e:	d001      	beq.n	1c84 <Time_ns+0x40>
    1c80:	f7ff fc50 	bl	1524 <__stack_chk_fail>
    1c84:	b005      	add	sp, #20
    1c86:	f85d fb04 	ldr.w	pc, [sp], #4
    1c8a:	bf00      	nop
    1c8c:	1fffe9d0 	.word	0x1fffe9d0
    1c90:	000f4240 	.word	0x000f4240

00001c94 <Time_duration_rollover>:
// Time since the given time
// If the given time value is lower, then assume a single register wrap
// This is around 49 days (plenty of time for most tasks)

Time Time_duration_rollover( Time now, Time since )
{
    1c94:	b082      	sub	sp, #8
    1c96:	b530      	push	{r4, r5, lr}
    1c98:	b087      	sub	sp, #28
    1c9a:	4604      	mov	r4, r0
    1c9c:	a802      	add	r0, sp, #8
    1c9e:	e880 0006 	stmia.w	r0, {r1, r2}
    1ca2:	aa0a      	add	r2, sp, #40	; 0x28
	// Ticks do not rollover, they are computed from the last increment of ms
	// Depending on the set clock speed, the maximum number of ticks per ms may vary
	duration.ticks = now.ticks + ( Time_maxTicks - since.ticks );

	// If ticks have exceeded 1 ms, increment ms
	if ( duration.ticks >= Time_maxTicks )
    1ca4:	f64b 357f 	movw	r5, #47999	; 0xbb7f
{
    1ca8:	f842 3f04 	str.w	r3, [r2, #4]!
    1cac:	e892 0003 	ldmia.w	r2, {r0, r1}
    1cb0:	466b      	mov	r3, sp
    1cb2:	9a02      	ldr	r2, [sp, #8]
    1cb4:	e883 0003 	stmia.w	r3, {r0, r1}
    1cb8:	490f      	ldr	r1, [pc, #60]	; (1cf8 <Time_duration_rollover+0x64>)
	if ( now.ms < since.ms )
    1cba:	4282      	cmp	r2, r0
{
    1cbc:	680b      	ldr	r3, [r1, #0]
    1cbe:	9305      	str	r3, [sp, #20]
		duration.ms = now.ms + ( 0xFFFFFFFF - since.ms );
    1cc0:	bf38      	it	cc
    1cc2:	f102 32ff 	addcc.w	r2, r2, #4294967295	; 0xffffffff
		duration.ms = now.ms - since.ms;
    1cc6:	1a13      	subs	r3, r2, r0
	duration.ticks = now.ticks + ( Time_maxTicks - since.ticks );
    1cc8:	9a01      	ldr	r2, [sp, #4]
    1cca:	9803      	ldr	r0, [sp, #12]
    1ccc:	1a80      	subs	r0, r0, r2
    1cce:	f500 423b 	add.w	r2, r0, #47872	; 0xbb00
    1cd2:	3280      	adds	r2, #128	; 0x80
	if ( duration.ticks >= Time_maxTicks )
    1cd4:	42aa      	cmp	r2, r5
	{
		duration.ms++;
    1cd6:	bf84      	itt	hi
    1cd8:	4602      	movhi	r2, r0
    1cda:	3301      	addhi	r3, #1
		duration.ticks -= Time_maxTicks;
	}

	return duration;
    1cdc:	e9c4 3200 	strd	r3, r2, [r4]
}
    1ce0:	9a05      	ldr	r2, [sp, #20]
    1ce2:	680b      	ldr	r3, [r1, #0]
    1ce4:	429a      	cmp	r2, r3
    1ce6:	4620      	mov	r0, r4
    1ce8:	d001      	beq.n	1cee <Time_duration_rollover+0x5a>
    1cea:	f7ff fc1b 	bl	1524 <__stack_chk_fail>
    1cee:	b007      	add	sp, #28
    1cf0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    1cf4:	b002      	add	sp, #8
    1cf6:	4770      	bx	lr
    1cf8:	1fffe9d0 	.word	0x1fffe9d0

00001cfc <Time_duration_rollover_now>:

Time Time_duration_rollover_now( Time since )
{
    1cfc:	b530      	push	{r4, r5, lr}
    1cfe:	4c0f      	ldr	r4, [pc, #60]	; (1d3c <Time_duration_rollover_now+0x40>)
    1d00:	b089      	sub	sp, #36	; 0x24
    1d02:	ab02      	add	r3, sp, #8
    1d04:	e883 0006 	stmia.w	r3, {r1, r2}
    1d08:	6823      	ldr	r3, [r4, #0]
    1d0a:	9307      	str	r3, [sp, #28]
	Time time = {
    1d0c:	4b0c      	ldr	r3, [pc, #48]	; (1d40 <Time_duration_rollover_now+0x44>)
    1d0e:	681a      	ldr	r2, [r3, #0]
		.ticks = ARM_DWT_CYCCNT,
    1d10:	4b0c      	ldr	r3, [pc, #48]	; (1d44 <Time_duration_rollover_now+0x48>)
    1d12:	681b      	ldr	r3, [r3, #0]
	return time;
    1d14:	e9cd 2305 	strd	r2, r3, [sp, #20]
	Time now = Time_now();
	return Time_duration_rollover( now, since );
    1d18:	9b03      	ldr	r3, [sp, #12]
    1d1a:	9300      	str	r3, [sp, #0]
    1d1c:	aa05      	add	r2, sp, #20
    1d1e:	460b      	mov	r3, r1
    1d20:	ca06      	ldmia	r2, {r1, r2}
{
    1d22:	4605      	mov	r5, r0
	return Time_duration_rollover( now, since );
    1d24:	f7ff ffb6 	bl	1c94 <Time_duration_rollover>
}
    1d28:	9a07      	ldr	r2, [sp, #28]
    1d2a:	6823      	ldr	r3, [r4, #0]
    1d2c:	429a      	cmp	r2, r3
    1d2e:	4628      	mov	r0, r5
    1d30:	d001      	beq.n	1d36 <Time_duration_rollover_now+0x3a>
    1d32:	f7ff fbf7 	bl	1524 <__stack_chk_fail>
    1d36:	b009      	add	sp, #36	; 0x24
    1d38:	bd30      	pop	{r4, r5, pc}
    1d3a:	bf00      	nop
    1d3c:	1fffe9d0 	.word	0x1fffe9d0
    1d40:	1ffff048 	.word	0x1ffff048
    1d44:	e0001004 	.word	0xe0001004

00001d48 <Time_duration_ms>:
	Time duration = Time_duration_rollover_now( since );
	return Time_seconds( duration );
}

uint32_t Time_duration_ms( Time since )
{
    1d48:	b510      	push	{r4, lr}
    1d4a:	b086      	sub	sp, #24
    1d4c:	466b      	mov	r3, sp
    1d4e:	e883 0003 	stmia.w	r3, {r0, r1}
    1d52:	4c08      	ldr	r4, [pc, #32]	; (1d74 <Time_duration_ms+0x2c>)
    1d54:	6822      	ldr	r2, [r4, #0]
    1d56:	9205      	str	r2, [sp, #20]
	Time duration = Time_duration_rollover_now( since );
    1d58:	a803      	add	r0, sp, #12
    1d5a:	e893 0006 	ldmia.w	r3, {r1, r2}
    1d5e:	f7ff ffcd 	bl	1cfc <Time_duration_rollover_now>
	return Time_ms( duration );
}
    1d62:	9a05      	ldr	r2, [sp, #20]
    1d64:	6823      	ldr	r3, [r4, #0]
    1d66:	9803      	ldr	r0, [sp, #12]
    1d68:	429a      	cmp	r2, r3
    1d6a:	d001      	beq.n	1d70 <Time_duration_ms+0x28>
    1d6c:	f7ff fbda 	bl	1524 <__stack_chk_fail>
    1d70:	b006      	add	sp, #24
    1d72:	bd10      	pop	{r4, pc}
    1d74:	1fffe9d0 	.word	0x1fffe9d0

00001d78 <Time_duration_us>:

uint32_t Time_duration_us( Time since )
{
    1d78:	b530      	push	{r4, r5, lr}
    1d7a:	b087      	sub	sp, #28
    1d7c:	466b      	mov	r3, sp
    1d7e:	e883 0003 	stmia.w	r3, {r0, r1}
    1d82:	4d0b      	ldr	r5, [pc, #44]	; (1db0 <Time_duration_us+0x38>)
	Time duration = Time_duration_rollover_now( since );
    1d84:	ac03      	add	r4, sp, #12
{
    1d86:	682a      	ldr	r2, [r5, #0]
    1d88:	9205      	str	r2, [sp, #20]
	Time duration = Time_duration_rollover_now( since );
    1d8a:	4620      	mov	r0, r4
    1d8c:	e893 0006 	ldmia.w	r3, {r1, r2}
    1d90:	f7ff ffb4 	bl	1cfc <Time_duration_rollover_now>
	return Time_us( duration );
    1d94:	9a05      	ldr	r2, [sp, #20]
    1d96:	682b      	ldr	r3, [r5, #0]
    1d98:	429a      	cmp	r2, r3
    1d9a:	d001      	beq.n	1da0 <Time_duration_us+0x28>
    1d9c:	f7ff fbc2 	bl	1524 <__stack_chk_fail>
    1da0:	e894 0003 	ldmia.w	r4, {r0, r1}
}
    1da4:	b007      	add	sp, #28
    1da6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return Time_us( duration );
    1daa:	f7ff bf27 	b.w	1bfc <Time_us>
    1dae:	bf00      	nop
    1db0:	1fffe9d0 	.word	0x1fffe9d0

00001db4 <Time_duration_ns>:

uint32_t Time_duration_ns( Time since )
{
    1db4:	b530      	push	{r4, r5, lr}
    1db6:	b087      	sub	sp, #28
    1db8:	466b      	mov	r3, sp
    1dba:	e883 0003 	stmia.w	r3, {r0, r1}
    1dbe:	4d0b      	ldr	r5, [pc, #44]	; (1dec <Time_duration_ns+0x38>)
	Time duration = Time_duration_rollover_now( since );
    1dc0:	ac03      	add	r4, sp, #12
{
    1dc2:	682a      	ldr	r2, [r5, #0]
    1dc4:	9205      	str	r2, [sp, #20]
	Time duration = Time_duration_rollover_now( since );
    1dc6:	4620      	mov	r0, r4
    1dc8:	e893 0006 	ldmia.w	r3, {r1, r2}
    1dcc:	f7ff ff96 	bl	1cfc <Time_duration_rollover_now>
	return Time_ns( duration );
    1dd0:	9a05      	ldr	r2, [sp, #20]
    1dd2:	682b      	ldr	r3, [r5, #0]
    1dd4:	429a      	cmp	r2, r3
    1dd6:	d001      	beq.n	1ddc <Time_duration_ns+0x28>
    1dd8:	f7ff fba4 	bl	1524 <__stack_chk_fail>
    1ddc:	e894 0003 	ldmia.w	r4, {r0, r1}
}
    1de0:	b007      	add	sp, #28
    1de2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return Time_ns( duration );
    1de6:	f7ff bf2d 	b.w	1c44 <Time_ns>
    1dea:	bf00      	nop
    1dec:	1fffe9d0 	.word	0x1fffe9d0

00001df0 <Time_duration_ticks>:

// Number of ticks since
uint32_t Time_duration_ticks( Time since )
{
    1df0:	b510      	push	{r4, lr}
    1df2:	b086      	sub	sp, #24
    1df4:	466b      	mov	r3, sp
    1df6:	e883 0003 	stmia.w	r3, {r0, r1}
    1dfa:	4c0e      	ldr	r4, [pc, #56]	; (1e34 <Time_duration_ticks+0x44>)
    1dfc:	6822      	ldr	r2, [r4, #0]
    1dfe:	9205      	str	r2, [sp, #20]
	Time duration = Time_duration_rollover_now( since );
    1e00:	a803      	add	r0, sp, #12
    1e02:	e893 0006 	ldmia.w	r3, {r1, r2}
    1e06:	f7ff ff79 	bl	1cfc <Time_duration_rollover_now>
    1e0a:	e9dd 0303 	ldrd	r0, r3, [sp, #12]
	if ( time.ms >= Time_maxTicks_ms )
    1e0e:	4a0a      	ldr	r2, [pc, #40]	; (1e38 <Time_duration_ticks+0x48>)
    1e10:	4290      	cmp	r0, r2
	ticks += time.ticks;
    1e12:	bf9c      	itt	ls
    1e14:	f64b 3280 	movwls	r2, #48000	; 0xbb80
    1e18:	fb02 3000 	mlals	r0, r2, r0, r3
	return Time_ticks( duration );
}
    1e1c:	9a05      	ldr	r2, [sp, #20]
    1e1e:	6823      	ldr	r3, [r4, #0]
		return 0xFFFFFFFF;
    1e20:	bf88      	it	hi
    1e22:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
}
    1e26:	429a      	cmp	r2, r3
    1e28:	d001      	beq.n	1e2e <Time_duration_ticks+0x3e>
    1e2a:	f7ff fb7b 	bl	1524 <__stack_chk_fail>
    1e2e:	b006      	add	sp, #24
    1e30:	bd10      	pop	{r4, pc}
    1e32:	bf00      	nop
    1e34:	1fffe9d0 	.word	0x1fffe9d0
    1e38:	00015d85 	.word	0x00015d85

00001e3c <Time_tick_reset>:
	// Reset last_tick and ticks_since_start
	Time_tick_reset( store );
}

void Time_tick_reset( TickStore *store )
{
    1e3c:	b507      	push	{r0, r1, r2, lr}
    1e3e:	4b0b      	ldr	r3, [pc, #44]	; (1e6c <Time_tick_reset+0x30>)
    1e40:	681a      	ldr	r2, [r3, #0]
    1e42:	9201      	str	r2, [sp, #4]
	Time time = {
    1e44:	4a0a      	ldr	r2, [pc, #40]	; (1e70 <Time_tick_reset+0x34>)
    1e46:	6811      	ldr	r1, [r2, #0]
		.ticks = ARM_DWT_CYCCNT,
    1e48:	4a0a      	ldr	r2, [pc, #40]	; (1e74 <Time_tick_reset+0x38>)
    1e4a:	6812      	ldr	r2, [r2, #0]
	// Reset last_tick and ticks_since_start
	store->last_tick = Time_now();
    1e4c:	e9c0 1200 	strd	r1, r2, [r0]
	store->ticks_since_start = 0;
    1e50:	2200      	movs	r2, #0
    1e52:	6102      	str	r2, [r0, #16]

	// Mark as a fresh TickStore
	store->fresh_store = 1;
    1e54:	2201      	movs	r2, #1
    1e56:	7602      	strb	r2, [r0, #24]
}
    1e58:	9a01      	ldr	r2, [sp, #4]
    1e5a:	681b      	ldr	r3, [r3, #0]
    1e5c:	429a      	cmp	r2, r3
    1e5e:	d001      	beq.n	1e64 <Time_tick_reset+0x28>
    1e60:	f7ff fb60 	bl	1524 <__stack_chk_fail>
    1e64:	b003      	add	sp, #12
    1e66:	f85d fb04 	ldr.w	pc, [sp], #4
    1e6a:	bf00      	nop
    1e6c:	1fffe9d0 	.word	0x1fffe9d0
    1e70:	1ffff048 	.word	0x1ffff048
    1e74:	e0001004 	.word	0xe0001004

00001e78 <Time_tick_start>:
{
    1e78:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    1e7a:	4604      	mov	r4, r0
    1e7c:	4668      	mov	r0, sp
    1e7e:	e880 0006 	stmia.w	r0, {r1, r2}
    1e82:	4d0a      	ldr	r5, [pc, #40]	; (1eac <Time_tick_start+0x34>)
    1e84:	6829      	ldr	r1, [r5, #0]
    1e86:	9103      	str	r1, [sp, #12]
	store->tick_duration = duration;
    1e88:	c803      	ldmia	r0, {r0, r1}
    1e8a:	f104 0608 	add.w	r6, r4, #8
    1e8e:	e886 0005 	stmia.w	r6, {r0, r2}
	Time_tick_reset( store );
    1e92:	9a03      	ldr	r2, [sp, #12]
	store->max_ticks = max_ticks;
    1e94:	6163      	str	r3, [r4, #20]
	Time_tick_reset( store );
    1e96:	682b      	ldr	r3, [r5, #0]
    1e98:	429a      	cmp	r2, r3
    1e9a:	d001      	beq.n	1ea0 <Time_tick_start+0x28>
    1e9c:	f7ff fb42 	bl	1524 <__stack_chk_fail>
    1ea0:	4620      	mov	r0, r4
}
    1ea2:	b004      	add	sp, #16
    1ea4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	Time_tick_reset( store );
    1ea8:	f7ff bfc8 	b.w	1e3c <Time_tick_reset>
    1eac:	1fffe9d0 	.word	0x1fffe9d0

00001eb0 <Time_tick_update>:

uint32_t Time_tick_update( TickStore *store )
{
    1eb0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    1eb4:	4e1b      	ldr	r6, [pc, #108]	; (1f24 <Time_tick_update+0x74>)
    1eb6:	6833      	ldr	r3, [r6, #0]
    1eb8:	9303      	str	r3, [sp, #12]
	// TODO (HaaTa) Handle rollover case (only happens once every 49 days while the keyboard is on)
	// Check if we've already gotten to the max tick threshold
	if ( store->ticks_since_start > store->max_ticks )
    1eba:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
    1ebe:	429a      	cmp	r2, r3
{
    1ec0:	4604      	mov	r4, r0
	if ( store->ticks_since_start > store->max_ticks )
    1ec2:	d829      	bhi.n	1f18 <Time_tick_update+0x68>
	Time time = {
    1ec4:	4b18      	ldr	r3, [pc, #96]	; (1f28 <Time_tick_update+0x78>)
    1ec6:	681a      	ldr	r2, [r3, #0]
		.ticks = ARM_DWT_CYCCNT,
    1ec8:	4b18      	ldr	r3, [pc, #96]	; (1f2c <Time_tick_update+0x7c>)
    1eca:	681b      	ldr	r3, [r3, #0]

	// Query current time
	Time now = Time_now();

	// Previous time
	Time prev = store->last_tick;
    1ecc:	e9d0 8700 	ldrd	r8, r7, [r0]
	return time;
    1ed0:	e9cd 2301 	strd	r2, r3, [sp, #4]
	uint32_t ticks = 0;
    1ed4:	2500      	movs	r5, #0

	// Otherwise just increment until we've gone too far
	while ( Time_compare( now, store->last_tick ) <= 0 )
    1ed6:	f10d 0904 	add.w	r9, sp, #4
	{
		prev = store->last_tick;
		Time_add( &store->last_tick, store->tick_duration );
    1eda:	f100 0a08 	add.w	sl, r0, #8
	while ( Time_compare( now, store->last_tick ) <= 0 )
    1ede:	e894 000c 	ldmia.w	r4, {r2, r3}
    1ee2:	e899 0003 	ldmia.w	r9, {r0, r1}
    1ee6:	f7ff fe61 	bl	1bac <Time_compare>
    1eea:	2800      	cmp	r0, #0
    1eec:	dd0b      	ble.n	1f06 <Time_tick_update+0x56>
	// Reverse back to previous tick
	ticks -= 1;
	store->last_tick = prev;

	// Add ticks to store
	store->ticks_since_start += ticks;
    1eee:	6923      	ldr	r3, [r4, #16]
	ticks -= 1;
    1ef0:	1e68      	subs	r0, r5, #1
	store->last_tick = prev;
    1ef2:	e9c4 8700 	strd	r8, r7, [r4]
	store->ticks_since_start += ticks;
    1ef6:	4403      	add	r3, r0
    1ef8:	6123      	str	r3, [r4, #16]

	return ticks;
}
    1efa:	9a03      	ldr	r2, [sp, #12]
    1efc:	6833      	ldr	r3, [r6, #0]
    1efe:	429a      	cmp	r2, r3
    1f00:	d00c      	beq.n	1f1c <Time_tick_update+0x6c>
    1f02:	f7ff fb0f 	bl	1524 <__stack_chk_fail>
		Time_add( &store->last_tick, store->tick_duration );
    1f06:	e89a 0006 	ldmia.w	sl, {r1, r2}
    1f0a:	4620      	mov	r0, r4
		prev = store->last_tick;
    1f0c:	e9d4 8700 	ldrd	r8, r7, [r4]
		ticks++;
    1f10:	3501      	adds	r5, #1
		Time_add( &store->last_tick, store->tick_duration );
    1f12:	f7ff fe1f 	bl	1b54 <Time_add>
    1f16:	e7e2      	b.n	1ede <Time_tick_update+0x2e>
		return 0;
    1f18:	2000      	movs	r0, #0
    1f1a:	e7ee      	b.n	1efa <Time_tick_update+0x4a>
}
    1f1c:	b004      	add	sp, #16
    1f1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1f22:	bf00      	nop
    1f24:	1fffe9d0 	.word	0x1fffe9d0
    1f28:	1ffff048 	.word	0x1ffff048
    1f2c:	e0001004 	.word	0xe0001004

00001f30 <cliFunc_matrixState>:
	info_msg("Matrix Debug Mode: ");
	printInt8( matrixDebugMode );
}

void cliFunc_matrixState( char* args )
{
    1f30:	b530      	push	{r4, r5, lr}
    1f32:	4c0d      	ldr	r4, [pc, #52]	; (1f68 <cliFunc_matrixState+0x38>)
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    1f34:	4d0d      	ldr	r5, [pc, #52]	; (1f6c <cliFunc_matrixState+0x3c>)
{
    1f36:	6823      	ldr	r3, [r4, #0]
    1f38:	b085      	sub	sp, #20
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    1f3a:	aa02      	add	r2, sp, #8
    1f3c:	a901      	add	r1, sp, #4
{
    1f3e:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    1f40:	f006 fd74 	bl	8a2c <CLI_argumentIsolation>

	if ( arg1Ptr[0] != '\0' )
    1f44:	9801      	ldr	r0, [sp, #4]
	matrixDebugStateCounter = 1;
    1f46:	2301      	movs	r3, #1
    1f48:	802b      	strh	r3, [r5, #0]
	if ( arg1Ptr[0] != '\0' )
    1f4a:	7803      	ldrb	r3, [r0, #0]
    1f4c:	b11b      	cbz	r3, 1f56 <cliFunc_matrixState+0x26>
	{
		matrixDebugStateCounter = (uint16_t)numToInt( arg1Ptr );
    1f4e:	f007 fc6b 	bl	9828 <numToInt>
    1f52:	b280      	uxth	r0, r0
    1f54:	8028      	strh	r0, [r5, #0]
	}
}
    1f56:	9a03      	ldr	r2, [sp, #12]
    1f58:	6823      	ldr	r3, [r4, #0]
    1f5a:	429a      	cmp	r2, r3
    1f5c:	d001      	beq.n	1f62 <cliFunc_matrixState+0x32>
    1f5e:	f7ff fae1 	bl	1524 <__stack_chk_fail>
    1f62:	b005      	add	sp, #20
    1f64:	bd30      	pop	{r4, r5, pc}
    1f66:	bf00      	nop
    1f68:	1fffe9d0 	.word	0x1fffe9d0
    1f6c:	1ffff28e 	.word	0x1ffff28e

00001f70 <cliFunc_debounce>:
{
    1f70:	b530      	push	{r4, r5, lr}
    1f72:	4c12      	ldr	r4, [pc, #72]	; (1fbc <cliFunc_debounce+0x4c>)
    1f74:	4d12      	ldr	r5, [pc, #72]	; (1fc0 <cliFunc_debounce+0x50>)
    1f76:	6823      	ldr	r3, [r4, #0]
    1f78:	b085      	sub	sp, #20
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    1f7a:	aa02      	add	r2, sp, #8
    1f7c:	a901      	add	r1, sp, #4
{
    1f7e:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    1f80:	f006 fd54 	bl	8a2c <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    1f84:	9801      	ldr	r0, [sp, #4]
    1f86:	7803      	ldrb	r3, [r0, #0]
    1f88:	b11b      	cbz	r3, 1f92 <cliFunc_debounce+0x22>
		debounceExpiryTime = (uint8_t)numToInt( arg1Ptr );
    1f8a:	f007 fc4d 	bl	9828 <numToInt>
    1f8e:	b2c0      	uxtb	r0, r0
    1f90:	7028      	strb	r0, [r5, #0]
	print( NL );
    1f92:	480c      	ldr	r0, [pc, #48]	; (1fc4 <cliFunc_debounce+0x54>)
    1f94:	f007 fa78 	bl	9488 <_print>
	info_msg("Debounce Timer: ");
    1f98:	480b      	ldr	r0, [pc, #44]	; (1fc8 <cliFunc_debounce+0x58>)
    1f9a:	f007 fa75 	bl	9488 <_print>
	printInt8( debounceExpiryTime );
    1f9e:	7828      	ldrb	r0, [r5, #0]
    1fa0:	f007 fadc 	bl	955c <printInt8>
	print("ms");
    1fa4:	4809      	ldr	r0, [pc, #36]	; (1fcc <cliFunc_debounce+0x5c>)
    1fa6:	f007 fa6f 	bl	9488 <_print>
}
    1faa:	9a03      	ldr	r2, [sp, #12]
    1fac:	6823      	ldr	r3, [r4, #0]
    1fae:	429a      	cmp	r2, r3
    1fb0:	d001      	beq.n	1fb6 <cliFunc_debounce+0x46>
    1fb2:	f7ff fab7 	bl	1524 <__stack_chk_fail>
    1fb6:	b005      	add	sp, #20
    1fb8:	bd30      	pop	{r4, r5, pc}
    1fba:	bf00      	nop
    1fbc:	1fffe9d0 	.word	0x1fffe9d0
    1fc0:	1ffff26c 	.word	0x1ffff26c
    1fc4:	0000d348 	.word	0x0000d348
    1fc8:	00009aad 	.word	0x00009aad
    1fcc:	00009ad0 	.word	0x00009ad0

00001fd0 <cliFunc_matrixInfo>:
{
    1fd0:	b513      	push	{r0, r1, r4, lr}
    1fd2:	4c13      	ldr	r4, [pc, #76]	; (2020 <cliFunc_matrixInfo+0x50>)
	print( NL );
    1fd4:	4813      	ldr	r0, [pc, #76]	; (2024 <cliFunc_matrixInfo+0x54>)
{
    1fd6:	6823      	ldr	r3, [r4, #0]
    1fd8:	9301      	str	r3, [sp, #4]
	print( NL );
    1fda:	f007 fa55 	bl	9488 <_print>
	info_msg("Columns:  ");
    1fde:	4812      	ldr	r0, [pc, #72]	; (2028 <cliFunc_matrixInfo+0x58>)
    1fe0:	f007 fa52 	bl	9488 <_print>
	printInt8( Matrix_colsNum );
    1fe4:	2009      	movs	r0, #9
    1fe6:	f007 fab9 	bl	955c <printInt8>
	print( NL );
    1fea:	480e      	ldr	r0, [pc, #56]	; (2024 <cliFunc_matrixInfo+0x54>)
    1fec:	f007 fa4c 	bl	9488 <_print>
	info_msg("Rows:     ");
    1ff0:	480e      	ldr	r0, [pc, #56]	; (202c <cliFunc_matrixInfo+0x5c>)
    1ff2:	f007 fa49 	bl	9488 <_print>
	printInt8( Matrix_rowsNum );
    1ff6:	2007      	movs	r0, #7
    1ff8:	f007 fab0 	bl	955c <printInt8>
	print( NL );
    1ffc:	4809      	ldr	r0, [pc, #36]	; (2024 <cliFunc_matrixInfo+0x54>)
    1ffe:	f007 fa43 	bl	9488 <_print>
	info_msg("Max Keys: ");
    2002:	480b      	ldr	r0, [pc, #44]	; (2030 <cliFunc_matrixInfo+0x60>)
    2004:	f007 fa40 	bl	9488 <_print>
	printInt8( Matrix_maxKeys );
    2008:	9a01      	ldr	r2, [sp, #4]
    200a:	6823      	ldr	r3, [r4, #0]
    200c:	429a      	cmp	r2, r3
    200e:	d001      	beq.n	2014 <cliFunc_matrixInfo+0x44>
    2010:	f7ff fa88 	bl	1524 <__stack_chk_fail>
    2014:	203f      	movs	r0, #63	; 0x3f
}
    2016:	b002      	add	sp, #8
    2018:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( Matrix_maxKeys );
    201c:	f007 ba9e 	b.w	955c <printInt8>
    2020:	1fffe9d0 	.word	0x1fffe9d0
    2024:	0000d348 	.word	0x0000d348
    2028:	00009af9 	.word	0x00009af9
    202c:	00009b16 	.word	0x00009b16
    2030:	00009b33 	.word	0x00009b33

00002034 <cliFunc_matrixDebug>:
{
    2034:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2036:	4c1f      	ldr	r4, [pc, #124]	; (20b4 <cliFunc_matrixDebug+0x80>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    2038:	aa02      	add	r2, sp, #8
{
    203a:	6823      	ldr	r3, [r4, #0]
    203c:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    203e:	a901      	add	r1, sp, #4
    2040:	f006 fcf4 	bl	8a2c <CLI_argumentIsolation>
	switch ( arg1Ptr[0] )
    2044:	9b01      	ldr	r3, [sp, #4]
    2046:	781b      	ldrb	r3, [r3, #0]
    2048:	2b32      	cmp	r3, #50	; 0x32
    204a:	d015      	beq.n	2078 <cliFunc_matrixDebug+0x44>
    204c:	d808      	bhi.n	2060 <cliFunc_matrixDebug+0x2c>
    204e:	b333      	cbz	r3, 209e <cliFunc_matrixDebug+0x6a>
    2050:	2b31      	cmp	r3, #49	; 0x31
    2052:	d024      	beq.n	209e <cliFunc_matrixDebug+0x6a>
}
    2054:	9a03      	ldr	r2, [sp, #12]
    2056:	6823      	ldr	r3, [r4, #0]
    2058:	429a      	cmp	r2, r3
    205a:	d028      	beq.n	20ae <cliFunc_matrixDebug+0x7a>
    205c:	f7ff fa62 	bl	1524 <__stack_chk_fail>
	switch ( arg1Ptr[0] )
    2060:	2b54      	cmp	r3, #84	; 0x54
    2062:	d009      	beq.n	2078 <cliFunc_matrixDebug+0x44>
    2064:	2b74      	cmp	r3, #116	; 0x74
    2066:	d007      	beq.n	2078 <cliFunc_matrixDebug+0x44>
    2068:	2b33      	cmp	r3, #51	; 0x33
    206a:	d1f3      	bne.n	2054 <cliFunc_matrixDebug+0x20>
		matrixDebugMode = matrixDebugMode != 3 ? 3 : 0;
    206c:	4b12      	ldr	r3, [pc, #72]	; (20b8 <cliFunc_matrixDebug+0x84>)
    206e:	781a      	ldrb	r2, [r3, #0]
    2070:	2a03      	cmp	r2, #3
    2072:	bf18      	it	ne
    2074:	2203      	movne	r2, #3
    2076:	e004      	b.n	2082 <cliFunc_matrixDebug+0x4e>
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
    2078:	4b0f      	ldr	r3, [pc, #60]	; (20b8 <cliFunc_matrixDebug+0x84>)
    207a:	781a      	ldrb	r2, [r3, #0]
    207c:	2a02      	cmp	r2, #2
    207e:	bf18      	it	ne
    2080:	2202      	movne	r2, #2
		matrixDebugMode = matrixDebugMode != 3 ? 3 : 0;
    2082:	bf08      	it	eq
    2084:	2200      	moveq	r2, #0
    2086:	701a      	strb	r2, [r3, #0]
	print( NL );
    2088:	480c      	ldr	r0, [pc, #48]	; (20bc <cliFunc_matrixDebug+0x88>)
    208a:	f007 f9fd 	bl	9488 <_print>
	info_msg("Matrix Debug Mode: ");
    208e:	480c      	ldr	r0, [pc, #48]	; (20c0 <cliFunc_matrixDebug+0x8c>)
    2090:	f007 f9fa 	bl	9488 <_print>
	printInt8( matrixDebugMode );
    2094:	4b08      	ldr	r3, [pc, #32]	; (20b8 <cliFunc_matrixDebug+0x84>)
    2096:	7818      	ldrb	r0, [r3, #0]
    2098:	f007 fa60 	bl	955c <printInt8>
    209c:	e7da      	b.n	2054 <cliFunc_matrixDebug+0x20>
		matrixDebugMode = matrixDebugMode != 1 ? 1 : 0;
    209e:	4a06      	ldr	r2, [pc, #24]	; (20b8 <cliFunc_matrixDebug+0x84>)
    20a0:	7813      	ldrb	r3, [r2, #0]
    20a2:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    20a6:	bf18      	it	ne
    20a8:	2301      	movne	r3, #1
    20aa:	7013      	strb	r3, [r2, #0]
		break;
    20ac:	e7ec      	b.n	2088 <cliFunc_matrixDebug+0x54>
}
    20ae:	b004      	add	sp, #16
    20b0:	bd10      	pop	{r4, pc}
    20b2:	bf00      	nop
    20b4:	1fffe9d0 	.word	0x1fffe9d0
    20b8:	1ffff28d 	.word	0x1ffff28d
    20bc:	0000d348 	.word	0x0000d348
    20c0:	00009ad3 	.word	0x00009ad3

000020c4 <cliFunc_strobeDelay>:

void cliFunc_strobeDelay( char* args )
{
    20c4:	b530      	push	{r4, r5, lr}
    20c6:	4c12      	ldr	r4, [pc, #72]	; (2110 <cliFunc_strobeDelay+0x4c>)
    20c8:	4d12      	ldr	r5, [pc, #72]	; (2114 <cliFunc_strobeDelay+0x50>)
    20ca:	6823      	ldr	r3, [r4, #0]
    20cc:	b085      	sub	sp, #20
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    20ce:	aa02      	add	r2, sp, #8
    20d0:	a901      	add	r1, sp, #4
{
    20d2:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    20d4:	f006 fcaa 	bl	8a2c <CLI_argumentIsolation>

	if ( arg1Ptr[0] != '\0' )
    20d8:	9801      	ldr	r0, [sp, #4]
    20da:	7803      	ldrb	r3, [r0, #0]
    20dc:	b11b      	cbz	r3, 20e6 <cliFunc_strobeDelay+0x22>
	{
		strobeDelayTime = (uint8_t)numToInt( arg1Ptr );
    20de:	f007 fba3 	bl	9828 <numToInt>
    20e2:	b2c0      	uxtb	r0, r0
    20e4:	7028      	strb	r0, [r5, #0]
	}

	print( NL );
    20e6:	480c      	ldr	r0, [pc, #48]	; (2118 <cliFunc_strobeDelay+0x54>)
    20e8:	f007 f9ce 	bl	9488 <_print>
	info_msg("Strobe Delay: ");
    20ec:	480b      	ldr	r0, [pc, #44]	; (211c <cliFunc_strobeDelay+0x58>)
    20ee:	f007 f9cb 	bl	9488 <_print>
	printInt8( strobeDelayTime );
    20f2:	7828      	ldrb	r0, [r5, #0]
    20f4:	f007 fa32 	bl	955c <printInt8>
	print("us");
    20f8:	4809      	ldr	r0, [pc, #36]	; (2120 <cliFunc_strobeDelay+0x5c>)
    20fa:	f007 f9c5 	bl	9488 <_print>
}
    20fe:	9a03      	ldr	r2, [sp, #12]
    2100:	6823      	ldr	r3, [r4, #0]
    2102:	429a      	cmp	r2, r3
    2104:	d001      	beq.n	210a <cliFunc_strobeDelay+0x46>
    2106:	f7ff fa0d 	bl	1524 <__stack_chk_fail>
    210a:	b005      	add	sp, #20
    210c:	bd30      	pop	{r4, r5, pc}
    210e:	bf00      	nop
    2110:	1fffe9d0 	.word	0x1fffe9d0
    2114:	1ffff298 	.word	0x1ffff298
    2118:	0000d348 	.word	0x0000d348
    211c:	00009b50 	.word	0x00009b50
    2120:	00009b71 	.word	0x00009b71

00002124 <Matrix_setup>:
{
    2124:	b5f0      	push	{r4, r5, r6, r7, lr}
    2126:	4e37      	ldr	r6, [pc, #220]	; (2204 <Matrix_setup+0xe0>)
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    2128:	4937      	ldr	r1, [pc, #220]	; (2208 <Matrix_setup+0xe4>)
{
    212a:	6833      	ldr	r3, [r6, #0]
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    212c:	4837      	ldr	r0, [pc, #220]	; (220c <Matrix_setup+0xe8>)
		GPIO_Ctrl( Matrix_cols[ pin ], GPIO_Type_DriveSetup, Matrix_type );
    212e:	4d38      	ldr	r5, [pc, #224]	; (2210 <Matrix_setup+0xec>)
{
    2130:	b085      	sub	sp, #20
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    2132:	2400      	movs	r4, #0
{
    2134:	9303      	str	r3, [sp, #12]
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    2136:	f006 fd37 	bl	8ba8 <CLI_registerDictionary>
		GPIO_Ctrl( Matrix_cols[ pin ], GPIO_Type_DriveSetup, Matrix_type );
    213a:	eb05 0244 	add.w	r2, r5, r4, lsl #1
    213e:	f815 3014 	ldrb.w	r3, [r5, r4, lsl #1]
    2142:	7850      	ldrb	r0, [r2, #1]
    2144:	2103      	movs	r1, #3
    2146:	2202      	movs	r2, #2
    2148:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    214c:	3401      	adds	r4, #1
    214e:	f7ff fbd1 	bl	18f4 <GPIO_Ctrl>
	for ( uint8_t pin = 0; pin < Matrix_colsNum; pin++ )
    2152:	2c09      	cmp	r4, #9
    2154:	d1f1      	bne.n	213a <Matrix_setup+0x16>
		GPIO_Ctrl( Matrix_rows[ pin ], GPIO_Type_ReadSetup, Matrix_type );
    2156:	4d2f      	ldr	r5, [pc, #188]	; (2214 <Matrix_setup+0xf0>)
    2158:	2400      	movs	r4, #0
    215a:	eb05 0244 	add.w	r2, r5, r4, lsl #1
    215e:	f815 3014 	ldrb.w	r3, [r5, r4, lsl #1]
    2162:	7850      	ldrb	r0, [r2, #1]
    2164:	2105      	movs	r1, #5
    2166:	2202      	movs	r2, #2
    2168:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    216c:	3401      	adds	r4, #1
    216e:	f7ff fbc1 	bl	18f4 <GPIO_Ctrl>
	for ( uint8_t pin = 0; pin < Matrix_rowsNum; pin++ )
    2172:	2c07      	cmp	r4, #7
    2174:	d1f1      	bne.n	215a <Matrix_setup+0x36>
    2176:	2300      	movs	r3, #0
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    2178:	4927      	ldr	r1, [pc, #156]	; (2218 <Matrix_setup+0xf4>)
    217a:	461c      	mov	r4, r3
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold; // Start at 'off' steady state
    217c:	20ff      	movs	r0, #255	; 0xff
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    217e:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
    2182:	7094      	strb	r4, [r2, #2]
		Matrix_scanArray[ item ].curState         = KeyState_Off;
    2184:	70d4      	strb	r4, [r2, #3]
		Matrix_scanArray[ item ].activeCount      = 0;
    2186:	f801 4033 	strb.w	r4, [r1, r3, lsl #3]
    218a:	3301      	adds	r3, #1
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    218c:	2b3f      	cmp	r3, #63	; 0x3f
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold; // Start at 'off' steady state
    218e:	7050      	strb	r0, [r2, #1]
		Matrix_scanArray[ item ].prevDecisionTime = 0;
    2190:	6054      	str	r4, [r2, #4]
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    2192:	d1f4      	bne.n	217e <Matrix_setup+0x5a>
	matrixCurrentStrobe = 0;
    2194:	4b21      	ldr	r3, [pc, #132]	; (221c <Matrix_setup+0xf8>)
	activity_tick_duration = Time_init();
    2196:	4d22      	ldr	r5, [pc, #136]	; (2220 <Matrix_setup+0xfc>)
	matrixCurrentStrobe = 0;
    2198:	701c      	strb	r4, [r3, #0]
	matrixDebugMode = 0;
    219a:	4b22      	ldr	r3, [pc, #136]	; (2224 <Matrix_setup+0x100>)
    219c:	701c      	strb	r4, [r3, #0]
	matrixDebugStateCounter = 0;
    219e:	4b22      	ldr	r3, [pc, #136]	; (2228 <Matrix_setup+0x104>)
    21a0:	801c      	strh	r4, [r3, #0]
	debounceExpiryTime = MinDebounceTime_define;
    21a2:	4b22      	ldr	r3, [pc, #136]	; (222c <Matrix_setup+0x108>)
    21a4:	2206      	movs	r2, #6
    21a6:	701a      	strb	r2, [r3, #0]
	activity_tick_duration = Time_init();
    21a8:	466f      	mov	r7, sp
	strobeDelayTime = StrobeDelay_define;
    21aa:	4b21      	ldr	r3, [pc, #132]	; (2230 <Matrix_setup+0x10c>)
	activity_tick_duration = Time_init();
    21ac:	4638      	mov	r0, r7
	strobeDelayTime = StrobeDelay_define;
    21ae:	701c      	strb	r4, [r3, #0]
	activity_tick_duration = Time_init();
    21b0:	f7ff fcbe 	bl	1b30 <Time_init>
    21b4:	e897 0003 	ldmia.w	r7, {r0, r1}
    21b8:	e885 0003 	stmia.w	r5, {r0, r1}
	activity_tick_duration.ms = 1000 * ActivityTimerMultiplier_define;
    21bc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    21c0:	602b      	str	r3, [r5, #0]
	Time_tick_start( &activity_tickstore, activity_tick_duration, TickStore_MaxTicks );
    21c2:	e895 0006 	ldmia.w	r5, {r1, r2}
    21c6:	23ff      	movs	r3, #255	; 0xff
    21c8:	481a      	ldr	r0, [pc, #104]	; (2234 <Matrix_setup+0x110>)
    21ca:	f7ff fe55 	bl	1e78 <Time_tick_start>
	Time_tick_start( &inactivity_tickstore, activity_tick_duration, TickStore_MaxTicks );
    21ce:	e895 0006 	ldmia.w	r5, {r1, r2}
    21d2:	23ff      	movs	r3, #255	; 0xff
    21d4:	4818      	ldr	r0, [pc, #96]	; (2238 <Matrix_setup+0x114>)
    21d6:	f7ff fe4f 	bl	1e78 <Time_tick_start>
	matrixStateActiveCount = 0;
    21da:	4b18      	ldr	r3, [pc, #96]	; (223c <Matrix_setup+0x118>)
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    21dc:	4818      	ldr	r0, [pc, #96]	; (2240 <Matrix_setup+0x11c>)
	matrixStateActiveCount = 0;
    21de:	801c      	strh	r4, [r3, #0]
	matrixStatePressCount = 0;
    21e0:	4b18      	ldr	r3, [pc, #96]	; (2244 <Matrix_setup+0x120>)
    21e2:	801c      	strh	r4, [r3, #0]
	matrixStateReleaseCount = 0;
    21e4:	4b18      	ldr	r3, [pc, #96]	; (2248 <Matrix_setup+0x124>)
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    21e6:	2100      	movs	r1, #0
	matrixStateReleaseCount = 0;
    21e8:	801c      	strh	r4, [r3, #0]
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    21ea:	f007 f803 	bl	91f4 <Latency_add_resource>
    21ee:	4b17      	ldr	r3, [pc, #92]	; (224c <Matrix_setup+0x128>)
    21f0:	7018      	strb	r0, [r3, #0]
}
    21f2:	9a03      	ldr	r2, [sp, #12]
    21f4:	6833      	ldr	r3, [r6, #0]
    21f6:	429a      	cmp	r2, r3
    21f8:	d001      	beq.n	21fe <Matrix_setup+0xda>
    21fa:	f7ff f993 	bl	1524 <__stack_chk_fail>
    21fe:	b005      	add	sp, #20
    2200:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2202:	bf00      	nop
    2204:	1fffe9d0 	.word	0x1fffe9d0
    2208:	00009bf8 	.word	0x00009bf8
    220c:	00009bb0 	.word	0x00009bb0
    2210:	000099a8 	.word	0x000099a8
    2214:	000099f8 	.word	0x000099f8
    2218:	1ffff050 	.word	0x1ffff050
    221c:	1ffff28c 	.word	0x1ffff28c
    2220:	1ffff248 	.word	0x1ffff248
    2224:	1ffff28d 	.word	0x1ffff28d
    2228:	1ffff28e 	.word	0x1ffff28e
    222c:	1ffff26c 	.word	0x1ffff26c
    2230:	1ffff298 	.word	0x1ffff298
    2234:	1ffff250 	.word	0x1ffff250
    2238:	1ffff270 	.word	0x1ffff270
    223c:	1ffff292 	.word	0x1ffff292
    2240:	00009a06 	.word	0x00009a06
    2244:	1ffff294 	.word	0x1ffff294
    2248:	1ffff296 	.word	0x1ffff296
    224c:	1ffff290 	.word	0x1ffff290

00002250 <Matrix_keyPositionDebug>:
{
    2250:	b507      	push	{r0, r1, r2, lr}
    2252:	4b16      	ldr	r3, [pc, #88]	; (22ac <Matrix_keyPositionDebug+0x5c>)
    2254:	681a      	ldr	r2, [r3, #0]
    2256:	9201      	str	r2, [sp, #4]
	switch ( pos )
    2258:	2803      	cmp	r0, #3
    225a:	d821      	bhi.n	22a0 <Matrix_keyPositionDebug+0x50>
    225c:	e8df f000 	tbb	[pc, r0]
    2260:	1a140e02 	.word	0x1a140e02
		print("\033[1mO\033[0m");
    2264:	9a01      	ldr	r2, [sp, #4]
    2266:	681b      	ldr	r3, [r3, #0]
    2268:	429a      	cmp	r2, r3
    226a:	d001      	beq.n	2270 <Matrix_keyPositionDebug+0x20>
		print("\033[1;31mI\033[0m");
    226c:	f7ff f95a 	bl	1524 <__stack_chk_fail>
		print("\033[1mO\033[0m");
    2270:	480f      	ldr	r0, [pc, #60]	; (22b0 <Matrix_keyPositionDebug+0x60>)
}
    2272:	b003      	add	sp, #12
    2274:	f85d eb04 	ldr.w	lr, [sp], #4
		print("\033[1;31mI\033[0m");
    2278:	f007 b906 	b.w	9488 <_print>
		print("\033[1;33mP\033[0m");
    227c:	9a01      	ldr	r2, [sp, #4]
    227e:	681b      	ldr	r3, [r3, #0]
    2280:	429a      	cmp	r2, r3
    2282:	d1f3      	bne.n	226c <Matrix_keyPositionDebug+0x1c>
    2284:	480b      	ldr	r0, [pc, #44]	; (22b4 <Matrix_keyPositionDebug+0x64>)
    2286:	e7f4      	b.n	2272 <Matrix_keyPositionDebug+0x22>
		print("\033[1;32mH\033[0m");
    2288:	9a01      	ldr	r2, [sp, #4]
    228a:	681b      	ldr	r3, [r3, #0]
    228c:	429a      	cmp	r2, r3
    228e:	d1ed      	bne.n	226c <Matrix_keyPositionDebug+0x1c>
    2290:	4809      	ldr	r0, [pc, #36]	; (22b8 <Matrix_keyPositionDebug+0x68>)
    2292:	e7ee      	b.n	2272 <Matrix_keyPositionDebug+0x22>
		print("\033[1;35mR\033[0m");
    2294:	9a01      	ldr	r2, [sp, #4]
    2296:	681b      	ldr	r3, [r3, #0]
    2298:	429a      	cmp	r2, r3
    229a:	d1e7      	bne.n	226c <Matrix_keyPositionDebug+0x1c>
    229c:	4807      	ldr	r0, [pc, #28]	; (22bc <Matrix_keyPositionDebug+0x6c>)
    229e:	e7e8      	b.n	2272 <Matrix_keyPositionDebug+0x22>
		print("\033[1;31mI\033[0m");
    22a0:	9a01      	ldr	r2, [sp, #4]
    22a2:	681b      	ldr	r3, [r3, #0]
    22a4:	429a      	cmp	r2, r3
    22a6:	d1e1      	bne.n	226c <Matrix_keyPositionDebug+0x1c>
    22a8:	4805      	ldr	r0, [pc, #20]	; (22c0 <Matrix_keyPositionDebug+0x70>)
    22aa:	e7e2      	b.n	2272 <Matrix_keyPositionDebug+0x22>
    22ac:	1fffe9d0 	.word	0x1fffe9d0
    22b0:	000099ba 	.word	0x000099ba
    22b4:	000099c4 	.word	0x000099c4
    22b8:	000099d1 	.word	0x000099d1
    22bc:	000099de 	.word	0x000099de
    22c0:	000099eb 	.word	0x000099eb

000022c4 <Matrix_single_scan>:
{
    22c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    22c8:	4e6a      	ldr	r6, [pc, #424]	; (2474 <Matrix_single_scan+0x1b0>)
	Latency_start_time( matrixLatencyResource );
    22ca:	4d6b      	ldr	r5, [pc, #428]	; (2478 <Matrix_single_scan+0x1b4>)
{
    22cc:	6833      	ldr	r3, [r6, #0]
    22ce:	b089      	sub	sp, #36	; 0x24
	uint8_t strobe = matrixCurrentStrobe;
    22d0:	2400      	movs	r4, #0
{
    22d2:	9307      	str	r3, [sp, #28]
	Latency_start_time( matrixLatencyResource );
    22d4:	7828      	ldrb	r0, [r5, #0]
    22d6:	f007 f805 	bl	92e4 <Latency_start_time>
	uint32_t currentTime = systick_millis_count;
    22da:	4b68      	ldr	r3, [pc, #416]	; (247c <Matrix_single_scan+0x1b8>)
    22dc:	681b      	ldr	r3, [r3, #0]
    22de:	9301      	str	r3, [sp, #4]
	uint8_t strobe = matrixCurrentStrobe;
    22e0:	4b67      	ldr	r3, [pc, #412]	; (2480 <Matrix_single_scan+0x1bc>)
    22e2:	9300      	str	r3, [sp, #0]
    22e4:	781f      	ldrb	r7, [r3, #0]
    22e6:	e9cd 6503 	strd	r6, r5, [sp, #12]
		GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_DriveSetup, Matrix_type );
    22ea:	4e66      	ldr	r6, [pc, #408]	; (2484 <Matrix_single_scan+0x1c0>)
	uint8_t strobe = matrixCurrentStrobe;
    22ec:	b2ff      	uxtb	r7, r7
		GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_DriveSetup, Matrix_type );
    22ee:	eb06 0344 	add.w	r3, r6, r4, lsl #1
    22f2:	f816 5014 	ldrb.w	r5, [r6, r4, lsl #1]
    22f6:	785b      	ldrb	r3, [r3, #1]
    22f8:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    22fc:	2202      	movs	r2, #2
    22fe:	2103      	movs	r1, #3
    2300:	4628      	mov	r0, r5
    2302:	f7ff faf7 	bl	18f4 <GPIO_Ctrl>
		GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_DriveLow, Matrix_type );
    2306:	2202      	movs	r2, #2
    2308:	2101      	movs	r1, #1
    230a:	4628      	mov	r0, r5
    230c:	f7ff faf2 	bl	18f4 <GPIO_Ctrl>
    2310:	3401      	adds	r4, #1
		GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_ReadSetup, Matrix_type );
    2312:	2202      	movs	r2, #2
    2314:	2105      	movs	r1, #5
    2316:	4628      	mov	r0, r5
    2318:	f7ff faec 	bl	18f4 <GPIO_Ctrl>
	for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
    231c:	2c07      	cmp	r4, #7
    231e:	d1e6      	bne.n	22ee <Matrix_single_scan+0x2a>
	GPIO_Ctrl( Matrix_cols[ strobe ], GPIO_Type_DriveHigh, Matrix_type );
    2320:	4b59      	ldr	r3, [pc, #356]	; (2488 <Matrix_single_scan+0x1c4>)
    2322:	f813 0017 	ldrb.w	r0, [r3, r7, lsl #1]
    2326:	eb03 0347 	add.w	r3, r3, r7, lsl #1
    232a:	2202      	movs	r2, #2
    232c:	785b      	ldrb	r3, [r3, #1]
    232e:	2100      	movs	r1, #0
    2330:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    2334:	f7ff fade 	bl	18f4 <GPIO_Ctrl>
	if ( strobeDelayTime > 0 )
    2338:	4b54      	ldr	r3, [pc, #336]	; (248c <Matrix_single_scan+0x1c8>)
    233a:	781a      	ldrb	r2, [r3, #0]
    233c:	b112      	cbz	r2, 2344 <Matrix_single_scan+0x80>
		delay_us( strobeDelayTime );
    233e:	7818      	ldrb	r0, [r3, #0]
    2340:	f7ff f978 	bl	1634 <delay_us>
    2344:	4c52      	ldr	r4, [pc, #328]	; (2490 <Matrix_single_scan+0x1cc>)
		if ( matrixDebugMode && state->curState != state->prevState )
    2346:	f8df a158 	ldr.w	sl, [pc, #344]	; 24a0 <Matrix_single_scan+0x1dc>
    234a:	463d      	mov	r5, r7
	uint8_t strobe = matrixCurrentStrobe;
    234c:	f04f 0800 	mov.w	r8, #0
    2350:	b2ae      	uxth	r6, r5
		uint16_t key = Matrix_colsNum * sense + strobe;
    2352:	fa1f f388 	uxth.w	r3, r8
		if ( key + 1 > MaxScanCode_KLL )
    2356:	2e3e      	cmp	r6, #62	; 0x3e
		uint16_t key = Matrix_colsNum * sense + strobe;
    2358:	9302      	str	r3, [sp, #8]
    235a:	fa1f fb87 	uxth.w	fp, r7
		if ( key + 1 > MaxScanCode_KLL )
    235e:	f200 80ad 	bhi.w	24bc <Matrix_single_scan+0x1f8>
		if ( GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_Read, Matrix_type ) )
    2362:	4b48      	ldr	r3, [pc, #288]	; (2484 <Matrix_single_scan+0x1c0>)
    2364:	f813 0018 	ldrb.w	r0, [r3, r8, lsl #1]
    2368:	eb03 0348 	add.w	r3, r3, r8, lsl #1
    236c:	2202      	movs	r2, #2
    236e:	785b      	ldrb	r3, [r3, #1]
    2370:	2104      	movs	r1, #4
    2372:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    2376:	f7ff fabd 	bl	18f4 <GPIO_Ctrl>
    237a:	b318      	cbz	r0, 23c4 <Matrix_single_scan+0x100>
			if ( state->activeCount < DebounceDivThreshold ) state->activeCount += 1;
    237c:	f814 3035 	ldrb.w	r3, [r4, r5, lsl #3]
    2380:	2bff      	cmp	r3, #255	; 0xff
    2382:	bf1f      	itttt	ne
    2384:	f814 3035 	ldrbne.w	r3, [r4, r5, lsl #3]
    2388:	3301      	addne	r3, #1
    238a:	b2db      	uxtbne	r3, r3
    238c:	f804 3035 	strbne.w	r3, [r4, r5, lsl #3]
			state->inactiveCount >>= 1;
    2390:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
    2394:	7853      	ldrb	r3, [r2, #1]
    2396:	085b      	lsrs	r3, r3, #1
    2398:	7053      	strb	r3, [r2, #1]
		state->prevState = state->curState;
    239a:	00eb      	lsls	r3, r5, #3
    239c:	18e2      	adds	r2, r4, r3
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    239e:	9801      	ldr	r0, [sp, #4]
		state->prevState = state->curState;
    23a0:	78d1      	ldrb	r1, [r2, #3]
    23a2:	b2c9      	uxtb	r1, r1
    23a4:	7091      	strb	r1, [r2, #2]
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    23a6:	6851      	ldr	r1, [r2, #4]
		switch ( state->prevState )
    23a8:	7892      	ldrb	r2, [r2, #2]
    23aa:	3601      	adds	r6, #1
    23ac:	b2b6      	uxth	r6, r6
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    23ae:	eba0 0901 	sub.w	r9, r0, r1
		switch ( state->prevState )
    23b2:	2a03      	cmp	r2, #3
    23b4:	f200 8138 	bhi.w	2628 <Matrix_single_scan+0x364>
    23b8:	e8df f012 	tbh	[pc, r2, lsl #1]
    23bc:	00130127 	.word	0x00130127
    23c0:	01270013 	.word	0x01270013
			if ( state->inactiveCount < DebounceDivThreshold ) state->inactiveCount += 1;
    23c4:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
    23c8:	7853      	ldrb	r3, [r2, #1]
    23ca:	2bff      	cmp	r3, #255	; 0xff
    23cc:	bf1f      	itttt	ne
    23ce:	7853      	ldrbne	r3, [r2, #1]
    23d0:	3301      	addne	r3, #1
    23d2:	b2db      	uxtbne	r3, r3
    23d4:	7053      	strbne	r3, [r2, #1]
			state->activeCount >>= 1;
    23d6:	f814 3035 	ldrb.w	r3, [r4, r5, lsl #3]
    23da:	085b      	lsrs	r3, r3, #1
    23dc:	f804 3035 	strb.w	r3, [r4, r5, lsl #3]
    23e0:	e7db      	b.n	239a <Matrix_single_scan+0xd6>
			if ( state->activeCount > state->inactiveCount )
    23e2:	4423      	add	r3, r4
    23e4:	f814 1035 	ldrb.w	r1, [r4, r5, lsl #3]
    23e8:	785a      	ldrb	r2, [r3, #1]
    23ea:	4291      	cmp	r1, r2
    23ec:	d95a      	bls.n	24a4 <Matrix_single_scan+0x1e0>
				state->curState = KeyState_Hold;
    23ee:	2202      	movs	r2, #2
				state->curState = KeyState_Press;
    23f0:	70da      	strb	r2, [r3, #3]
		state->prevDecisionTime = currentTime;
    23f2:	eb04 0bc5 	add.w	fp, r4, r5, lsl #3
    23f6:	9b01      	ldr	r3, [sp, #4]
    23f8:	f8cb 3004 	str.w	r3, [fp, #4]
		Macro_keyState( key_disp, state->curState );
    23fc:	f89b 1003 	ldrb.w	r1, [fp, #3]
    2400:	4630      	mov	r0, r6
    2402:	f001 fab9 	bl	3978 <Macro_keyState>
		if ( state->curState != KeyState_Off )
    2406:	f89b 3003 	ldrb.w	r3, [fp, #3]
    240a:	b123      	cbz	r3, 2416 <Matrix_single_scan+0x152>
			matrixStateActiveCount++;
    240c:	4a21      	ldr	r2, [pc, #132]	; (2494 <Matrix_single_scan+0x1d0>)
    240e:	8813      	ldrh	r3, [r2, #0]
    2410:	3301      	adds	r3, #1
    2412:	b29b      	uxth	r3, r3
    2414:	8013      	strh	r3, [r2, #0]
		switch ( state->curState )
    2416:	ea4f 0bc5 	mov.w	fp, r5, lsl #3
    241a:	eb04 030b 	add.w	r3, r4, fp
    241e:	78db      	ldrb	r3, [r3, #3]
    2420:	b2db      	uxtb	r3, r3
    2422:	2b01      	cmp	r3, #1
    2424:	f000 8123 	beq.w	266e <Matrix_single_scan+0x3aa>
    2428:	2b03      	cmp	r3, #3
    242a:	f000 8126 	beq.w	267a <Matrix_single_scan+0x3b6>
		if ( matrixDebugMode && state->curState != state->prevState )
    242e:	f89a 3000 	ldrb.w	r3, [sl]
    2432:	2b00      	cmp	r3, #0
    2434:	d042      	beq.n	24bc <Matrix_single_scan+0x1f8>
    2436:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
    243a:	78d9      	ldrb	r1, [r3, #3]
    243c:	789a      	ldrb	r2, [r3, #2]
    243e:	4291      	cmp	r1, r2
    2440:	d03c      	beq.n	24bc <Matrix_single_scan+0x1f8>
			if ( matrixDebugMode == 1 && state->curState == KeyState_Press )
    2442:	f89a 2000 	ldrb.w	r2, [sl]
    2446:	2a01      	cmp	r2, #1
    2448:	f040 8119 	bne.w	267e <Matrix_single_scan+0x3ba>
    244c:	78d9      	ldrb	r1, [r3, #3]
    244e:	b2c9      	uxtb	r1, r1
    2450:	2901      	cmp	r1, #1
    2452:	f040 8114 	bne.w	267e <Matrix_single_scan+0x3ba>
				printInt16( key_disp );
    2456:	4630      	mov	r0, r6
    2458:	9102      	str	r1, [sp, #8]
    245a:	f007 f8b5 	bl	95c8 <printInt16>
				print(":");
    245e:	480e      	ldr	r0, [pc, #56]	; (2498 <Matrix_single_scan+0x1d4>)
    2460:	f007 f812 	bl	9488 <_print>
				printHex( key_disp );
    2464:	9902      	ldr	r1, [sp, #8]
    2466:	4630      	mov	r0, r6
    2468:	f007 f934 	bl	96d4 <printHex_op>
				print(" ");
    246c:	480b      	ldr	r0, [pc, #44]	; (249c <Matrix_single_scan+0x1d8>)
				print( NL );
    246e:	f007 f80b 	bl	9488 <_print>
    2472:	e023      	b.n	24bc <Matrix_single_scan+0x1f8>
    2474:	1fffe9d0 	.word	0x1fffe9d0
    2478:	1ffff290 	.word	0x1ffff290
    247c:	1ffff048 	.word	0x1ffff048
    2480:	1ffff28c 	.word	0x1ffff28c
    2484:	000099f8 	.word	0x000099f8
    2488:	000099a8 	.word	0x000099a8
    248c:	1ffff298 	.word	0x1ffff298
    2490:	1ffff050 	.word	0x1ffff050
    2494:	1ffff292 	.word	0x1ffff292
    2498:	0000d681 	.word	0x0000d681
    249c:	0000d6a4 	.word	0x0000d6a4
    24a0:	1ffff28d 	.word	0x1ffff28d
				if ( lastTransition < debounceExpiryTime )
    24a4:	4a9b      	ldr	r2, [pc, #620]	; (2714 <Matrix_single_scan+0x450>)
    24a6:	7812      	ldrb	r2, [r2, #0]
    24a8:	454a      	cmp	r2, r9
    24aa:	f240 80ac 	bls.w	2606 <Matrix_single_scan+0x342>
					state->curState = state->prevState;
    24ae:	789a      	ldrb	r2, [r3, #2]
    24b0:	b2d2      	uxtb	r2, r2
    24b2:	70da      	strb	r2, [r3, #3]
					Macro_keyState( key_disp, state->curState );
    24b4:	78d9      	ldrb	r1, [r3, #3]
    24b6:	4630      	mov	r0, r6
    24b8:	f001 fa5e 	bl	3978 <Macro_keyState>
    24bc:	f108 0801 	add.w	r8, r8, #1
	for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
    24c0:	f1b8 0f07 	cmp.w	r8, #7
    24c4:	f105 0509 	add.w	r5, r5, #9
    24c8:	f47f af42 	bne.w	2350 <Matrix_single_scan+0x8c>
	GPIO_Ctrl( Matrix_cols[ strobe ], GPIO_Type_DriveLow, Matrix_type );
    24cc:	4b92      	ldr	r3, [pc, #584]	; (2718 <Matrix_single_scan+0x454>)
    24ce:	f813 0017 	ldrb.w	r0, [r3, r7, lsl #1]
    24d2:	eb03 0747 	add.w	r7, r3, r7, lsl #1
    24d6:	2202      	movs	r2, #2
    24d8:	787b      	ldrb	r3, [r7, #1]
    24da:	2101      	movs	r1, #1
    24dc:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    24e0:	f7ff fa08 	bl	18f4 <GPIO_Ctrl>
	Latency_end_time( matrixLatencyResource );
    24e4:	9b04      	ldr	r3, [sp, #16]
    24e6:	7818      	ldrb	r0, [r3, #0]
    24e8:	f006 ff1a 	bl	9320 <Latency_end_time>
	if ( matrixDebugStateCounter > 0 )
    24ec:	4a8b      	ldr	r2, [pc, #556]	; (271c <Matrix_single_scan+0x458>)
    24ee:	8813      	ldrh	r3, [r2, #0]
    24f0:	b29b      	uxth	r3, r3
    24f2:	2b00      	cmp	r3, #0
    24f4:	d04b      	beq.n	258e <Matrix_single_scan+0x2ca>
		matrixDebugStateCounter--;
    24f6:	8813      	ldrh	r3, [r2, #0]
		print("<key>:<previous state><current state> <active count> <inactive count>");
    24f8:	4889      	ldr	r0, [pc, #548]	; (2720 <Matrix_single_scan+0x45c>)
				print( NL );
    24fa:	4f8a      	ldr	r7, [pc, #552]	; (2724 <Matrix_single_scan+0x460>)
			print("\033[1m");
    24fc:	4e8a      	ldr	r6, [pc, #552]	; (2728 <Matrix_single_scan+0x464>)
			print(" 0x");
    24fe:	4d8b      	ldr	r5, [pc, #556]	; (272c <Matrix_single_scan+0x468>)
		matrixDebugStateCounter--;
    2500:	3b01      	subs	r3, #1
    2502:	b29b      	uxth	r3, r3
    2504:	8013      	strh	r3, [r2, #0]
		print("<key>:<previous state><current state> <active count> <inactive count>");
    2506:	f006 ffbf 	bl	9488 <_print>
    250a:	2400      	movs	r4, #0
			if ( key % 5 == 0 )
    250c:	b2e2      	uxtb	r2, r4
    250e:	2305      	movs	r3, #5
    2510:	fbb2 f3f3 	udiv	r3, r2, r3
    2514:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    2518:	1ad3      	subs	r3, r2, r3
    251a:	f013 0fff 	tst.w	r3, #255	; 0xff
    251e:	d102      	bne.n	2526 <Matrix_single_scan+0x262>
				print( NL );
    2520:	4638      	mov	r0, r7
    2522:	f006 ffb1 	bl	9488 <_print>
			print("\033[1m");
    2526:	4630      	mov	r0, r6
			printInt16( key + 1 );
    2528:	f104 0901 	add.w	r9, r4, #1
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    252c:	f8df a230 	ldr.w	sl, [pc, #560]	; 2760 <Matrix_single_scan+0x49c>
			print("\033[1m");
    2530:	f006 ffaa 	bl	9488 <_print>
			printInt16( key + 1 );
    2534:	fa1f f089 	uxth.w	r0, r9
    2538:	f007 f846 	bl	95c8 <printInt16>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    253c:	eb0a 08c4 	add.w	r8, sl, r4, lsl #3
			print("\033[0m");
    2540:	487b      	ldr	r0, [pc, #492]	; (2730 <Matrix_single_scan+0x46c>)
    2542:	f006 ffa1 	bl	9488 <_print>
			print(":");
    2546:	487b      	ldr	r0, [pc, #492]	; (2734 <Matrix_single_scan+0x470>)
    2548:	f006 ff9e 	bl	9488 <_print>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    254c:	f898 0002 	ldrb.w	r0, [r8, #2]
    2550:	f7ff fe7e 	bl	2250 <Matrix_keyPositionDebug>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].curState );
    2554:	f898 0003 	ldrb.w	r0, [r8, #3]
    2558:	f7ff fe7a 	bl	2250 <Matrix_keyPositionDebug>
			print(" 0x");
    255c:	4628      	mov	r0, r5
    255e:	f006 ff93 	bl	9488 <_print>
			printHex_op( Matrix_scanArray[ key ].activeCount, 2 );
    2562:	f81a 0034 	ldrb.w	r0, [sl, r4, lsl #3]
    2566:	2102      	movs	r1, #2
    2568:	f007 f8b4 	bl	96d4 <printHex_op>
			print(" 0x");
    256c:	4628      	mov	r0, r5
    256e:	f006 ff8b 	bl	9488 <_print>
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 2 );
    2572:	f898 0001 	ldrb.w	r0, [r8, #1]
    2576:	2102      	movs	r1, #2
    2578:	f007 f8ac 	bl	96d4 <printHex_op>
    257c:	464c      	mov	r4, r9
			print(" ");
    257e:	486e      	ldr	r0, [pc, #440]	; (2738 <Matrix_single_scan+0x474>)
    2580:	f006 ff82 	bl	9488 <_print>
		for ( uint8_t key = 0; key < Matrix_maxKeys; key++ )
    2584:	2c3f      	cmp	r4, #63	; 0x3f
    2586:	d1c1      	bne.n	250c <Matrix_single_scan+0x248>
		print( NL );
    2588:	4866      	ldr	r0, [pc, #408]	; (2724 <Matrix_single_scan+0x460>)
    258a:	f006 ff7d 	bl	9488 <_print>
	if ( ++matrixCurrentStrobe >= Matrix_colsNum )
    258e:	9b00      	ldr	r3, [sp, #0]
    2590:	9a00      	ldr	r2, [sp, #0]
    2592:	781b      	ldrb	r3, [r3, #0]
    2594:	3301      	adds	r3, #1
    2596:	b2db      	uxtb	r3, r3
    2598:	2b08      	cmp	r3, #8
    259a:	7013      	strb	r3, [r2, #0]
    259c:	f04f 0000 	mov.w	r0, #0
    25a0:	d929      	bls.n	25f6 <Matrix_single_scan+0x332>
		if ( matrixStatePressCount > 0 && matrixStateReleaseCount == 0 )
    25a2:	4c66      	ldr	r4, [pc, #408]	; (273c <Matrix_single_scan+0x478>)
		matrixCurrentStrobe = 0;
    25a4:	7010      	strb	r0, [r2, #0]
		if ( matrixStatePressCount > 0 && matrixStateReleaseCount == 0 )
    25a6:	8823      	ldrh	r3, [r4, #0]
    25a8:	4d65      	ldr	r5, [pc, #404]	; (2740 <Matrix_single_scan+0x47c>)
    25aa:	b29b      	uxth	r3, r3
    25ac:	b12b      	cbz	r3, 25ba <Matrix_single_scan+0x2f6>
    25ae:	882b      	ldrh	r3, [r5, #0]
    25b0:	b29b      	uxth	r3, r3
    25b2:	b913      	cbnz	r3, 25ba <Matrix_single_scan+0x2f6>
			Time_tick_reset( &inactivity_tickstore );
    25b4:	4863      	ldr	r0, [pc, #396]	; (2744 <Matrix_single_scan+0x480>)
    25b6:	f7ff fc41 	bl	1e3c <Time_tick_reset>
		if ( matrixStateReleaseCount > 0 && matrixStatePressCount == 0 )
    25ba:	882b      	ldrh	r3, [r5, #0]
    25bc:	b29b      	uxth	r3, r3
    25be:	b12b      	cbz	r3, 25cc <Matrix_single_scan+0x308>
    25c0:	8823      	ldrh	r3, [r4, #0]
    25c2:	b29b      	uxth	r3, r3
    25c4:	b913      	cbnz	r3, 25cc <Matrix_single_scan+0x308>
			Time_tick_reset( &activity_tickstore );
    25c6:	4860      	ldr	r0, [pc, #384]	; (2748 <Matrix_single_scan+0x484>)
    25c8:	f7ff fc38 	bl	1e3c <Time_tick_reset>
		if ( matrixStateActiveCount > 0 )
    25cc:	4e5f      	ldr	r6, [pc, #380]	; (274c <Matrix_single_scan+0x488>)
    25ce:	8833      	ldrh	r3, [r6, #0]
    25d0:	b29b      	uxth	r3, r3
    25d2:	2b00      	cmp	r3, #0
    25d4:	f000 8092 	beq.w	26fc <Matrix_single_scan+0x438>
			if ( activity_tickstore.fresh_store )
    25d8:	4b5b      	ldr	r3, [pc, #364]	; (2748 <Matrix_single_scan+0x484>)
    25da:	7e1b      	ldrb	r3, [r3, #24]
    25dc:	b113      	cbz	r3, 25e4 <Matrix_single_scan+0x320>
				Time_tick_reset( &inactivity_tickstore );
    25de:	4859      	ldr	r0, [pc, #356]	; (2744 <Matrix_single_scan+0x480>)
    25e0:	f7ff fc2c 	bl	1e3c <Time_tick_reset>
			Macro_tick_update( &activity_tickstore, TriggerType_Active1 );
    25e4:	4858      	ldr	r0, [pc, #352]	; (2748 <Matrix_single_scan+0x484>)
    25e6:	2114      	movs	r1, #20
			Macro_tick_update( &inactivity_tickstore, TriggerType_Inactive1 );
    25e8:	f001 fb72 	bl	3cd0 <Macro_tick_update>
		matrixStateActiveCount = 0;
    25ec:	2300      	movs	r3, #0
    25ee:	8033      	strh	r3, [r6, #0]
		return 1;
    25f0:	2001      	movs	r0, #1
		matrixStatePressCount = 0;
    25f2:	8023      	strh	r3, [r4, #0]
		matrixStateReleaseCount = 0;
    25f4:	802b      	strh	r3, [r5, #0]
}
    25f6:	9b03      	ldr	r3, [sp, #12]
    25f8:	9a07      	ldr	r2, [sp, #28]
    25fa:	681b      	ldr	r3, [r3, #0]
    25fc:	429a      	cmp	r2, r3
    25fe:	f000 8086 	beq.w	270e <Matrix_single_scan+0x44a>
    2602:	f7fe ff8f 	bl	1524 <__stack_chk_fail>
				state->curState = KeyState_Release;
    2606:	2203      	movs	r2, #3
    2608:	e6f2      	b.n	23f0 <Matrix_single_scan+0x12c>
			if ( state->activeCount > state->inactiveCount )
    260a:	4423      	add	r3, r4
    260c:	f814 1035 	ldrb.w	r1, [r4, r5, lsl #3]
    2610:	785a      	ldrb	r2, [r3, #1]
    2612:	4291      	cmp	r1, r2
    2614:	d906      	bls.n	2624 <Matrix_single_scan+0x360>
				if ( lastTransition < debounceExpiryTime )
    2616:	4a3f      	ldr	r2, [pc, #252]	; (2714 <Matrix_single_scan+0x450>)
    2618:	7812      	ldrb	r2, [r2, #0]
    261a:	454a      	cmp	r2, r9
    261c:	f63f af47 	bhi.w	24ae <Matrix_single_scan+0x1ea>
				state->curState = KeyState_Press;
    2620:	2201      	movs	r2, #1
    2622:	e6e5      	b.n	23f0 <Matrix_single_scan+0x12c>
				state->curState = KeyState_Off;
    2624:	2200      	movs	r2, #0
    2626:	e6e3      	b.n	23f0 <Matrix_single_scan+0x12c>
			erro_msg("Matrix scan bug!! Report me! - ");
    2628:	4849      	ldr	r0, [pc, #292]	; (2750 <Matrix_single_scan+0x48c>)
    262a:	9305      	str	r3, [sp, #20]
    262c:	f006 ff2c 	bl	9488 <_print>
			printHex( state->prevState );
    2630:	9b05      	ldr	r3, [sp, #20]
    2632:	4423      	add	r3, r4
    2634:	2101      	movs	r1, #1
    2636:	7898      	ldrb	r0, [r3, #2]
    2638:	f007 f84c 	bl	96d4 <printHex_op>
			print(" Col: ");
    263c:	4845      	ldr	r0, [pc, #276]	; (2754 <Matrix_single_scan+0x490>)
    263e:	f006 ff23 	bl	9488 <_print>
			printHex( strobe );
    2642:	2101      	movs	r1, #1
    2644:	4658      	mov	r0, fp
    2646:	f007 f845 	bl	96d4 <printHex_op>
			print(" Row: ");
    264a:	4843      	ldr	r0, [pc, #268]	; (2758 <Matrix_single_scan+0x494>)
    264c:	f006 ff1c 	bl	9488 <_print>
			printHex( sense );
    2650:	2101      	movs	r1, #1
    2652:	9802      	ldr	r0, [sp, #8]
    2654:	f007 f83e 	bl	96d4 <printHex_op>
			print(" Key: ");
    2658:	4840      	ldr	r0, [pc, #256]	; (275c <Matrix_single_scan+0x498>)
    265a:	f006 ff15 	bl	9488 <_print>
			printHex( key_disp );
    265e:	4630      	mov	r0, r6
    2660:	2101      	movs	r1, #1
    2662:	f007 f837 	bl	96d4 <printHex_op>
			print( NL );
    2666:	482f      	ldr	r0, [pc, #188]	; (2724 <Matrix_single_scan+0x460>)
    2668:	f006 ff0e 	bl	9488 <_print>
			break;
    266c:	e6c1      	b.n	23f2 <Matrix_single_scan+0x12e>
			matrixStatePressCount++;
    266e:	4a33      	ldr	r2, [pc, #204]	; (273c <Matrix_single_scan+0x478>)
			matrixStateReleaseCount++;
    2670:	8813      	ldrh	r3, [r2, #0]
    2672:	3301      	adds	r3, #1
    2674:	b29b      	uxth	r3, r3
    2676:	8013      	strh	r3, [r2, #0]
			break;
    2678:	e6d9      	b.n	242e <Matrix_single_scan+0x16a>
			matrixStateReleaseCount++;
    267a:	4a31      	ldr	r2, [pc, #196]	; (2740 <Matrix_single_scan+0x47c>)
    267c:	e7f8      	b.n	2670 <Matrix_single_scan+0x3ac>
			else if ( matrixDebugMode == 2 )
    267e:	f89a 3000 	ldrb.w	r3, [sl]
    2682:	2b02      	cmp	r3, #2
    2684:	d108      	bne.n	2698 <Matrix_single_scan+0x3d4>
				printInt16( key_disp );
    2686:	4630      	mov	r0, r6
    2688:	f006 ff9e 	bl	95c8 <printInt16>
				Matrix_keyPositionDebug( state->curState );
    268c:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
    2690:	78d8      	ldrb	r0, [r3, #3]
    2692:	f7ff fddd 	bl	2250 <Matrix_keyPositionDebug>
    2696:	e6e9      	b.n	246c <Matrix_single_scan+0x1a8>
			else if ( matrixDebugMode == 3 )
    2698:	f89a 3000 	ldrb.w	r3, [sl]
    269c:	2b03      	cmp	r3, #3
    269e:	f47f af0d 	bne.w	24bc <Matrix_single_scan+0x1f8>
				print("\033[1m");
    26a2:	4821      	ldr	r0, [pc, #132]	; (2728 <Matrix_single_scan+0x464>)
    26a4:	f006 fef0 	bl	9488 <_print>
				printInt16( key_disp );
    26a8:	4630      	mov	r0, r6
    26aa:	f006 ff8d 	bl	95c8 <printInt16>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    26ae:	44a3      	add	fp, r4
				print("\033[0m");
    26b0:	481f      	ldr	r0, [pc, #124]	; (2730 <Matrix_single_scan+0x46c>)
    26b2:	f006 fee9 	bl	9488 <_print>
				print(":");
    26b6:	481f      	ldr	r0, [pc, #124]	; (2734 <Matrix_single_scan+0x470>)
    26b8:	f006 fee6 	bl	9488 <_print>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    26bc:	f89b 0002 	ldrb.w	r0, [fp, #2]
    26c0:	f7ff fdc6 	bl	2250 <Matrix_keyPositionDebug>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].curState );
    26c4:	f89b 0003 	ldrb.w	r0, [fp, #3]
    26c8:	f7ff fdc2 	bl	2250 <Matrix_keyPositionDebug>
				print(" 0x");
    26cc:	4817      	ldr	r0, [pc, #92]	; (272c <Matrix_single_scan+0x468>)
    26ce:	f006 fedb 	bl	9488 <_print>
				printHex_op( state->activeCount, 2 );
    26d2:	2102      	movs	r1, #2
    26d4:	f814 0035 	ldrb.w	r0, [r4, r5, lsl #3]
    26d8:	f006 fffc 	bl	96d4 <printHex_op>
				print(" 0x");
    26dc:	4813      	ldr	r0, [pc, #76]	; (272c <Matrix_single_scan+0x468>)
    26de:	f006 fed3 	bl	9488 <_print>
				printHex_op( state->inactiveCount, 2 );
    26e2:	2102      	movs	r1, #2
    26e4:	f89b 0001 	ldrb.w	r0, [fp, #1]
    26e8:	f006 fff4 	bl	96d4 <printHex_op>
				print(" ");
    26ec:	4812      	ldr	r0, [pc, #72]	; (2738 <Matrix_single_scan+0x474>)
    26ee:	f006 fecb 	bl	9488 <_print>
				printInt32( lastTransition );
    26f2:	4648      	mov	r0, r9
    26f4:	f006 ff9e 	bl	9634 <printInt32>
				print( NL );
    26f8:	480a      	ldr	r0, [pc, #40]	; (2724 <Matrix_single_scan+0x460>)
    26fa:	e6b8      	b.n	246e <Matrix_single_scan+0x1aa>
			if ( inactivity_tickstore.fresh_store )
    26fc:	4b11      	ldr	r3, [pc, #68]	; (2744 <Matrix_single_scan+0x480>)
    26fe:	7e1b      	ldrb	r3, [r3, #24]
    2700:	b113      	cbz	r3, 2708 <Matrix_single_scan+0x444>
				Time_tick_reset( &activity_tickstore );
    2702:	4811      	ldr	r0, [pc, #68]	; (2748 <Matrix_single_scan+0x484>)
    2704:	f7ff fb9a 	bl	1e3c <Time_tick_reset>
			Macro_tick_update( &inactivity_tickstore, TriggerType_Inactive1 );
    2708:	2113      	movs	r1, #19
    270a:	480e      	ldr	r0, [pc, #56]	; (2744 <Matrix_single_scan+0x480>)
    270c:	e76c      	b.n	25e8 <Matrix_single_scan+0x324>
}
    270e:	b009      	add	sp, #36	; 0x24
    2710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2714:	1ffff26c 	.word	0x1ffff26c
    2718:	000099a8 	.word	0x000099a8
    271c:	1ffff28e 	.word	0x1ffff28e
    2720:	00009a67 	.word	0x00009a67
    2724:	0000d348 	.word	0x0000d348
    2728:	00009a5e 	.word	0x00009a5e
    272c:	00009a63 	.word	0x00009a63
    2730:	0000ac37 	.word	0x0000ac37
    2734:	0000d681 	.word	0x0000d681
    2738:	0000d6a4 	.word	0x0000d6a4
    273c:	1ffff294 	.word	0x1ffff294
    2740:	1ffff296 	.word	0x1ffff296
    2744:	1ffff270 	.word	0x1ffff270
    2748:	1ffff250 	.word	0x1ffff250
    274c:	1ffff292 	.word	0x1ffff292
    2750:	00009a14 	.word	0x00009a14
    2754:	00009a49 	.word	0x00009a49
    2758:	00009a50 	.word	0x00009a50
    275c:	00009a57 	.word	0x00009a57
    2760:	1ffff050 	.word	0x1ffff050

00002764 <Matrix_start>:
{
    2764:	b507      	push	{r0, r1, r2, lr}
    2766:	4b08      	ldr	r3, [pc, #32]	; (2788 <Matrix_start+0x24>)
    2768:	681a      	ldr	r2, [r3, #0]
    276a:	9201      	str	r2, [sp, #4]
	Periodic_init( PeriodicCycles_define );
    276c:	9a01      	ldr	r2, [sp, #4]
    276e:	681b      	ldr	r3, [r3, #0]
    2770:	429a      	cmp	r2, r3
    2772:	d001      	beq.n	2778 <Matrix_start+0x14>
    2774:	f7fe fed6 	bl	1524 <__stack_chk_fail>
    2778:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}
    277c:	b003      	add	sp, #12
    277e:	f85d eb04 	ldr.w	lr, [sp], #4
	Periodic_init( PeriodicCycles_define );
    2782:	f7ff b923 	b.w	19cc <Periodic_init>
    2786:	bf00      	nop
    2788:	1fffe9d0 	.word	0x1fffe9d0

0000278c <Matrix_currentChange>:
{
    278c:	b507      	push	{r0, r1, r2, lr}
    278e:	4b06      	ldr	r3, [pc, #24]	; (27a8 <Matrix_currentChange+0x1c>)
    2790:	681a      	ldr	r2, [r3, #0]
    2792:	9201      	str	r2, [sp, #4]
}
    2794:	9a01      	ldr	r2, [sp, #4]
    2796:	681b      	ldr	r3, [r3, #0]
    2798:	429a      	cmp	r2, r3
    279a:	d001      	beq.n	27a0 <Matrix_currentChange+0x14>
    279c:	f7fe fec2 	bl	1524 <__stack_chk_fail>
    27a0:	b003      	add	sp, #12
    27a2:	f85d fb04 	ldr.w	pc, [sp], #4
    27a6:	bf00      	nop
    27a8:	1fffe9d0 	.word	0x1fffe9d0

000027ac <cliFunc_echo>:

// ----- CLI Command Functions -----

// XXX Just an example command showing how to parse arguments (more complex than generally needed)
void cliFunc_echo( char* args )
{
    27ac:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    27ae:	4c0e      	ldr	r4, [pc, #56]	; (27e8 <cliFunc_echo+0x3c>)
	char* arg2Ptr = args;

	// Parse args until a \0 is found
	while ( 1 )
	{
		print( NL ); // No \r\n by default after the command is entered
    27b0:	4e0e      	ldr	r6, [pc, #56]	; (27ec <cliFunc_echo+0x40>)
{
    27b2:	6822      	ldr	r2, [r4, #0]
    27b4:	9203      	str	r2, [sp, #12]
	char* arg2Ptr = args;
    27b6:	ad04      	add	r5, sp, #16
    27b8:	f845 0d08 	str.w	r0, [r5, #-8]!
		print( NL ); // No \r\n by default after the command is entered
    27bc:	4630      	mov	r0, r6
    27be:	f006 fe63 	bl	9488 <_print>

		curArgs = arg2Ptr; // Use the previous 2nd arg pointer to separate the next arg from the list
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    27c2:	9802      	ldr	r0, [sp, #8]
    27c4:	462a      	mov	r2, r5
    27c6:	a901      	add	r1, sp, #4
    27c8:	f006 f930 	bl	8a2c <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    27cc:	9801      	ldr	r0, [sp, #4]
    27ce:	7803      	ldrb	r3, [r0, #0]
    27d0:	b113      	cbz	r3, 27d8 <cliFunc_echo+0x2c>
			break;

		// Print out the arg
		dPrint( arg1Ptr );
    27d2:	f003 fad5 	bl	5d80 <Output_putstr>
		print( NL ); // No \r\n by default after the command is entered
    27d6:	e7f1      	b.n	27bc <cliFunc_echo+0x10>
	}
}
    27d8:	9a03      	ldr	r2, [sp, #12]
    27da:	6823      	ldr	r3, [r4, #0]
    27dc:	429a      	cmp	r2, r3
    27de:	d001      	beq.n	27e4 <cliFunc_echo+0x38>
    27e0:	f7fe fea0 	bl	1524 <__stack_chk_fail>
    27e4:	b004      	add	sp, #16
    27e6:	bd70      	pop	{r4, r5, r6, pc}
    27e8:	1fffe9d0 	.word	0x1fffe9d0
    27ec:	0000d348 	.word	0x0000d348

000027f0 <Scan_setup>:
{
    27f0:	b513      	push	{r0, r1, r4, lr}
    27f2:	4c0a      	ldr	r4, [pc, #40]	; (281c <Scan_setup+0x2c>)
	CLI_registerDictionary( scanCLIDict, scanCLIDictName );
    27f4:	490a      	ldr	r1, [pc, #40]	; (2820 <Scan_setup+0x30>)
{
    27f6:	6823      	ldr	r3, [r4, #0]
	CLI_registerDictionary( scanCLIDict, scanCLIDictName );
    27f8:	480a      	ldr	r0, [pc, #40]	; (2824 <Scan_setup+0x34>)
{
    27fa:	9301      	str	r3, [sp, #4]
	CLI_registerDictionary( scanCLIDict, scanCLIDictName );
    27fc:	f006 f9d4 	bl	8ba8 <CLI_registerDictionary>
	Matrix_setup();
    2800:	f7ff fc90 	bl	2124 <Matrix_setup>
	Matrix_start();
    2804:	9a01      	ldr	r2, [sp, #4]
    2806:	6823      	ldr	r3, [r4, #0]
    2808:	429a      	cmp	r2, r3
    280a:	d001      	beq.n	2810 <Scan_setup+0x20>
    280c:	f7fe fe8a 	bl	1524 <__stack_chk_fail>
}
    2810:	b002      	add	sp, #8
    2812:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Matrix_start();
    2816:	f7ff bfa5 	b.w	2764 <Matrix_start>
    281a:	bf00      	nop
    281c:	1fffe9d0 	.word	0x1fffe9d0
    2820:	00009e0c 	.word	0x00009e0c
    2824:	00009df4 	.word	0x00009df4

00002828 <Scan_poll>:
{
    2828:	b507      	push	{r0, r1, r2, lr}
    282a:	4b06      	ldr	r3, [pc, #24]	; (2844 <Scan_poll+0x1c>)
    282c:	681a      	ldr	r2, [r3, #0]
    282e:	9201      	str	r2, [sp, #4]
}
    2830:	9a01      	ldr	r2, [sp, #4]
    2832:	681b      	ldr	r3, [r3, #0]
    2834:	429a      	cmp	r2, r3
    2836:	d001      	beq.n	283c <Scan_poll+0x14>
    2838:	f7fe fe74 	bl	1524 <__stack_chk_fail>
    283c:	b003      	add	sp, #12
    283e:	f85d fb04 	ldr.w	pc, [sp], #4
    2842:	bf00      	nop
    2844:	1fffe9d0 	.word	0x1fffe9d0

00002848 <Scan_periodic>:
{
    2848:	b507      	push	{r0, r1, r2, lr}
    284a:	4b07      	ldr	r3, [pc, #28]	; (2868 <Scan_periodic+0x20>)
    284c:	681a      	ldr	r2, [r3, #0]
    284e:	9201      	str	r2, [sp, #4]
	return Matrix_single_scan();
    2850:	9a01      	ldr	r2, [sp, #4]
    2852:	681b      	ldr	r3, [r3, #0]
    2854:	429a      	cmp	r2, r3
    2856:	d001      	beq.n	285c <Scan_periodic+0x14>
    2858:	f7fe fe64 	bl	1524 <__stack_chk_fail>
}
    285c:	b003      	add	sp, #12
    285e:	f85d eb04 	ldr.w	lr, [sp], #4
	return Matrix_single_scan();
    2862:	f7ff bd2f 	b.w	22c4 <Matrix_single_scan>
    2866:	bf00      	nop
    2868:	1fffe9d0 	.word	0x1fffe9d0

0000286c <Scan_finishedWithMacro>:
{
    286c:	b507      	push	{r0, r1, r2, lr}
    286e:	4b06      	ldr	r3, [pc, #24]	; (2888 <Scan_finishedWithMacro+0x1c>)
    2870:	681a      	ldr	r2, [r3, #0]
    2872:	9201      	str	r2, [sp, #4]
}
    2874:	9a01      	ldr	r2, [sp, #4]
    2876:	681b      	ldr	r3, [r3, #0]
    2878:	429a      	cmp	r2, r3
    287a:	d001      	beq.n	2880 <Scan_finishedWithMacro+0x14>
    287c:	f7fe fe52 	bl	1524 <__stack_chk_fail>
    2880:	b003      	add	sp, #12
    2882:	f85d fb04 	ldr.w	pc, [sp], #4
    2886:	bf00      	nop
    2888:	1fffe9d0 	.word	0x1fffe9d0

0000288c <Scan_finishedWithOutput>:
    288c:	b507      	push	{r0, r1, r2, lr}
    288e:	4b06      	ldr	r3, [pc, #24]	; (28a8 <Scan_finishedWithOutput+0x1c>)
    2890:	681a      	ldr	r2, [r3, #0]
    2892:	9201      	str	r2, [sp, #4]
    2894:	9a01      	ldr	r2, [sp, #4]
    2896:	681b      	ldr	r3, [r3, #0]
    2898:	429a      	cmp	r2, r3
    289a:	d001      	beq.n	28a0 <Scan_finishedWithOutput+0x14>
    289c:	f7fe fe42 	bl	1524 <__stack_chk_fail>
    28a0:	b003      	add	sp, #12
    28a2:	f85d fb04 	ldr.w	pc, [sp], #4
    28a6:	bf00      	nop
    28a8:	1fffe9d0 	.word	0x1fffe9d0

000028ac <Scan_currentChange>:
{
    28ac:	b507      	push	{r0, r1, r2, lr}
    28ae:	4b07      	ldr	r3, [pc, #28]	; (28cc <Scan_currentChange+0x20>)
    28b0:	681a      	ldr	r2, [r3, #0]
    28b2:	9201      	str	r2, [sp, #4]
	Matrix_currentChange( current );
    28b4:	9a01      	ldr	r2, [sp, #4]
    28b6:	681b      	ldr	r3, [r3, #0]
    28b8:	429a      	cmp	r2, r3
    28ba:	d001      	beq.n	28c0 <Scan_currentChange+0x14>
    28bc:	f7fe fe32 	bl	1524 <__stack_chk_fail>
}
    28c0:	b003      	add	sp, #12
    28c2:	f85d eb04 	ldr.w	lr, [sp], #4
	Matrix_currentChange( current );
    28c6:	f7ff bf61 	b.w	278c <Matrix_currentChange>
    28ca:	bf00      	nop
    28cc:	1fffe9d0 	.word	0x1fffe9d0

000028d0 <KLL_TriggerIndex_loopkup>:

// ----- Functions -----

// Based on the type and index, lookup the full index
var_uint_t KLL_TriggerIndex_loopkup( TriggerType type, uint8_t index )
{
    28d0:	b507      	push	{r0, r1, r2, lr}
    28d2:	4b13      	ldr	r3, [pc, #76]	; (2920 <KLL_TriggerIndex_loopkup+0x50>)
    28d4:	2810      	cmp	r0, #16
    28d6:	681a      	ldr	r2, [r3, #0]
    28d8:	9201      	str	r2, [sp, #4]
    28da:	461a      	mov	r2, r3
    28dc:	d80e      	bhi.n	28fc <KLL_TriggerIndex_loopkup+0x2c>
    28de:	2301      	movs	r3, #1
    28e0:	fa03 f000 	lsl.w	r0, r3, r0
    28e4:	4b0f      	ldr	r3, [pc, #60]	; (2924 <KLL_TriggerIndex_loopkup+0x54>)
    28e6:	4218      	tst	r0, r3
    28e8:	d113      	bne.n	2912 <KLL_TriggerIndex_loopkup+0x42>
    28ea:	f648 0384 	movw	r3, #34948	; 0x8884
    28ee:	4218      	tst	r0, r3
    28f0:	d10b      	bne.n	290a <KLL_TriggerIndex_loopkup+0x3a>
    28f2:	f244 4342 	movw	r3, #17474	; 0x4442
    28f6:	4218      	tst	r0, r3
    28f8:	d000      	beq.n	28fc <KLL_TriggerIndex_loopkup+0x2c>
	{
	case TriggerType_Switch2:
	case TriggerType_Analog2:
	case TriggerType_Layer2:
	case TriggerType_Animation2:
		fullindex += 255;
    28fa:	31ff      	adds	r1, #255	; 0xff
	default:
		break;
	}

	return fullindex;
}
    28fc:	4608      	mov	r0, r1
    28fe:	9901      	ldr	r1, [sp, #4]
    2900:	6813      	ldr	r3, [r2, #0]
    2902:	4299      	cmp	r1, r3
    2904:	d008      	beq.n	2918 <KLL_TriggerIndex_loopkup+0x48>
    2906:	f7fe fe0d 	bl	1524 <__stack_chk_fail>
		fullindex += 511;
    290a:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
		fullindex += 767;
    290e:	b289      	uxth	r1, r1
		break;
    2910:	e7f4      	b.n	28fc <KLL_TriggerIndex_loopkup+0x2c>
		fullindex += 767;
    2912:	f201 21ff 	addw	r1, r1, #767	; 0x2ff
    2916:	e7fa      	b.n	290e <KLL_TriggerIndex_loopkup+0x3e>
}
    2918:	b003      	add	sp, #12
    291a:	f85d fb04 	ldr.w	pc, [sp], #4
    291e:	bf00      	nop
    2920:	1fffe9d0 	.word	0x1fffe9d0
    2924:	00011108 	.word	0x00011108

00002928 <KLL_CapabilityState>:


// Given a state and state type determine a CapabilityState
CapabilityState KLL_CapabilityState( ScheduleState state, TriggerType type )
{
    2928:	b507      	push	{r0, r1, r2, lr}
    292a:	4b1e      	ldr	r3, [pc, #120]	; (29a4 <KLL_CapabilityState+0x7c>)
	// Lookup trigger type
	switch ( type )
    292c:	290c      	cmp	r1, #12
{
    292e:	681a      	ldr	r2, [r3, #0]
    2930:	9201      	str	r2, [sp, #4]
	switch ( type )
    2932:	d811      	bhi.n	2958 <KLL_CapabilityState+0x30>
    2934:	2909      	cmp	r1, #9
    2936:	d21d      	bcs.n	2974 <KLL_CapabilityState+0x4c>
    2938:	2904      	cmp	r1, #4
    293a:	d01b      	beq.n	2974 <KLL_CapabilityState+0x4c>
    293c:	d91a      	bls.n	2974 <KLL_CapabilityState+0x4c>
		// XXX There is no "Press" state per say
		//     0x02 is reserved for Press
		//     0x01 is reserved for Release
		//     However these are reserved for working with state scheduling events
		//     By default, all analog values have to be handled manually (unless state scheduled)
		switch ( state )
    293e:	2801      	cmp	r0, #1
    2940:	d02a      	beq.n	2998 <KLL_CapabilityState+0x70>
    2942:	d30e      	bcc.n	2962 <KLL_CapabilityState+0x3a>
			return CapabilityState_Any;
    2944:	2802      	cmp	r0, #2
    2946:	bf0c      	ite	eq
    2948:	2001      	moveq	r0, #1
    294a:	2003      	movne	r0, #3
		break;
	}

	// Ignore otherwise
	return CapabilityState_None;
}
    294c:	9a01      	ldr	r2, [sp, #4]
    294e:	681b      	ldr	r3, [r3, #0]
    2950:	429a      	cmp	r2, r3
    2952:	d023      	beq.n	299c <KLL_CapabilityState+0x74>
    2954:	f7fe fde6 	bl	1524 <__stack_chk_fail>
	switch ( type )
    2958:	2915      	cmp	r1, #21
    295a:	d01b      	beq.n	2994 <KLL_CapabilityState+0x6c>
    295c:	d803      	bhi.n	2966 <KLL_CapabilityState+0x3e>
    295e:	2910      	cmp	r1, #16
    2960:	d912      	bls.n	2988 <KLL_CapabilityState+0x60>
	return CapabilityState_None;
    2962:	2000      	movs	r0, #0
    2964:	e7f2      	b.n	294c <KLL_CapabilityState+0x24>
	switch ( type )
    2966:	29ff      	cmp	r1, #255	; 0xff
    2968:	d1fb      	bne.n	2962 <KLL_CapabilityState+0x3a>
		if ( state == ScheduleType_Debug )
    296a:	28ff      	cmp	r0, #255	; 0xff
    296c:	bf0c      	ite	eq
    296e:	20ff      	moveq	r0, #255	; 0xff
    2970:	2000      	movne	r0, #0
    2972:	e7eb      	b.n	294c <KLL_CapabilityState+0x24>
		switch ( state )
    2974:	2802      	cmp	r0, #2
    2976:	d005      	beq.n	2984 <KLL_CapabilityState+0x5c>
    2978:	2803      	cmp	r0, #3
    297a:	d00d      	beq.n	2998 <KLL_CapabilityState+0x70>
	return CapabilityState_None;
    297c:	1e42      	subs	r2, r0, #1
    297e:	4250      	negs	r0, r2
    2980:	4150      	adcs	r0, r2
    2982:	e7e3      	b.n	294c <KLL_CapabilityState+0x24>
			return CapabilityState_Any;
    2984:	2003      	movs	r0, #3
    2986:	e7e1      	b.n	294c <KLL_CapabilityState+0x24>
		switch ( state )
    2988:	3806      	subs	r0, #6
			return CapabilityState_Any;
    298a:	2801      	cmp	r0, #1
    298c:	bf8c      	ite	hi
    298e:	2000      	movhi	r0, #0
    2990:	2003      	movls	r0, #3
    2992:	e7db      	b.n	294c <KLL_CapabilityState+0x24>
			return CapabilityState_Initial;
    2994:	2001      	movs	r0, #1
    2996:	e7d9      	b.n	294c <KLL_CapabilityState+0x24>
			return CapabilityState_Last;
    2998:	2002      	movs	r0, #2
    299a:	e7d7      	b.n	294c <KLL_CapabilityState+0x24>
}
    299c:	b003      	add	sp, #12
    299e:	f85d fb04 	ldr.w	pc, [sp], #4
    29a2:	bf00      	nop
    29a4:	1fffe9d0 	.word	0x1fffe9d0

000029a8 <Layer_layerStateSet.part.0>:


// ----- Capabilities -----

// Sets the given layer with the specified layerState
void Layer_layerStateSet( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
    29a8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    29ac:	4e46      	ldr	r6, [pc, #280]	; (2ac8 <Layer_layerStateSet.part.0+0x120>)
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
		return;

	// Check current layer state
	uint8_t oldState = LayerState[ layer ];
    29ae:	4c47      	ldr	r4, [pc, #284]	; (2acc <Layer_layerStateSet.part.0+0x124>)

	// Is layer in the LayerIndexStack?
	uint8_t inLayerIndexStack = 0;
	uint16_t stackItem = 0;
	while ( stackItem < macroLayerIndexStackSize )
    29b0:	4d47      	ldr	r5, [pc, #284]	; (2ad0 <Layer_layerStateSet.part.0+0x128>)
void Layer_layerStateSet( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
    29b2:	6833      	ldr	r3, [r6, #0]
	uint8_t oldState = LayerState[ layer ];
    29b4:	7867      	ldrb	r7, [r4, #1]
	while ( stackItem < macroLayerIndexStackSize )
    29b6:	8829      	ldrh	r1, [r5, #0]
	{
		// Flag if layer is already in the LayerIndexStack
		if ( macroLayerIndexStack[ stackItem ] == layer )
    29b8:	f8df e118 	ldr.w	lr, [pc, #280]	; 2ad4 <Layer_layerStateSet.part.0+0x12c>
void Layer_layerStateSet( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
    29bc:	9301      	str	r3, [sp, #4]
	while ( stackItem < macroLayerIndexStackSize )
    29be:	f04f 0c00 	mov.w	ip, #0
    29c2:	fa1f f38c 	uxth.w	r3, ip
    29c6:	428b      	cmp	r3, r1
    29c8:	d33f      	bcc.n	2a4a <Layer_layerStateSet.part.0+0xa2>
	uint8_t inLayerIndexStack = 0;
    29ca:	2200      	movs	r2, #0
		// Increment to next item
		stackItem++;
	}

	// Toggle Layer State Byte
	if ( LayerState[ layer ] & layerState )
    29cc:	4207      	tst	r7, r0
	{
		// Unset
		LayerState[ layer ] &= ~layerState;
    29ce:	bf14      	ite	ne
    29d0:	ea27 0e00 	bicne.w	lr, r7, r0
	}
	else
	{
		// Set
		LayerState[ layer ] |= layerState;
    29d4:	ea47 0e00 	orreq.w	lr, r7, r0
    29d8:	f884 e001 	strb.w	lr, [r4, #1]
	}

	// If the layer was not in the LayerIndexStack add it
	if ( !inLayerIndexStack )
    29dc:	b94a      	cbnz	r2, 29f2 <Layer_layerStateSet.part.0+0x4a>
	{
		macroLayerIndexStack[ macroLayerIndexStackSize++ ] = layer;
    29de:	f101 0e01 	add.w	lr, r1, #1
    29e2:	f8a5 e000 	strh.w	lr, [r5]
    29e6:	f8df e0ec 	ldr.w	lr, [pc, #236]	; 2ad4 <Layer_layerStateSet.part.0+0x12c>
    29ea:	f04f 0801 	mov.w	r8, #1
    29ee:	f82e 8011 	strh.w	r8, [lr, r1, lsl #1]
	}

	// If the layer is in the LayerIndexStack and the state is 0x00, remove
	uint8_t newState = LayerState[ layer ];
    29f2:	7861      	ldrb	r1, [r4, #1]
	if ( newState == LayerStateType_Off && inLayerIndexStack )
    29f4:	2900      	cmp	r1, #0
    29f6:	d157      	bne.n	2aa8 <Layer_layerStateSet.part.0+0x100>
    29f8:	b13a      	cbz	r2, 2a0a <Layer_layerStateSet.part.0+0x62>
    29fa:	4a36      	ldr	r2, [pc, #216]	; (2ad4 <Layer_layerStateSet.part.0+0x12c>)
	{
		// Remove the layer from the LayerIndexStack
		// Using the already positioned stackItem variable from the loop above
		while ( stackItem < macroLayerIndexStackSize )
    29fc:	8829      	ldrh	r1, [r5, #0]
    29fe:	eb02 024c 	add.w	r2, r2, ip, lsl #1
    2a02:	428b      	cmp	r3, r1
    2a04:	d329      	bcc.n	2a5a <Layer_layerStateSet.part.0+0xb2>
			macroLayerIndexStack[ stackItem ] = macroLayerIndexStack[ stackItem + 1 ];
			stackItem++;
		}

		// Reduce LayerIndexStack size
		macroLayerIndexStackSize--;
    2a06:	3901      	subs	r1, #1
    2a08:	8029      	strh	r1, [r5, #0]
	}

	// Determine what signal to send about layer
	if ( oldState && newState )
    2a0a:	2f00      	cmp	r7, #0
    2a0c:	d135      	bne.n	2a7a <Layer_layerStateSet.part.0+0xd2>
		// Send layer state that deactivated
		Macro_layerState( layer, ScheduleType_D | (layerState << 4) );
	}

	// Layer Debug Mode
	if ( layerDebugMode )
    2a0e:	4b32      	ldr	r3, [pc, #200]	; (2ad8 <Layer_layerStateSet.part.0+0x130>)
    2a10:	781b      	ldrb	r3, [r3, #0]
    2a12:	2b00      	cmp	r3, #0
    2a14:	d050      	beq.n	2ab8 <Layer_layerStateSet.part.0+0x110>
	{
		print("\033[1;36mL\033[0m ");
    2a16:	4831      	ldr	r0, [pc, #196]	; (2adc <Layer_layerStateSet.part.0+0x134>)
		print(" 0");

		// Iterate over the layer stack starting from the bottom of the stack
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
		{
			print(":");
    2a18:	4f31      	ldr	r7, [pc, #196]	; (2ae0 <Layer_layerStateSet.part.0+0x138>)
		print("\033[1;36mL\033[0m ");
    2a1a:	f006 fd35 	bl	9488 <_print>
			printHex_op( LayerState[ index ], 0 );
    2a1e:	7820      	ldrb	r0, [r4, #0]
    2a20:	2100      	movs	r1, #0
    2a22:	f006 fe57 	bl	96d4 <printHex_op>
    2a26:	7860      	ldrb	r0, [r4, #1]
    2a28:	2100      	movs	r1, #0
    2a2a:	f006 fe53 	bl	96d4 <printHex_op>
		print(" 0");
    2a2e:	482d      	ldr	r0, [pc, #180]	; (2ae4 <Layer_layerStateSet.part.0+0x13c>)
    2a30:	f006 fd2a 	bl	9488 <_print>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    2a34:	882c      	ldrh	r4, [r5, #0]
    2a36:	4d27      	ldr	r5, [pc, #156]	; (2ad4 <Layer_layerStateSet.part.0+0x12c>)
    2a38:	eb05 0544 	add.w	r5, r5, r4, lsl #1
    2a3c:	bb1c      	cbnz	r4, 2a86 <Layer_layerStateSet.part.0+0xde>
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
		}

		print( NL );
    2a3e:	9a01      	ldr	r2, [sp, #4]
    2a40:	6833      	ldr	r3, [r6, #0]
    2a42:	429a      	cmp	r2, r3
    2a44:	d02a      	beq.n	2a9c <Layer_layerStateSet.part.0+0xf4>
	}
}
    2a46:	f7fe fd6d 	bl	1524 <__stack_chk_fail>
		if ( macroLayerIndexStack[ stackItem ] == layer )
    2a4a:	f83e 201c 	ldrh.w	r2, [lr, ip, lsl #1]
    2a4e:	2a01      	cmp	r2, #1
    2a50:	f10c 0801 	add.w	r8, ip, #1
    2a54:	d0ba      	beq.n	29cc <Layer_layerStateSet.part.0+0x24>
    2a56:	46c4      	mov	ip, r8
    2a58:	e7b3      	b.n	29c2 <Layer_layerStateSet.part.0+0x1a>
			macroLayerIndexStack[ stackItem ] = macroLayerIndexStack[ stackItem + 1 ];
    2a5a:	f832 cf02 	ldrh.w	ip, [r2, #2]!
    2a5e:	f822 cc02 	strh.w	ip, [r2, #-2]
			stackItem++;
    2a62:	3301      	adds	r3, #1
    2a64:	b29b      	uxth	r3, r3
    2a66:	e7cc      	b.n	2a02 <Layer_layerStateSet.part.0+0x5a>
		Macro_layerState( layer, ScheduleType_On | (LayerState[ layer ] << 4) );
    2a68:	0109      	lsls	r1, r1, #4
    2a6a:	f041 0102 	orr.w	r1, r1, #2
    2a6e:	f001 01f2 	and.w	r1, r1, #242	; 0xf2
		Macro_layerState( layer, ScheduleType_D | (layerState << 4) );
    2a72:	2001      	movs	r0, #1
    2a74:	f001 f848 	bl	3b08 <Macro_layerState>
    2a78:	e7c9      	b.n	2a0e <Layer_layerStateSet.part.0+0x66>
    2a7a:	0100      	lsls	r0, r0, #4
    2a7c:	f040 0103 	orr.w	r1, r0, #3
    2a80:	f001 01f3 	and.w	r1, r1, #243	; 0xf3
    2a84:	e7f5      	b.n	2a72 <Layer_layerStateSet.part.0+0xca>
			print(":");
    2a86:	4638      	mov	r0, r7
    2a88:	f006 fcfe 	bl	9488 <_print>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    2a8c:	3c01      	subs	r4, #1
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
    2a8e:	2100      	movs	r1, #0
    2a90:	f835 0d02 	ldrh.w	r0, [r5, #-2]!
    2a94:	f006 fe1e 	bl	96d4 <printHex_op>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    2a98:	b2a4      	uxth	r4, r4
    2a9a:	e7cf      	b.n	2a3c <Layer_layerStateSet.part.0+0x94>
		print( NL );
    2a9c:	4812      	ldr	r0, [pc, #72]	; (2ae8 <Layer_layerStateSet.part.0+0x140>)
}
    2a9e:	b002      	add	sp, #8
    2aa0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		print( NL );
    2aa4:	f006 bcf0 	b.w	9488 <_print>
	if ( oldState && newState )
    2aa8:	2f00      	cmp	r7, #0
    2aaa:	d1dd      	bne.n	2a68 <Layer_layerStateSet.part.0+0xc0>
		Macro_layerState( layer, ScheduleType_A | (layerState << 4) );
    2aac:	0100      	lsls	r0, r0, #4
    2aae:	f040 0101 	orr.w	r1, r0, #1
    2ab2:	f001 01f1 	and.w	r1, r1, #241	; 0xf1
    2ab6:	e7dc      	b.n	2a72 <Layer_layerStateSet.part.0+0xca>
}
    2ab8:	9a01      	ldr	r2, [sp, #4]
    2aba:	6833      	ldr	r3, [r6, #0]
    2abc:	429a      	cmp	r2, r3
    2abe:	d1c2      	bne.n	2a46 <Layer_layerStateSet.part.0+0x9e>
    2ac0:	b002      	add	sp, #8
    2ac2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2ac6:	bf00      	nop
    2ac8:	1fffe9d0 	.word	0x1fffe9d0
    2acc:	1ffffcb3 	.word	0x1ffffcb3
    2ad0:	1ffff29e 	.word	0x1ffff29e
    2ad4:	1ffff29a 	.word	0x1ffff29a
    2ad8:	1ffffc2c 	.word	0x1ffffc2c
    2adc:	00009e98 	.word	0x00009e98
    2ae0:	0000d681 	.word	0x0000d681
    2ae4:	00009ea6 	.word	0x00009ea6
    2ae8:	0000d348 	.word	0x0000d348

00002aec <Layer_layerState_capability>:

// Modifies the specified Layer control byte
// Argument #1: Layer Index -> uint16_t
// Argument #2: Layer State -> uint8_t
void Layer_layerState_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    2aec:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2aee:	4d1a      	ldr	r5, [pc, #104]	; (2b58 <Layer_layerState_capability+0x6c>)
    2af0:	4608      	mov	r0, r1
    2af2:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2af4:	4611      	mov	r1, r2
{
    2af6:	682b      	ldr	r3, [r5, #0]
    2af8:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2afa:	f7ff ff15 	bl	2928 <KLL_CapabilityState>
    2afe:	462e      	mov	r6, r5

	switch ( cstate )
    2b00:	b320      	cbz	r0, 2b4c <Layer_layerState_capability+0x60>
    2b02:	2802      	cmp	r0, #2
    2b04:	d915      	bls.n	2b32 <Layer_layerState_capability+0x46>
    2b06:	28ff      	cmp	r0, #255	; 0xff
    2b08:	d120      	bne.n	2b4c <Layer_layerState_capability+0x60>
	case CapabilityState_Last:
		// Only use capability on press or release
		break;
	case CapabilityState_Debug:
		// Display capability name
		print("Layer_layerState(layerIndex,layerState)");
    2b0a:	4814      	ldr	r0, [pc, #80]	; (2b5c <Layer_layerState_capability+0x70>)
    2b0c:	f006 fcbc 	bl	9488 <_print>

		// Read arg if not set to 0
		if ( args != 0 )
    2b10:	b1e4      	cbz	r4, 2b4c <Layer_layerState_capability+0x60>
		{
			uint16_t key = *(uint16_t*)(&args[0]);
			print(" -> ");
    2b12:	4813      	ldr	r0, [pc, #76]	; (2b60 <Layer_layerState_capability+0x74>)
			uint16_t key = *(uint16_t*)(&args[0]);
    2b14:	8824      	ldrh	r4, [r4, #0]
			print(" -> ");
    2b16:	f006 fcb7 	bl	9488 <_print>
			printInt16( key );
    2b1a:	9a01      	ldr	r2, [sp, #4]
    2b1c:	682b      	ldr	r3, [r5, #0]
    2b1e:	429a      	cmp	r2, r3
    2b20:	d001      	beq.n	2b26 <Layer_layerState_capability+0x3a>

	// Get layer toggle byte
	uint8_t layerState = args[ sizeof(uint16_t) ];

	Layer_layerStateSet( trigger, state, stateType, layer, layerState );
}
    2b22:	f7fe fcff 	bl	1524 <__stack_chk_fail>
			printInt16( key );
    2b26:	4620      	mov	r0, r4
}
    2b28:	b002      	add	sp, #8
    2b2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    2b2e:	f006 bd4b 	b.w	95c8 <printInt16>
	if ( layer >= LayerNum || layer == 0 )
    2b32:	8823      	ldrh	r3, [r4, #0]
    2b34:	2b01      	cmp	r3, #1
    2b36:	d109      	bne.n	2b4c <Layer_layerState_capability+0x60>
    2b38:	9a01      	ldr	r2, [sp, #4]
    2b3a:	682b      	ldr	r3, [r5, #0]
    2b3c:	429a      	cmp	r2, r3
    2b3e:	d1f0      	bne.n	2b22 <Layer_layerState_capability+0x36>
    2b40:	78a0      	ldrb	r0, [r4, #2]
}
    2b42:	b002      	add	sp, #8
    2b44:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    2b48:	f7ff bf2e 	b.w	29a8 <Layer_layerStateSet.part.0>
    2b4c:	9a01      	ldr	r2, [sp, #4]
    2b4e:	6833      	ldr	r3, [r6, #0]
    2b50:	429a      	cmp	r2, r3
    2b52:	d1e6      	bne.n	2b22 <Layer_layerState_capability+0x36>
    2b54:	b002      	add	sp, #8
    2b56:	bd70      	pop	{r4, r5, r6, pc}
    2b58:	1fffe9d0 	.word	0x1fffe9d0
    2b5c:	00009ea9 	.word	0x00009ea9
    2b60:	00009ed1 	.word	0x00009ed1

00002b64 <Layer_layerLatch_capability>:


// Latches given layer
// Argument #1: Layer Index -> uint16_t
void Layer_layerLatch_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    2b64:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2b66:	4c19      	ldr	r4, [pc, #100]	; (2bcc <Layer_layerLatch_capability+0x68>)
    2b68:	4608      	mov	r0, r1
    2b6a:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2b6c:	4611      	mov	r1, r2
{
    2b6e:	6823      	ldr	r3, [r4, #0]
    2b70:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2b72:	f7ff fed9 	bl	2928 <KLL_CapabilityState>

	switch ( cstate )
    2b76:	2802      	cmp	r0, #2
    2b78:	4626      	mov	r6, r4
    2b7a:	d015      	beq.n	2ba8 <Layer_layerLatch_capability+0x44>
    2b7c:	28ff      	cmp	r0, #255	; 0xff
    2b7e:	d11f      	bne.n	2bc0 <Layer_layerLatch_capability+0x5c>
	case CapabilityState_Last:
		// Only use capability on release
		break;
	case CapabilityState_Debug:
		// Display capability name
		print("Layer_layerLatch(layerIndex)");
    2b80:	4813      	ldr	r0, [pc, #76]	; (2bd0 <Layer_layerLatch_capability+0x6c>)
    2b82:	f006 fc81 	bl	9488 <_print>

		// Read arg if not set to 0
		if ( args != 0 )
    2b86:	b1dd      	cbz	r5, 2bc0 <Layer_layerLatch_capability+0x5c>
		{
			uint16_t key = *(uint16_t*)(&args[0]);
			print(" -> ");
    2b88:	4812      	ldr	r0, [pc, #72]	; (2bd4 <Layer_layerLatch_capability+0x70>)
			uint16_t key = *(uint16_t*)(&args[0]);
    2b8a:	882d      	ldrh	r5, [r5, #0]
			print(" -> ");
    2b8c:	f006 fc7c 	bl	9488 <_print>
			printInt16( key );
    2b90:	9a01      	ldr	r2, [sp, #4]
    2b92:	6823      	ldr	r3, [r4, #0]
    2b94:	429a      	cmp	r2, r3
    2b96:	d001      	beq.n	2b9c <Layer_layerLatch_capability+0x38>
	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	Layer_layerStateSet( trigger, state, stateType, layer, LayerStateType_Latch );
}
    2b98:	f7fe fcc4 	bl	1524 <__stack_chk_fail>
			printInt16( key );
    2b9c:	4628      	mov	r0, r5
}
    2b9e:	b002      	add	sp, #8
    2ba0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    2ba4:	f006 bd10 	b.w	95c8 <printInt16>
	if ( layer >= LayerNum || layer == 0 )
    2ba8:	882b      	ldrh	r3, [r5, #0]
    2baa:	2b01      	cmp	r3, #1
    2bac:	d108      	bne.n	2bc0 <Layer_layerLatch_capability+0x5c>
    2bae:	9a01      	ldr	r2, [sp, #4]
    2bb0:	6823      	ldr	r3, [r4, #0]
    2bb2:	429a      	cmp	r2, r3
    2bb4:	d1f0      	bne.n	2b98 <Layer_layerLatch_capability+0x34>
}
    2bb6:	b002      	add	sp, #8
    2bb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    2bbc:	f7ff bef4 	b.w	29a8 <Layer_layerStateSet.part.0>
    2bc0:	9a01      	ldr	r2, [sp, #4]
    2bc2:	6833      	ldr	r3, [r6, #0]
    2bc4:	429a      	cmp	r2, r3
    2bc6:	d1e7      	bne.n	2b98 <Layer_layerLatch_capability+0x34>
    2bc8:	b002      	add	sp, #8
    2bca:	bd70      	pop	{r4, r5, r6, pc}
    2bcc:	1fffe9d0 	.word	0x1fffe9d0
    2bd0:	00009e26 	.word	0x00009e26
    2bd4:	00009ed1 	.word	0x00009ed1

00002bd8 <Layer_layerLock_capability>:


// Locks given layer
// Argument #1: Layer Index -> uint16_t
void Layer_layerLock_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    2bd8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2bda:	4c1a      	ldr	r4, [pc, #104]	; (2c44 <Layer_layerLock_capability+0x6c>)
    2bdc:	4608      	mov	r0, r1
    2bde:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2be0:	4611      	mov	r1, r2
{
    2be2:	6823      	ldr	r3, [r4, #0]
    2be4:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2be6:	f7ff fe9f 	bl	2928 <KLL_CapabilityState>

	switch ( cstate )
    2bea:	2801      	cmp	r0, #1
    2bec:	4626      	mov	r6, r4
    2bee:	d015      	beq.n	2c1c <Layer_layerLock_capability+0x44>
    2bf0:	28ff      	cmp	r0, #255	; 0xff
    2bf2:	d120      	bne.n	2c36 <Layer_layerLock_capability+0x5e>
	case CapabilityState_Initial:
		// Only use capability on press
		break;
	case CapabilityState_Debug:
		// Display capability name
		print("Layer_layerLock(layerIndex)");
    2bf4:	4814      	ldr	r0, [pc, #80]	; (2c48 <Layer_layerLock_capability+0x70>)
    2bf6:	f006 fc47 	bl	9488 <_print>

		// Read arg if not set to 0
		if ( args != 0 )
    2bfa:	b1e5      	cbz	r5, 2c36 <Layer_layerLock_capability+0x5e>
		{
			uint16_t key = *(uint16_t*)(&args[0]);
			print(" -> ");
    2bfc:	4813      	ldr	r0, [pc, #76]	; (2c4c <Layer_layerLock_capability+0x74>)
			uint16_t key = *(uint16_t*)(&args[0]);
    2bfe:	882d      	ldrh	r5, [r5, #0]
			print(" -> ");
    2c00:	f006 fc42 	bl	9488 <_print>
			printInt16( key );
    2c04:	9a01      	ldr	r2, [sp, #4]
    2c06:	6823      	ldr	r3, [r4, #0]
    2c08:	429a      	cmp	r2, r3
    2c0a:	d001      	beq.n	2c10 <Layer_layerLock_capability+0x38>
	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	Layer_layerStateSet( trigger, state, stateType, layer, LayerStateType_Lock );
}
    2c0c:	f7fe fc8a 	bl	1524 <__stack_chk_fail>
			printInt16( key );
    2c10:	4628      	mov	r0, r5
}
    2c12:	b002      	add	sp, #8
    2c14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    2c18:	f006 bcd6 	b.w	95c8 <printInt16>
	if ( layer >= LayerNum || layer == 0 )
    2c1c:	882b      	ldrh	r3, [r5, #0]
    2c1e:	2b01      	cmp	r3, #1
    2c20:	d109      	bne.n	2c36 <Layer_layerLock_capability+0x5e>
    2c22:	9a01      	ldr	r2, [sp, #4]
    2c24:	6823      	ldr	r3, [r4, #0]
    2c26:	429a      	cmp	r2, r3
    2c28:	d1f0      	bne.n	2c0c <Layer_layerLock_capability+0x34>
    2c2a:	2004      	movs	r0, #4
}
    2c2c:	b002      	add	sp, #8
    2c2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    2c32:	f7ff beb9 	b.w	29a8 <Layer_layerStateSet.part.0>
    2c36:	9a01      	ldr	r2, [sp, #4]
    2c38:	6833      	ldr	r3, [r6, #0]
    2c3a:	429a      	cmp	r2, r3
    2c3c:	d1e6      	bne.n	2c0c <Layer_layerLock_capability+0x34>
    2c3e:	b002      	add	sp, #8
    2c40:	bd70      	pop	{r4, r5, r6, pc}
    2c42:	bf00      	nop
    2c44:	1fffe9d0 	.word	0x1fffe9d0
    2c48:	00009e43 	.word	0x00009e43
    2c4c:	00009ed1 	.word	0x00009ed1

00002c50 <Layer_layerShift_capability>:


// Shifts given layer
// Argument #1: Layer Index -> uint16_t
void Layer_layerShift_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    2c50:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2c52:	4d22      	ldr	r5, [pc, #136]	; (2cdc <Layer_layerShift_capability+0x8c>)
    2c54:	461e      	mov	r6, r3
    2c56:	4608      	mov	r0, r1
    2c58:	682b      	ldr	r3, [r5, #0]
    2c5a:	9301      	str	r3, [sp, #4]
	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2c5c:	4611      	mov	r1, r2
	uint16_t layer = *(uint16_t*)(&args[0]);
    2c5e:	8834      	ldrh	r4, [r6, #0]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2c60:	f7ff fe62 	bl	2928 <KLL_CapabilityState>

	switch ( cstate )
    2c64:	2802      	cmp	r0, #2
    2c66:	462b      	mov	r3, r5
    2c68:	d015      	beq.n	2c96 <Layer_layerShift_capability+0x46>
    2c6a:	28ff      	cmp	r0, #255	; 0xff
    2c6c:	d01f      	beq.n	2cae <Layer_layerShift_capability+0x5e>
    2c6e:	2801      	cmp	r0, #1
    2c70:	d12e      	bne.n	2cd0 <Layer_layerShift_capability+0x80>
	{
	case CapabilityState_Initial:
		// Press
		// Only set the layer if it is disabled
		if ( (LayerState[ layer ] & LayerStateType_Shift) != LayerStateType_Off )
    2c72:	4a1b      	ldr	r2, [pc, #108]	; (2ce0 <Layer_layerShift_capability+0x90>)
    2c74:	5d12      	ldrb	r2, [r2, r4]
    2c76:	07d1      	lsls	r1, r2, #31
    2c78:	d511      	bpl.n	2c9e <Layer_layerShift_capability+0x4e>
	if ( layer >= LayerNum || layer == 0 )
    2c7a:	2c01      	cmp	r4, #1
    2c7c:	d128      	bne.n	2cd0 <Layer_layerShift_capability+0x80>
    2c7e:	9a01      	ldr	r2, [sp, #4]
    2c80:	681b      	ldr	r3, [r3, #0]
    2c82:	429a      	cmp	r2, r3
    2c84:	d001      	beq.n	2c8a <Layer_layerShift_capability+0x3a>
	default:
		return;
	}

	Layer_layerStateSet( trigger, state, stateType, layer, LayerStateType_Shift );
}
    2c86:	f7fe fc4d 	bl	1524 <__stack_chk_fail>
    2c8a:	2000      	movs	r0, #0
    2c8c:	b002      	add	sp, #8
    2c8e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    2c92:	f7ff be89 	b.w	29a8 <Layer_layerStateSet.part.0>
		if ( (LayerState[ layer ] & LayerStateType_Shift) == LayerStateType_Off )
    2c96:	4a12      	ldr	r2, [pc, #72]	; (2ce0 <Layer_layerShift_capability+0x90>)
    2c98:	5d12      	ldrb	r2, [r2, r4]
    2c9a:	07d2      	lsls	r2, r2, #31
    2c9c:	d5ed      	bpl.n	2c7a <Layer_layerShift_capability+0x2a>
	if ( layer >= LayerNum || layer == 0 )
    2c9e:	2c01      	cmp	r4, #1
    2ca0:	d116      	bne.n	2cd0 <Layer_layerShift_capability+0x80>
    2ca2:	9a01      	ldr	r2, [sp, #4]
    2ca4:	681b      	ldr	r3, [r3, #0]
    2ca6:	429a      	cmp	r2, r3
    2ca8:	d1ed      	bne.n	2c86 <Layer_layerShift_capability+0x36>
    2caa:	4620      	mov	r0, r4
    2cac:	e7ee      	b.n	2c8c <Layer_layerShift_capability+0x3c>
		print("Layer_layerShift(layerIndex)");
    2cae:	480d      	ldr	r0, [pc, #52]	; (2ce4 <Layer_layerShift_capability+0x94>)
    2cb0:	f006 fbea 	bl	9488 <_print>
			print(" -> ");
    2cb4:	480c      	ldr	r0, [pc, #48]	; (2ce8 <Layer_layerShift_capability+0x98>)
			uint16_t key = *(uint16_t*)(&args[0]);
    2cb6:	8834      	ldrh	r4, [r6, #0]
			print(" -> ");
    2cb8:	f006 fbe6 	bl	9488 <_print>
			printInt16( key );
    2cbc:	9a01      	ldr	r2, [sp, #4]
    2cbe:	682b      	ldr	r3, [r5, #0]
    2cc0:	429a      	cmp	r2, r3
    2cc2:	d1e0      	bne.n	2c86 <Layer_layerShift_capability+0x36>
    2cc4:	4620      	mov	r0, r4
}
    2cc6:	b002      	add	sp, #8
    2cc8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    2ccc:	f006 bc7c 	b.w	95c8 <printInt16>
}
    2cd0:	9a01      	ldr	r2, [sp, #4]
    2cd2:	681b      	ldr	r3, [r3, #0]
    2cd4:	429a      	cmp	r2, r3
    2cd6:	d1d6      	bne.n	2c86 <Layer_layerShift_capability+0x36>
    2cd8:	b002      	add	sp, #8
    2cda:	bd70      	pop	{r4, r5, r6, pc}
    2cdc:	1fffe9d0 	.word	0x1fffe9d0
    2ce0:	1ffffcb3 	.word	0x1ffffcb3
    2ce4:	00009e7b 	.word	0x00009e7b
    2ce8:	00009ed1 	.word	0x00009ed1

00002cec <Layer_layerRotate_capability>:

// Rotate layer to next/previous
// Uses state variable to keep track of the current layer position
// Layers are still evaluated using the layer stack
void Layer_layerRotate_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    2cec:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2cee:	4c26      	ldr	r4, [pc, #152]	; (2d88 <Layer_layerRotate_capability+0x9c>)
    2cf0:	4608      	mov	r0, r1
    2cf2:	461e      	mov	r6, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2cf4:	4611      	mov	r1, r2
{
    2cf6:	6823      	ldr	r3, [r4, #0]
    2cf8:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2cfa:	f7ff fe15 	bl	2928 <KLL_CapabilityState>

	switch ( cstate )
    2cfe:	2801      	cmp	r0, #1
    2d00:	4625      	mov	r5, r4
    2d02:	d016      	beq.n	2d32 <Layer_layerRotate_capability+0x46>
    2d04:	28ff      	cmp	r0, #255	; 0xff
    2d06:	d138      	bne.n	2d7a <Layer_layerRotate_capability+0x8e>
	case CapabilityState_Initial:
		// Only use capability on press
		break;
	case CapabilityState_Debug:
		// Display capability name
		print("Layer_layerRotate(previous)");
    2d08:	4820      	ldr	r0, [pc, #128]	; (2d8c <Layer_layerRotate_capability+0xa0>)
    2d0a:	f006 fbbd 	bl	9488 <_print>

		// Read arg if not set to 0
		if ( args != 0 )
    2d0e:	2e00      	cmp	r6, #0
    2d10:	d033      	beq.n	2d7a <Layer_layerRotate_capability+0x8e>
		{
			uint8_t key = args[0];
			print(" -> ");
    2d12:	481f      	ldr	r0, [pc, #124]	; (2d90 <Layer_layerRotate_capability+0xa4>)
			uint8_t key = args[0];
    2d14:	7835      	ldrb	r5, [r6, #0]
			print(" -> ");
    2d16:	f006 fbb7 	bl	9488 <_print>
			printInt8( key );
    2d1a:	9a01      	ldr	r2, [sp, #4]
    2d1c:	6823      	ldr	r3, [r4, #0]
    2d1e:	429a      	cmp	r2, r3
    2d20:	d001      	beq.n	2d26 <Layer_layerRotate_capability+0x3a>
			Layer_rotationLayer = LayerNum - 1;
	}

	// Toggle the computed layer rotation
	Layer_layerStateSet( trigger, state, stateType, Layer_rotationLayer, LayerStateType_Lock );
}
    2d22:	f7fe fbff 	bl	1524 <__stack_chk_fail>
			printInt8( key );
    2d26:	4628      	mov	r0, r5
}
    2d28:	b002      	add	sp, #8
    2d2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt8( key );
    2d2e:	f006 bc15 	b.w	955c <printInt8>
	if ( Layer_rotationLayer != 0 )
    2d32:	4c18      	ldr	r4, [pc, #96]	; (2d94 <Layer_layerRotate_capability+0xa8>)
	if ( layer >= LayerNum || layer == 0 )
    2d34:	8823      	ldrh	r3, [r4, #0]
    2d36:	2b01      	cmp	r3, #1
    2d38:	d102      	bne.n	2d40 <Layer_layerRotate_capability+0x54>
    2d3a:	2004      	movs	r0, #4
    2d3c:	f7ff fe34 	bl	29a8 <Layer_layerStateSet.part.0>
	if ( !direction )
    2d40:	7832      	ldrb	r2, [r6, #0]
    2d42:	8823      	ldrh	r3, [r4, #0]
    2d44:	b99a      	cbnz	r2, 2d6e <Layer_layerRotate_capability+0x82>
		Layer_rotationLayer++;
    2d46:	3301      	adds	r3, #1
    2d48:	b29b      	uxth	r3, r3
		if ( Layer_rotationLayer >= LayerNum )
    2d4a:	2b01      	cmp	r3, #1
    2d4c:	d801      	bhi.n	2d52 <Layer_layerRotate_capability+0x66>
			Layer_rotationLayer = LayerNum - 1;
    2d4e:	8023      	strh	r3, [r4, #0]
    2d50:	e000      	b.n	2d54 <Layer_layerRotate_capability+0x68>
			Layer_rotationLayer = 0;
    2d52:	8022      	strh	r2, [r4, #0]
	if ( layer >= LayerNum || layer == 0 )
    2d54:	8823      	ldrh	r3, [r4, #0]
    2d56:	2b01      	cmp	r3, #1
    2d58:	d10f      	bne.n	2d7a <Layer_layerRotate_capability+0x8e>
    2d5a:	9a01      	ldr	r2, [sp, #4]
    2d5c:	682b      	ldr	r3, [r5, #0]
    2d5e:	429a      	cmp	r2, r3
    2d60:	d1df      	bne.n	2d22 <Layer_layerRotate_capability+0x36>
    2d62:	2004      	movs	r0, #4
}
    2d64:	b002      	add	sp, #8
    2d66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    2d6a:	f7ff be1d 	b.w	29a8 <Layer_layerStateSet.part.0>
		Layer_rotationLayer--;
    2d6e:	3b01      	subs	r3, #1
    2d70:	b29b      	uxth	r3, r3
		if ( Layer_rotationLayer >= LayerNum )
    2d72:	2b01      	cmp	r3, #1
			Layer_rotationLayer = LayerNum - 1;
    2d74:	bf88      	it	hi
    2d76:	2301      	movhi	r3, #1
    2d78:	e7e9      	b.n	2d4e <Layer_layerRotate_capability+0x62>
}
    2d7a:	9a01      	ldr	r2, [sp, #4]
    2d7c:	682b      	ldr	r3, [r5, #0]
    2d7e:	429a      	cmp	r2, r3
    2d80:	d1cf      	bne.n	2d22 <Layer_layerRotate_capability+0x36>
    2d82:	b002      	add	sp, #8
    2d84:	bd70      	pop	{r4, r5, r6, pc}
    2d86:	bf00      	nop
    2d88:	1fffe9d0 	.word	0x1fffe9d0
    2d8c:	00009e5f 	.word	0x00009e5f
    2d90:	00009ed1 	.word	0x00009ed1
    2d94:	1ffffc2a 	.word	0x1ffffc2a

00002d98 <Layer_clearLayers>:

// ----- Functions -----

// Clears the current layer state
void Layer_clearLayers()
{
    2d98:	b507      	push	{r0, r1, r2, lr}
    2d9a:	4b09      	ldr	r3, [pc, #36]	; (2dc0 <Layer_clearLayers+0x28>)
    2d9c:	681a      	ldr	r2, [r3, #0]
    2d9e:	9201      	str	r2, [sp, #4]
	// Clear layer stack
	macroLayerIndexStackSize = 0;
    2da0:	4a08      	ldr	r2, [pc, #32]	; (2dc4 <Layer_clearLayers+0x2c>)
    2da2:	2100      	movs	r1, #0
    2da4:	8011      	strh	r1, [r2, #0]

	// Clear layer states
	memset( &LayerState, 0, sizeof(LayerStateType) * LayerNum );
    2da6:	9a01      	ldr	r2, [sp, #4]
    2da8:	681b      	ldr	r3, [r3, #0]
    2daa:	429a      	cmp	r2, r3
    2dac:	d001      	beq.n	2db2 <Layer_clearLayers+0x1a>
    2dae:	f7fe fbb9 	bl	1524 <__stack_chk_fail>
    2db2:	4805      	ldr	r0, [pc, #20]	; (2dc8 <Layer_clearLayers+0x30>)
    2db4:	2202      	movs	r2, #2
}
    2db6:	b003      	add	sp, #12
    2db8:	f85d eb04 	ldr.w	lr, [sp], #4
	memset( &LayerState, 0, sizeof(LayerStateType) * LayerNum );
    2dbc:	f7fe bbc0 	b.w	1540 <memset>
    2dc0:	1fffe9d0 	.word	0x1fffe9d0
    2dc4:	1ffff29e 	.word	0x1ffff29e
    2dc8:	1ffffcb3 	.word	0x1ffffcb3

00002dcc <Layer_setup>:


// Setup layers
void Layer_setup()
{
    2dcc:	b513      	push	{r0, r1, r4, lr}
    2dce:	4c09      	ldr	r4, [pc, #36]	; (2df4 <Layer_setup+0x28>)
    2dd0:	6823      	ldr	r3, [r4, #0]
    2dd2:	9301      	str	r3, [sp, #4]
	// Cleanup layers
	Layer_clearLayers();
    2dd4:	f7ff ffe0 	bl	2d98 <Layer_clearLayers>

	// Set the current rotated layer to 0
	Layer_rotationLayer = 0;
    2dd8:	4a07      	ldr	r2, [pc, #28]	; (2df8 <Layer_setup+0x2c>)
    2dda:	2300      	movs	r3, #0
    2ddc:	8013      	strh	r3, [r2, #0]

	// Layer debug mode
	layerDebugMode = 0;
    2dde:	4a07      	ldr	r2, [pc, #28]	; (2dfc <Layer_setup+0x30>)
    2de0:	7013      	strb	r3, [r2, #0]
}
    2de2:	9a01      	ldr	r2, [sp, #4]
    2de4:	6823      	ldr	r3, [r4, #0]
    2de6:	429a      	cmp	r2, r3
    2de8:	d001      	beq.n	2dee <Layer_setup+0x22>
    2dea:	f7fe fb9b 	bl	1524 <__stack_chk_fail>
    2dee:	b002      	add	sp, #8
    2df0:	bd10      	pop	{r4, pc}
    2df2:	bf00      	nop
    2df4:	1fffe9d0 	.word	0x1fffe9d0
    2df8:	1ffffc2a 	.word	0x1ffffc2a
    2dfc:	1ffffc2c 	.word	0x1ffffc2c

00002e00 <Layer_layerLookup>:


// Looks up the trigger list for the given scan code (from the active layer)
// NOTE: Calling function must handle the NULL pointer case
nat_ptr_t *Layer_layerLookup( TriggerEvent *event, uint8_t latch_expire )
{
    2e00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e04:	4f46      	ldr	r7, [pc, #280]	; (2f20 <Layer_layerLookup+0x120>)
	uint8_t index = event->index;
    2e06:	7885      	ldrb	r5, [r0, #2]
{
    2e08:	683b      	ldr	r3, [r7, #0]
    2e0a:	b085      	sub	sp, #20
    2e0c:	4680      	mov	r8, r0
    2e0e:	4689      	mov	r9, r1

	// Cached Lookup (for handling layer latches)
	uint8_t cache_lookup = 0;
	CapabilityState cstate = KLL_CapabilityState( event->state, event->type );
    2e10:	7801      	ldrb	r1, [r0, #0]
    2e12:	7840      	ldrb	r0, [r0, #1]
{
    2e14:	9303      	str	r3, [sp, #12]
	CapabilityState cstate = KLL_CapabilityState( event->state, event->type );
    2e16:	f7ff fd87 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    2e1a:	3802      	subs	r0, #2
    2e1c:	2801      	cmp	r0, #1
    2e1e:	d816      	bhi.n	2e4e <Layer_layerLookup+0x4e>

	// Do a cached lookup if necessary
	if ( cache_lookup )
	{
		// Cached layer
		var_uint_t cachedLayer = macroTriggerEventLayerCache[ index ];
    2e20:	4b40      	ldr	r3, [pc, #256]	; (2f24 <Layer_layerLookup+0x124>)

		// Lookup map, then layer
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    2e22:	4841      	ldr	r0, [pc, #260]	; (2f28 <Layer_layerLookup+0x128>)
		var_uint_t cachedLayer = macroTriggerEventLayerCache[ index ];
    2e24:	f833 2015 	ldrh.w	r2, [r3, r5, lsl #1]
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    2e28:	230c      	movs	r3, #12
    2e2a:	4353      	muls	r3, r2
    2e2c:	18c1      	adds	r1, r0, r3
		const Layer *layer = &LayerIndex[ cachedLayer ];

		// Cache trigger list before attempting to expire latch
		nat_ptr_t *trigger_list = map[ index - layer->first ];
    2e2e:	58c3      	ldr	r3, [r0, r3]
    2e30:	7a09      	ldrb	r1, [r1, #8]
    2e32:	1a6d      	subs	r5, r5, r1
    2e34:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]

		// Check if latch has been pressed for this layer
		uint8_t latch = LayerState[ cachedLayer ] & LayerStateType_Latch;
    2e38:	4b3c      	ldr	r3, [pc, #240]	; (2f2c <Layer_layerLookup+0x12c>)
    2e3a:	5c9b      	ldrb	r3, [r3, r2]
		if ( latch && latch_expire )
    2e3c:	079b      	lsls	r3, r3, #30
    2e3e:	d421      	bmi.n	2e84 <Layer_layerLookup+0x84>
	}

	// Otherwise no defined Trigger Macro
	// Just ignore it
	return 0;
}
    2e40:	9a03      	ldr	r2, [sp, #12]
    2e42:	683b      	ldr	r3, [r7, #0]
    2e44:	429a      	cmp	r2, r3
    2e46:	4620      	mov	r0, r4
    2e48:	d067      	beq.n	2f1a <Layer_layerLookup+0x11a>
    2e4a:	f7fe fb6b 	bl	1524 <__stack_chk_fail>
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    2e4e:	4b38      	ldr	r3, [pc, #224]	; (2f30 <Layer_layerLookup+0x130>)
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    2e50:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 2f34 <Layer_layerLookup+0x134>
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    2e54:	881e      	ldrh	r6, [r3, #0]
    2e56:	f64f 73ff 	movw	r3, #65535	; 0xffff
    2e5a:	429e      	cmp	r6, r3
    2e5c:	d11b      	bne.n	2e96 <Layer_layerLookup+0x96>
	nat_ptr_t **map = (nat_ptr_t**)LayerIndex[0].triggerMap;
    2e5e:	4b32      	ldr	r3, [pc, #200]	; (2f28 <Layer_layerLookup+0x128>)
    2e60:	681c      	ldr	r4, [r3, #0]
	if ( map != 0
    2e62:	2c00      	cmp	r4, #0
    2e64:	d0ec      	beq.n	2e40 <Layer_layerLookup+0x40>
		&& index <= layer->last
    2e66:	7a5a      	ldrb	r2, [r3, #9]
    2e68:	42aa      	cmp	r2, r5
    2e6a:	d352      	bcc.n	2f12 <Layer_layerLookup+0x112>
		&& index >= layer->first
    2e6c:	7a1b      	ldrb	r3, [r3, #8]
    2e6e:	42ab      	cmp	r3, r5
    2e70:	d84f      	bhi.n	2f12 <Layer_layerLookup+0x112>
		&& *map[ index - layer->first ] != 0 )
    2e72:	1aeb      	subs	r3, r5, r3
    2e74:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
    2e78:	6823      	ldr	r3, [r4, #0]
    2e7a:	2b00      	cmp	r3, #0
    2e7c:	d04b      	beq.n	2f16 <Layer_layerLookup+0x116>
		macroTriggerEventLayerCache[ index ] = 0;
    2e7e:	4b29      	ldr	r3, [pc, #164]	; (2f24 <Layer_layerLookup+0x124>)
    2e80:	2200      	movs	r2, #0
    2e82:	e03f      	b.n	2f04 <Layer_layerLookup+0x104>
		if ( latch && latch_expire )
    2e84:	f1b9 0f00 	cmp.w	r9, #0
    2e88:	d0da      	beq.n	2e40 <Layer_layerLookup+0x40>
	if ( layer >= LayerNum || layer == 0 )
    2e8a:	2a01      	cmp	r2, #1
    2e8c:	d1d8      	bne.n	2e40 <Layer_layerLookup+0x40>
    2e8e:	2002      	movs	r0, #2
    2e90:	f7ff fd8a 	bl	29a8 <Layer_layerStateSet.part.0>
    2e94:	e7d4      	b.n	2e40 <Layer_layerLookup+0x40>
		switch ( event->type )
    2e96:	f898 3000 	ldrb.w	r3, [r8]
    2e9a:	3b09      	subs	r3, #9
    2e9c:	2b03      	cmp	r3, #3
    2e9e:	d934      	bls.n	2f0a <Layer_layerLookup+0x10a>
		uint8_t shift = LayerState[ macroLayerIndexStack[ layerIndex ] ] & LayerStateType_Shift;
    2ea0:	4b22      	ldr	r3, [pc, #136]	; (2f2c <Layer_layerLookup+0x12c>)
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    2ea2:	f83a b016 	ldrh.w	fp, [sl, r6, lsl #1]
		uint8_t shift = LayerState[ macroLayerIndexStack[ layerIndex ] ] & LayerStateType_Shift;
    2ea6:	f813 400b 	ldrb.w	r4, [r3, fp]
		if ( latch && latch_expire )
    2eaa:	f014 0102 	ands.w	r1, r4, #2
		uint8_t shift = LayerState[ macroLayerIndexStack[ layerIndex ] ] & LayerStateType_Shift;
    2eae:	f004 0301 	and.w	r3, r4, #1
		if ( latch && latch_expire )
    2eb2:	d00c      	beq.n	2ece <Layer_layerLookup+0xce>
    2eb4:	f1b9 0f00 	cmp.w	r9, #0
    2eb8:	d009      	beq.n	2ece <Layer_layerLookup+0xce>
	if ( layer >= LayerNum || layer == 0 )
    2eba:	f1bb 0f01 	cmp.w	fp, #1
    2ebe:	d106      	bne.n	2ece <Layer_layerLookup+0xce>
    2ec0:	2002      	movs	r0, #2
    2ec2:	e9cd 3100 	strd	r3, r1, [sp]
    2ec6:	f7ff fd6f 	bl	29a8 <Layer_layerStateSet.part.0>
    2eca:	e9dd 3100 	ldrd	r3, r1, [sp]
		if ( (shift) ^ (latch>>1) ^ (lock>>2) )
    2ece:	ea83 0351 	eor.w	r3, r3, r1, lsr #1
    2ed2:	f3c4 0480 	ubfx	r4, r4, #2, #1
    2ed6:	42a3      	cmp	r3, r4
    2ed8:	d018      	beq.n	2f0c <Layer_layerLookup+0x10c>
			nat_ptr_t **map = (nat_ptr_t**)layer->triggerMap;
    2eda:	230c      	movs	r3, #12
    2edc:	4812      	ldr	r0, [pc, #72]	; (2f28 <Layer_layerLookup+0x128>)
    2ede:	fb03 f30b 	mul.w	r3, r3, fp
    2ee2:	18c1      	adds	r1, r0, r3
    2ee4:	58c2      	ldr	r2, [r0, r3]
			if ( map != 0
    2ee6:	b18a      	cbz	r2, 2f0c <Layer_layerLookup+0x10c>
				&& index <= layer->last
    2ee8:	7a4b      	ldrb	r3, [r1, #9]
    2eea:	42ab      	cmp	r3, r5
    2eec:	d30e      	bcc.n	2f0c <Layer_layerLookup+0x10c>
				&& index >= layer->first
    2eee:	7a0b      	ldrb	r3, [r1, #8]
    2ef0:	42ab      	cmp	r3, r5
    2ef2:	d80b      	bhi.n	2f0c <Layer_layerLookup+0x10c>
				&& *map[ index - layer->first ] != 0 )
    2ef4:	1aeb      	subs	r3, r5, r3
    2ef6:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    2efa:	6823      	ldr	r3, [r4, #0]
    2efc:	b133      	cbz	r3, 2f0c <Layer_layerLookup+0x10c>
				macroTriggerEventLayerCache[ index ] = macroLayerIndexStack[ layerIndex ];
    2efe:	f83a 2016 	ldrh.w	r2, [sl, r6, lsl #1]
    2f02:	4b08      	ldr	r3, [pc, #32]	; (2f24 <Layer_layerLookup+0x124>)
		macroTriggerEventLayerCache[ index ] = 0;
    2f04:	f823 2015 	strh.w	r2, [r3, r5, lsl #1]
		return map[ index - layer->first ];
    2f08:	e79a      	b.n	2e40 <Layer_layerLookup+0x40>
			layerIndex = 0;
    2f0a:	2600      	movs	r6, #0
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    2f0c:	3e01      	subs	r6, #1
    2f0e:	b2b6      	uxth	r6, r6
    2f10:	e7a1      	b.n	2e56 <Layer_layerLookup+0x56>
	return 0;
    2f12:	2400      	movs	r4, #0
    2f14:	e794      	b.n	2e40 <Layer_layerLookup+0x40>
    2f16:	461c      	mov	r4, r3
    2f18:	e792      	b.n	2e40 <Layer_layerLookup+0x40>
}
    2f1a:	b005      	add	sp, #20
    2f1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2f20:	1fffe9d0 	.word	0x1fffe9d0
    2f24:	1ffffc2e 	.word	0x1ffffc2e
    2f28:	00009f70 	.word	0x00009f70
    2f2c:	1ffffcb3 	.word	0x1ffffcb3
    2f30:	1ffff29e 	.word	0x1ffff29e
    2f34:	1ffff29a 	.word	0x1ffff29a

00002f38 <Macro_none_capability>:
	Macro_rotationState( index, increment );
}

// No-op capability (None)
void Macro_none_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    2f38:	b513      	push	{r0, r1, r4, lr}
    2f3a:	4c0c      	ldr	r4, [pc, #48]	; (2f6c <Macro_none_capability+0x34>)
    2f3c:	4608      	mov	r0, r1
    2f3e:	6823      	ldr	r3, [r4, #0]
    2f40:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    2f42:	4611      	mov	r1, r2
    2f44:	f7ff fcf0 	bl	2928 <KLL_CapabilityState>

	switch ( cstate )
    2f48:	28ff      	cmp	r0, #255	; 0xff
	{
	case CapabilityState_Debug:
		// Display capability name
		print("Macro_none()");
    2f4a:	9a01      	ldr	r2, [sp, #4]
    2f4c:	6823      	ldr	r3, [r4, #0]
	switch ( cstate )
    2f4e:	d109      	bne.n	2f64 <Macro_none_capability+0x2c>
		print("Macro_none()");
    2f50:	429a      	cmp	r2, r3
    2f52:	d001      	beq.n	2f58 <Macro_none_capability+0x20>
		return;
	default:
		break;
	}

}
    2f54:	f7fe fae6 	bl	1524 <__stack_chk_fail>
		print("Macro_none()");
    2f58:	4805      	ldr	r0, [pc, #20]	; (2f70 <Macro_none_capability+0x38>)
}
    2f5a:	b002      	add	sp, #8
    2f5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		print("Macro_none()");
    2f60:	f006 ba92 	b.w	9488 <_print>
}
    2f64:	429a      	cmp	r2, r3
    2f66:	d1f5      	bne.n	2f54 <Macro_none_capability+0x1c>
    2f68:	b002      	add	sp, #8
    2f6a:	bd10      	pop	{r4, pc}
    2f6c:	1fffe9d0 	.word	0x1fffe9d0
    2f70:	0000a002 	.word	0x0000a002

00002f74 <cliFunc_posList>:
	printInt16( Key_Position[ key ].name.i ); \
	print("."); \
	printInt16( Key_Position[ key ].name.f )

void cliFunc_posList( char* args )
{
    2f74:	b507      	push	{r0, r1, r2, lr}
    2f76:	4b07      	ldr	r3, [pc, #28]	; (2f94 <cliFunc_posList+0x20>)
    2f78:	681a      	ldr	r2, [r3, #0]
    2f7a:	9201      	str	r2, [sp, #4]
	print( NL );
    2f7c:	9a01      	ldr	r2, [sp, #4]
    2f7e:	681b      	ldr	r3, [r3, #0]
    2f80:	429a      	cmp	r2, r3
    2f82:	d001      	beq.n	2f88 <cliFunc_posList+0x14>
    2f84:	f7fe face 	bl	1524 <__stack_chk_fail>
    2f88:	4803      	ldr	r0, [pc, #12]	; (2f98 <cliFunc_posList+0x24>)
		Key_PositionPrint( key, rz );
		print("]");
		print( NL );
	}
	*/
}
    2f8a:	b003      	add	sp, #12
    2f8c:	f85d eb04 	ldr.w	lr, [sp], #4
	print( NL );
    2f90:	f006 ba7a 	b.w	9488 <_print>
    2f94:	1fffe9d0 	.word	0x1fffe9d0
    2f98:	0000d348 	.word	0x0000d348

00002f9c <cliFunc_capDebug>:
{
    2f9c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2f9e:	4d0d      	ldr	r5, [pc, #52]	; (2fd4 <cliFunc_capDebug+0x38>)
	capDebugMode = capDebugMode ? 0 : 1;
    2fa0:	4c0d      	ldr	r4, [pc, #52]	; (2fd8 <cliFunc_capDebug+0x3c>)
{
    2fa2:	682b      	ldr	r3, [r5, #0]
    2fa4:	9301      	str	r3, [sp, #4]
	capDebugMode = capDebugMode ? 0 : 1;
    2fa6:	7823      	ldrb	r3, [r4, #0]
	print( NL );
    2fa8:	480c      	ldr	r0, [pc, #48]	; (2fdc <cliFunc_capDebug+0x40>)
	capDebugMode = capDebugMode ? 0 : 1;
    2faa:	fab3 f383 	clz	r3, r3
    2fae:	095b      	lsrs	r3, r3, #5
    2fb0:	7023      	strb	r3, [r4, #0]
	print( NL );
    2fb2:	f006 fa69 	bl	9488 <_print>
	info_msg("Capability Debug Mode: ");
    2fb6:	480a      	ldr	r0, [pc, #40]	; (2fe0 <cliFunc_capDebug+0x44>)
    2fb8:	f006 fa66 	bl	9488 <_print>
	printInt8( capDebugMode );
    2fbc:	9a01      	ldr	r2, [sp, #4]
    2fbe:	682b      	ldr	r3, [r5, #0]
    2fc0:	429a      	cmp	r2, r3
    2fc2:	d001      	beq.n	2fc8 <cliFunc_capDebug+0x2c>
    2fc4:	f7fe faae 	bl	1524 <__stack_chk_fail>
    2fc8:	7820      	ldrb	r0, [r4, #0]
}
    2fca:	b003      	add	sp, #12
    2fcc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt8( capDebugMode );
    2fd0:	f006 bac4 	b.w	955c <printInt8>
    2fd4:	1fffe9d0 	.word	0x1fffe9d0
    2fd8:	200000f0 	.word	0x200000f0
    2fdc:	0000d348 	.word	0x0000d348
    2fe0:	0000a78f 	.word	0x0000a78f

00002fe4 <cliFunc_layerDebug>:
{
    2fe4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2fe6:	4d0d      	ldr	r5, [pc, #52]	; (301c <cliFunc_layerDebug+0x38>)
	layerDebugMode = layerDebugMode ? 0 : 1;
    2fe8:	4c0d      	ldr	r4, [pc, #52]	; (3020 <cliFunc_layerDebug+0x3c>)
{
    2fea:	682b      	ldr	r3, [r5, #0]
    2fec:	9301      	str	r3, [sp, #4]
	layerDebugMode = layerDebugMode ? 0 : 1;
    2fee:	7823      	ldrb	r3, [r4, #0]
	print( NL );
    2ff0:	480c      	ldr	r0, [pc, #48]	; (3024 <cliFunc_layerDebug+0x40>)
	layerDebugMode = layerDebugMode ? 0 : 1;
    2ff2:	fab3 f383 	clz	r3, r3
    2ff6:	095b      	lsrs	r3, r3, #5
    2ff8:	7023      	strb	r3, [r4, #0]
	print( NL );
    2ffa:	f006 fa45 	bl	9488 <_print>
	info_msg("Layer Debug Mode: ");
    2ffe:	480a      	ldr	r0, [pc, #40]	; (3028 <cliFunc_layerDebug+0x44>)
    3000:	f006 fa42 	bl	9488 <_print>
	printInt8( layerDebugMode );
    3004:	9a01      	ldr	r2, [sp, #4]
    3006:	682b      	ldr	r3, [r5, #0]
    3008:	429a      	cmp	r2, r3
    300a:	d001      	beq.n	3010 <cliFunc_layerDebug+0x2c>
    300c:	f7fe fa8a 	bl	1524 <__stack_chk_fail>
    3010:	7820      	ldrb	r0, [r4, #0]
}
    3012:	b003      	add	sp, #12
    3014:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt8( layerDebugMode );
    3018:	f006 baa0 	b.w	955c <printInt8>
    301c:	1fffe9d0 	.word	0x1fffe9d0
    3020:	1ffffc2c 	.word	0x1ffffc2c
    3024:	0000d348 	.word	0x0000d348
    3028:	0000a88c 	.word	0x0000a88c

0000302c <cliFunc_macroProc>:
{
    302c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    302e:	4d0d      	ldr	r5, [pc, #52]	; (3064 <cliFunc_macroProc+0x38>)
	macroPauseMode = macroPauseMode ? 0 : 1;
    3030:	4c0d      	ldr	r4, [pc, #52]	; (3068 <cliFunc_macroProc+0x3c>)
{
    3032:	682b      	ldr	r3, [r5, #0]
    3034:	9301      	str	r3, [sp, #4]
	macroPauseMode = macroPauseMode ? 0 : 1;
    3036:	7823      	ldrb	r3, [r4, #0]
	print( NL );
    3038:	480c      	ldr	r0, [pc, #48]	; (306c <cliFunc_macroProc+0x40>)
	macroPauseMode = macroPauseMode ? 0 : 1;
    303a:	fab3 f383 	clz	r3, r3
    303e:	095b      	lsrs	r3, r3, #5
    3040:	7023      	strb	r3, [r4, #0]
	print( NL );
    3042:	f006 fa21 	bl	9488 <_print>
	info_msg("Macro Processing Mode: ");
    3046:	480a      	ldr	r0, [pc, #40]	; (3070 <cliFunc_macroProc+0x44>)
    3048:	f006 fa1e 	bl	9488 <_print>
	printInt8( macroPauseMode );
    304c:	9a01      	ldr	r2, [sp, #4]
    304e:	682b      	ldr	r3, [r5, #0]
    3050:	429a      	cmp	r2, r3
    3052:	d001      	beq.n	3058 <cliFunc_macroProc+0x2c>
    3054:	f7fe fa66 	bl	1524 <__stack_chk_fail>
    3058:	7820      	ldrb	r0, [r4, #0]
}
    305a:	b003      	add	sp, #12
    305c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt8( macroPauseMode );
    3060:	f006 ba7c 	b.w	955c <printInt8>
    3064:	1fffe9d0 	.word	0x1fffe9d0
    3068:	1ffffcaf 	.word	0x1ffffcaf
    306c:	0000d348 	.word	0x0000d348
    3070:	0000b12b 	.word	0x0000b12b

00003074 <cliFunc_capList>:
{
    3074:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    3078:	4d18      	ldr	r5, [pc, #96]	; (30dc <cliFunc_capList+0x68>)
	print( NL );
    307a:	4819      	ldr	r0, [pc, #100]	; (30e0 <cliFunc_capList+0x6c>)
{
    307c:	682b      	ldr	r3, [r5, #0]
    307e:	9301      	str	r3, [sp, #4]
	print( NL );
    3080:	f006 fa02 	bl	9488 <_print>
	info_msg("Capabilities List ");
    3084:	4817      	ldr	r0, [pc, #92]	; (30e4 <cliFunc_capList+0x70>)
		print( NL "\t" );
    3086:	f8df 9068 	ldr.w	r9, [pc, #104]	; 30f0 <cliFunc_capList+0x7c>
		print(" - ");
    308a:	4e17      	ldr	r6, [pc, #92]	; (30e8 <cliFunc_capList+0x74>)
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
    308c:	4f17      	ldr	r7, [pc, #92]	; (30ec <cliFunc_capList+0x78>)
	info_msg("Capabilities List ");
    308e:	f006 f9fb 	bl	9488 <_print>
	printHex( CapabilitiesNum );
    3092:	2101      	movs	r1, #1
    3094:	2013      	movs	r0, #19
    3096:	f006 fb1d 	bl	96d4 <printHex_op>
    309a:	2400      	movs	r4, #0
    309c:	46a8      	mov	r8, r5
		print( NL "\t" );
    309e:	4648      	mov	r0, r9
    30a0:	f006 f9f2 	bl	9488 <_print>
		printHex( cap );
    30a4:	2101      	movs	r1, #1
    30a6:	b2a0      	uxth	r0, r4
    30a8:	f006 fb14 	bl	96d4 <printHex_op>
		print(" - ");
    30ac:	4630      	mov	r0, r6
    30ae:	f006 f9eb 	bl	9488 <_print>
		capability( 0, 0xFF, 0xFF, 0 );
    30b2:	2300      	movs	r3, #0
    30b4:	22ff      	movs	r2, #255	; 0xff
    30b6:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
    30ba:	4611      	mov	r1, r2
    30bc:	4618      	mov	r0, r3
    30be:	3401      	adds	r4, #1
    30c0:	47a8      	blx	r5
	for ( var_uint_t cap = 0; cap < CapabilitiesNum; cap++ )
    30c2:	2c13      	cmp	r4, #19
    30c4:	d1eb      	bne.n	309e <cliFunc_capList+0x2a>
}
    30c6:	9a01      	ldr	r2, [sp, #4]
    30c8:	f8d8 3000 	ldr.w	r3, [r8]
    30cc:	429a      	cmp	r2, r3
    30ce:	d001      	beq.n	30d4 <cliFunc_capList+0x60>
    30d0:	f7fe fa28 	bl	1524 <__stack_chk_fail>
    30d4:	b003      	add	sp, #12
    30d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    30da:	bf00      	nop
    30dc:	1fffe9d0 	.word	0x1fffe9d0
    30e0:	0000d348 	.word	0x0000d348
    30e4:	0000a7b9 	.word	0x0000a7b9
    30e8:	0000cc04 	.word	0x0000cc04
    30ec:	00009ed8 	.word	0x00009ed8
    30f0:	0000a7de 	.word	0x0000a7de

000030f4 <cliFunc_macroList>:
{
    30f4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    30f8:	4c54      	ldr	r4, [pc, #336]	; (324c <cliFunc_macroList+0x158>)
	print( NL );
    30fa:	4855      	ldr	r0, [pc, #340]	; (3250 <cliFunc_macroList+0x15c>)
{
    30fc:	6823      	ldr	r3, [r4, #0]
	printInt16( (uint16_t)macroTriggerEventBufferSize );
    30fe:	4d55      	ldr	r5, [pc, #340]	; (3254 <cliFunc_macroList+0x160>)
{
    3100:	9301      	str	r3, [sp, #4]
	print( NL );
    3102:	f006 f9c1 	bl	9488 <_print>
	info_msg("Pending Key Events: ");
    3106:	4854      	ldr	r0, [pc, #336]	; (3258 <cliFunc_macroList+0x164>)
		printHex( macroTriggerEventBuffer[ key ].index );
    3108:	f8df 8180 	ldr.w	r8, [pc, #384]	; 328c <cliFunc_macroList+0x198>
		print(" ");
    310c:	4e53      	ldr	r6, [pc, #332]	; (325c <cliFunc_macroList+0x168>)
	info_msg("Pending Key Events: ");
    310e:	f006 f9bb 	bl	9488 <_print>
	printInt16( (uint16_t)macroTriggerEventBufferSize );
    3112:	8828      	ldrh	r0, [r5, #0]
    3114:	f006 fa58 	bl	95c8 <printInt16>
	print(" : ");
    3118:	4851      	ldr	r0, [pc, #324]	; (3260 <cliFunc_macroList+0x16c>)
    311a:	f006 f9b5 	bl	9488 <_print>
	for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    311e:	2300      	movs	r3, #0
    3120:	8829      	ldrh	r1, [r5, #0]
    3122:	b29a      	uxth	r2, r3
    3124:	4291      	cmp	r1, r2
    3126:	f103 0701 	add.w	r7, r3, #1
    312a:	d867      	bhi.n	31fc <cliFunc_macroList+0x108>
	print( NL );
    312c:	4848      	ldr	r0, [pc, #288]	; (3250 <cliFunc_macroList+0x15c>)
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    312e:	4d4d      	ldr	r5, [pc, #308]	; (3264 <cliFunc_macroList+0x170>)
		printHex( macroTriggerMacroPendingList[ macro ] );
    3130:	f8df 815c 	ldr.w	r8, [pc, #348]	; 3290 <cliFunc_macroList+0x19c>
		print(" ");
    3134:	4f49      	ldr	r7, [pc, #292]	; (325c <cliFunc_macroList+0x168>)
	print( NL );
    3136:	f006 f9a7 	bl	9488 <_print>
	info_msg("Pending Trigger Macros: ");
    313a:	484b      	ldr	r0, [pc, #300]	; (3268 <cliFunc_macroList+0x174>)
    313c:	f006 f9a4 	bl	9488 <_print>
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    3140:	8828      	ldrh	r0, [r5, #0]
    3142:	f006 fa41 	bl	95c8 <printInt16>
	print(" : ");
    3146:	4846      	ldr	r0, [pc, #280]	; (3260 <cliFunc_macroList+0x16c>)
    3148:	f006 f99e 	bl	9488 <_print>
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    314c:	2300      	movs	r3, #0
    314e:	8829      	ldrh	r1, [r5, #0]
    3150:	b29a      	uxth	r2, r3
    3152:	4291      	cmp	r1, r2
    3154:	f103 0601 	add.w	r6, r3, #1
    3158:	d85d      	bhi.n	3216 <cliFunc_macroList+0x122>
	print( NL );
    315a:	483d      	ldr	r0, [pc, #244]	; (3250 <cliFunc_macroList+0x15c>)
	printInt16( (uint16_t)macroResultMacroPendingList.size );
    315c:	4d43      	ldr	r5, [pc, #268]	; (326c <cliFunc_macroList+0x178>)
		print(" ");
    315e:	4e3f      	ldr	r6, [pc, #252]	; (325c <cliFunc_macroList+0x168>)
	print( NL );
    3160:	f006 f992 	bl	9488 <_print>
	info_msg("Pending Result Macros: ");
    3164:	4842      	ldr	r0, [pc, #264]	; (3270 <cliFunc_macroList+0x17c>)
    3166:	f006 f98f 	bl	9488 <_print>
	printInt16( (uint16_t)macroResultMacroPendingList.size );
    316a:	f8b5 0258 	ldrh.w	r0, [r5, #600]	; 0x258
    316e:	f006 fa2b 	bl	95c8 <printInt16>
	print(" : ");
    3172:	483b      	ldr	r0, [pc, #236]	; (3260 <cliFunc_macroList+0x16c>)
    3174:	f006 f988 	bl	9488 <_print>
		printHex( macroResultMacroPendingList.data[ macro ].index );
    3178:	f04f 080c 	mov.w	r8, #12
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    317c:	2300      	movs	r3, #0
    317e:	f8b5 1258 	ldrh.w	r1, [r5, #600]	; 0x258
    3182:	b29a      	uxth	r2, r3
    3184:	4291      	cmp	r1, r2
    3186:	f103 0701 	add.w	r7, r3, #1
    318a:	d84f      	bhi.n	322c <cliFunc_macroList+0x138>
	print( NL );
    318c:	4830      	ldr	r0, [pc, #192]	; (3250 <cliFunc_macroList+0x15c>)
		print( NL );
    318e:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 3250 <cliFunc_macroList+0x15c>
		print("\tT");
    3192:	4f38      	ldr	r7, [pc, #224]	; (3274 <cliFunc_macroList+0x180>)
		print(" : R");
    3194:	4e38      	ldr	r6, [pc, #224]	; (3278 <cliFunc_macroList+0x184>)
	print( NL );
    3196:	f006 f977 	bl	9488 <_print>
	info_msg("Trigger Macros Range: T0 -> T");
    319a:	4838      	ldr	r0, [pc, #224]	; (327c <cliFunc_macroList+0x188>)
    319c:	f006 f974 	bl	9488 <_print>
	printInt16( (uint16_t)TriggerMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    31a0:	205e      	movs	r0, #94	; 0x5e
    31a2:	f006 fa11 	bl	95c8 <printInt16>
	print( NL );
    31a6:	482a      	ldr	r0, [pc, #168]	; (3250 <cliFunc_macroList+0x15c>)
    31a8:	f006 f96e 	bl	9488 <_print>
	info_msg("Result  Macros Range: R0 -> R");
    31ac:	4834      	ldr	r0, [pc, #208]	; (3280 <cliFunc_macroList+0x18c>)
    31ae:	f006 f96b 	bl	9488 <_print>
	printInt16( (uint16_t)ResultMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    31b2:	205d      	movs	r0, #93	; 0x5d
    31b4:	f006 fa08 	bl	95c8 <printInt16>
	print( NL );
    31b8:	4825      	ldr	r0, [pc, #148]	; (3250 <cliFunc_macroList+0x15c>)
    31ba:	f006 f965 	bl	9488 <_print>
	info_msg("Trigger : Result Macro Pairs");
    31be:	4831      	ldr	r0, [pc, #196]	; (3284 <cliFunc_macroList+0x190>)
    31c0:	f006 f962 	bl	9488 <_print>
    31c4:	2500      	movs	r5, #0
		print( NL );
    31c6:	4640      	mov	r0, r8
    31c8:	f006 f95e 	bl	9488 <_print>
		print("\tT");
    31cc:	4638      	mov	r0, r7
    31ce:	f006 f95b 	bl	9488 <_print>
		printInt16( (uint16_t)macro ); // Hopefully large enough :P (can't assume 32-bit)
    31d2:	b2a8      	uxth	r0, r5
    31d4:	f006 f9f8 	bl	95c8 <printInt16>
		print(" : R");
    31d8:	4630      	mov	r0, r6
    31da:	f006 f955 	bl	9488 <_print>
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
    31de:	4b2a      	ldr	r3, [pc, #168]	; (3288 <cliFunc_macroList+0x194>)
    31e0:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    31e4:	3501      	adds	r5, #1
    31e6:	8898      	ldrh	r0, [r3, #4]
    31e8:	f006 f9ee 	bl	95c8 <printInt16>
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    31ec:	2d5f      	cmp	r5, #95	; 0x5f
    31ee:	d1ea      	bne.n	31c6 <cliFunc_macroList+0xd2>
}
    31f0:	9a01      	ldr	r2, [sp, #4]
    31f2:	6823      	ldr	r3, [r4, #0]
    31f4:	429a      	cmp	r2, r3
    31f6:	d025      	beq.n	3244 <cliFunc_macroList+0x150>
    31f8:	f7fe f994 	bl	1524 <__stack_chk_fail>
		printHex( macroTriggerEventBuffer[ key ].index );
    31fc:	b29b      	uxth	r3, r3
    31fe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    3202:	4443      	add	r3, r8
    3204:	2101      	movs	r1, #1
    3206:	7898      	ldrb	r0, [r3, #2]
    3208:	f006 fa64 	bl	96d4 <printHex_op>
		print(" ");
    320c:	4630      	mov	r0, r6
    320e:	f006 f93b 	bl	9488 <_print>
    3212:	463b      	mov	r3, r7
    3214:	e784      	b.n	3120 <cliFunc_macroList+0x2c>
		printHex( macroTriggerMacroPendingList[ macro ] );
    3216:	b29b      	uxth	r3, r3
    3218:	2101      	movs	r1, #1
    321a:	f838 0013 	ldrh.w	r0, [r8, r3, lsl #1]
    321e:	f006 fa59 	bl	96d4 <printHex_op>
		print(" ");
    3222:	4638      	mov	r0, r7
    3224:	f006 f930 	bl	9488 <_print>
    3228:	4633      	mov	r3, r6
    322a:	e790      	b.n	314e <cliFunc_macroList+0x5a>
		printHex( macroResultMacroPendingList.data[ macro ].index );
    322c:	b29b      	uxth	r3, r3
    322e:	fb08 5303 	mla	r3, r8, r3, r5
    3232:	2101      	movs	r1, #1
    3234:	8898      	ldrh	r0, [r3, #4]
    3236:	f006 fa4d 	bl	96d4 <printHex_op>
		print(" ");
    323a:	4630      	mov	r0, r6
    323c:	f006 f924 	bl	9488 <_print>
    3240:	463b      	mov	r3, r7
    3242:	e79c      	b.n	317e <cliFunc_macroList+0x8a>
}
    3244:	b002      	add	sp, #8
    3246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    324a:	bf00      	nop
    324c:	1fffe9d0 	.word	0x1fffe9d0
    3250:	0000d348 	.word	0x0000d348
    3254:	1ffffcb0 	.word	0x1ffffcb0
    3258:	0000b014 	.word	0x0000b014
    325c:	0000d6a4 	.word	0x0000d6a4
    3260:	0000b03b 	.word	0x0000b03b
    3264:	1ffff460 	.word	0x1ffff460
    3268:	0000b03f 	.word	0x0000b03f
    326c:	200000f4 	.word	0x200000f4
    3270:	0000b06a 	.word	0x0000b06a
    3274:	0000b123 	.word	0x0000b123
    3278:	0000b126 	.word	0x0000b126
    327c:	0000b094 	.word	0x0000b094
    3280:	0000b0c4 	.word	0x0000b0c4
    3284:	0000b0f4 	.word	0x0000b0f4
    3288:	0000a39c 	.word	0x0000a39c
    328c:	1ffffcb5 	.word	0x1ffffcb5
    3290:	1ffff3a2 	.word	0x1ffff3a2

00003294 <cliFunc_macroDebug>:
{
    3294:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    3296:	4c1d      	ldr	r4, [pc, #116]	; (330c <cliFunc_macroDebug+0x78>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3298:	aa02      	add	r2, sp, #8
{
    329a:	6823      	ldr	r3, [r4, #0]
    329c:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    329e:	a901      	add	r1, sp, #4
    32a0:	f005 fbc4 	bl	8a2c <CLI_argumentIsolation>
	switch ( arg1Ptr[0] )
    32a4:	9b01      	ldr	r3, [sp, #4]
    32a6:	781b      	ldrb	r3, [r3, #0]
    32a8:	2b31      	cmp	r3, #49	; 0x31
    32aa:	d024      	beq.n	32f6 <cliFunc_macroDebug+0x62>
    32ac:	d806      	bhi.n	32bc <cliFunc_macroDebug+0x28>
    32ae:	b313      	cbz	r3, 32f6 <cliFunc_macroDebug+0x62>
}
    32b0:	9a03      	ldr	r2, [sp, #12]
    32b2:	6823      	ldr	r3, [r4, #0]
    32b4:	429a      	cmp	r2, r3
    32b6:	d026      	beq.n	3306 <cliFunc_macroDebug+0x72>
    32b8:	f7fe f934 	bl	1524 <__stack_chk_fail>
	switch ( arg1Ptr[0] )
    32bc:	2b32      	cmp	r3, #50	; 0x32
    32be:	d014      	beq.n	32ea <cliFunc_macroDebug+0x56>
    32c0:	2b33      	cmp	r3, #51	; 0x33
    32c2:	d1f5      	bne.n	32b0 <cliFunc_macroDebug+0x1c>
		macroDebugMode = macroDebugMode != 3 ? 3 : 0;
    32c4:	4b12      	ldr	r3, [pc, #72]	; (3310 <cliFunc_macroDebug+0x7c>)
    32c6:	781a      	ldrb	r2, [r3, #0]
    32c8:	2a03      	cmp	r2, #3
    32ca:	bf18      	it	ne
    32cc:	2203      	movne	r2, #3
		macroDebugMode = macroDebugMode != 2 ? 2 : 0;
    32ce:	bf08      	it	eq
    32d0:	2200      	moveq	r2, #0
    32d2:	701a      	strb	r2, [r3, #0]
	print( NL );
    32d4:	480f      	ldr	r0, [pc, #60]	; (3314 <cliFunc_macroDebug+0x80>)
    32d6:	f006 f8d7 	bl	9488 <_print>
	info_msg("Macro Debug Mode: ");
    32da:	480f      	ldr	r0, [pc, #60]	; (3318 <cliFunc_macroDebug+0x84>)
    32dc:	f006 f8d4 	bl	9488 <_print>
	printInt8( macroDebugMode );
    32e0:	4b0b      	ldr	r3, [pc, #44]	; (3310 <cliFunc_macroDebug+0x7c>)
    32e2:	7818      	ldrb	r0, [r3, #0]
    32e4:	f006 f93a 	bl	955c <printInt8>
    32e8:	e7e2      	b.n	32b0 <cliFunc_macroDebug+0x1c>
		macroDebugMode = macroDebugMode != 2 ? 2 : 0;
    32ea:	4b09      	ldr	r3, [pc, #36]	; (3310 <cliFunc_macroDebug+0x7c>)
    32ec:	781a      	ldrb	r2, [r3, #0]
    32ee:	2a02      	cmp	r2, #2
    32f0:	bf18      	it	ne
    32f2:	2202      	movne	r2, #2
    32f4:	e7eb      	b.n	32ce <cliFunc_macroDebug+0x3a>
		macroDebugMode = macroDebugMode != 1 ? 1 : 0;
    32f6:	4a06      	ldr	r2, [pc, #24]	; (3310 <cliFunc_macroDebug+0x7c>)
    32f8:	7813      	ldrb	r3, [r2, #0]
    32fa:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    32fe:	bf18      	it	ne
    3300:	2301      	movne	r3, #1
    3302:	7013      	strb	r3, [r2, #0]
		break;
    3304:	e7e6      	b.n	32d4 <cliFunc_macroDebug+0x40>
}
    3306:	b004      	add	sp, #16
    3308:	bd10      	pop	{r4, pc}
    330a:	bf00      	nop
    330c:	1fffe9d0 	.word	0x1fffe9d0
    3310:	1ffffd78 	.word	0x1ffffd78
    3314:	0000d348 	.word	0x0000d348
    3318:	0000afef 	.word	0x0000afef

0000331c <cliFunc_capSelect>:
{
    331c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3320:	4a3e      	ldr	r2, [pc, #248]	; (341c <cliFunc_capSelect+0x100>)
			print(" - ");
    3322:	f8df 9118 	ldr.w	r9, [pc, #280]	; 343c <cliFunc_capSelect+0x120>
{
    3326:	6813      	ldr	r3, [r2, #0]
    3328:	b085      	sub	sp, #20
	char* arg2Ptr = args;
    332a:	2600      	movs	r6, #0
{
    332c:	4604      	mov	r4, r0
    332e:	9303      	str	r3, [sp, #12]
	char* arg2Ptr = args;
    3330:	9002      	str	r0, [sp, #8]
	var_uint_t argSetCount = 0;
    3332:	4637      	mov	r7, r6
	var_uint_t cap = 0;
    3334:	46b0      	mov	r8, r6
	var_uint_t totalArgs = 2; // Always at least two args
    3336:	f04f 0b02 	mov.w	fp, #2
    333a:	4692      	mov	sl, r2
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    333c:	aa02      	add	r2, sp, #8
    333e:	9802      	ldr	r0, [sp, #8]
    3340:	a901      	add	r1, sp, #4
    3342:	f005 fb73 	bl	8a2c <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    3346:	9801      	ldr	r0, [sp, #4]
    3348:	7802      	ldrb	r2, [r0, #0]
    334a:	2a00      	cmp	r2, #0
    334c:	d050      	beq.n	33f0 <cliFunc_capSelect+0xd4>
		if ( c == 0 ) switch ( arg1Ptr[0] )
    334e:	b2b1      	uxth	r1, r6
    3350:	b9a9      	cbnz	r1, 337e <cliFunc_capSelect+0x62>
    3352:	2a4b      	cmp	r2, #75	; 0x4b
    3354:	d113      	bne.n	337e <cliFunc_capSelect+0x62>
			cap = numToInt( &arg1Ptr[1] );
    3356:	3001      	adds	r0, #1
    3358:	f006 fa66 	bl	9828 <numToInt>
			totalArgs += CapabilitiesList[ cap ].argCount;
    335c:	4a30      	ldr	r2, [pc, #192]	; (3420 <cliFunc_capSelect+0x104>)
			cap = numToInt( &arg1Ptr[1] );
    335e:	fa1f f880 	uxth.w	r8, r0
			totalArgs += CapabilitiesList[ cap ].argCount;
    3362:	eb02 00c8 	add.w	r0, r2, r8, lsl #3
			continue;
    3366:	463d      	mov	r5, r7
			totalArgs += CapabilitiesList[ cap ].argCount;
    3368:	7902      	ldrb	r2, [r0, #4]
    336a:	eb0b 0302 	add.w	r3, fp, r2
    336e:	fa1f fb83 	uxth.w	fp, r3
	for ( var_uint_t c = 0; argSetCount < totalArgs; c++ )
    3372:	45ab      	cmp	fp, r5
    3374:	f106 0601 	add.w	r6, r6, #1
    3378:	d93a      	bls.n	33f0 <cliFunc_capSelect+0xd4>
    337a:	462f      	mov	r7, r5
    337c:	e7de      	b.n	333c <cliFunc_capSelect+0x20>
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    337e:	f006 fa53 	bl	9828 <numToInt>
    3382:	1c7d      	adds	r5, r7, #1
    3384:	b2ad      	uxth	r5, r5
		if ( argSetCount == totalArgs )
    3386:	455d      	cmp	r5, fp
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    3388:	55e0      	strb	r0, [r4, r7]
		if ( argSetCount == totalArgs )
    338a:	d1f2      	bne.n	3372 <cliFunc_capSelect+0x56>
			print( NL );
    338c:	4825      	ldr	r0, [pc, #148]	; (3424 <cliFunc_capSelect+0x108>)
    338e:	f006 f87b 	bl	9488 <_print>
			info_msg("K");
    3392:	4825      	ldr	r0, [pc, #148]	; (3428 <cliFunc_capSelect+0x10c>)
    3394:	f006 f878 	bl	9488 <_print>
			printInt8( cap );
    3398:	fa5f f088 	uxtb.w	r0, r8
    339c:	f006 f8de 	bl	955c <printInt8>
			print(" - ");
    33a0:	4648      	mov	r0, r9
    33a2:	f006 f871 	bl	9488 <_print>
			printHex( argSet[0] );
    33a6:	2101      	movs	r1, #1
    33a8:	7820      	ldrb	r0, [r4, #0]
    33aa:	f006 f993 	bl	96d4 <printHex_op>
			print(" - ");
    33ae:	4648      	mov	r0, r9
    33b0:	f006 f86a 	bl	9488 <_print>
			printHex( argSet[1] );
    33b4:	2101      	movs	r1, #1
    33b6:	7860      	ldrb	r0, [r4, #1]
    33b8:	f006 f98c 	bl	96d4 <printHex_op>
			print(" - ");
    33bc:	4648      	mov	r0, r9
    33be:	f006 f863 	bl	9488 <_print>
			printHex( argSet[2] );
    33c2:	2101      	movs	r1, #1
    33c4:	78a0      	ldrb	r0, [r4, #2]
    33c6:	f006 f985 	bl	96d4 <printHex_op>
			print( "..." NL );
    33ca:	4818      	ldr	r0, [pc, #96]	; (342c <cliFunc_capSelect+0x110>)
    33cc:	f006 f85c 	bl	9488 <_print>
				if ( CapabilitiesList[ cap ].func == (const void*)Output_flashMode_capability )
    33d0:	4a13      	ldr	r2, [pc, #76]	; (3420 <cliFunc_capSelect+0x104>)
    33d2:	4917      	ldr	r1, [pc, #92]	; (3430 <cliFunc_capSelect+0x114>)
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
    33d4:	2300      	movs	r3, #0
				if ( CapabilitiesList[ cap ].func == (const void*)Output_flashMode_capability )
    33d6:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
    33da:	4288      	cmp	r0, r1
    33dc:	d10f      	bne.n	33fe <cliFunc_capSelect+0xe2>
					print( NL );
    33de:	4811      	ldr	r0, [pc, #68]	; (3424 <cliFunc_capSelect+0x108>)
    33e0:	f006 f852 	bl	9488 <_print>
					warn_print("flashModeEnabled not set, cancelling firmware reload...");
    33e4:	4813      	ldr	r0, [pc, #76]	; (3434 <cliFunc_capSelect+0x118>)
    33e6:	f006 f84f 	bl	9488 <_print>
					info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    33ea:	4813      	ldr	r0, [pc, #76]	; (3438 <cliFunc_capSelect+0x11c>)
    33ec:	f006 f84c 	bl	9488 <_print>
}
    33f0:	9a03      	ldr	r2, [sp, #12]
    33f2:	f8da 3000 	ldr.w	r3, [sl]
    33f6:	429a      	cmp	r2, r3
    33f8:	d00d      	beq.n	3416 <cliFunc_capSelect+0xfa>
    33fa:	f7fe f893 	bl	1524 <__stack_chk_fail>
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
    33fe:	3301      	adds	r3, #1
    3400:	2b13      	cmp	r3, #19
    3402:	d1e8      	bne.n	33d6 <cliFunc_capSelect+0xba>
			capability( 0, argSet[0], argSet[1], &argSet[2] );
    3404:	f852 7038 	ldr.w	r7, [r2, r8, lsl #3]
    3408:	7821      	ldrb	r1, [r4, #0]
    340a:	7862      	ldrb	r2, [r4, #1]
    340c:	1ca3      	adds	r3, r4, #2
    340e:	2000      	movs	r0, #0
    3410:	47b8      	blx	r7
    3412:	46ab      	mov	fp, r5
    3414:	e7ad      	b.n	3372 <cliFunc_capSelect+0x56>
}
    3416:	b005      	add	sp, #20
    3418:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    341c:	1fffe9d0 	.word	0x1fffe9d0
    3420:	00009ed8 	.word	0x00009ed8
    3424:	0000d348 	.word	0x0000d348
    3428:	0000a7e2 	.word	0x0000a7e2
    342c:	0000a83f 	.word	0x0000a83f
    3430:	00005abd 	.word	0x00005abd
    3434:	0000a7f6 	.word	0x0000a7f6
    3438:	0000a845 	.word	0x0000a845
    343c:	0000cc04 	.word	0x0000cc04

00003440 <cliFunc_layerState>:
{
    3440:	b5f0      	push	{r4, r5, r6, r7, lr}
    3442:	4c1a      	ldr	r4, [pc, #104]	; (34ac <cliFunc_layerState+0x6c>)
    3444:	b085      	sub	sp, #20
    3446:	6822      	ldr	r2, [r4, #0]
    3448:	9203      	str	r2, [sp, #12]
	for ( uint8_t c = 0; c < 2; c++ )
    344a:	2500      	movs	r5, #0
	char* arg2Ptr = args;
    344c:	9002      	str	r0, [sp, #8]
	uint8_t arg1 = 0;
    344e:	462e      	mov	r6, r5
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3450:	9802      	ldr	r0, [sp, #8]
    3452:	aa02      	add	r2, sp, #8
    3454:	a901      	add	r1, sp, #4
    3456:	f005 fae9 	bl	8a2c <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    345a:	9801      	ldr	r0, [sp, #4]
    345c:	7803      	ldrb	r3, [r0, #0]
    345e:	b1eb      	cbz	r3, 349c <cliFunc_layerState+0x5c>
		switch ( c )
    3460:	b93d      	cbnz	r5, 3472 <cliFunc_layerState+0x32>
			if ( arg1Ptr[0] != 'L' )
    3462:	2b4c      	cmp	r3, #76	; 0x4c
    3464:	d11a      	bne.n	349c <cliFunc_layerState+0x5c>
			arg1 = (uint8_t)numToInt( &arg1Ptr[1] );
    3466:	3001      	adds	r0, #1
    3468:	f006 f9de 	bl	9828 <numToInt>
    346c:	2501      	movs	r5, #1
    346e:	b2c6      	uxtb	r6, r0
    3470:	e7ee      	b.n	3450 <cliFunc_layerState+0x10>
			arg2 = (uint8_t)numToInt( arg1Ptr );
    3472:	f006 f9d9 	bl	9828 <numToInt>
    3476:	b2c7      	uxtb	r7, r0
			print( NL );
    3478:	480d      	ldr	r0, [pc, #52]	; (34b0 <cliFunc_layerState+0x70>)
    347a:	f006 f805 	bl	9488 <_print>
			info_msg("Setting Layer L");
    347e:	480d      	ldr	r0, [pc, #52]	; (34b4 <cliFunc_layerState+0x74>)
    3480:	f006 f802 	bl	9488 <_print>
			printInt8( arg1 );
    3484:	4630      	mov	r0, r6
    3486:	f006 f869 	bl	955c <printInt8>
			print(" to - ");
    348a:	480b      	ldr	r0, [pc, #44]	; (34b8 <cliFunc_layerState+0x78>)
    348c:	f005 fffc 	bl	9488 <_print>
			printHex( arg2 );
    3490:	4629      	mov	r1, r5
    3492:	4638      	mov	r0, r7
    3494:	f006 f91e 	bl	96d4 <printHex_op>
			LayerState[ arg1 ] = arg2;
    3498:	4b08      	ldr	r3, [pc, #32]	; (34bc <cliFunc_layerState+0x7c>)
    349a:	559f      	strb	r7, [r3, r6]
}
    349c:	9a03      	ldr	r2, [sp, #12]
    349e:	6823      	ldr	r3, [r4, #0]
    34a0:	429a      	cmp	r2, r3
    34a2:	d001      	beq.n	34a8 <cliFunc_layerState+0x68>
    34a4:	f7fe f83e 	bl	1524 <__stack_chk_fail>
    34a8:	b005      	add	sp, #20
    34aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    34ac:	1fffe9d0 	.word	0x1fffe9d0
    34b0:	0000d348 	.word	0x0000d348
    34b4:	0000afc6 	.word	0x0000afc6
    34b8:	0000afe8 	.word	0x0000afe8
    34bc:	1ffffcb3 	.word	0x1ffffcb3

000034c0 <cliFunc_macroStep>:
{
    34c0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    34c2:	4c0c      	ldr	r4, [pc, #48]	; (34f4 <cliFunc_macroStep+0x34>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    34c4:	aa02      	add	r2, sp, #8
{
    34c6:	6823      	ldr	r3, [r4, #0]
    34c8:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    34ca:	a901      	add	r1, sp, #4
    34cc:	f005 faae 	bl	8a2c <CLI_argumentIsolation>
	var_uint_t count = (var_uint_t)numToInt( arg1Ptr );
    34d0:	9801      	ldr	r0, [sp, #4]
    34d2:	f006 f9a9 	bl	9828 <numToInt>
    34d6:	b280      	uxth	r0, r0
		count = 1;
    34d8:	2800      	cmp	r0, #0
	macroStepCounter = count;
    34da:	4b07      	ldr	r3, [pc, #28]	; (34f8 <cliFunc_macroStep+0x38>)
}
    34dc:	9a03      	ldr	r2, [sp, #12]
		count = 1;
    34de:	bf08      	it	eq
    34e0:	2001      	moveq	r0, #1
	macroStepCounter = count;
    34e2:	8018      	strh	r0, [r3, #0]
}
    34e4:	6823      	ldr	r3, [r4, #0]
    34e6:	429a      	cmp	r2, r3
    34e8:	d001      	beq.n	34ee <cliFunc_macroStep+0x2e>
    34ea:	f7fe f81b 	bl	1524 <__stack_chk_fail>
    34ee:	b004      	add	sp, #16
    34f0:	bd10      	pop	{r4, pc}
    34f2:	bf00      	nop
    34f4:	1fffe9d0 	.word	0x1fffe9d0
    34f8:	1ffffd76 	.word	0x1ffffd76

000034fc <cliFunc_layerList>:
{
    34fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    34fe:	4c2d      	ldr	r4, [pc, #180]	; (35b4 <cliFunc_layerList+0xb8>)
	print( NL );
    3500:	482d      	ldr	r0, [pc, #180]	; (35b8 <cliFunc_layerList+0xbc>)
{
    3502:	6823      	ldr	r3, [r4, #0]
    3504:	9301      	str	r3, [sp, #4]
	print( NL );
    3506:	f005 ffbf 	bl	9488 <_print>
	info_msg("Layer List");
    350a:	482c      	ldr	r0, [pc, #176]	; (35bc <cliFunc_layerList+0xc0>)
		printHex( LayerState[ layer ] );
    350c:	4d2c      	ldr	r5, [pc, #176]	; (35c0 <cliFunc_layerList+0xc4>)
	info_msg("Layer List");
    350e:	f005 ffbb 	bl	9488 <_print>
		print( NL "\t" );
    3512:	482c      	ldr	r0, [pc, #176]	; (35c4 <cliFunc_layerList+0xc8>)
    3514:	f005 ffb8 	bl	9488 <_print>
		printHex( layer );
    3518:	2101      	movs	r1, #1
    351a:	2000      	movs	r0, #0
    351c:	f006 f8da 	bl	96d4 <printHex_op>
		print(" - ");
    3520:	4829      	ldr	r0, [pc, #164]	; (35c8 <cliFunc_layerList+0xcc>)
    3522:	f005 ffb1 	bl	9488 <_print>
		dPrint( (char*)LayerIndex[ layer ].name );
    3526:	4829      	ldr	r0, [pc, #164]	; (35cc <cliFunc_layerList+0xd0>)
    3528:	f002 fc2a 	bl	5d80 <Output_putstr>
			print(" \033[1m(default)\033[0m");
    352c:	4828      	ldr	r0, [pc, #160]	; (35d0 <cliFunc_layerList+0xd4>)
    352e:	f005 ffab 	bl	9488 <_print>
		print( NL "\t\t Layer State: " );
    3532:	4828      	ldr	r0, [pc, #160]	; (35d4 <cliFunc_layerList+0xd8>)
    3534:	f005 ffa8 	bl	9488 <_print>
		printHex( LayerState[ layer ] );
    3538:	2101      	movs	r1, #1
    353a:	7828      	ldrb	r0, [r5, #0]
    353c:	f006 f8ca 	bl	96d4 <printHex_op>
		print(" First -> Last Indices: ");
    3540:	4825      	ldr	r0, [pc, #148]	; (35d8 <cliFunc_layerList+0xdc>)
    3542:	f005 ffa1 	bl	9488 <_print>
		printHex( LayerIndex[ layer ].first );
    3546:	2101      	movs	r1, #1
    3548:	2000      	movs	r0, #0
    354a:	f006 f8c3 	bl	96d4 <printHex_op>
		print(" -> ");
    354e:	4823      	ldr	r0, [pc, #140]	; (35dc <cliFunc_layerList+0xe0>)
    3550:	f005 ff9a 	bl	9488 <_print>
		printHex( LayerIndex[ layer ].last );
    3554:	2101      	movs	r1, #1
    3556:	203f      	movs	r0, #63	; 0x3f
    3558:	f006 f8bc 	bl	96d4 <printHex_op>
		print( NL "\t" );
    355c:	4819      	ldr	r0, [pc, #100]	; (35c4 <cliFunc_layerList+0xc8>)
    355e:	f005 ff93 	bl	9488 <_print>
		printHex( layer );
    3562:	2101      	movs	r1, #1
    3564:	4608      	mov	r0, r1
    3566:	f006 f8b5 	bl	96d4 <printHex_op>
		print(" - ");
    356a:	4817      	ldr	r0, [pc, #92]	; (35c8 <cliFunc_layerList+0xcc>)
    356c:	f005 ff8c 	bl	9488 <_print>
		dPrint( (char*)LayerIndex[ layer ].name );
    3570:	481b      	ldr	r0, [pc, #108]	; (35e0 <cliFunc_layerList+0xe4>)
    3572:	f002 fc05 	bl	5d80 <Output_putstr>
		print( NL "\t\t Layer State: " );
    3576:	4817      	ldr	r0, [pc, #92]	; (35d4 <cliFunc_layerList+0xd8>)
    3578:	f005 ff86 	bl	9488 <_print>
		printHex( LayerState[ layer ] );
    357c:	2101      	movs	r1, #1
    357e:	7868      	ldrb	r0, [r5, #1]
    3580:	f006 f8a8 	bl	96d4 <printHex_op>
		print(" First -> Last Indices: ");
    3584:	4814      	ldr	r0, [pc, #80]	; (35d8 <cliFunc_layerList+0xdc>)
    3586:	f005 ff7f 	bl	9488 <_print>
		printHex( LayerIndex[ layer ].first );
    358a:	2101      	movs	r1, #1
    358c:	2002      	movs	r0, #2
    358e:	f006 f8a1 	bl	96d4 <printHex_op>
		print(" -> ");
    3592:	4812      	ldr	r0, [pc, #72]	; (35dc <cliFunc_layerList+0xe0>)
    3594:	f005 ff78 	bl	9488 <_print>
		printHex( LayerIndex[ layer ].last );
    3598:	9a01      	ldr	r2, [sp, #4]
    359a:	6823      	ldr	r3, [r4, #0]
    359c:	429a      	cmp	r2, r3
    359e:	d001      	beq.n	35a4 <cliFunc_layerList+0xa8>
    35a0:	f7fd ffc0 	bl	1524 <__stack_chk_fail>
    35a4:	2101      	movs	r1, #1
    35a6:	2035      	movs	r0, #53	; 0x35
}
    35a8:	b003      	add	sp, #12
    35aa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		printHex( LayerIndex[ layer ].last );
    35ae:	f006 b891 	b.w	96d4 <printHex_op>
    35b2:	bf00      	nop
    35b4:	1fffe9d0 	.word	0x1fffe9d0
    35b8:	0000d348 	.word	0x0000d348
    35bc:	0000a8b1 	.word	0x0000a8b1
    35c0:	1ffffcb3 	.word	0x1ffffcb3
    35c4:	0000a7de 	.word	0x0000a7de
    35c8:	0000cc04 	.word	0x0000cc04
    35cc:	0000a8ce 	.word	0x0000a8ce
    35d0:	0000ac29 	.word	0x0000ac29
    35d4:	0000ac3c 	.word	0x0000ac3c
    35d8:	0000ac4f 	.word	0x0000ac4f
    35dc:	00009ed1 	.word	0x00009ed1
    35e0:	0000ac68 	.word	0x0000ac68

000035e4 <cliFunc_voteDebug>:

void cliFunc_voteDebug( char* args )
{
    35e4:	b530      	push	{r4, r5, lr}
    35e6:	4c12      	ldr	r4, [pc, #72]	; (3630 <cliFunc_voteDebug+0x4c>)
    35e8:	b085      	sub	sp, #20
    35ea:	6823      	ldr	r3, [r4, #0]
    35ec:	9303      	str	r3, [sp, #12]
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    35ee:	aa02      	add	r2, sp, #8
    35f0:	a901      	add	r1, sp, #4
    35f2:	f005 fa1b 	bl	8a2c <CLI_argumentIsolation>

	// Set the vote debug flag depending on the argument
	switch ( arg1Ptr[0] )
    35f6:	9b01      	ldr	r3, [sp, #4]
    35f8:	781b      	ldrb	r3, [r3, #0]
    35fa:	2b01      	cmp	r3, #1
    35fc:	d80f      	bhi.n	361e <cliFunc_voteDebug+0x3a>
	{
	// No argument
	case 1:
	case '\0':
		voteDebugMode = voteDebugMode != 1 ? 1 : 0;
    35fe:	4d0d      	ldr	r5, [pc, #52]	; (3634 <cliFunc_voteDebug+0x50>)
	// Invalid argument
	default:
		return;
	}

	print( NL );
    3600:	480d      	ldr	r0, [pc, #52]	; (3638 <cliFunc_voteDebug+0x54>)
		voteDebugMode = voteDebugMode != 1 ? 1 : 0;
    3602:	782b      	ldrb	r3, [r5, #0]
    3604:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    3608:	bf18      	it	ne
    360a:	2301      	movne	r3, #1
    360c:	702b      	strb	r3, [r5, #0]
	print( NL );
    360e:	f005 ff3b 	bl	9488 <_print>
	info_msg("Vote Debug Mode: ");
    3612:	480a      	ldr	r0, [pc, #40]	; (363c <cliFunc_voteDebug+0x58>)
    3614:	f005 ff38 	bl	9488 <_print>
	printInt8( voteDebugMode );
    3618:	7828      	ldrb	r0, [r5, #0]
    361a:	f005 ff9f 	bl	955c <printInt8>
}
    361e:	9a03      	ldr	r2, [sp, #12]
    3620:	6823      	ldr	r3, [r4, #0]
    3622:	429a      	cmp	r2, r3
    3624:	d001      	beq.n	362a <cliFunc_voteDebug+0x46>
    3626:	f7fd ff7d 	bl	1524 <__stack_chk_fail>
    362a:	b005      	add	sp, #20
    362c:	bd30      	pop	{r4, r5, pc}
    362e:	bf00      	nop
    3630:	1fffe9d0 	.word	0x1fffe9d0
    3634:	1ffffcb2 	.word	0x1ffffcb2
    3638:	0000d348 	.word	0x0000d348
    363c:	0000b155 	.word	0x0000b155

00003640 <Macro_showScheduleType>:
{
    3640:	b573      	push	{r0, r1, r4, r5, r6, lr}
    3642:	4c23      	ldr	r4, [pc, #140]	; (36d0 <Macro_showScheduleType+0x90>)
    3644:	f000 060f 	and.w	r6, r0, #15
    3648:	6823      	ldr	r3, [r4, #0]
    364a:	9301      	str	r3, [sp, #4]
    364c:	4605      	mov	r5, r0
	switch ( state & 0x0F )
    364e:	2e07      	cmp	r6, #7
    3650:	d824      	bhi.n	369c <Macro_showScheduleType+0x5c>
    3652:	e8df f006 	tbb	[pc, r6]
    3656:	0419      	.short	0x0419
    3658:	1d1b1715 	.word	0x1d1b1715
    365c:	211f      	.short	0x211f
		print("\033[1;33mP\033[0m");
    365e:	481d      	ldr	r0, [pc, #116]	; (36d4 <Macro_showScheduleType+0x94>)
		print("\033[1;32mH\033[0m");
    3660:	f005 ff12 	bl	9488 <_print>
	switch ( state & 0xF0 )
    3664:	f005 00f0 	and.w	r0, r5, #240	; 0xf0
    3668:	2820      	cmp	r0, #32
		print("La");
    366a:	9a01      	ldr	r2, [sp, #4]
    366c:	6823      	ldr	r3, [r4, #0]
	switch ( state & 0xF0 )
    366e:	d022      	beq.n	36b6 <Macro_showScheduleType+0x76>
    3670:	2840      	cmp	r0, #64	; 0x40
    3672:	d024      	beq.n	36be <Macro_showScheduleType+0x7e>
    3674:	2810      	cmp	r0, #16
    3676:	d126      	bne.n	36c6 <Macro_showScheduleType+0x86>
		print("Sh");
    3678:	429a      	cmp	r2, r3
    367a:	d016      	beq.n	36aa <Macro_showScheduleType+0x6a>
}
    367c:	f7fd ff52 	bl	1524 <__stack_chk_fail>
		print("\033[1;32mH\033[0m");
    3680:	4815      	ldr	r0, [pc, #84]	; (36d8 <Macro_showScheduleType+0x98>)
    3682:	e7ed      	b.n	3660 <Macro_showScheduleType+0x20>
		print("\033[1;35mR\033[0m");
    3684:	4815      	ldr	r0, [pc, #84]	; (36dc <Macro_showScheduleType+0x9c>)
    3686:	e7eb      	b.n	3660 <Macro_showScheduleType+0x20>
		print("\033[1mO\033[0m");
    3688:	4815      	ldr	r0, [pc, #84]	; (36e0 <Macro_showScheduleType+0xa0>)
    368a:	e7e9      	b.n	3660 <Macro_showScheduleType+0x20>
		print("UP");
    368c:	4815      	ldr	r0, [pc, #84]	; (36e4 <Macro_showScheduleType+0xa4>)
    368e:	e7e7      	b.n	3660 <Macro_showScheduleType+0x20>
		print("UR");
    3690:	4815      	ldr	r0, [pc, #84]	; (36e8 <Macro_showScheduleType+0xa8>)
    3692:	e7e5      	b.n	3660 <Macro_showScheduleType+0x20>
		print("Done");
    3694:	4815      	ldr	r0, [pc, #84]	; (36ec <Macro_showScheduleType+0xac>)
    3696:	e7e3      	b.n	3660 <Macro_showScheduleType+0x20>
		print("Repeat");
    3698:	4815      	ldr	r0, [pc, #84]	; (36f0 <Macro_showScheduleType+0xb0>)
    369a:	e7e1      	b.n	3660 <Macro_showScheduleType+0x20>
		print("\033[1;31mINVALID\033[0m");
    369c:	4815      	ldr	r0, [pc, #84]	; (36f4 <Macro_showScheduleType+0xb4>)
    369e:	f005 fef3 	bl	9488 <_print>
		printInt8( state & 0x0F );
    36a2:	4630      	mov	r0, r6
    36a4:	f005 ff5a 	bl	955c <printInt8>
		break;
    36a8:	e7dc      	b.n	3664 <Macro_showScheduleType+0x24>
		print("Sh");
    36aa:	4813      	ldr	r0, [pc, #76]	; (36f8 <Macro_showScheduleType+0xb8>)
}
    36ac:	b002      	add	sp, #8
    36ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Lo");
    36b2:	f005 bee9 	b.w	9488 <_print>
		print("La");
    36b6:	429a      	cmp	r2, r3
    36b8:	d1e0      	bne.n	367c <Macro_showScheduleType+0x3c>
    36ba:	4810      	ldr	r0, [pc, #64]	; (36fc <Macro_showScheduleType+0xbc>)
    36bc:	e7f6      	b.n	36ac <Macro_showScheduleType+0x6c>
		print("Lo");
    36be:	429a      	cmp	r2, r3
    36c0:	d1dc      	bne.n	367c <Macro_showScheduleType+0x3c>
    36c2:	480f      	ldr	r0, [pc, #60]	; (3700 <Macro_showScheduleType+0xc0>)
    36c4:	e7f2      	b.n	36ac <Macro_showScheduleType+0x6c>
}
    36c6:	429a      	cmp	r2, r3
    36c8:	d1d8      	bne.n	367c <Macro_showScheduleType+0x3c>
    36ca:	b002      	add	sp, #8
    36cc:	bd70      	pop	{r4, r5, r6, pc}
    36ce:	bf00      	nop
    36d0:	1fffe9d0 	.word	0x1fffe9d0
    36d4:	000099c4 	.word	0x000099c4
    36d8:	000099d1 	.word	0x000099d1
    36dc:	000099de 	.word	0x000099de
    36e0:	000099ba 	.word	0x000099ba
    36e4:	0000a0d2 	.word	0x0000a0d2
    36e8:	0000a0d5 	.word	0x0000a0d5
    36ec:	0000a0d8 	.word	0x0000a0d8
    36f0:	0000a0dd 	.word	0x0000a0dd
    36f4:	0000a0e4 	.word	0x0000a0e4
    36f8:	0000a0f7 	.word	0x0000a0f7
    36fc:	0000a0fa 	.word	0x0000a0fa
    3700:	0000a0fd 	.word	0x0000a0fd

00003704 <Macro_showTriggerType>:
{
    3704:	b507      	push	{r0, r1, r2, lr}
    3706:	4b34      	ldr	r3, [pc, #208]	; (37d8 <Macro_showTriggerType+0xd4>)
	switch ( type )
    3708:	2810      	cmp	r0, #16
{
    370a:	681a      	ldr	r2, [r3, #0]
    370c:	9201      	str	r2, [sp, #4]
    370e:	4619      	mov	r1, r3
	switch ( type )
    3710:	d80d      	bhi.n	372e <Macro_showTriggerType+0x2a>
    3712:	280d      	cmp	r0, #13
    3714:	d23b      	bcs.n	378e <Macro_showTriggerType+0x8a>
    3716:	2808      	cmp	r0, #8
    3718:	d833      	bhi.n	3782 <Macro_showTriggerType+0x7e>
    371a:	2805      	cmp	r0, #5
    371c:	d22b      	bcs.n	3776 <Macro_showTriggerType+0x72>
    371e:	2803      	cmp	r0, #3
    3720:	d823      	bhi.n	376a <Macro_showTriggerType+0x66>
		print("Sw");
    3722:	9a01      	ldr	r2, [sp, #4]
    3724:	681b      	ldr	r3, [r3, #0]
    3726:	429a      	cmp	r2, r3
    3728:	d019      	beq.n	375e <Macro_showTriggerType+0x5a>
		print("Debug");
    372a:	f7fd fefb 	bl	1524 <__stack_chk_fail>
	switch ( type )
    372e:	2813      	cmp	r0, #19
    3730:	d03f      	beq.n	37b2 <Macro_showTriggerType+0xae>
    3732:	d809      	bhi.n	3748 <Macro_showTriggerType+0x44>
    3734:	2811      	cmp	r0, #17
    3736:	d030      	beq.n	379a <Macro_showTriggerType+0x96>
    3738:	2812      	cmp	r0, #18
    373a:	d034      	beq.n	37a6 <Macro_showTriggerType+0xa2>
		print("INVALID");
    373c:	9a01      	ldr	r2, [sp, #4]
    373e:	680b      	ldr	r3, [r1, #0]
    3740:	429a      	cmp	r2, r3
    3742:	d1f2      	bne.n	372a <Macro_showTriggerType+0x26>
    3744:	4825      	ldr	r0, [pc, #148]	; (37dc <Macro_showTriggerType+0xd8>)
    3746:	e00b      	b.n	3760 <Macro_showTriggerType+0x5c>
	switch ( type )
    3748:	2815      	cmp	r0, #21
    374a:	d03e      	beq.n	37ca <Macro_showTriggerType+0xc6>
    374c:	d337      	bcc.n	37be <Macro_showTriggerType+0xba>
    374e:	28ff      	cmp	r0, #255	; 0xff
    3750:	d1f4      	bne.n	373c <Macro_showTriggerType+0x38>
		print("Debug");
    3752:	9a01      	ldr	r2, [sp, #4]
    3754:	681b      	ldr	r3, [r3, #0]
    3756:	429a      	cmp	r2, r3
    3758:	d1e7      	bne.n	372a <Macro_showTriggerType+0x26>
    375a:	4821      	ldr	r0, [pc, #132]	; (37e0 <Macro_showTriggerType+0xdc>)
    375c:	e000      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("Sw");
    375e:	4821      	ldr	r0, [pc, #132]	; (37e4 <Macro_showTriggerType+0xe0>)
}
    3760:	b003      	add	sp, #12
    3762:	f85d eb04 	ldr.w	lr, [sp], #4
		print("Debug");
    3766:	f005 be8f 	b.w	9488 <_print>
		print("LED");
    376a:	9a01      	ldr	r2, [sp, #4]
    376c:	681b      	ldr	r3, [r3, #0]
    376e:	429a      	cmp	r2, r3
    3770:	d1db      	bne.n	372a <Macro_showTriggerType+0x26>
    3772:	481d      	ldr	r0, [pc, #116]	; (37e8 <Macro_showTriggerType+0xe4>)
    3774:	e7f4      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("An");
    3776:	9a01      	ldr	r2, [sp, #4]
    3778:	681b      	ldr	r3, [r3, #0]
    377a:	429a      	cmp	r2, r3
    377c:	d1d5      	bne.n	372a <Macro_showTriggerType+0x26>
    377e:	481b      	ldr	r0, [pc, #108]	; (37ec <Macro_showTriggerType+0xe8>)
    3780:	e7ee      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("Layer");
    3782:	9a01      	ldr	r2, [sp, #4]
    3784:	681b      	ldr	r3, [r3, #0]
    3786:	429a      	cmp	r2, r3
    3788:	d1cf      	bne.n	372a <Macro_showTriggerType+0x26>
    378a:	4819      	ldr	r0, [pc, #100]	; (37f0 <Macro_showTriggerType+0xec>)
    378c:	e7e8      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("Animation");
    378e:	9a01      	ldr	r2, [sp, #4]
    3790:	681b      	ldr	r3, [r3, #0]
    3792:	429a      	cmp	r2, r3
    3794:	d1c9      	bne.n	372a <Macro_showTriggerType+0x26>
    3796:	4817      	ldr	r0, [pc, #92]	; (37f4 <Macro_showTriggerType+0xf0>)
    3798:	e7e2      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("Sleep");
    379a:	9a01      	ldr	r2, [sp, #4]
    379c:	681b      	ldr	r3, [r3, #0]
    379e:	429a      	cmp	r2, r3
    37a0:	d1c3      	bne.n	372a <Macro_showTriggerType+0x26>
    37a2:	4815      	ldr	r0, [pc, #84]	; (37f8 <Macro_showTriggerType+0xf4>)
    37a4:	e7dc      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("Resume");
    37a6:	9a01      	ldr	r2, [sp, #4]
    37a8:	681b      	ldr	r3, [r3, #0]
    37aa:	429a      	cmp	r2, r3
    37ac:	d1bd      	bne.n	372a <Macro_showTriggerType+0x26>
    37ae:	4813      	ldr	r0, [pc, #76]	; (37fc <Macro_showTriggerType+0xf8>)
    37b0:	e7d6      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("Inactive");
    37b2:	9a01      	ldr	r2, [sp, #4]
    37b4:	681b      	ldr	r3, [r3, #0]
    37b6:	429a      	cmp	r2, r3
    37b8:	d1b7      	bne.n	372a <Macro_showTriggerType+0x26>
    37ba:	4811      	ldr	r0, [pc, #68]	; (3800 <Macro_showTriggerType+0xfc>)
    37bc:	e7d0      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("Active");
    37be:	9a01      	ldr	r2, [sp, #4]
    37c0:	681b      	ldr	r3, [r3, #0]
    37c2:	429a      	cmp	r2, r3
    37c4:	d1b1      	bne.n	372a <Macro_showTriggerType+0x26>
    37c6:	480f      	ldr	r0, [pc, #60]	; (3804 <Macro_showTriggerType+0x100>)
    37c8:	e7ca      	b.n	3760 <Macro_showTriggerType+0x5c>
		print("Rotation");
    37ca:	9a01      	ldr	r2, [sp, #4]
    37cc:	681b      	ldr	r3, [r3, #0]
    37ce:	429a      	cmp	r2, r3
    37d0:	d1ab      	bne.n	372a <Macro_showTriggerType+0x26>
    37d2:	480d      	ldr	r0, [pc, #52]	; (3808 <Macro_showTriggerType+0x104>)
    37d4:	e7c4      	b.n	3760 <Macro_showTriggerType+0x5c>
    37d6:	bf00      	nop
    37d8:	1fffe9d0 	.word	0x1fffe9d0
    37dc:	0000a140 	.word	0x0000a140
    37e0:	0000bbf5 	.word	0x0000bbf5
    37e4:	0000a100 	.word	0x0000a100
    37e8:	0000a103 	.word	0x0000a103
    37ec:	0000a107 	.word	0x0000a107
    37f0:	0000a10a 	.word	0x0000a10a
    37f4:	0000a110 	.word	0x0000a110
    37f8:	0000a11a 	.word	0x0000a11a
    37fc:	0000a120 	.word	0x0000a120
    3800:	0000a127 	.word	0x0000a127
    3804:	0000a130 	.word	0x0000a130
    3808:	0000a137 	.word	0x0000a137

0000380c <Macro_testThreadSafe_capability>:
{
    380c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    380e:	4c18      	ldr	r4, [pc, #96]	; (3870 <Macro_testThreadSafe_capability+0x64>)
    3810:	460d      	mov	r5, r1
    3812:	6823      	ldr	r3, [r4, #0]
    3814:	9301      	str	r3, [sp, #4]
    3816:	4607      	mov	r7, r0
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    3818:	4611      	mov	r1, r2
    381a:	4628      	mov	r0, r5
{
    381c:	4616      	mov	r6, r2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    381e:	f7ff f883 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    3822:	28ff      	cmp	r0, #255	; 0xff
    3824:	d10b      	bne.n	383e <Macro_testThreadSafe_capability+0x32>
		print("Macro_testThreadSafe()");
    3826:	9a01      	ldr	r2, [sp, #4]
    3828:	6823      	ldr	r3, [r4, #0]
    382a:	429a      	cmp	r2, r3
    382c:	d001      	beq.n	3832 <Macro_testThreadSafe_capability+0x26>
	print(NL);
    382e:	f7fd fe79 	bl	1524 <__stack_chk_fail>
		print("Macro_testThreadSafe()");
    3832:	4810      	ldr	r0, [pc, #64]	; (3874 <Macro_testThreadSafe_capability+0x68>)
}
    3834:	b003      	add	sp, #12
    3836:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	print(NL);
    383a:	f005 be25 	b.w	9488 <_print>
	print("ThreadSafe: ");
    383e:	480e      	ldr	r0, [pc, #56]	; (3878 <Macro_testThreadSafe_capability+0x6c>)
    3840:	f005 fe22 	bl	9488 <_print>
	Macro_showTriggerType( (TriggerType)stateType );
    3844:	4630      	mov	r0, r6
    3846:	f7ff ff5d 	bl	3704 <Macro_showTriggerType>
	print(" ");
    384a:	480c      	ldr	r0, [pc, #48]	; (387c <Macro_testThreadSafe_capability+0x70>)
    384c:	f005 fe1c 	bl	9488 <_print>
	Macro_showScheduleType( (ScheduleState)state );
    3850:	4628      	mov	r0, r5
    3852:	f7ff fef5 	bl	3640 <Macro_showScheduleType>
	print(" - ");
    3856:	480a      	ldr	r0, [pc, #40]	; (3880 <Macro_testThreadSafe_capability+0x74>)
    3858:	f005 fe16 	bl	9488 <_print>
	printHex32( (intptr_t)trigger );
    385c:	2101      	movs	r1, #1
    385e:	4638      	mov	r0, r7
    3860:	f005 ff8a 	bl	9778 <printHex32_op>
	print(NL);
    3864:	9a01      	ldr	r2, [sp, #4]
    3866:	6823      	ldr	r3, [r4, #0]
    3868:	429a      	cmp	r2, r3
    386a:	d1e0      	bne.n	382e <Macro_testThreadSafe_capability+0x22>
    386c:	4805      	ldr	r0, [pc, #20]	; (3884 <Macro_testThreadSafe_capability+0x78>)
    386e:	e7e1      	b.n	3834 <Macro_testThreadSafe_capability+0x28>
    3870:	1fffe9d0 	.word	0x1fffe9d0
    3874:	0000a148 	.word	0x0000a148
    3878:	0000a15f 	.word	0x0000a15f
    387c:	0000d6a4 	.word	0x0000d6a4
    3880:	0000cc04 	.word	0x0000cc04
    3884:	0000d348 	.word	0x0000d348

00003888 <Macro_testThreadUnsafe_capability>:
{
    3888:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    388a:	4c18      	ldr	r4, [pc, #96]	; (38ec <Macro_testThreadUnsafe_capability+0x64>)
    388c:	460d      	mov	r5, r1
    388e:	6823      	ldr	r3, [r4, #0]
    3890:	9301      	str	r3, [sp, #4]
    3892:	4607      	mov	r7, r0
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    3894:	4611      	mov	r1, r2
    3896:	4628      	mov	r0, r5
{
    3898:	4616      	mov	r6, r2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    389a:	f7ff f845 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    389e:	28ff      	cmp	r0, #255	; 0xff
    38a0:	d10b      	bne.n	38ba <Macro_testThreadUnsafe_capability+0x32>
		print("Macro_testThreadUnsafe()");
    38a2:	9a01      	ldr	r2, [sp, #4]
    38a4:	6823      	ldr	r3, [r4, #0]
    38a6:	429a      	cmp	r2, r3
    38a8:	d001      	beq.n	38ae <Macro_testThreadUnsafe_capability+0x26>
	print(NL);
    38aa:	f7fd fe3b 	bl	1524 <__stack_chk_fail>
		print("Macro_testThreadUnsafe()");
    38ae:	4810      	ldr	r0, [pc, #64]	; (38f0 <Macro_testThreadUnsafe_capability+0x68>)
}
    38b0:	b003      	add	sp, #12
    38b2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	print(NL);
    38b6:	f005 bde7 	b.w	9488 <_print>
	print("ThreadUnsafe: ");
    38ba:	480e      	ldr	r0, [pc, #56]	; (38f4 <Macro_testThreadUnsafe_capability+0x6c>)
    38bc:	f005 fde4 	bl	9488 <_print>
	Macro_showTriggerType( (TriggerType)stateType );
    38c0:	4630      	mov	r0, r6
    38c2:	f7ff ff1f 	bl	3704 <Macro_showTriggerType>
	print(" ");
    38c6:	480c      	ldr	r0, [pc, #48]	; (38f8 <Macro_testThreadUnsafe_capability+0x70>)
    38c8:	f005 fdde 	bl	9488 <_print>
	Macro_showScheduleType( (ScheduleState)state );
    38cc:	4628      	mov	r0, r5
    38ce:	f7ff feb7 	bl	3640 <Macro_showScheduleType>
	print(" - ");
    38d2:	480a      	ldr	r0, [pc, #40]	; (38fc <Macro_testThreadUnsafe_capability+0x74>)
    38d4:	f005 fdd8 	bl	9488 <_print>
	printHex32( (intptr_t)trigger );
    38d8:	2101      	movs	r1, #1
    38da:	4638      	mov	r0, r7
    38dc:	f005 ff4c 	bl	9778 <printHex32_op>
	print(NL);
    38e0:	9a01      	ldr	r2, [sp, #4]
    38e2:	6823      	ldr	r3, [r4, #0]
    38e4:	429a      	cmp	r2, r3
    38e6:	d1e0      	bne.n	38aa <Macro_testThreadUnsafe_capability+0x22>
    38e8:	4805      	ldr	r0, [pc, #20]	; (3900 <Macro_testThreadUnsafe_capability+0x78>)
    38ea:	e7e1      	b.n	38b0 <Macro_testThreadUnsafe_capability+0x28>
    38ec:	1fffe9d0 	.word	0x1fffe9d0
    38f0:	0000a16c 	.word	0x0000a16c
    38f4:	0000a185 	.word	0x0000a185
    38f8:	0000d6a4 	.word	0x0000d6a4
    38fc:	0000cc04 	.word	0x0000cc04
    3900:	0000d348 	.word	0x0000d348

00003904 <Macro_showTriggerEvent>:
{
    3904:	b537      	push	{r0, r1, r2, r4, r5, lr}
    3906:	4d18      	ldr	r5, [pc, #96]	; (3968 <Macro_showTriggerEvent+0x64>)
    3908:	4604      	mov	r4, r0
    390a:	682b      	ldr	r3, [r5, #0]
	Macro_showTriggerType( event->type );
    390c:	7800      	ldrb	r0, [r0, #0]
{
    390e:	9301      	str	r3, [sp, #4]
	Macro_showTriggerType( event->type );
    3910:	f7ff fef8 	bl	3704 <Macro_showTriggerType>
	print(" ");
    3914:	4815      	ldr	r0, [pc, #84]	; (396c <Macro_showTriggerEvent+0x68>)
    3916:	f005 fdb7 	bl	9488 <_print>
    391a:	7823      	ldrb	r3, [r4, #0]
    391c:	7860      	ldrb	r0, [r4, #1]
    391e:	3b05      	subs	r3, #5
    3920:	b2db      	uxtb	r3, r3
    3922:	2b10      	cmp	r3, #16
    3924:	d816      	bhi.n	3954 <Macro_showTriggerEvent+0x50>
    3926:	2201      	movs	r2, #1
    3928:	fa02 f303 	lsl.w	r3, r2, r3
    392c:	4a10      	ldr	r2, [pc, #64]	; (3970 <Macro_showTriggerEvent+0x6c>)
    392e:	401a      	ands	r2, r3
    3930:	b182      	cbz	r2, 3954 <Macro_showTriggerEvent+0x50>
		printInt8( event->state );
    3932:	f005 fe13 	bl	955c <printInt8>
	print(" ");
    3936:	480d      	ldr	r0, [pc, #52]	; (396c <Macro_showTriggerEvent+0x68>)
    3938:	f005 fda6 	bl	9488 <_print>
	printInt8( event->type );
    393c:	7820      	ldrb	r0, [r4, #0]
    393e:	f005 fe0d 	bl	955c <printInt8>
	print(":");
    3942:	480c      	ldr	r0, [pc, #48]	; (3974 <Macro_showTriggerEvent+0x70>)
    3944:	f005 fda0 	bl	9488 <_print>
	printInt8( event->index );
    3948:	9a01      	ldr	r2, [sp, #4]
    394a:	682b      	ldr	r3, [r5, #0]
    394c:	429a      	cmp	r2, r3
    394e:	d004      	beq.n	395a <Macro_showTriggerEvent+0x56>
    3950:	f7fd fde8 	bl	1524 <__stack_chk_fail>
		Macro_showScheduleType( event->state );
    3954:	f7ff fe74 	bl	3640 <Macro_showScheduleType>
		break;
    3958:	e7ed      	b.n	3936 <Macro_showTriggerEvent+0x32>
	printInt8( event->index );
    395a:	78a0      	ldrb	r0, [r4, #2]
}
    395c:	b003      	add	sp, #12
    395e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt8( event->index );
    3962:	f005 bdfb 	b.w	955c <printInt8>
    3966:	bf00      	nop
    3968:	1fffe9d0 	.word	0x1fffe9d0
    396c:	0000d6a4 	.word	0x0000d6a4
    3970:	0001000f 	.word	0x0001000f
    3974:	0000d681 	.word	0x0000d681

00003978 <Macro_keyState>:
{
    3978:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    397a:	4d17      	ldr	r5, [pc, #92]	; (39d8 <Macro_keyState+0x60>)
    397c:	682b      	ldr	r3, [r5, #0]
    397e:	9301      	str	r3, [sp, #4]
	switch ( state )
    3980:	1e4b      	subs	r3, r1, #1
    3982:	2b02      	cmp	r3, #2
{
    3984:	4604      	mov	r4, r0
    3986:	462f      	mov	r7, r5
	switch ( state )
    3988:	d81f      	bhi.n	39ca <Macro_keyState+0x52>
		if ( scanCode > MaxScanCode_KLL )
    398a:	283f      	cmp	r0, #63	; 0x3f
    398c:	d911      	bls.n	39b2 <Macro_keyState+0x3a>
			warn_msg("ScanCode is out of range/not defined: ");
    398e:	4813      	ldr	r0, [pc, #76]	; (39dc <Macro_keyState+0x64>)
    3990:	f005 fd7a 	bl	9488 <_print>
			printInt16( scanCode );
    3994:	4620      	mov	r0, r4
    3996:	f005 fe17 	bl	95c8 <printInt16>
			print( NL );
    399a:	9a01      	ldr	r2, [sp, #4]
    399c:	682b      	ldr	r3, [r5, #0]
    399e:	429a      	cmp	r2, r3
    39a0:	d001      	beq.n	39a6 <Macro_keyState+0x2e>
}
    39a2:	f7fd fdbf 	bl	1524 <__stack_chk_fail>
			print( NL );
    39a6:	480e      	ldr	r0, [pc, #56]	; (39e0 <Macro_keyState+0x68>)
}
    39a8:	b003      	add	sp, #12
    39aa:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			print( NL );
    39ae:	f005 bd6b 	b.w	9488 <_print>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    39b2:	4a0c      	ldr	r2, [pc, #48]	; (39e4 <Macro_keyState+0x6c>)
    39b4:	4d0c      	ldr	r5, [pc, #48]	; (39e8 <Macro_keyState+0x70>)
    39b6:	8813      	ldrh	r3, [r2, #0]
    39b8:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    39bc:	182e      	adds	r6, r5, r0
		macroTriggerEventBufferSize++;
    39be:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    39c0:	7071      	strb	r1, [r6, #1]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    39c2:	2100      	movs	r1, #0
    39c4:	5429      	strb	r1, [r5, r0]
			index = scanCode;
    39c6:	70b4      	strb	r4, [r6, #2]
		macroTriggerEventBufferSize++;
    39c8:	8013      	strh	r3, [r2, #0]
}
    39ca:	9a01      	ldr	r2, [sp, #4]
    39cc:	683b      	ldr	r3, [r7, #0]
    39ce:	429a      	cmp	r2, r3
    39d0:	d1e7      	bne.n	39a2 <Macro_keyState+0x2a>
    39d2:	b003      	add	sp, #12
    39d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    39d6:	bf00      	nop
    39d8:	1fffe9d0 	.word	0x1fffe9d0
    39dc:	00009f88 	.word	0x00009f88
    39e0:	0000d348 	.word	0x0000d348
    39e4:	1ffffcb0 	.word	0x1ffffcb0
    39e8:	1ffffcb5 	.word	0x1ffffcb5

000039ec <cliFunc_keyHold>:
{
    39ec:	b530      	push	{r4, r5, lr}
    39ee:	b085      	sub	sp, #20
    39f0:	4c0f      	ldr	r4, [pc, #60]	; (3a30 <cliFunc_keyHold+0x44>)
	char* arg2Ptr = args;
    39f2:	ad04      	add	r5, sp, #16
{
    39f4:	6822      	ldr	r2, [r4, #0]
	char* arg2Ptr = args;
    39f6:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    39fa:	9203      	str	r2, [sp, #12]
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    39fc:	9802      	ldr	r0, [sp, #8]
    39fe:	462a      	mov	r2, r5
    3a00:	a901      	add	r1, sp, #4
    3a02:	f005 f813 	bl	8a2c <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    3a06:	9801      	ldr	r0, [sp, #4]
    3a08:	7803      	ldrb	r3, [r0, #0]
    3a0a:	b14b      	cbz	r3, 3a20 <cliFunc_keyHold+0x34>
		switch ( arg1Ptr[0] )
    3a0c:	2b53      	cmp	r3, #83	; 0x53
    3a0e:	d1f5      	bne.n	39fc <cliFunc_keyHold+0x10>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x02 ); // Hold scancode
    3a10:	3001      	adds	r0, #1
    3a12:	f005 ff09 	bl	9828 <numToInt>
    3a16:	2102      	movs	r1, #2
    3a18:	b2c0      	uxtb	r0, r0
    3a1a:	f7ff ffad 	bl	3978 <Macro_keyState>
			break;
    3a1e:	e7ed      	b.n	39fc <cliFunc_keyHold+0x10>
}
    3a20:	9a03      	ldr	r2, [sp, #12]
    3a22:	6823      	ldr	r3, [r4, #0]
    3a24:	429a      	cmp	r2, r3
    3a26:	d001      	beq.n	3a2c <cliFunc_keyHold+0x40>
    3a28:	f7fd fd7c 	bl	1524 <__stack_chk_fail>
    3a2c:	b005      	add	sp, #20
    3a2e:	bd30      	pop	{r4, r5, pc}
    3a30:	1fffe9d0 	.word	0x1fffe9d0

00003a34 <cliFunc_keyPress>:
{
    3a34:	b530      	push	{r4, r5, lr}
    3a36:	b085      	sub	sp, #20
    3a38:	4c0f      	ldr	r4, [pc, #60]	; (3a78 <cliFunc_keyPress+0x44>)
	char* arg2Ptr = args;
    3a3a:	ad04      	add	r5, sp, #16
{
    3a3c:	6822      	ldr	r2, [r4, #0]
	char* arg2Ptr = args;
    3a3e:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    3a42:	9203      	str	r2, [sp, #12]
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3a44:	9802      	ldr	r0, [sp, #8]
    3a46:	462a      	mov	r2, r5
    3a48:	a901      	add	r1, sp, #4
    3a4a:	f004 ffef 	bl	8a2c <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    3a4e:	9801      	ldr	r0, [sp, #4]
    3a50:	7803      	ldrb	r3, [r0, #0]
    3a52:	b14b      	cbz	r3, 3a68 <cliFunc_keyPress+0x34>
		switch ( arg1Ptr[0] )
    3a54:	2b53      	cmp	r3, #83	; 0x53
    3a56:	d1f5      	bne.n	3a44 <cliFunc_keyPress+0x10>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x01 ); // Press scancode
    3a58:	3001      	adds	r0, #1
    3a5a:	f005 fee5 	bl	9828 <numToInt>
    3a5e:	2101      	movs	r1, #1
    3a60:	b2c0      	uxtb	r0, r0
    3a62:	f7ff ff89 	bl	3978 <Macro_keyState>
			break;
    3a66:	e7ed      	b.n	3a44 <cliFunc_keyPress+0x10>
}
    3a68:	9a03      	ldr	r2, [sp, #12]
    3a6a:	6823      	ldr	r3, [r4, #0]
    3a6c:	429a      	cmp	r2, r3
    3a6e:	d001      	beq.n	3a74 <cliFunc_keyPress+0x40>
    3a70:	f7fd fd58 	bl	1524 <__stack_chk_fail>
    3a74:	b005      	add	sp, #20
    3a76:	bd30      	pop	{r4, r5, pc}
    3a78:	1fffe9d0 	.word	0x1fffe9d0

00003a7c <cliFunc_keyRelease>:
{
    3a7c:	b530      	push	{r4, r5, lr}
    3a7e:	b085      	sub	sp, #20
    3a80:	4c0f      	ldr	r4, [pc, #60]	; (3ac0 <cliFunc_keyRelease+0x44>)
	char* arg2Ptr = args;
    3a82:	ad04      	add	r5, sp, #16
{
    3a84:	6822      	ldr	r2, [r4, #0]
	char* arg2Ptr = args;
    3a86:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    3a8a:	9203      	str	r2, [sp, #12]
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3a8c:	9802      	ldr	r0, [sp, #8]
    3a8e:	462a      	mov	r2, r5
    3a90:	a901      	add	r1, sp, #4
    3a92:	f004 ffcb 	bl	8a2c <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    3a96:	9801      	ldr	r0, [sp, #4]
    3a98:	7803      	ldrb	r3, [r0, #0]
    3a9a:	b14b      	cbz	r3, 3ab0 <cliFunc_keyRelease+0x34>
		switch ( arg1Ptr[0] )
    3a9c:	2b53      	cmp	r3, #83	; 0x53
    3a9e:	d1f5      	bne.n	3a8c <cliFunc_keyRelease+0x10>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x03 ); // Release scancode
    3aa0:	3001      	adds	r0, #1
    3aa2:	f005 fec1 	bl	9828 <numToInt>
    3aa6:	2103      	movs	r1, #3
    3aa8:	b2c0      	uxtb	r0, r0
    3aaa:	f7ff ff65 	bl	3978 <Macro_keyState>
			break;
    3aae:	e7ed      	b.n	3a8c <cliFunc_keyRelease+0x10>
}
    3ab0:	9a03      	ldr	r2, [sp, #12]
    3ab2:	6823      	ldr	r3, [r4, #0]
    3ab4:	429a      	cmp	r2, r3
    3ab6:	d001      	beq.n	3abc <cliFunc_keyRelease+0x40>
    3ab8:	f7fd fd34 	bl	1524 <__stack_chk_fail>
    3abc:	b005      	add	sp, #20
    3abe:	bd30      	pop	{r4, r5, pc}
    3ac0:	1fffe9d0 	.word	0x1fffe9d0

00003ac4 <Macro_ledState>:
{
    3ac4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3ac6:	4b0d      	ldr	r3, [pc, #52]	; (3afc <Macro_ledState+0x38>)
    3ac8:	681a      	ldr	r2, [r3, #0]
    3aca:	9201      	str	r2, [sp, #4]
	switch ( state )
    3acc:	1e4a      	subs	r2, r1, #1
    3ace:	2a02      	cmp	r2, #2
    3ad0:	461a      	mov	r2, r3
    3ad2:	d80b      	bhi.n	3aec <Macro_ledState+0x28>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    3ad4:	4c0a      	ldr	r4, [pc, #40]	; (3b00 <Macro_ledState+0x3c>)
    3ad6:	4e0b      	ldr	r6, [pc, #44]	; (3b04 <Macro_ledState+0x40>)
    3ad8:	8823      	ldrh	r3, [r4, #0]
    3ada:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    3ade:	1977      	adds	r7, r6, r5
		macroTriggerEventBufferSize++;
    3ae0:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    3ae2:	7079      	strb	r1, [r7, #1]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    3ae4:	2104      	movs	r1, #4
    3ae6:	5571      	strb	r1, [r6, r5]
	uint8_t index = ledCode;
    3ae8:	70b8      	strb	r0, [r7, #2]
		macroTriggerEventBufferSize++;
    3aea:	8023      	strh	r3, [r4, #0]
}
    3aec:	9901      	ldr	r1, [sp, #4]
    3aee:	6813      	ldr	r3, [r2, #0]
    3af0:	4299      	cmp	r1, r3
    3af2:	d001      	beq.n	3af8 <Macro_ledState+0x34>
    3af4:	f7fd fd16 	bl	1524 <__stack_chk_fail>
    3af8:	b003      	add	sp, #12
    3afa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3afc:	1fffe9d0 	.word	0x1fffe9d0
    3b00:	1ffffcb0 	.word	0x1ffffcb0
    3b04:	1ffffcb5 	.word	0x1ffffcb5

00003b08 <Macro_layerState>:
{
    3b08:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3b0a:	4d18      	ldr	r5, [pc, #96]	; (3b6c <Macro_layerState+0x64>)
    3b0c:	682b      	ldr	r3, [r5, #0]
    3b0e:	9301      	str	r3, [sp, #4]
	switch ( state & ScheduleType_D )
    3b10:	f001 0303 	and.w	r3, r1, #3
    3b14:	3b01      	subs	r3, #1
    3b16:	2b02      	cmp	r3, #2
{
    3b18:	4604      	mov	r4, r0
    3b1a:	462f      	mov	r7, r5
	switch ( state & ScheduleType_D )
    3b1c:	d81f      	bhi.n	3b5e <Macro_layerState+0x56>
		if ( layerIndex > LayerNum_KLL )
    3b1e:	2802      	cmp	r0, #2
    3b20:	d911      	bls.n	3b46 <Macro_layerState+0x3e>
			warn_msg("LayerIndex is out of range/not defined: ");
    3b22:	4813      	ldr	r0, [pc, #76]	; (3b70 <Macro_layerState+0x68>)
    3b24:	f005 fcb0 	bl	9488 <_print>
			printInt16( layerIndex );
    3b28:	4620      	mov	r0, r4
    3b2a:	f005 fd4d 	bl	95c8 <printInt16>
			print( NL );
    3b2e:	9a01      	ldr	r2, [sp, #4]
    3b30:	682b      	ldr	r3, [r5, #0]
    3b32:	429a      	cmp	r2, r3
    3b34:	d001      	beq.n	3b3a <Macro_layerState+0x32>
}
    3b36:	f7fd fcf5 	bl	1524 <__stack_chk_fail>
			print( NL );
    3b3a:	480e      	ldr	r0, [pc, #56]	; (3b74 <Macro_layerState+0x6c>)
}
    3b3c:	b003      	add	sp, #12
    3b3e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			print( NL );
    3b42:	f005 bca1 	b.w	9488 <_print>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    3b46:	4a0c      	ldr	r2, [pc, #48]	; (3b78 <Macro_layerState+0x70>)
    3b48:	4d0c      	ldr	r5, [pc, #48]	; (3b7c <Macro_layerState+0x74>)
    3b4a:	8813      	ldrh	r3, [r2, #0]
    3b4c:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    3b50:	182e      	adds	r6, r5, r0
		macroTriggerEventBufferSize++;
    3b52:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    3b54:	7071      	strb	r1, [r6, #1]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    3b56:	2109      	movs	r1, #9
    3b58:	5429      	strb	r1, [r5, r0]
			index = layerIndex;
    3b5a:	70b4      	strb	r4, [r6, #2]
		macroTriggerEventBufferSize++;
    3b5c:	8013      	strh	r3, [r2, #0]
}
    3b5e:	9a01      	ldr	r2, [sp, #4]
    3b60:	683b      	ldr	r3, [r7, #0]
    3b62:	429a      	cmp	r2, r3
    3b64:	d1e7      	bne.n	3b36 <Macro_layerState+0x2e>
    3b66:	b003      	add	sp, #12
    3b68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3b6a:	bf00      	nop
    3b6c:	1fffe9d0 	.word	0x1fffe9d0
    3b70:	00009fc4 	.word	0x00009fc4
    3b74:	0000d348 	.word	0x0000d348
    3b78:	1ffffcb0 	.word	0x1ffffcb0
    3b7c:	1ffffcb5 	.word	0x1ffffcb5

00003b80 <Macro_timeState>:
{
    3b80:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3b82:	4c1d      	ldr	r4, [pc, #116]	; (3bf8 <Macro_timeState+0x78>)
    3b84:	6823      	ldr	r3, [r4, #0]
    3b86:	9301      	str	r3, [sp, #4]
	switch ( type )
    3b88:	f1a0 0311 	sub.w	r3, r0, #17
    3b8c:	2b03      	cmp	r3, #3
{
    3b8e:	4605      	mov	r5, r0
    3b90:	460e      	mov	r6, r1
    3b92:	46a4      	mov	ip, r4
	switch ( type )
    3b94:	d90c      	bls.n	3bb0 <Macro_timeState+0x30>
		warn_msg("Invalid time state trigger update: ");
    3b96:	4819      	ldr	r0, [pc, #100]	; (3bfc <Macro_timeState+0x7c>)
    3b98:	f005 fc76 	bl	9488 <_print>
		printHex( type );
    3b9c:	2101      	movs	r1, #1
    3b9e:	4628      	mov	r0, r5
    3ba0:	f005 fd98 	bl	96d4 <printHex_op>
		print(NL);
    3ba4:	9a01      	ldr	r2, [sp, #4]
    3ba6:	6823      	ldr	r3, [r4, #0]
    3ba8:	429a      	cmp	r2, r3
    3baa:	d00a      	beq.n	3bc2 <Macro_timeState+0x42>
}
    3bac:	f7fd fcba 	bl	1524 <__stack_chk_fail>
	if ( cur_time > 0xFF )
    3bb0:	29ff      	cmp	r1, #255	; 0xff
    3bb2:	d90c      	bls.n	3bce <Macro_timeState+0x4e>
		warn_msg("Only 255 time instances are accepted for a time state trigger: ");
    3bb4:	4812      	ldr	r0, [pc, #72]	; (3c00 <Macro_timeState+0x80>)
    3bb6:	f005 fc67 	bl	9488 <_print>
		printInt16( cur_time );
    3bba:	4630      	mov	r0, r6
    3bbc:	f005 fd04 	bl	95c8 <printInt16>
    3bc0:	e7f0      	b.n	3ba4 <Macro_timeState+0x24>
		print(NL);
    3bc2:	4810      	ldr	r0, [pc, #64]	; (3c04 <Macro_timeState+0x84>)
}
    3bc4:	b003      	add	sp, #12
    3bc6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		print(NL);
    3bca:	f005 bc5d 	b.w	9488 <_print>
	switch ( state )
    3bce:	1e53      	subs	r3, r2, #1
    3bd0:	2b02      	cmp	r3, #2
    3bd2:	d80a      	bhi.n	3bea <Macro_timeState+0x6a>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    3bd4:	490c      	ldr	r1, [pc, #48]	; (3c08 <Macro_timeState+0x88>)
    3bd6:	4c0d      	ldr	r4, [pc, #52]	; (3c0c <Macro_timeState+0x8c>)
    3bd8:	880b      	ldrh	r3, [r1, #0]
    3bda:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    3bde:	1827      	adds	r7, r4, r0
		macroTriggerEventBufferSize++;
    3be0:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    3be2:	5425      	strb	r5, [r4, r0]
	uint8_t index = cur_time;
    3be4:	70be      	strb	r6, [r7, #2]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    3be6:	707a      	strb	r2, [r7, #1]
		macroTriggerEventBufferSize++;
    3be8:	800b      	strh	r3, [r1, #0]
}
    3bea:	9a01      	ldr	r2, [sp, #4]
    3bec:	f8dc 3000 	ldr.w	r3, [ip]
    3bf0:	429a      	cmp	r2, r3
    3bf2:	d1db      	bne.n	3bac <Macro_timeState+0x2c>
    3bf4:	b003      	add	sp, #12
    3bf6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3bf8:	1fffe9d0 	.word	0x1fffe9d0
    3bfc:	0000a194 	.word	0x0000a194
    3c00:	0000a1cd 	.word	0x0000a1cd
    3c04:	0000d348 	.word	0x0000d348
    3c08:	1ffffcb0 	.word	0x1ffffcb0
    3c0c:	1ffffcb5 	.word	0x1ffffcb5

00003c10 <Macro_rotationState>:
{
    3c10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    3c12:	4a15      	ldr	r2, [pc, #84]	; (3c68 <Macro_rotationState+0x58>)
    3c14:	6813      	ldr	r3, [r2, #0]
    3c16:	9301      	str	r3, [sp, #4]
	if ( index > RotationNum )
    3c18:	b9e8      	cbnz	r0, 3c56 <Macro_rotationState+0x46>
	int16_t position = Macro_rotation_store[index] + increment;
    3c1a:	4b14      	ldr	r3, [pc, #80]	; (3c6c <Macro_rotationState+0x5c>)
    3c1c:	781c      	ldrb	r4, [r3, #0]
	if ( Macro_rotation_store[index] == 255 )
    3c1e:	2cff      	cmp	r4, #255	; 0xff
    3c20:	d00a      	beq.n	3c38 <Macro_rotationState+0x28>
	int16_t position = Macro_rotation_store[index] + increment;
    3c22:	1860      	adds	r0, r4, r1
    3c24:	2800      	cmp	r0, #0
    3c26:	bfa8      	it	ge
    3c28:	1a00      	subge	r0, r0, r0
	if ( position < 0 )
    3c2a:	b128      	cbz	r0, 3c38 <Macro_rotationState+0x28>
			position += Rotation_MaxParameter[index] - 1;
    3c2c:	4601      	mov	r1, r0
		while ( position * -1 > Rotation_MaxParameter[index] )
    3c2e:	2900      	cmp	r1, #0
    3c30:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    3c34:	b200      	sxth	r0, r0
    3c36:	dbf9      	blt.n	3c2c <Macro_rotationState+0x1c>
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    3c38:	490d      	ldr	r1, [pc, #52]	; (3c70 <Macro_rotationState+0x60>)
    3c3a:	4d0e      	ldr	r5, [pc, #56]	; (3c74 <Macro_rotationState+0x64>)
	Macro_rotation_store[index] = position;
    3c3c:	b2c0      	uxtb	r0, r0
    3c3e:	7018      	strb	r0, [r3, #0]
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    3c40:	880b      	ldrh	r3, [r1, #0]
    3c42:	eb03 0443 	add.w	r4, r3, r3, lsl #1
    3c46:	192e      	adds	r6, r5, r4
    3c48:	2700      	movs	r7, #0
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = position;
    3c4a:	7070      	strb	r0, [r6, #1]
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    3c4c:	2015      	movs	r0, #21
	macroTriggerEventBufferSize++;
    3c4e:	3301      	adds	r3, #1
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    3c50:	5528      	strb	r0, [r5, r4]
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    3c52:	70b7      	strb	r7, [r6, #2]
	macroTriggerEventBufferSize++;
    3c54:	800b      	strh	r3, [r1, #0]
}
    3c56:	9901      	ldr	r1, [sp, #4]
    3c58:	6813      	ldr	r3, [r2, #0]
    3c5a:	4299      	cmp	r1, r3
    3c5c:	d001      	beq.n	3c62 <Macro_rotationState+0x52>
    3c5e:	f7fd fc61 	bl	1524 <__stack_chk_fail>
    3c62:	b003      	add	sp, #12
    3c64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3c66:	bf00      	nop
    3c68:	1fffe9d0 	.word	0x1fffe9d0
    3c6c:	1ffff2a0 	.word	0x1ffff2a0
    3c70:	1ffffcb0 	.word	0x1ffffcb0
    3c74:	1ffffcb5 	.word	0x1ffffcb5

00003c78 <Macro_rotate_capability>:
{
    3c78:	b537      	push	{r0, r1, r2, r4, r5, lr}
    3c7a:	4c13      	ldr	r4, [pc, #76]	; (3cc8 <Macro_rotate_capability+0x50>)
    3c7c:	4608      	mov	r0, r1
    3c7e:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    3c80:	4611      	mov	r1, r2
{
    3c82:	6823      	ldr	r3, [r4, #0]
    3c84:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    3c86:	f7fe fe4f 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    3c8a:	2801      	cmp	r0, #1
	Macro_rotationState( index, increment );
    3c8c:	9a01      	ldr	r2, [sp, #4]
    3c8e:	6823      	ldr	r3, [r4, #0]
	switch ( cstate )
    3c90:	d00b      	beq.n	3caa <Macro_rotate_capability+0x32>
    3c92:	28ff      	cmp	r0, #255	; 0xff
    3c94:	d113      	bne.n	3cbe <Macro_rotate_capability+0x46>
		print("Macro_rotate()");
    3c96:	429a      	cmp	r2, r3
    3c98:	d001      	beq.n	3c9e <Macro_rotate_capability+0x26>
}
    3c9a:	f7fd fc43 	bl	1524 <__stack_chk_fail>
		print("Macro_rotate()");
    3c9e:	480b      	ldr	r0, [pc, #44]	; (3ccc <Macro_rotate_capability+0x54>)
}
    3ca0:	b003      	add	sp, #12
    3ca2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		print("Macro_rotate()");
    3ca6:	f005 bbef 	b.w	9488 <_print>
	Macro_rotationState( index, increment );
    3caa:	429a      	cmp	r2, r3
    3cac:	d1f5      	bne.n	3c9a <Macro_rotate_capability+0x22>
    3cae:	f995 1001 	ldrsb.w	r1, [r5, #1]
    3cb2:	7828      	ldrb	r0, [r5, #0]
}
    3cb4:	b003      	add	sp, #12
    3cb6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	Macro_rotationState( index, increment );
    3cba:	f7ff bfa9 	b.w	3c10 <Macro_rotationState>
}
    3cbe:	429a      	cmp	r2, r3
    3cc0:	d1eb      	bne.n	3c9a <Macro_rotate_capability+0x22>
    3cc2:	b003      	add	sp, #12
    3cc4:	bd30      	pop	{r4, r5, pc}
    3cc6:	bf00      	nop
    3cc8:	1fffe9d0 	.word	0x1fffe9d0
    3ccc:	0000a0b8 	.word	0x0000a0b8

00003cd0 <Macro_tick_update>:
{
    3cd0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    3cd4:	4e17      	ldr	r6, [pc, #92]	; (3d34 <Macro_tick_update+0x64>)
    3cd6:	4605      	mov	r5, r0
    3cd8:	6833      	ldr	r3, [r6, #0]
    3cda:	9301      	str	r3, [sp, #4]
    3cdc:	4688      	mov	r8, r1
	uint32_t ticks = Time_tick_update( store );
    3cde:	f7fe f8e7 	bl	1eb0 <Time_tick_update>
	if ( store->fresh_store )
    3ce2:	7e2f      	ldrb	r7, [r5, #24]
	uint32_t ticks = Time_tick_update( store );
    3ce4:	4604      	mov	r4, r0
	if ( store->fresh_store )
    3ce6:	b167      	cbz	r7, 3d02 <Macro_tick_update+0x32>
		Time_tick_reset( store );
    3ce8:	4628      	mov	r0, r5
    3cea:	f7fe f8a7 	bl	1e3c <Time_tick_reset>
		store->fresh_store = 0;
    3cee:	2100      	movs	r1, #0
    3cf0:	7629      	strb	r1, [r5, #24]
		Macro_timeState( type, 0, ScheduleType_A );
    3cf2:	2201      	movs	r2, #1
    3cf4:	4640      	mov	r0, r8
    3cf6:	f7ff ff43 	bl	3b80 <Macro_timeState>
		store->ticks_since_start++;
    3cfa:	692b      	ldr	r3, [r5, #16]
    3cfc:	3301      	adds	r3, #1
    3cfe:	612b      	str	r3, [r5, #16]
		signal_sent = 1;
    3d00:	2701      	movs	r7, #1
	if ( ticks == 0 )
    3d02:	b934      	cbnz	r4, 3d12 <Macro_tick_update+0x42>
}
    3d04:	9a01      	ldr	r2, [sp, #4]
    3d06:	6833      	ldr	r3, [r6, #0]
    3d08:	429a      	cmp	r2, r3
    3d0a:	4638      	mov	r0, r7
    3d0c:	d00e      	beq.n	3d2c <Macro_tick_update+0x5c>
    3d0e:	f7fd fc09 	bl	1524 <__stack_chk_fail>
		uint16_t signal = store->ticks_since_start - ticks;
    3d12:	692b      	ldr	r3, [r5, #16]
    3d14:	1b1c      	subs	r4, r3, r4
	for (
    3d16:	692b      	ldr	r3, [r5, #16]
		signal++
    3d18:	b2a4      	uxth	r4, r4
	for (
    3d1a:	429c      	cmp	r4, r3
    3d1c:	d2f2      	bcs.n	3d04 <Macro_tick_update+0x34>
		Macro_timeState( type, signal, ScheduleStateSize_define );
    3d1e:	4621      	mov	r1, r4
    3d20:	2208      	movs	r2, #8
    3d22:	4640      	mov	r0, r8
    3d24:	f7ff ff2c 	bl	3b80 <Macro_timeState>
		signal++
    3d28:	3401      	adds	r4, #1
    3d2a:	e7f4      	b.n	3d16 <Macro_tick_update+0x46>
}
    3d2c:	b002      	add	sp, #8
    3d2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3d32:	bf00      	nop
    3d34:	1fffe9d0 	.word	0x1fffe9d0

00003d38 <Macro_poll>:
{
    3d38:	b507      	push	{r0, r1, r2, lr}
    3d3a:	4b07      	ldr	r3, [pc, #28]	; (3d58 <Macro_poll+0x20>)
    3d3c:	681a      	ldr	r2, [r3, #0]
    3d3e:	9201      	str	r2, [sp, #4]
	Result_process_delayed();
    3d40:	9a01      	ldr	r2, [sp, #4]
    3d42:	681b      	ldr	r3, [r3, #0]
    3d44:	429a      	cmp	r2, r3
    3d46:	d001      	beq.n	3d4c <Macro_poll+0x14>
    3d48:	f7fd fbec 	bl	1524 <__stack_chk_fail>
}
    3d4c:	b003      	add	sp, #12
    3d4e:	f85d eb04 	ldr.w	lr, [sp], #4
	Result_process_delayed();
    3d52:	f000 bc49 	b.w	45e8 <Result_process_delayed>
    3d56:	bf00      	nop
    3d58:	1fffe9d0 	.word	0x1fffe9d0

00003d5c <Macro_periodic>:
{
    3d5c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3d60:	4e52      	ldr	r6, [pc, #328]	; (3eac <Macro_periodic+0x150>)
	Latency_start_time( macroLatencyResource );
    3d62:	4f53      	ldr	r7, [pc, #332]	; (3eb0 <Macro_periodic+0x154>)
{
    3d64:	6833      	ldr	r3, [r6, #0]
	Latency_start_time( macroLatencyResource );
    3d66:	7838      	ldrb	r0, [r7, #0]
{
    3d68:	9301      	str	r3, [sp, #4]
	Latency_start_time( macroLatencyResource );
    3d6a:	f005 fabb 	bl	92e4 <Latency_start_time>
		uint8_t currentInterconnectCacheSize = macroInterconnectCacheSize;
    3d6e:	4b51      	ldr	r3, [pc, #324]	; (3eb4 <Macro_periodic+0x158>)
    3d70:	4c51      	ldr	r4, [pc, #324]	; (3eb8 <Macro_periodic+0x15c>)
    3d72:	781a      	ldrb	r2, [r3, #0]
    3d74:	f8df a168 	ldr.w	sl, [pc, #360]	; 3ee0 <Macro_periodic+0x184>
			macroTriggerEventBuffer[ macroTriggerEventBufferSize++ ] = macroInterconnectCache[ c ];
    3d78:	f8df b168 	ldr.w	fp, [pc, #360]	; 3ee4 <Macro_periodic+0x188>
		macroInterconnectCacheSize = 0;
    3d7c:	2100      	movs	r1, #0
    3d7e:	f04f 0903 	mov.w	r9, #3
    3d82:	7019      	strb	r1, [r3, #0]
    3d84:	fb19 4902 	smlabb	r9, r9, r2, r4
    3d88:	4698      	mov	r8, r3
    3d8a:	4655      	mov	r5, sl
		for ( uint8_t c = 0; c < currentInterconnectCacheSize; c++ )
    3d8c:	454c      	cmp	r4, r9
    3d8e:	f8ba 3000 	ldrh.w	r3, [sl]
    3d92:	d10a      	bne.n	3daa <Macro_periodic+0x4e>
	switch ( macroDebugMode )
    3d94:	4c49      	ldr	r4, [pc, #292]	; (3ebc <Macro_periodic+0x160>)
    3d96:	7823      	ldrb	r3, [r4, #0]
    3d98:	3b01      	subs	r3, #1
    3d9a:	2b01      	cmp	r3, #1
    3d9c:	d84a      	bhi.n	3e34 <Macro_periodic+0xd8>
    3d9e:	2000      	movs	r0, #0
			Macro_showTriggerEvent( &macroTriggerEventBuffer[trigger] );
    3da0:	f8df a140 	ldr.w	sl, [pc, #320]	; 3ee4 <Macro_periodic+0x188>
			print( NL );
    3da4:	f8df 811c 	ldr.w	r8, [pc, #284]	; 3ec4 <Macro_periodic+0x168>
    3da8:	e03e      	b.n	3e28 <Macro_periodic+0xcc>
			macroTriggerEventBuffer[ macroTriggerEventBufferSize++ ] = macroInterconnectCache[ c ];
    3daa:	1c5a      	adds	r2, r3, #1
    3dac:	f8aa 2000 	strh.w	r2, [sl]
    3db0:	4622      	mov	r2, r4
    3db2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    3db6:	f832 0d01 	ldrh.w	r0, [r2, #-1]!
    3dba:	f82b 0003 	strh.w	r0, [fp, r3]
    3dbe:	eb0b 0103 	add.w	r1, fp, r3
    3dc2:	7893      	ldrb	r3, [r2, #2]
    3dc4:	708b      	strb	r3, [r1, #2]
			switch ( macroInterconnectCache[ c ].type )
    3dc6:	f814 3c01 	ldrb.w	r3, [r4, #-1]
    3dca:	2b04      	cmp	r3, #4
    3dcc:	d90c      	bls.n	3de8 <Macro_periodic+0x8c>
    3dce:	2b15      	cmp	r3, #21
    3dd0:	d01e      	beq.n	3e10 <Macro_periodic+0xb4>
				erro_msg("Interconnect Trigger Event Type - Not Implemented ");
    3dd2:	483b      	ldr	r0, [pc, #236]	; (3ec0 <Macro_periodic+0x164>)
    3dd4:	f005 fb58 	bl	9488 <_print>
				printInt8( macroInterconnectCache[ c ].type );
    3dd8:	f814 0c01 	ldrb.w	r0, [r4, #-1]
    3ddc:	f005 fbbe 	bl	955c <printInt8>
				print( NL );
    3de0:	4838      	ldr	r0, [pc, #224]	; (3ec4 <Macro_periodic+0x168>)
    3de2:	f005 fb51 	bl	9488 <_print>
				break;
    3de6:	e013      	b.n	3e10 <Macro_periodic+0xb4>
				switch ( macroInterconnectCache[ c ].state )
    3de8:	7823      	ldrb	r3, [r4, #0]
    3dea:	2b01      	cmp	r3, #1
    3dec:	d110      	bne.n	3e10 <Macro_periodic+0xb4>
					macroInterconnectCache[ c ].state = ScheduleType_H;
    3dee:	2302      	movs	r3, #2
    3df0:	7023      	strb	r3, [r4, #0]
					macroInterconnectCache[ macroInterconnectCacheSize++ ] = macroInterconnectCache[ c ];
    3df2:	f898 3000 	ldrb.w	r3, [r8]
    3df6:	f8b2 c000 	ldrh.w	ip, [r2]
    3dfa:	1c59      	adds	r1, r3, #1
    3dfc:	f888 1000 	strb.w	r1, [r8]
    3e00:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    3e04:	4930      	ldr	r1, [pc, #192]	; (3ec8 <Macro_periodic+0x16c>)
    3e06:	f821 c003 	strh.w	ip, [r1, r3]
    3e0a:	18c8      	adds	r0, r1, r3
    3e0c:	7893      	ldrb	r3, [r2, #2]
    3e0e:	7083      	strb	r3, [r0, #2]
    3e10:	3403      	adds	r4, #3
    3e12:	e7bb      	b.n	3d8c <Macro_periodic+0x30>
			Macro_showTriggerEvent( &macroTriggerEventBuffer[trigger] );
    3e14:	b280      	uxth	r0, r0
    3e16:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    3e1a:	4450      	add	r0, sl
    3e1c:	f7ff fd72 	bl	3904 <Macro_showTriggerEvent>
			print( NL );
    3e20:	4640      	mov	r0, r8
    3e22:	f005 fb31 	bl	9488 <_print>
    3e26:	4648      	mov	r0, r9
		for ( uint16_t trigger = 0; trigger < macroTriggerEventBufferSize; trigger++ )
    3e28:	882a      	ldrh	r2, [r5, #0]
    3e2a:	b283      	uxth	r3, r0
    3e2c:	429a      	cmp	r2, r3
    3e2e:	f100 0901 	add.w	r9, r0, #1
    3e32:	d8ef      	bhi.n	3e14 <Macro_periodic+0xb8>
	if ( macroTriggerEventBufferSize >= MaxScanCode_KLL )
    3e34:	882b      	ldrh	r3, [r5, #0]
    3e36:	2b3e      	cmp	r3, #62	; 0x3e
    3e38:	d90a      	bls.n	3e50 <Macro_periodic+0xf4>
			erro_msg("Macro Trigger Event Overflow! Serious Bug! ");
    3e3a:	4824      	ldr	r0, [pc, #144]	; (3ecc <Macro_periodic+0x170>)
    3e3c:	f005 fb24 	bl	9488 <_print>
			printInt16( macroTriggerEventBufferSize );
    3e40:	8828      	ldrh	r0, [r5, #0]
    3e42:	f005 fbc1 	bl	95c8 <printInt16>
			print( NL );
    3e46:	481f      	ldr	r0, [pc, #124]	; (3ec4 <Macro_periodic+0x168>)
    3e48:	f005 fb1e 	bl	9488 <_print>
			macroTriggerEventBufferSize = 0;
    3e4c:	2300      	movs	r3, #0
    3e4e:	802b      	strh	r3, [r5, #0]
	if ( macroPauseMode )
    3e50:	4b1f      	ldr	r3, [pc, #124]	; (3ed0 <Macro_periodic+0x174>)
    3e52:	781b      	ldrb	r3, [r3, #0]
    3e54:	b13b      	cbz	r3, 3e66 <Macro_periodic+0x10a>
		if ( macroStepCounter == 0 )
    3e56:	4a1f      	ldr	r2, [pc, #124]	; (3ed4 <Macro_periodic+0x178>)
    3e58:	8813      	ldrh	r3, [r2, #0]
    3e5a:	b1eb      	cbz	r3, 3e98 <Macro_periodic+0x13c>
		macroStepCounter--;
    3e5c:	3b01      	subs	r3, #1
		dbug_print("Macro Step");
    3e5e:	481e      	ldr	r0, [pc, #120]	; (3ed8 <Macro_periodic+0x17c>)
		macroStepCounter--;
    3e60:	8013      	strh	r3, [r2, #0]
		dbug_print("Macro Step");
    3e62:	f005 fb11 	bl	9488 <_print>
	Trigger_process();
    3e66:	f000 ffcf 	bl	4e08 <Trigger_process>
	var_uint_t macroTriggerEventBufferSize_processed = macroTriggerEventBufferSize;
    3e6a:	f8b5 9000 	ldrh.w	r9, [r5]
	macroTriggerEventBufferSize = 0;
    3e6e:	f04f 0800 	mov.w	r8, #0
    3e72:	f8a5 8000 	strh.w	r8, [r5]
	Result_process();
    3e76:	f000 fc0d 	bl	4694 <Result_process>
	Scan_finishedWithMacro( macroTriggerEventBufferSize_processed );
    3e7a:	fa5f f089 	uxtb.w	r0, r9
    3e7e:	f7fe fcf5 	bl	286c <Scan_finishedWithMacro>
	Latency_end_time( macroLatencyResource );
    3e82:	7838      	ldrb	r0, [r7, #0]
    3e84:	f005 fa4c 	bl	9320 <Latency_end_time>
	if ( macroDebugMode == 1 || macroDebugMode == 3 )
    3e88:	7823      	ldrb	r3, [r4, #0]
    3e8a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    3e8e:	2b01      	cmp	r3, #1
		USBKeys_primary.changed = 0;
    3e90:	bf04      	itt	eq
    3e92:	4b12      	ldreq	r3, [pc, #72]	; (3edc <Macro_periodic+0x180>)
    3e94:	f883 8020 	strbeq.w	r8, [r3, #32]
}
    3e98:	9a01      	ldr	r2, [sp, #4]
    3e9a:	6833      	ldr	r3, [r6, #0]
    3e9c:	429a      	cmp	r2, r3
    3e9e:	d001      	beq.n	3ea4 <Macro_periodic+0x148>
    3ea0:	f7fd fb40 	bl	1524 <__stack_chk_fail>
    3ea4:	b003      	add	sp, #12
    3ea6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3eaa:	bf00      	nop
    3eac:	1fffe9d0 	.word	0x1fffe9d0
    3eb0:	1ffff3a1 	.word	0x1ffff3a1
    3eb4:	1ffff3a0 	.word	0x1ffff3a0
    3eb8:	1ffffd7a 	.word	0x1ffffd7a
    3ebc:	1ffffd78 	.word	0x1ffffd78
    3ec0:	0000a00f 	.word	0x0000a00f
    3ec4:	0000d348 	.word	0x0000d348
    3ec8:	1ffffd79 	.word	0x1ffffd79
    3ecc:	0000a057 	.word	0x0000a057
    3ed0:	1ffffcaf 	.word	0x1ffffcaf
    3ed4:	1ffffd76 	.word	0x1ffffd76
    3ed8:	0000a098 	.word	0x0000a098
    3edc:	20000776 	.word	0x20000776
    3ee0:	1ffffcb0 	.word	0x1ffffcb0
    3ee4:	1ffffcb5 	.word	0x1ffffcb5

00003ee8 <Macro_setup>:
{
    3ee8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    3eea:	4d16      	ldr	r5, [pc, #88]	; (3f44 <Macro_setup+0x5c>)
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    3eec:	4916      	ldr	r1, [pc, #88]	; (3f48 <Macro_setup+0x60>)
{
    3eee:	682b      	ldr	r3, [r5, #0]
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    3ef0:	4816      	ldr	r0, [pc, #88]	; (3f4c <Macro_setup+0x64>)
{
    3ef2:	9301      	str	r3, [sp, #4]
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    3ef4:	f004 fe58 	bl	8ba8 <CLI_registerDictionary>
	macroDebugMode = 0;
    3ef8:	4b15      	ldr	r3, [pc, #84]	; (3f50 <Macro_setup+0x68>)
	memset( Macro_rotation_store, 255, sizeof(Macro_rotate_capability) );
    3efa:	4816      	ldr	r0, [pc, #88]	; (3f54 <Macro_setup+0x6c>)
	macroDebugMode = 0;
    3efc:	2400      	movs	r4, #0
    3efe:	701c      	strb	r4, [r3, #0]
	macroPauseMode = 0;
    3f00:	4b15      	ldr	r3, [pc, #84]	; (3f58 <Macro_setup+0x70>)
    3f02:	701c      	strb	r4, [r3, #0]
	macroStepCounter = 0;
    3f04:	4b15      	ldr	r3, [pc, #84]	; (3f5c <Macro_setup+0x74>)
    3f06:	801c      	strh	r4, [r3, #0]
	voteDebugMode = 0;
    3f08:	4b15      	ldr	r3, [pc, #84]	; (3f60 <Macro_setup+0x78>)
    3f0a:	701c      	strb	r4, [r3, #0]
	triggerPendingDebugMode = 0;
    3f0c:	4b15      	ldr	r3, [pc, #84]	; (3f64 <Macro_setup+0x7c>)
    3f0e:	701c      	strb	r4, [r3, #0]
	macroTriggerEventBufferSize = 0;
    3f10:	4b15      	ldr	r3, [pc, #84]	; (3f68 <Macro_setup+0x80>)
	memset( Macro_rotation_store, 255, sizeof(Macro_rotate_capability) );
    3f12:	2201      	movs	r2, #1
    3f14:	21ff      	movs	r1, #255	; 0xff
	macroTriggerEventBufferSize = 0;
    3f16:	801c      	strh	r4, [r3, #0]
	memset( Macro_rotation_store, 255, sizeof(Macro_rotate_capability) );
    3f18:	f7fd fb12 	bl	1540 <memset>
	Layer_setup();
    3f1c:	f7fe ff56 	bl	2dcc <Layer_setup>
	Trigger_setup();
    3f20:	f000 ff56 	bl	4dd0 <Trigger_setup>
	Result_setup();
    3f24:	f000 fb42 	bl	45ac <Result_setup>
	macroLatencyResource = Latency_add_resource("PartialMap", LatencyOption_Ticks);
    3f28:	4621      	mov	r1, r4
    3f2a:	4810      	ldr	r0, [pc, #64]	; (3f6c <Macro_setup+0x84>)
    3f2c:	f005 f962 	bl	91f4 <Latency_add_resource>
    3f30:	4b0f      	ldr	r3, [pc, #60]	; (3f70 <Macro_setup+0x88>)
}
    3f32:	9a01      	ldr	r2, [sp, #4]
	macroLatencyResource = Latency_add_resource("PartialMap", LatencyOption_Ticks);
    3f34:	7018      	strb	r0, [r3, #0]
}
    3f36:	682b      	ldr	r3, [r5, #0]
    3f38:	429a      	cmp	r2, r3
    3f3a:	d001      	beq.n	3f40 <Macro_setup+0x58>
    3f3c:	f7fd faf2 	bl	1524 <__stack_chk_fail>
    3f40:	b003      	add	sp, #12
    3f42:	bd30      	pop	{r4, r5, pc}
    3f44:	1fffe9d0 	.word	0x1fffe9d0
    3f48:	0000b7b0 	.word	0x0000b7b0
    3f4c:	0000b6e4 	.word	0x0000b6e4
    3f50:	1ffffd78 	.word	0x1ffffd78
    3f54:	1ffff2a0 	.word	0x1ffff2a0
    3f58:	1ffffcaf 	.word	0x1ffffcaf
    3f5c:	1ffffd76 	.word	0x1ffffd76
    3f60:	1ffffcb2 	.word	0x1ffffcb2
    3f64:	1ffffcae 	.word	0x1ffffcae
    3f68:	1ffffcb0 	.word	0x1ffffcb0
    3f6c:	0000a0c7 	.word	0x0000a0c7
    3f70:	1ffff3a1 	.word	0x1ffff3a1

00003f74 <macroDebugShowTrigger>:
{
    3f74:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f78:	4c4a      	ldr	r4, [pc, #296]	; (40a4 <macroDebugShowTrigger+0x130>)
	if ( index >= TriggerMacroNum )
    3f7a:	285e      	cmp	r0, #94	; 0x5e
{
    3f7c:	6823      	ldr	r3, [r4, #0]
    3f7e:	9301      	str	r3, [sp, #4]
    3f80:	4606      	mov	r6, r0
	if ( index >= TriggerMacroNum )
    3f82:	f200 8088 	bhi.w	4096 <macroDebugShowTrigger+0x122>
	print( NL );
    3f86:	4848      	ldr	r0, [pc, #288]	; (40a8 <macroDebugShowTrigger+0x134>)
	uint8_t comboLength = macro->guide[ pos ];
    3f88:	4d48      	ldr	r5, [pc, #288]	; (40ac <macroDebugShowTrigger+0x138>)
			print("|");
    3f8a:	f8df 9154 	ldr.w	r9, [pc, #340]	; 40e0 <macroDebugShowTrigger+0x16c>
	print( NL );
    3f8e:	f005 fa7b 	bl	9488 <_print>
	info_msg("Trigger Macro Index: ");
    3f92:	4847      	ldr	r0, [pc, #284]	; (40b0 <macroDebugShowTrigger+0x13c>)
    3f94:	f005 fa78 	bl	9488 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    3f98:	4630      	mov	r0, r6
    3f9a:	f005 fb15 	bl	95c8 <printInt16>
	print( NL );
    3f9e:	4842      	ldr	r0, [pc, #264]	; (40a8 <macroDebugShowTrigger+0x134>)
    3fa0:	f005 fa72 	bl	9488 <_print>
	uint8_t comboLength = macro->guide[ pos ];
    3fa4:	f855 8036 	ldr.w	r8, [r5, r6, lsl #3]
    3fa8:	f898 7000 	ldrb.w	r7, [r8]
	var_uint_t pos = 0;
    3fac:	f04f 0a00 	mov.w	sl, #0
	while ( comboLength != 0 )
    3fb0:	bb0f      	cbnz	r7, 3ff6 <macroDebugShowTrigger+0x82>
	print( NL "Position: " );
    3fb2:	4840      	ldr	r0, [pc, #256]	; (40b4 <macroDebugShowTrigger+0x140>)
    3fb4:	f005 fa68 	bl	9488 <_print>
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    3fb8:	2306      	movs	r3, #6
    3fba:	4373      	muls	r3, r6
    3fbc:	4a3e      	ldr	r2, [pc, #248]	; (40b8 <macroDebugShowTrigger+0x144>)
    3fbe:	18d7      	adds	r7, r2, r3
    3fc0:	5ad0      	ldrh	r0, [r2, r3]
    3fc2:	f005 fb01 	bl	95c8 <printInt16>
	print(" ");
    3fc6:	483d      	ldr	r0, [pc, #244]	; (40bc <macroDebugShowTrigger+0x148>)
    3fc8:	f005 fa5e 	bl	9488 <_print>
	printInt16( (uint16_t)macro->result ); // Hopefully large enough :P (can't assume 32-bit)
    3fcc:	eb05 05c6 	add.w	r5, r5, r6, lsl #3
	printInt16( (uint16_t)record->prevPos );
    3fd0:	8878      	ldrh	r0, [r7, #2]
    3fd2:	f005 faf9 	bl	95c8 <printInt16>
	print( NL "Result Macro Index: " );
    3fd6:	483a      	ldr	r0, [pc, #232]	; (40c0 <macroDebugShowTrigger+0x14c>)
    3fd8:	f005 fa56 	bl	9488 <_print>
	printInt16( (uint16_t)macro->result ); // Hopefully large enough :P (can't assume 32-bit)
    3fdc:	88a8      	ldrh	r0, [r5, #4]
    3fde:	f005 faf3 	bl	95c8 <printInt16>
	print( NL "Trigger Macro State: " );
    3fe2:	4838      	ldr	r0, [pc, #224]	; (40c4 <macroDebugShowTrigger+0x150>)
    3fe4:	f005 fa50 	bl	9488 <_print>
	switch ( record->state )
    3fe8:	793b      	ldrb	r3, [r7, #4]
    3fea:	2b03      	cmp	r3, #3
    3fec:	d853      	bhi.n	4096 <macroDebugShowTrigger+0x122>
    3fee:	e8df f003 	tbb	[pc, r3]
    3ff2:	344c      	.short	0x344c
    3ff4:	4640      	.short	0x4640
		var_uint_t comboPos = ++pos;
    3ff6:	f10a 0301 	add.w	r3, sl, #1
    3ffa:	fa1f fa83 	uxth.w	sl, r3
		while ( pos < comboLength * TriggerGuideSize + comboPos )
    3ffe:	2203      	movs	r2, #3
    4000:	fb12 a707 	smlabb	r7, r2, r7, sl
    4004:	45ba      	cmp	sl, r7
    4006:	eb08 0b0a 	add.w	fp, r8, sl
    400a:	d307      	bcc.n	401c <macroDebugShowTrigger+0xa8>
		comboLength = macro->guide[ pos ];
    400c:	f89b 7000 	ldrb.w	r7, [fp]
		if ( comboLength != 0 )
    4010:	2f00      	cmp	r7, #0
    4012:	d0ce      	beq.n	3fb2 <macroDebugShowTrigger+0x3e>
			print(";");
    4014:	482c      	ldr	r0, [pc, #176]	; (40c8 <macroDebugShowTrigger+0x154>)
    4016:	f005 fa37 	bl	9488 <_print>
    401a:	e7c9      	b.n	3fb0 <macroDebugShowTrigger+0x3c>
			printHex( guide->scanCode );
    401c:	2101      	movs	r1, #1
    401e:	f89b 0002 	ldrb.w	r0, [fp, #2]
    4022:	f005 fb57 	bl	96d4 <printHex_op>
			print("|");
    4026:	4648      	mov	r0, r9
    4028:	f005 fa2e 	bl	9488 <_print>
			printHex( guide->type );
    402c:	2101      	movs	r1, #1
    402e:	f818 000a 	ldrb.w	r0, [r8, sl]
    4032:	f005 fb4f 	bl	96d4 <printHex_op>
			print("|");
    4036:	4648      	mov	r0, r9
    4038:	f005 fa26 	bl	9488 <_print>
			printHex( guide->state );
    403c:	2101      	movs	r1, #1
    403e:	f89b 0001 	ldrb.w	r0, [fp, #1]
    4042:	f005 fb47 	bl	96d4 <printHex_op>
			pos += TriggerGuideSize;
    4046:	f10a 0303 	add.w	r3, sl, #3
    404a:	fa1f fa83 	uxth.w	sl, r3
			if ( pos < comboLength * TriggerGuideSize + comboPos )
    404e:	45ba      	cmp	sl, r7
    4050:	d2d8      	bcs.n	4004 <macroDebugShowTrigger+0x90>
				print("+");
    4052:	481e      	ldr	r0, [pc, #120]	; (40cc <macroDebugShowTrigger+0x158>)
    4054:	f005 fa18 	bl	9488 <_print>
    4058:	e7d4      	b.n	4004 <macroDebugShowTrigger+0x90>
	case TriggerMacro_Press:        print("Press");   break;
    405a:	9a01      	ldr	r2, [sp, #4]
    405c:	6823      	ldr	r3, [r4, #0]
    405e:	429a      	cmp	r2, r3
    4060:	d001      	beq.n	4066 <macroDebugShowTrigger+0xf2>
}
    4062:	f7fd fa5f 	bl	1524 <__stack_chk_fail>
	case TriggerMacro_Press:        print("Press");   break;
    4066:	481a      	ldr	r0, [pc, #104]	; (40d0 <macroDebugShowTrigger+0x15c>)
}
    4068:	b003      	add	sp, #12
    406a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	case TriggerMacro_Waiting:      print("Waiting"); break;
    406e:	f005 ba0b 	b.w	9488 <_print>
	case TriggerMacro_Release:      print("Release"); break;
    4072:	9a01      	ldr	r2, [sp, #4]
    4074:	6823      	ldr	r3, [r4, #0]
    4076:	429a      	cmp	r2, r3
    4078:	d1f3      	bne.n	4062 <macroDebugShowTrigger+0xee>
    407a:	4816      	ldr	r0, [pc, #88]	; (40d4 <macroDebugShowTrigger+0x160>)
    407c:	e7f4      	b.n	4068 <macroDebugShowTrigger+0xf4>
	case TriggerMacro_PressRelease: print("Press|Release"); break;
    407e:	9a01      	ldr	r2, [sp, #4]
    4080:	6823      	ldr	r3, [r4, #0]
    4082:	429a      	cmp	r2, r3
    4084:	d1ed      	bne.n	4062 <macroDebugShowTrigger+0xee>
    4086:	4814      	ldr	r0, [pc, #80]	; (40d8 <macroDebugShowTrigger+0x164>)
    4088:	e7ee      	b.n	4068 <macroDebugShowTrigger+0xf4>
	case TriggerMacro_Waiting:      print("Waiting"); break;
    408a:	9a01      	ldr	r2, [sp, #4]
    408c:	6823      	ldr	r3, [r4, #0]
    408e:	429a      	cmp	r2, r3
    4090:	d1e7      	bne.n	4062 <macroDebugShowTrigger+0xee>
    4092:	4812      	ldr	r0, [pc, #72]	; (40dc <macroDebugShowTrigger+0x168>)
    4094:	e7e8      	b.n	4068 <macroDebugShowTrigger+0xf4>
}
    4096:	9a01      	ldr	r2, [sp, #4]
    4098:	6823      	ldr	r3, [r4, #0]
    409a:	429a      	cmp	r2, r3
    409c:	d1e1      	bne.n	4062 <macroDebugShowTrigger+0xee>
    409e:	b003      	add	sp, #12
    40a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    40a4:	1fffe9d0 	.word	0x1fffe9d0
    40a8:	0000d348 	.word	0x0000d348
    40ac:	0000a39c 	.word	0x0000a39c
    40b0:	0000b840 	.word	0x0000b840
    40b4:	0000b86c 	.word	0x0000b86c
    40b8:	1ffffe3a 	.word	0x1ffffe3a
    40bc:	0000d6a4 	.word	0x0000d6a4
    40c0:	0000b879 	.word	0x0000b879
    40c4:	0000b890 	.word	0x0000b890
    40c8:	0000b86a 	.word	0x0000b86a
    40cc:	0000d2fe 	.word	0x0000d2fe
    40d0:	0000bb85 	.word	0x0000bb85
    40d4:	0000bb8e 	.word	0x0000bb8e
    40d8:	0000b8a8 	.word	0x0000b8a8
    40dc:	0000b8b6 	.word	0x0000b8b6
    40e0:	0000b868 	.word	0x0000b868

000040e4 <macroDebugShowResult>:
{
    40e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    40e8:	4b41      	ldr	r3, [pc, #260]	; (41f0 <macroDebugShowResult+0x10c>)
    40ea:	b085      	sub	sp, #20
    40ec:	681a      	ldr	r2, [r3, #0]
    40ee:	9203      	str	r2, [sp, #12]
	if ( index >= ResultMacroNum )
    40f0:	285d      	cmp	r0, #93	; 0x5d
{
    40f2:	4604      	mov	r4, r0
    40f4:	9301      	str	r3, [sp, #4]
	if ( index >= ResultMacroNum )
    40f6:	d816      	bhi.n	4126 <macroDebugShowResult+0x42>
	print( NL );
    40f8:	483e      	ldr	r0, [pc, #248]	; (41f4 <macroDebugShowResult+0x110>)
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    40fa:	f8df 811c 	ldr.w	r8, [pc, #284]	; 4218 <macroDebugShowResult+0x134>
	print( NL );
    40fe:	f005 f9c3 	bl	9488 <_print>
	info_msg("Result Macro Index: ");
    4102:	483d      	ldr	r0, [pc, #244]	; (41f8 <macroDebugShowResult+0x114>)
    4104:	f005 f9c0 	bl	9488 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    4108:	4620      	mov	r0, r4
    410a:	f005 fa5d 	bl	95c8 <printInt16>
	print( NL );
    410e:	4839      	ldr	r0, [pc, #228]	; (41f4 <macroDebugShowResult+0x110>)
    4110:	f005 f9ba 	bl	9488 <_print>
	uint8_t comboLength = macro->guide[ pos++ ];
    4114:	4b39      	ldr	r3, [pc, #228]	; (41fc <macroDebugShowResult+0x118>)
    4116:	f853 7024 	ldr.w	r7, [r3, r4, lsl #2]
    411a:	f897 9000 	ldrb.w	r9, [r7]
    411e:	2401      	movs	r4, #1
	while ( comboLength != 0 )
    4120:	f1b9 0f00 	cmp.w	r9, #0
    4124:	d15f      	bne.n	41e6 <macroDebugShowResult+0x102>
}
    4126:	9b01      	ldr	r3, [sp, #4]
    4128:	9a03      	ldr	r2, [sp, #12]
    412a:	681b      	ldr	r3, [r3, #0]
    412c:	429a      	cmp	r2, r3
    412e:	d05c      	beq.n	41ea <macroDebugShowResult+0x106>
    4130:	f7fd f9f8 	bl	1524 <__stack_chk_fail>
			printHex( guide->index );
    4134:	2101      	movs	r1, #1
    4136:	4658      	mov	r0, fp
    4138:	f005 facc 	bl	96d4 <printHex_op>
			print("|");
    413c:	4830      	ldr	r0, [pc, #192]	; (4200 <macroDebugShowResult+0x11c>)
    413e:	f005 f9a3 	bl	9488 <_print>
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    4142:	5d3b      	ldrb	r3, [r7, r4]
    4144:	2101      	movs	r1, #1
    4146:	f838 0033 	ldrh.w	r0, [r8, r3, lsl #3]
    414a:	f005 fac3 	bl	96d4 <printHex_op>
			print("|");
    414e:	482c      	ldr	r0, [pc, #176]	; (4200 <macroDebugShowResult+0x11c>)
    4150:	f005 f99a 	bl	9488 <_print>
				(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
    4154:	5d3b      	ldrb	r3, [r7, r4]
			capability( 0, 0xFF, 0xFF, 0 );
    4156:	22ff      	movs	r2, #255	; 0xff
    4158:	f858 b033 	ldr.w	fp, [r8, r3, lsl #3]
    415c:	2300      	movs	r3, #0
    415e:	4618      	mov	r0, r3
    4160:	4611      	mov	r1, r2
    4162:	47d8      	blx	fp
			print("(");
    4164:	4827      	ldr	r0, [pc, #156]	; (4204 <macroDebugShowResult+0x120>)
    4166:	f005 f98f 	bl	9488 <_print>
    416a:	46b3      	mov	fp, r6
			for ( var_uint_t arg = 0; arg < CapabilitiesList[ guide->index ].argCount; arg++ )
    416c:	7831      	ldrb	r1, [r6, #0]
    416e:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
    4172:	ebab 0306 	sub.w	r3, fp, r6
    4176:	7909      	ldrb	r1, [r1, #4]
    4178:	b29b      	uxth	r3, r3
    417a:	4299      	cmp	r1, r3
    417c:	d822      	bhi.n	41c4 <macroDebugShowResult+0xe0>
			print(")");
    417e:	4822      	ldr	r0, [pc, #136]	; (4208 <macroDebugShowResult+0x124>)
    4180:	f005 f982 	bl	9488 <_print>
			pos += ResultGuideSize( guide );
    4184:	7833      	ldrb	r3, [r6, #0]
    4186:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
			funcCount++;
    418a:	3501      	adds	r5, #1
			pos += ResultGuideSize( guide );
    418c:	791b      	ldrb	r3, [r3, #4]
			funcCount++;
    418e:	b2ad      	uxth	r5, r5
			pos += ResultGuideSize( guide );
    4190:	3301      	adds	r3, #1
    4192:	441c      	add	r4, r3
			if ( funcCount < comboLength )
    4194:	4555      	cmp	r5, sl
			pos += ResultGuideSize( guide );
    4196:	b2a4      	uxth	r4, r4
			if ( funcCount < comboLength )
    4198:	d202      	bcs.n	41a0 <macroDebugShowResult+0xbc>
				print("+");
    419a:	481c      	ldr	r0, [pc, #112]	; (420c <macroDebugShowResult+0x128>)
    419c:	f005 f974 	bl	9488 <_print>
		while ( funcCount < comboLength )
    41a0:	fa1f fa89 	uxth.w	sl, r9
    41a4:	4555      	cmp	r5, sl
    41a6:	eb07 0604 	add.w	r6, r7, r4
    41aa:	f817 b004 	ldrb.w	fp, [r7, r4]
    41ae:	d3c1      	bcc.n	4134 <macroDebugShowResult+0x50>
		comboLength = macro->guide[ pos++ ];
    41b0:	3401      	adds	r4, #1
    41b2:	b2a4      	uxth	r4, r4
		if ( comboLength != 0 )
    41b4:	f1bb 0f00 	cmp.w	fp, #0
    41b8:	d002      	beq.n	41c0 <macroDebugShowResult+0xdc>
			print(";");
    41ba:	4815      	ldr	r0, [pc, #84]	; (4210 <macroDebugShowResult+0x12c>)
    41bc:	f005 f964 	bl	9488 <_print>
		var_uint_t funcCount = 0;
    41c0:	46d9      	mov	r9, fp
    41c2:	e7ad      	b.n	4120 <macroDebugShowResult+0x3c>
				printHex( (&guide->args)[ arg ] );
    41c4:	2101      	movs	r1, #1
    41c6:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
    41ca:	f005 fa83 	bl	96d4 <printHex_op>
				if ( arg + 1 < CapabilitiesList[ guide->index ].argCount )
    41ce:	7833      	ldrb	r3, [r6, #0]
    41d0:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
    41d4:	7919      	ldrb	r1, [r3, #4]
    41d6:	ebab 0306 	sub.w	r3, fp, r6
    41da:	4299      	cmp	r1, r3
    41dc:	ddc6      	ble.n	416c <macroDebugShowResult+0x88>
					print(",");
    41de:	480d      	ldr	r0, [pc, #52]	; (4214 <macroDebugShowResult+0x130>)
    41e0:	f005 f952 	bl	9488 <_print>
    41e4:	e7c2      	b.n	416c <macroDebugShowResult+0x88>
		var_uint_t funcCount = 0;
    41e6:	2500      	movs	r5, #0
    41e8:	e7da      	b.n	41a0 <macroDebugShowResult+0xbc>
}
    41ea:	b005      	add	sp, #20
    41ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    41f0:	1fffe9d0 	.word	0x1fffe9d0
    41f4:	0000d348 	.word	0x0000d348
    41f8:	0000b817 	.word	0x0000b817
    41fc:	0000a224 	.word	0x0000a224
    4200:	0000b868 	.word	0x0000b868
    4204:	0000cbce 	.word	0x0000cbce
    4208:	0000c4b9 	.word	0x0000c4b9
    420c:	0000d2fe 	.word	0x0000d2fe
    4210:	0000b86a 	.word	0x0000b86a
    4214:	0000b83e 	.word	0x0000b83e
    4218:	00009ed8 	.word	0x00009ed8

0000421c <cliFunc_macroShow>:
{
    421c:	b530      	push	{r4, r5, lr}
    421e:	b085      	sub	sp, #20
    4220:	4c13      	ldr	r4, [pc, #76]	; (4270 <cliFunc_macroShow+0x54>)
	char* arg2Ptr = args;
    4222:	ad04      	add	r5, sp, #16
{
    4224:	6822      	ldr	r2, [r4, #0]
	char* arg2Ptr = args;
    4226:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    422a:	9203      	str	r2, [sp, #12]
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    422c:	9802      	ldr	r0, [sp, #8]
    422e:	462a      	mov	r2, r5
    4230:	a901      	add	r1, sp, #4
    4232:	f004 fbfb 	bl	8a2c <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    4236:	9801      	ldr	r0, [sp, #4]
    4238:	7803      	ldrb	r3, [r0, #0]
    423a:	b18b      	cbz	r3, 4260 <cliFunc_macroShow+0x44>
		switch ( arg1Ptr[0] )
    423c:	2b52      	cmp	r3, #82	; 0x52
    423e:	d008      	beq.n	4252 <cliFunc_macroShow+0x36>
    4240:	2b54      	cmp	r3, #84	; 0x54
    4242:	d1f3      	bne.n	422c <cliFunc_macroShow+0x10>
			macroDebugShowTrigger( numToInt( &arg1Ptr[1] ) );
    4244:	3001      	adds	r0, #1
    4246:	f005 faef 	bl	9828 <numToInt>
    424a:	b280      	uxth	r0, r0
    424c:	f7ff fe92 	bl	3f74 <macroDebugShowTrigger>
			break;
    4250:	e7ec      	b.n	422c <cliFunc_macroShow+0x10>
			macroDebugShowResult( numToInt( &arg1Ptr[1] ) );
    4252:	3001      	adds	r0, #1
    4254:	f005 fae8 	bl	9828 <numToInt>
    4258:	b280      	uxth	r0, r0
    425a:	f7ff ff43 	bl	40e4 <macroDebugShowResult>
			break;
    425e:	e7e5      	b.n	422c <cliFunc_macroShow+0x10>
}
    4260:	9a03      	ldr	r2, [sp, #12]
    4262:	6823      	ldr	r3, [r4, #0]
    4264:	429a      	cmp	r2, r3
    4266:	d001      	beq.n	426c <cliFunc_macroShow+0x50>
    4268:	f7fd f95c 	bl	1524 <__stack_chk_fail>
    426c:	b005      	add	sp, #20
    426e:	bd30      	pop	{r4, r5, pc}
    4270:	1fffe9d0 	.word	0x1fffe9d0

00004274 <Result_evalResultMacroCombo>:
	ResultPendingElem *resultElem,
	const ResultMacro *macro,
	ResultMacroRecord *record,
	var_uint_t *comboItem
)
{
    4274:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4278:	461f      	mov	r7, r3
    427a:	4b4d      	ldr	r3, [pc, #308]	; (43b0 <Result_evalResultMacroCombo+0x13c>)

			// Call capability
			capability( resultElem->trigger, record->state, record->stateType, &guide->args );
		}
		// Otherwise, queue up the capability for later
		else if ( macroResultDelayedCapabilities.size < ResultCapabilityStackSize_define )
    427c:	4c4d      	ldr	r4, [pc, #308]	; (43b4 <Result_evalResultMacroCombo+0x140>)
{
    427e:	681b      	ldr	r3, [r3, #0]
    4280:	b087      	sub	sp, #28
    4282:	4616      	mov	r6, r2
    4284:	9305      	str	r3, [sp, #20]
	uint8_t pos = *comboItem - 1;
    4286:	783b      	ldrb	r3, [r7, #0]
	uint8_t comboLength = macro->guide[ pos ];
    4288:	680a      	ldr	r2, [r1, #0]
	uint8_t pos = *comboItem - 1;
    428a:	3b01      	subs	r3, #1
	uint8_t comboLength = macro->guide[ pos ];
    428c:	b2db      	uxtb	r3, r3
{
    428e:	4680      	mov	r8, r0
	uint8_t comboLength = macro->guide[ pos ];
    4290:	5cd3      	ldrb	r3, [r2, r3]
    4292:	9303      	str	r3, [sp, #12]
{
    4294:	4689      	mov	r9, r1
	while ( funcCount < comboLength )
    4296:	f04f 0a00 	mov.w	sl, #0
    429a:	9a03      	ldr	r2, [sp, #12]
    429c:	fa1f f38a 	uxth.w	r3, sl
    42a0:	429a      	cmp	r2, r3
    42a2:	d806      	bhi.n	42b2 <Result_evalResultMacroCombo+0x3e>

		// Increment counters
		funcCount++;
		*comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ *comboItem ]) );
	}
}
    42a4:	4b42      	ldr	r3, [pc, #264]	; (43b0 <Result_evalResultMacroCombo+0x13c>)
    42a6:	9a05      	ldr	r2, [sp, #20]
    42a8:	681b      	ldr	r3, [r3, #0]
    42aa:	429a      	cmp	r2, r3
    42ac:	d07d      	beq.n	43aa <Result_evalResultMacroCombo+0x136>
    42ae:	f7fd f939 	bl	1524 <__stack_chk_fail>
		ResultGuide *guide = (ResultGuide*)(&macro->guide[ *comboItem ]);
    42b2:	883b      	ldrh	r3, [r7, #0]
    42b4:	f8d9 2000 	ldr.w	r2, [r9]
    42b8:	18d5      	adds	r5, r2, r3
		if ( CapabilitiesList[ guide->index ].features & CapabilityFeature_Safe )
    42ba:	5cd1      	ldrb	r1, [r2, r3]
    42bc:	4a3e      	ldr	r2, [pc, #248]	; (43b8 <Result_evalResultMacroCombo+0x144>)
    42be:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
    42c2:	795b      	ldrb	r3, [r3, #5]
    42c4:	f013 0301 	ands.w	r3, r3, #1
    42c8:	d025      	beq.n	4316 <Result_evalResultMacroCombo+0xa2>
			if ( capDebugMode )
    42ca:	4b3c      	ldr	r3, [pc, #240]	; (43bc <Result_evalResultMacroCombo+0x148>)
			void (*capability)(TriggerMacro*, uint8_t, uint8_t, uint8_t*) = \
    42cc:	f852 b031 	ldr.w	fp, [r2, r1, lsl #3]
			if ( capDebugMode )
    42d0:	781b      	ldrb	r3, [r3, #0]
    42d2:	3501      	adds	r5, #1
    42d4:	b15b      	cbz	r3, 42ee <Result_evalResultMacroCombo+0x7a>
				dbug_msg("Safe: ");
    42d6:	483a      	ldr	r0, [pc, #232]	; (43c0 <Result_evalResultMacroCombo+0x14c>)
    42d8:	f005 f8d6 	bl	9488 <_print>
				capability( resultElem->trigger, ScheduleType_Debug, TriggerType_Debug, &guide->args );
    42dc:	22ff      	movs	r2, #255	; 0xff
    42de:	f8d8 0000 	ldr.w	r0, [r8]
    42e2:	462b      	mov	r3, r5
    42e4:	4611      	mov	r1, r2
    42e6:	47d8      	blx	fp
				print( NL );
    42e8:	4836      	ldr	r0, [pc, #216]	; (43c4 <Result_evalResultMacroCombo+0x150>)
    42ea:	f005 f8cd 	bl	9488 <_print>
			capability( resultElem->trigger, record->state, record->stateType, &guide->args );
    42ee:	462b      	mov	r3, r5
    42f0:	7972      	ldrb	r2, [r6, #5]
    42f2:	7931      	ldrb	r1, [r6, #4]
    42f4:	f8d8 0000 	ldr.w	r0, [r8]
    42f8:	47d8      	blx	fp
		*comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ *comboItem ]) );
    42fa:	883b      	ldrh	r3, [r7, #0]
    42fc:	f8d9 2000 	ldr.w	r2, [r9]
    4300:	492d      	ldr	r1, [pc, #180]	; (43b8 <Result_evalResultMacroCombo+0x144>)
    4302:	5cd2      	ldrb	r2, [r2, r3]
    4304:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
    4308:	3301      	adds	r3, #1
    430a:	7912      	ldrb	r2, [r2, #4]
    430c:	4413      	add	r3, r2
    430e:	803b      	strh	r3, [r7, #0]
    4310:	f10a 0a01 	add.w	sl, sl, #1
    4314:	e7c1      	b.n	429a <Result_evalResultMacroCombo+0x26>
		else if ( macroResultDelayedCapabilities.size < ResultCapabilityStackSize_define )
    4316:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
    431a:	2a09      	cmp	r2, #9
    431c:	d841      	bhi.n	43a2 <Result_evalResultMacroCombo+0x12e>
    431e:	f8d8 2000 	ldr.w	r2, [r8]
			uint8_t size = macroResultDelayedCapabilities.size;
    4322:	f894 0078 	ldrb.w	r0, [r4, #120]	; 0x78
    4326:	9201      	str	r2, [sp, #4]
    4328:	f896 b005 	ldrb.w	fp, [r6, #5]
    432c:	7932      	ldrb	r2, [r6, #4]
    432e:	9202      	str	r2, [sp, #8]
    4330:	b2c0      	uxtb	r0, r0
			for ( ; pos < size; pos++ )
    4332:	fa5f fc83 	uxtb.w	ip, r3
    4336:	4560      	cmp	r0, ip
    4338:	d813      	bhi.n	4362 <Result_evalResultMacroCombo+0xee>
				item->trigger         = resultElem->trigger;
    433a:	230c      	movs	r3, #12
    433c:	fb03 f200 	mul.w	r2, r3, r0
    4340:	18a3      	adds	r3, r4, r2
    4342:	9801      	ldr	r0, [sp, #4]
    4344:	50a0      	str	r0, [r4, r2]
				item->args            = &guide->args;
    4346:	3501      	adds	r5, #1
				item->state           = record->state;
    4348:	9a02      	ldr	r2, [sp, #8]
    434a:	711a      	strb	r2, [r3, #4]
				item->stateType       = record->stateType;
    434c:	f883 b005 	strb.w	fp, [r3, #5]
				item->capabilityIndex = guide->index;
    4350:	7199      	strb	r1, [r3, #6]
				item->args            = &guide->args;
    4352:	609d      	str	r5, [r3, #8]
				macroResultDelayedCapabilities.size++;
    4354:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    4358:	3301      	adds	r3, #1
    435a:	b2db      	uxtb	r3, r3
    435c:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    4360:	e7cb      	b.n	42fa <Result_evalResultMacroCombo+0x86>
					item->trigger == resultElem->trigger &&
    4362:	220c      	movs	r2, #12
    4364:	fb02 fe03 	mul.w	lr, r2, r3
    4368:	eb04 0c0e 	add.w	ip, r4, lr
				if (
    436c:	9a01      	ldr	r2, [sp, #4]
					item->trigger == resultElem->trigger &&
    436e:	f854 e00e 	ldr.w	lr, [r4, lr]
				if (
    4372:	4596      	cmp	lr, r2
    4374:	d113      	bne.n	439e <Result_evalResultMacroCombo+0x12a>
					item->state == record->state &&
    4376:	f89c e004 	ldrb.w	lr, [ip, #4]
					item->trigger == resultElem->trigger &&
    437a:	9a02      	ldr	r2, [sp, #8]
    437c:	4596      	cmp	lr, r2
    437e:	d10e      	bne.n	439e <Result_evalResultMacroCombo+0x12a>
					item->stateType == record->stateType &&
    4380:	f89c e005 	ldrb.w	lr, [ip, #5]
					item->state == record->state &&
    4384:	45de      	cmp	lr, fp
    4386:	d10a      	bne.n	439e <Result_evalResultMacroCombo+0x12a>
					item->capabilityIndex == guide->index
    4388:	f89c e006 	ldrb.w	lr, [ip, #6]
					item->stateType == record->stateType &&
    438c:	4571      	cmp	r1, lr
    438e:	d106      	bne.n	439e <Result_evalResultMacroCombo+0x12a>
					if ( guide->args != 0 && item->args == &guide->args )
    4390:	f895 e001 	ldrb.w	lr, [r5, #1]
    4394:	f1be 0f00 	cmp.w	lr, #0
    4398:	d001      	beq.n	439e <Result_evalResultMacroCombo+0x12a>
    439a:	f8dc c008 	ldr.w	ip, [ip, #8]
    439e:	3301      	adds	r3, #1
    43a0:	e7c7      	b.n	4332 <Result_evalResultMacroCombo+0xbe>
			warn_print("Delayed capability stack full!");
    43a2:	4809      	ldr	r0, [pc, #36]	; (43c8 <Result_evalResultMacroCombo+0x154>)
    43a4:	f005 f870 	bl	9488 <_print>
    43a8:	e7a7      	b.n	42fa <Result_evalResultMacroCombo+0x86>
}
    43aa:	b007      	add	sp, #28
    43ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    43b0:	1fffe9d0 	.word	0x1fffe9d0
    43b4:	20000074 	.word	0x20000074
    43b8:	00009ed8 	.word	0x00009ed8
    43bc:	200000f0 	.word	0x200000f0
    43c0:	0000bddf 	.word	0x0000bddf
    43c4:	0000d348 	.word	0x0000d348
    43c8:	0000bdf9 	.word	0x0000bdf9

000043cc <Result_appendResultMacroToPendingList>:


// Append result macro to pending list, duplicates are ok
void Result_appendResultMacroToPendingList( const TriggerMacro *triggerMacro )
{
    43cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Add, even if there's a duplicate
	// There may be multiple triggers that specify the capability
	// Different triggers may result in different final results
	ResultPendingElem *elem = &macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ];
    43d0:	4e4b      	ldr	r6, [pc, #300]	; (4500 <Result_appendResultMacroToPendingList+0x134>)
{
    43d2:	4f4c      	ldr	r7, [pc, #304]	; (4504 <Result_appendResultMacroToPendingList+0x138>)
	ResultPendingElem *elem = &macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ];
    43d4:	f8b6 8258 	ldrh.w	r8, [r6, #600]	; 0x258
{
    43d8:	683b      	ldr	r3, [r7, #0]
	var_uint_t resultMacroIndex = triggerMacro->result;
    43da:	8881      	ldrh	r1, [r0, #4]
{
    43dc:	b085      	sub	sp, #20
    43de:	4681      	mov	r9, r0
    43e0:	9303      	str	r3, [sp, #12]
	ResultPendingElem *elem = &macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ];
    43e2:	f108 0301 	add.w	r3, r8, #1
    43e6:	f8a6 3258 	strh.w	r3, [r6, #600]	; 0x258
	elem->trigger = (TriggerMacro*)triggerMacro;
    43ea:	230c      	movs	r3, #12
    43ec:	fb03 f308 	mul.w	r3, r3, r8
    43f0:	18f2      	adds	r2, r6, r3
    43f2:	50f0      	str	r0, [r6, r3]
	elem->index = resultMacroIndex;
    43f4:	8091      	strh	r1, [r2, #4]
	// Lookup index and type of a key in the last combo
	// Depending on the trigger type, which key selected will vary
	// First, find the last combo
	var_uint_t prev_pos = 0;
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    43f6:	6802      	ldr	r2, [r0, #0]
	var_uint_t pos = 0;
    43f8:	2300      	movs	r3, #0
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    43fa:	7814      	ldrb	r4, [r2, #0]
	var_uint_t prev_pos = 0;
    43fc:	469a      	mov	sl, r3
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    43fe:	b98c      	cbnz	r4, 4424 <Result_appendResultMacroToPendingList+0x58>

		// Lookup index in buffer list for the current state and stateType
		for ( var_uint_t keyIndex = 0; keyIndex < macroTriggerEventBufferSize; keyIndex++ )
		{
			if (
				macroTriggerEventBuffer[ keyIndex ].index == cur_guide->scanCode &&
    4400:	f8df b114 	ldr.w	fp, [pc, #276]	; 4518 <Result_appendResultMacroToPendingList+0x14c>
	TriggerEvent *event = 0;
    4404:	4625      	mov	r5, r4
	for ( uint8_t elem = 0; elem < triggerMacro->guide[prev_pos]; elem++ )
    4406:	f8d9 2000 	ldr.w	r2, [r9]
    440a:	f812 100a 	ldrb.w	r1, [r2, sl]
    440e:	b2e3      	uxtb	r3, r4
    4410:	4299      	cmp	r1, r3
    4412:	d810      	bhi.n	4436 <Result_appendResultMacroToPendingList+0x6a>
			break;
		}
	}

	// If event was not set, ignore
	if ( !event )
    4414:	2d00      	cmp	r5, #0
    4416:	d153      	bne.n	44c0 <Result_appendResultMacroToPendingList+0xf4>
	{
		erro_print("No event found! Bug!");
    4418:	9a03      	ldr	r2, [sp, #12]
    441a:	683b      	ldr	r3, [r7, #0]
    441c:	429a      	cmp	r2, r3
    441e:	d049      	beq.n	44b4 <Result_appendResultMacroToPendingList+0xe8>
	}

	// Reset the macro position
	elem->record.prevPos = 0;
	elem->record.pos = 0;
}
    4420:	f7fd f880 	bl	1524 <__stack_chk_fail>
		pos += TriggerGuideSize * comboLength + 1;
    4424:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    4428:	3401      	adds	r4, #1
    442a:	441c      	add	r4, r3
    442c:	b2a1      	uxth	r1, r4
		prev_pos = pos;
    442e:	469a      	mov	sl, r3
		comboLength = triggerMacro->guide[ pos ];
    4430:	5c54      	ldrb	r4, [r2, r1]
		pos += TriggerGuideSize * comboLength + 1;
    4432:	460b      	mov	r3, r1
    4434:	e7e3      	b.n	43fe <Result_appendResultMacroToPendingList+0x32>
		TriggerGuide *cur_guide = (TriggerGuide*)&triggerMacro->guide[prev_pos + 1];
    4436:	f10a 0301 	add.w	r3, sl, #1
    443a:	441a      	add	r2, r3
		for ( var_uint_t keyIndex = 0; keyIndex < macroTriggerEventBufferSize; keyIndex++ )
    443c:	4b32      	ldr	r3, [pc, #200]	; (4508 <Result_appendResultMacroToPendingList+0x13c>)
    443e:	881b      	ldrh	r3, [r3, #0]
    4440:	9301      	str	r3, [sp, #4]
    4442:	2100      	movs	r1, #0
    4444:	9801      	ldr	r0, [sp, #4]
    4446:	b28b      	uxth	r3, r1
    4448:	4283      	cmp	r3, r0
    444a:	d303      	bcc.n	4454 <Result_appendResultMacroToPendingList+0x88>
			erro_print("Could not find event in event buffer for activated trigger! This is a bug!");
    444c:	482f      	ldr	r0, [pc, #188]	; (450c <Result_appendResultMacroToPendingList+0x140>)
    444e:	f005 f81b 	bl	9488 <_print>
			continue;
    4452:	e024      	b.n	449e <Result_appendResultMacroToPendingList+0xd2>
    4454:	eb01 0041 	add.w	r0, r1, r1, lsl #1
				macroTriggerEventBuffer[ keyIndex ].index == cur_guide->scanCode &&
    4458:	eb00 030b 	add.w	r3, r0, fp
			if (
    445c:	f892 c002 	ldrb.w	ip, [r2, #2]
    4460:	f893 e002 	ldrb.w	lr, [r3, #2]
    4464:	45e6      	cmp	lr, ip
    4466:	d11c      	bne.n	44a2 <Result_appendResultMacroToPendingList+0xd6>
				macroTriggerEventBuffer[ keyIndex ].type == cur_guide->type
    4468:	f810 c00b 	ldrb.w	ip, [r0, fp]
				macroTriggerEventBuffer[ keyIndex ].index == cur_guide->scanCode &&
    446c:	7810      	ldrb	r0, [r2, #0]
    446e:	4560      	cmp	r0, ip
    4470:	d117      	bne.n	44a2 <Result_appendResultMacroToPendingList+0xd6>
				cur_event = &macroTriggerEventBuffer[ keyIndex ];
    4472:	2d00      	cmp	r5, #0
    4474:	bf08      	it	eq
    4476:	461d      	moveq	r5, r3
    4478:	2814      	cmp	r0, #20
    447a:	d810      	bhi.n	449e <Result_appendResultMacroToPendingList+0xd2>
    447c:	2101      	movs	r1, #1
    447e:	4a24      	ldr	r2, [pc, #144]	; (4510 <Result_appendResultMacroToPendingList+0x144>)
    4480:	4081      	lsls	r1, r0
    4482:	400a      	ands	r2, r1
    4484:	b15a      	cbz	r2, 449e <Result_appendResultMacroToPendingList+0xd2>
				( event->state == ScheduleType_H || event->state == ScheduleType_O ) &&
    4486:	7869      	ldrb	r1, [r5, #1]
    4488:	f011 0ffd 	tst.w	r1, #253	; 0xfd
    448c:	d10b      	bne.n	44a6 <Result_appendResultMacroToPendingList+0xda>
				( cur_event->state != event->state ) &&
    448e:	785a      	ldrb	r2, [r3, #1]
				( event->state == ScheduleType_H || event->state == ScheduleType_O ) &&
    4490:	4291      	cmp	r1, r2
    4492:	d004      	beq.n	449e <Result_appendResultMacroToPendingList+0xd2>
				( cur_event->state != event->state ) &&
    4494:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
				cur_event = &macroTriggerEventBuffer[ keyIndex ];
    4498:	2a01      	cmp	r2, #1
    449a:	bf08      	it	eq
    449c:	461d      	moveq	r5, r3
    449e:	3401      	adds	r4, #1
    44a0:	e7b1      	b.n	4406 <Result_appendResultMacroToPendingList+0x3a>
    44a2:	3101      	adds	r1, #1
    44a4:	e7ce      	b.n	4444 <Result_appendResultMacroToPendingList+0x78>
			else if ( event->state == ScheduleType_P && cur_event->state == ScheduleType_R )
    44a6:	2901      	cmp	r1, #1
    44a8:	d1f9      	bne.n	449e <Result_appendResultMacroToPendingList+0xd2>
    44aa:	785a      	ldrb	r2, [r3, #1]
				cur_event = &macroTriggerEventBuffer[ keyIndex ];
    44ac:	2a03      	cmp	r2, #3
    44ae:	bf08      	it	eq
    44b0:	461d      	moveq	r5, r3
    44b2:	e7f4      	b.n	449e <Result_appendResultMacroToPendingList+0xd2>
		erro_print("No event found! Bug!");
    44b4:	4817      	ldr	r0, [pc, #92]	; (4514 <Result_appendResultMacroToPendingList+0x148>)
}
    44b6:	b005      	add	sp, #20
    44b8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		erro_print("No event found! Bug!");
    44bc:	f004 bfe4 	b.w	9488 <_print>
	elem->record.state     = event->state;
    44c0:	220c      	movs	r2, #12
    44c2:	fb02 6208 	mla	r2, r2, r8, r6
	elem->record.stateType = event->type;
    44c6:	7829      	ldrb	r1, [r5, #0]
    44c8:	72d1      	strb	r1, [r2, #11]
	switch ( elem->record.stateType )
    44ca:	3909      	subs	r1, #9
	elem->record.state     = event->state;
    44cc:	786b      	ldrb	r3, [r5, #1]
    44ce:	7293      	strb	r3, [r2, #10]
	switch ( elem->record.stateType )
    44d0:	2903      	cmp	r1, #3
    44d2:	d807      	bhi.n	44e4 <Result_appendResultMacroToPendingList+0x118>
		if ( elem->record.state & 0xF0 && ( elem->record.state & 0x80 ) == 0x00 )
    44d4:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    44d8:	d004      	beq.n	44e4 <Result_appendResultMacroToPendingList+0x118>
    44da:	0619      	lsls	r1, r3, #24
			elem->record.state &= 0x8F;
    44dc:	bf5c      	itt	pl
    44de:	f023 0370 	bicpl.w	r3, r3, #112	; 0x70
    44e2:	7293      	strbpl	r3, [r2, #10]
	elem->record.prevPos = 0;
    44e4:	230c      	movs	r3, #12
    44e6:	fb03 6608 	mla	r6, r3, r8, r6
    44ea:	2300      	movs	r3, #0
}
    44ec:	9a03      	ldr	r2, [sp, #12]
	elem->record.prevPos = 0;
    44ee:	8133      	strh	r3, [r6, #8]
	elem->record.pos = 0;
    44f0:	80f3      	strh	r3, [r6, #6]
}
    44f2:	683b      	ldr	r3, [r7, #0]
    44f4:	429a      	cmp	r2, r3
    44f6:	d193      	bne.n	4420 <Result_appendResultMacroToPendingList+0x54>
    44f8:	b005      	add	sp, #20
    44fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    44fe:	bf00      	nop
    4500:	200000f4 	.word	0x200000f4
    4504:	1fffe9d0 	.word	0x1fffe9d0
    4508:	1ffffcb0 	.word	0x1ffffcb0
    450c:	0000bd7d 	.word	0x0000bd7d
    4510:	001e1e1f 	.word	0x001e1e1f
    4514:	0000bd51 	.word	0x0000bd51
    4518:	1ffffcb5 	.word	0x1ffffcb5

0000451c <Result_evalResultMacro>:


// Evaluate/Update ResultMacro
ResultMacroEval Result_evalResultMacro( ResultPendingElem *resultElem )
{
    451c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4520:	4d20      	ldr	r5, [pc, #128]	; (45a4 <Result_evalResultMacro+0x88>)

	// Lookup ResultMacroRecord
	ResultMacroRecord *record = &resultElem->record;

	// Current Macro position
	var_uint_t pos = record->pos;
    4522:	88c2      	ldrh	r2, [r0, #6]
{
    4524:	682b      	ldr	r3, [r5, #0]
	const ResultMacro *macro = &ResultMacroList[ resultElem->index ];
    4526:	8887      	ldrh	r7, [r0, #4]
    4528:	4e1f      	ldr	r6, [pc, #124]	; (45a8 <Result_evalResultMacro+0x8c>)
{
    452a:	b085      	sub	sp, #20
    452c:	4604      	mov	r4, r0
    452e:	9303      	str	r3, [sp, #12]

	// Combo Item Position within the guide
	var_uint_t comboItem = pos + 1;
    4530:	1c53      	adds	r3, r2, #1
    4532:	f8ad 3000 	strh.w	r3, [sp]

	// Process opposing event for previous item in sequence (if necessary)
	if ( record->prevPos != pos )
    4536:	8903      	ldrh	r3, [r0, #8]
    4538:	4293      	cmp	r3, r2
	const ResultMacro *macro = &ResultMacroList[ resultElem->index ];
    453a:	eb06 0887 	add.w	r8, r6, r7, lsl #2
	ResultMacroRecord *record = &resultElem->record;
    453e:	f100 0906 	add.w	r9, r0, #6
	if ( record->prevPos != pos )
    4542:	d012      	beq.n	456a <Result_evalResultMacro+0x4e>
	{
		// Previous comboItem position
		var_uint_t oComboItem = record->prevPos + 1;
    4544:	1c59      	adds	r1, r3, #1

		// TODO (HaaTa) Calculate opposing state and stateType
		ResultMacroRecord oRecord = {
    4546:	f8ad 3006 	strh.w	r3, [sp, #6]
    454a:	2303      	movs	r3, #3
    454c:	f88d 3008 	strb.w	r3, [sp, #8]
    4550:	7ac3      	ldrb	r3, [r0, #11]
		var_uint_t oComboItem = record->prevPos + 1;
    4552:	f8ad 1002 	strh.w	r1, [sp, #2]
		ResultMacroRecord oRecord = {
    4556:	f8ad 2004 	strh.w	r2, [sp, #4]
    455a:	f88d 3009 	strb.w	r3, [sp, #9]
			record->pos,
			record->prevPos,
			ScheduleType_R,
			record->stateType,
		};
		Result_evalResultMacroCombo( resultElem, macro, &oRecord, &oComboItem );
    455e:	aa01      	add	r2, sp, #4
    4560:	f10d 0302 	add.w	r3, sp, #2
    4564:	4641      	mov	r1, r8
    4566:	f7ff fe85 	bl	4274 <Result_evalResultMacroCombo>
	}

	// Evaluate Combo
	Result_evalResultMacroCombo( resultElem, macro, record, &comboItem );
    456a:	466b      	mov	r3, sp
    456c:	464a      	mov	r2, r9
    456e:	4641      	mov	r1, r8
    4570:	4620      	mov	r0, r4
    4572:	f7ff fe7f 	bl	4274 <Result_evalResultMacroCombo>

	// Move to next item in the sequence
	record->prevPos = record->pos;
    4576:	88e3      	ldrh	r3, [r4, #6]
    4578:	8123      	strh	r3, [r4, #8]
	record->pos = comboItem;

	// If the ResultMacro is finished, remove
	if ( macro->guide[ comboItem ] == 0 )
    457a:	f856 2027 	ldr.w	r2, [r6, r7, lsl #2]
	record->pos = comboItem;
    457e:	f8bd 3000 	ldrh.w	r3, [sp]
    4582:	80e3      	strh	r3, [r4, #6]
	if ( macro->guide[ comboItem ] == 0 )
    4584:	5cd3      	ldrb	r3, [r2, r3]
    4586:	b943      	cbnz	r3, 459a <Result_evalResultMacro+0x7e>
	{
		record->prevPos = 0;
    4588:	8123      	strh	r3, [r4, #8]
		record->pos = 0;
    458a:	80e3      	strh	r3, [r4, #6]
		return ResultMacroEval_Remove;
    458c:	2001      	movs	r0, #1
	}

	// Otherwise leave the macro in the list
	return ResultMacroEval_DoNothing;
}
    458e:	9a03      	ldr	r2, [sp, #12]
    4590:	682b      	ldr	r3, [r5, #0]
    4592:	429a      	cmp	r2, r3
    4594:	d003      	beq.n	459e <Result_evalResultMacro+0x82>
    4596:	f7fc ffc5 	bl	1524 <__stack_chk_fail>
	return ResultMacroEval_DoNothing;
    459a:	2000      	movs	r0, #0
    459c:	e7f7      	b.n	458e <Result_evalResultMacro+0x72>
}
    459e:	b005      	add	sp, #20
    45a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    45a4:	1fffe9d0 	.word	0x1fffe9d0
    45a8:	0000a224 	.word	0x0000a224

000045ac <Result_setup>:


void Result_setup()
{
    45ac:	b507      	push	{r0, r1, r2, lr}
    45ae:	4a0a      	ldr	r2, [pc, #40]	; (45d8 <Result_setup+0x2c>)
	// Initialize macroResultMacroPendingList
	macroResultMacroPendingList.size = 0;
    45b0:	490a      	ldr	r1, [pc, #40]	; (45dc <Result_setup+0x30>)
{
    45b2:	6813      	ldr	r3, [r2, #0]
    45b4:	9301      	str	r3, [sp, #4]
	macroResultMacroPendingList.size = 0;
    45b6:	2300      	movs	r3, #0
    45b8:	f8a1 3258 	strh.w	r3, [r1, #600]	; 0x258

	// Reset delayed capabilities stack
	macroResultDelayedCapabilities.size = 0;
    45bc:	4908      	ldr	r1, [pc, #32]	; (45e0 <Result_setup+0x34>)
    45be:	f881 3078 	strb.w	r3, [r1, #120]	; 0x78

	// Capability debug mode
	capDebugMode = 0;
    45c2:	4908      	ldr	r1, [pc, #32]	; (45e4 <Result_setup+0x38>)
    45c4:	700b      	strb	r3, [r1, #0]
}
    45c6:	9901      	ldr	r1, [sp, #4]
    45c8:	6813      	ldr	r3, [r2, #0]
    45ca:	4299      	cmp	r1, r3
    45cc:	d001      	beq.n	45d2 <Result_setup+0x26>
    45ce:	f7fc ffa9 	bl	1524 <__stack_chk_fail>
    45d2:	b003      	add	sp, #12
    45d4:	f85d fb04 	ldr.w	pc, [sp], #4
    45d8:	1fffe9d0 	.word	0x1fffe9d0
    45dc:	200000f4 	.word	0x200000f4
    45e0:	20000074 	.word	0x20000074
    45e4:	200000f0 	.word	0x200000f0

000045e8 <Result_process_delayed>:

// Process delayed capabilities
// Capabilities that are not called immediately (i.e. ones that are not deemed as thread safe)
// are processed with this function
void Result_process_delayed()
{
    45e8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    45ec:	4d23      	ldr	r5, [pc, #140]	; (467c <Result_process_delayed+0x94>)
	// Disable periodic interrupts if we have delayed capabilities
	Periodic_disable();

	// Process stack until empty
	// For each empty, make sure interrupts are disabled
	while ( macroResultDelayedCapabilities.size > 0 )
    45ee:	4c24      	ldr	r4, [pc, #144]	; (4680 <Result_process_delayed+0x98>)
{
    45f0:	682b      	ldr	r3, [r5, #0]
    45f2:	9301      	str	r3, [sp, #4]
	Periodic_disable();
    45f4:	f7fd fa2e 	bl	1a54 <Periodic_disable>
		// Lookup stack
		volatile ResultCapabilityStackItem *item = &macroResultDelayedCapabilities.stack[macroResultDelayedCapabilities.size - 1];

		// Do lookup on capability function
		void (*capability)(TriggerMacro*, uint8_t, uint8_t, uint8_t*) = \
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ item->capabilityIndex ].func);
    45f8:	4f22      	ldr	r7, [pc, #136]	; (4684 <Result_process_delayed+0x9c>)
    45fa:	4626      	mov	r6, r4
	while ( macroResultDelayedCapabilities.size > 0 )
    45fc:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    4600:	b92b      	cbnz	r3, 460e <Result_process_delayed+0x26>
		// Decrease stack size
		macroResultDelayedCapabilities.size--;
	}

	// Re-enable periodic interrupts
	Periodic_enable();
    4602:	9a01      	ldr	r2, [sp, #4]
    4604:	682b      	ldr	r3, [r5, #0]
    4606:	429a      	cmp	r2, r3
    4608:	d033      	beq.n	4672 <Result_process_delayed+0x8a>
    460a:	f7fc ff8b 	bl	1524 <__stack_chk_fail>
		volatile ResultCapabilityStackItem *item = &macroResultDelayedCapabilities.stack[macroResultDelayedCapabilities.size - 1];
    460e:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ item->capabilityIndex ].func);
    4612:	f04f 0a0c 	mov.w	sl, #12
		volatile ResultCapabilityStackItem *item = &macroResultDelayedCapabilities.stack[macroResultDelayedCapabilities.size - 1];
    4616:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ item->capabilityIndex ].func);
    461a:	fb0a fa08 	mul.w	sl, sl, r8
    461e:	eb04 0b0a 	add.w	fp, r4, sl
    4622:	f89b 3006 	ldrb.w	r3, [fp, #6]
		void (*capability)(TriggerMacro*, uint8_t, uint8_t, uint8_t*) = \
    4626:	f857 9033 	ldr.w	r9, [r7, r3, lsl #3]
		if ( capDebugMode )
    462a:	4b17      	ldr	r3, [pc, #92]	; (4688 <Result_process_delayed+0xa0>)
    462c:	781b      	ldrb	r3, [r3, #0]
    462e:	b163      	cbz	r3, 464a <Result_process_delayed+0x62>
			dbug_msg("Un-safe: ");
    4630:	4816      	ldr	r0, [pc, #88]	; (468c <Result_process_delayed+0xa4>)
    4632:	f004 ff29 	bl	9488 <_print>
			capability( item->trigger, ScheduleType_Debug, TriggerType_Debug, item->args );
    4636:	22ff      	movs	r2, #255	; 0xff
    4638:	f854 000a 	ldr.w	r0, [r4, sl]
    463c:	f8db 3008 	ldr.w	r3, [fp, #8]
    4640:	4611      	mov	r1, r2
    4642:	47c8      	blx	r9
			print( NL );
    4644:	4812      	ldr	r0, [pc, #72]	; (4690 <Result_process_delayed+0xa8>)
    4646:	f004 ff1f 	bl	9488 <_print>
		capability( item->trigger, item->state, item->stateType, item->args );
    464a:	230c      	movs	r3, #12
    464c:	fb03 f308 	mul.w	r3, r3, r8
    4650:	eb06 0c03 	add.w	ip, r6, r3
    4654:	58f0      	ldr	r0, [r6, r3]
    4656:	f89c 1004 	ldrb.w	r1, [ip, #4]
    465a:	f89c 2005 	ldrb.w	r2, [ip, #5]
    465e:	f8dc 3008 	ldr.w	r3, [ip, #8]
    4662:	47c8      	blx	r9
		macroResultDelayedCapabilities.size--;
    4664:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
    4668:	3b01      	subs	r3, #1
    466a:	b2db      	uxtb	r3, r3
    466c:	f886 3078 	strb.w	r3, [r6, #120]	; 0x78
    4670:	e7c4      	b.n	45fc <Result_process_delayed+0x14>
}
    4672:	b003      	add	sp, #12
    4674:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	Periodic_enable();
    4678:	f7fd b9d6 	b.w	1a28 <Periodic_enable>
    467c:	1fffe9d0 	.word	0x1fffe9d0
    4680:	20000074 	.word	0x20000074
    4684:	00009ed8 	.word	0x00009ed8
    4688:	200000f0 	.word	0x200000f0
    468c:	0000be2f 	.word	0x0000be2f
    4690:	0000d348 	.word	0x0000d348

00004694 <Result_process>:


void Result_process()
{
    4694:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    4698:	4d16      	ldr	r5, [pc, #88]	; (46f4 <Result_process+0x60>)
	// Tail pointer for macroResultMacroPendingList
	// Macros must be explicitly re-added
	index_uint_t macroResultMacroPendingListTail = 0;

	// Iterate through the pending ResultMacros, processing each of them
	for ( index_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    469a:	4e17      	ldr	r6, [pc, #92]	; (46f8 <Result_process+0x64>)
{
    469c:	682b      	ldr	r3, [r5, #0]
    469e:	9301      	str	r3, [sp, #4]
	for ( index_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    46a0:	2400      	movs	r4, #0
	index_uint_t macroResultMacroPendingListTail = 0;
    46a2:	4627      	mov	r7, r4
	{
		switch ( Result_evalResultMacro( &macroResultMacroPendingList.data[ macro ] ) )
    46a4:	f04f 0a0c 	mov.w	sl, #12
	for ( index_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    46a8:	f8b6 2258 	ldrh.w	r2, [r6, #600]	; 0x258
    46ac:	b2a3      	uxth	r3, r4
    46ae:	429a      	cmp	r2, r3
    46b0:	d807      	bhi.n	46c2 <Result_process+0x2e>
		}
	}

	// Update the macroResultMacroPendingListSize with the tail pointer
	macroResultMacroPendingList.size = macroResultMacroPendingListTail;
}
    46b2:	9a01      	ldr	r2, [sp, #4]
    46b4:	682b      	ldr	r3, [r5, #0]
	macroResultMacroPendingList.size = macroResultMacroPendingListTail;
    46b6:	f8a6 7258 	strh.w	r7, [r6, #600]	; 0x258
}
    46ba:	429a      	cmp	r2, r3
    46bc:	d017      	beq.n	46ee <Result_process+0x5a>
    46be:	f7fc ff31 	bl	1524 <__stack_chk_fail>
		switch ( Result_evalResultMacro( &macroResultMacroPendingList.data[ macro ] ) )
    46c2:	fa1f f884 	uxth.w	r8, r4
    46c6:	fb0a 6808 	mla	r8, sl, r8, r6
    46ca:	4640      	mov	r0, r8
    46cc:	f7ff ff26 	bl	451c <Result_evalResultMacro>
    46d0:	2801      	cmp	r0, #1
    46d2:	d00a      	beq.n	46ea <Result_process+0x56>
			memcpy( &macroResultMacroPendingList.data[ macroResultMacroPendingListTail++ ],
    46d4:	fb0a 6007 	mla	r0, sl, r7, r6
    46d8:	220c      	movs	r2, #12
    46da:	4641      	mov	r1, r8
    46dc:	f107 0901 	add.w	r9, r7, #1
    46e0:	f7fc ff44 	bl	156c <memcpy>
    46e4:	fa1f f989 	uxth.w	r9, r9
    46e8:	464f      	mov	r7, r9
    46ea:	3401      	adds	r4, #1
    46ec:	e7dc      	b.n	46a8 <Result_process+0x14>
}
    46ee:	b002      	add	sp, #8
    46f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    46f4:	1fffe9d0 	.word	0x1fffe9d0
    46f8:	200000f4 	.word	0x200000f4

000046fc <Trigger_showTriggerMacroVote>:

// -- Debug --

// Show TriggerMacroVote
void Trigger_showTriggerMacroVote( TriggerMacroVote vote, uint8_t long_trigger_macro )
{
    46fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    46fe:	4c1f      	ldr	r4, [pc, #124]	; (477c <Trigger_showTriggerMacroVote+0x80>)
    4700:	6823      	ldr	r3, [r4, #0]
    4702:	9301      	str	r3, [sp, #4]
    4704:	4605      	mov	r5, r0
	const char *result = "";

	// Long Macro
	if ( long_trigger_macro )
    4706:	b1b1      	cbz	r1, 4736 <Trigger_showTriggerMacroVote+0x3a>
	{
		print("l");
    4708:	481d      	ldr	r0, [pc, #116]	; (4780 <Trigger_showTriggerMacroVote+0x84>)
	}
	// Short Macro
	else
	{
		print("s");
    470a:	f004 febd 	bl	9488 <_print>
	}

	// Static voting
	switch ( vote )
    470e:	2d08      	cmp	r5, #8
    4710:	d02d      	beq.n	476e <Trigger_showTriggerMacroVote+0x72>
    4712:	d812      	bhi.n	473a <Trigger_showTriggerMacroVote+0x3e>
    4714:	b34d      	cbz	r5, 476a <Trigger_showTriggerMacroVote+0x6e>
	case TriggerMacroVote_PassRelease:
		result = "V:PR";
		break;

	default:
		print("V:");
    4716:	481b      	ldr	r0, [pc, #108]	; (4784 <Trigger_showTriggerMacroVote+0x88>)
    4718:	f004 feb6 	bl	9488 <_print>
		if ( vote & TriggerMacroVote_Fail )
    471c:	07eb      	lsls	r3, r5, #31
    471e:	d502      	bpl.n	4726 <Trigger_showTriggerMacroVote+0x2a>
		{
			print("F");
    4720:	4819      	ldr	r0, [pc, #100]	; (4788 <Trigger_showTriggerMacroVote+0x8c>)
    4722:	f004 feb1 	bl	9488 <_print>
		}
		if ( vote & TriggerMacroVote_DoNothingRelease )
    4726:	0768      	lsls	r0, r5, #29
		{
			print("NR");
    4728:	9a01      	ldr	r2, [sp, #4]
    472a:	6823      	ldr	r3, [r4, #0]
		if ( vote & TriggerMacroVote_DoNothingRelease )
    472c:	d517      	bpl.n	475e <Trigger_showTriggerMacroVote+0x62>
			print("NR");
    472e:	429a      	cmp	r2, r3
    4730:	d00f      	beq.n	4752 <Trigger_showTriggerMacroVote+0x56>
		}
		return;
	}

	print( result );
}
    4732:	f7fc fef7 	bl	1524 <__stack_chk_fail>
		print("s");
    4736:	4815      	ldr	r0, [pc, #84]	; (478c <Trigger_showTriggerMacroVote+0x90>)
    4738:	e7e7      	b.n	470a <Trigger_showTriggerMacroVote+0xe>
	switch ( vote )
    473a:	2d10      	cmp	r5, #16
    473c:	d003      	beq.n	4746 <Trigger_showTriggerMacroVote+0x4a>
    473e:	2d18      	cmp	r5, #24
    4740:	d1e9      	bne.n	4716 <Trigger_showTriggerMacroVote+0x1a>
		result = "V:PR";
    4742:	4813      	ldr	r0, [pc, #76]	; (4790 <Trigger_showTriggerMacroVote+0x94>)
		break;
    4744:	e000      	b.n	4748 <Trigger_showTriggerMacroVote+0x4c>
		result = "V:R";
    4746:	4813      	ldr	r0, [pc, #76]	; (4794 <Trigger_showTriggerMacroVote+0x98>)
	print( result );
    4748:	9a01      	ldr	r2, [sp, #4]
    474a:	6823      	ldr	r3, [r4, #0]
    474c:	429a      	cmp	r2, r3
    474e:	d001      	beq.n	4754 <Trigger_showTriggerMacroVote+0x58>
    4750:	e7ef      	b.n	4732 <Trigger_showTriggerMacroVote+0x36>
			print("NR");
    4752:	4811      	ldr	r0, [pc, #68]	; (4798 <Trigger_showTriggerMacroVote+0x9c>)
}
    4754:	b003      	add	sp, #12
    4756:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	print( result );
    475a:	f004 be95 	b.w	9488 <_print>
		else if ( vote & TriggerMacroVote_DoNothing )
    475e:	07a9      	lsls	r1, r5, #30
    4760:	d507      	bpl.n	4772 <Trigger_showTriggerMacroVote+0x76>
			print("N");
    4762:	429a      	cmp	r2, r3
    4764:	d1e5      	bne.n	4732 <Trigger_showTriggerMacroVote+0x36>
    4766:	480d      	ldr	r0, [pc, #52]	; (479c <Trigger_showTriggerMacroVote+0xa0>)
    4768:	e7f4      	b.n	4754 <Trigger_showTriggerMacroVote+0x58>
		result = "V:I";
    476a:	480d      	ldr	r0, [pc, #52]	; (47a0 <Trigger_showTriggerMacroVote+0xa4>)
    476c:	e7ec      	b.n	4748 <Trigger_showTriggerMacroVote+0x4c>
		result = "V:P";
    476e:	480d      	ldr	r0, [pc, #52]	; (47a4 <Trigger_showTriggerMacroVote+0xa8>)
    4770:	e7ea      	b.n	4748 <Trigger_showTriggerMacroVote+0x4c>
}
    4772:	429a      	cmp	r2, r3
    4774:	d1dd      	bne.n	4732 <Trigger_showTriggerMacroVote+0x36>
    4776:	b003      	add	sp, #12
    4778:	bd30      	pop	{r4, r5, pc}
    477a:	bf00      	nop
    477c:	1fffe9d0 	.word	0x1fffe9d0
    4780:	0000afc4 	.word	0x0000afc4
    4784:	0000bf9d 	.word	0x0000bf9d
    4788:	0000bfa0 	.word	0x0000bfa0
    478c:	0000c85f 	.word	0x0000c85f
    4790:	0000bf98 	.word	0x0000bf98
    4794:	0000bf90 	.word	0x0000bf90
    4798:	0000bfa2 	.word	0x0000bfa2
    479c:	0000bfa5 	.word	0x0000bfa5
    47a0:	0000bf8c 	.word	0x0000bf8c
    47a4:	0000bf94 	.word	0x0000bf94

000047a8 <Trigger_isLongResultMacro>:

// -- General --

// Determine if long ResultMacro (more than 1 seqence element)
uint8_t Trigger_isLongResultMacro( const ResultMacro *macro )
{
    47a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    47aa:	4a0e      	ldr	r2, [pc, #56]	; (47e4 <Trigger_isLongResultMacro+0x3c>)
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    47ac:	6804      	ldr	r4, [r0, #0]
{
    47ae:	6813      	ldr	r3, [r2, #0]
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    47b0:	7826      	ldrb	r6, [r4, #0]
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    47b2:	4f0d      	ldr	r7, [pc, #52]	; (47e8 <Trigger_isLongResultMacro+0x40>)
{
    47b4:	9301      	str	r3, [sp, #4]
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    47b6:	2100      	movs	r1, #0
	var_uint_t position = 1;
    47b8:	2301      	movs	r3, #1
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    47ba:	b28d      	uxth	r5, r1
    47bc:	42ae      	cmp	r6, r5
    47be:	5ce0      	ldrb	r0, [r4, r3]
    47c0:	d805      	bhi.n	47ce <Trigger_isLongResultMacro+0x26>
	return macro->guide[ position ];
}
    47c2:	9901      	ldr	r1, [sp, #4]
    47c4:	6813      	ldr	r3, [r2, #0]
    47c6:	4299      	cmp	r1, r3
    47c8:	d009      	beq.n	47de <Trigger_isLongResultMacro+0x36>
    47ca:	f7fc feab 	bl	1524 <__stack_chk_fail>
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    47ce:	eb07 00c0 	add.w	r0, r7, r0, lsl #3
    47d2:	3101      	adds	r1, #1
    47d4:	7900      	ldrb	r0, [r0, #4]
    47d6:	3001      	adds	r0, #1
    47d8:	4403      	add	r3, r0
    47da:	b29b      	uxth	r3, r3
    47dc:	e7ed      	b.n	47ba <Trigger_isLongResultMacro+0x12>
}
    47de:	b003      	add	sp, #12
    47e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    47e2:	bf00      	nop
    47e4:	1fffe9d0 	.word	0x1fffe9d0
    47e8:	00009ed8 	.word	0x00009ed8

000047ec <Trigger_isLongTriggerMacro>:


// Determine if long TriggerMacro (more than 1 sequence element)
uint8_t Trigger_isLongTriggerMacro( const TriggerMacro *macro )
{
    47ec:	b507      	push	{r0, r1, r2, lr}
    47ee:	4a09      	ldr	r2, [pc, #36]	; (4814 <Trigger_isLongTriggerMacro+0x28>)
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    47f0:	6801      	ldr	r1, [r0, #0]
{
    47f2:	6813      	ldr	r3, [r2, #0]
    47f4:	9301      	str	r3, [sp, #4]
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    47f6:	780b      	ldrb	r3, [r1, #0]
    47f8:	2003      	movs	r0, #3
    47fa:	fb00 1303 	mla	r3, r0, r3, r1
}
    47fe:	9901      	ldr	r1, [sp, #4]
    4800:	7858      	ldrb	r0, [r3, #1]
    4802:	6813      	ldr	r3, [r2, #0]
    4804:	4299      	cmp	r1, r3
    4806:	d001      	beq.n	480c <Trigger_isLongTriggerMacro+0x20>
    4808:	f7fc fe8c 	bl	1524 <__stack_chk_fail>
    480c:	b003      	add	sp, #12
    480e:	f85d fb04 	ldr.w	pc, [sp], #4
    4812:	bf00      	nop
    4814:	1fffe9d0 	.word	0x1fffe9d0

00004818 <Trigger_evalShortTriggerMacroVote_PHRO>:


// Handle short trigger PHRO/AODO state transitions
TriggerMacroVote Trigger_evalShortTriggerMacroVote_PHRO( ScheduleState state )
{
    4818:	b507      	push	{r0, r1, r2, lr}
    481a:	f000 000f 	and.w	r0, r0, #15
    481e:	4b0a      	ldr	r3, [pc, #40]	; (4848 <Trigger_evalShortTriggerMacroVote_PHRO+0x30>)
    4820:	3801      	subs	r0, #1
    4822:	b2c0      	uxtb	r0, r0
    4824:	681a      	ldr	r2, [r3, #0]
    4826:	9201      	str	r2, [sp, #4]
    4828:	2802      	cmp	r0, #2
    482a:	bf9c      	itt	ls
    482c:	4a07      	ldrls	r2, [pc, #28]	; (484c <Trigger_evalShortTriggerMacroVote_PHRO+0x34>)
    482e:	5c10      	ldrbls	r0, [r2, r0]

	// Invalid state, fail
	default:
		return TriggerMacroVote_Fail;
	}
}
    4830:	9a01      	ldr	r2, [sp, #4]
    4832:	681b      	ldr	r3, [r3, #0]
{
    4834:	bf88      	it	hi
    4836:	2001      	movhi	r0, #1
}
    4838:	429a      	cmp	r2, r3
    483a:	d001      	beq.n	4840 <Trigger_evalShortTriggerMacroVote_PHRO+0x28>
    483c:	f7fc fe72 	bl	1524 <__stack_chk_fail>
    4840:	b003      	add	sp, #12
    4842:	f85d fb04 	ldr.w	pc, [sp], #4
    4846:	bf00      	nop
    4848:	1fffe9d0 	.word	0x1fffe9d0
    484c:	0000be4c 	.word	0x0000be4c

00004850 <Trigger_evalShortTriggerMacroVote_DRO>:


// Handle short trigger DRO state transitions
TriggerMacroVote Trigger_evalShortTriggerMacroVote_DRO( ScheduleState state )
{
    4850:	b507      	push	{r0, r1, r2, lr}
    4852:	4b08      	ldr	r3, [pc, #32]	; (4874 <Trigger_evalShortTriggerMacroVote_DRO+0x24>)
    4854:	681a      	ldr	r2, [r3, #0]
    4856:	9201      	str	r2, [sp, #4]
	switch ( state )
    4858:	3806      	subs	r0, #6

	// Invalid state, fail
	default:
		return TriggerMacroVote_Fail;
	}
}
    485a:	9a01      	ldr	r2, [sp, #4]
    485c:	681b      	ldr	r3, [r3, #0]
		return TriggerMacroVote_Pass;
    485e:	2801      	cmp	r0, #1
}
    4860:	bf8c      	ite	hi
    4862:	2001      	movhi	r0, #1
    4864:	2008      	movls	r0, #8
    4866:	429a      	cmp	r2, r3
    4868:	d001      	beq.n	486e <Trigger_evalShortTriggerMacroVote_DRO+0x1e>
    486a:	f7fc fe5b 	bl	1524 <__stack_chk_fail>
    486e:	b003      	add	sp, #12
    4870:	f85d fb04 	ldr.w	pc, [sp], #4
    4874:	1fffe9d0 	.word	0x1fffe9d0

00004878 <Trigger_evalShortTriggerMacroVote>:


// Votes on the given key vs. guide, short macros
TriggerMacroVote Trigger_evalShortTriggerMacroVote( TriggerEvent *event, TriggerGuide *guide, TriggerMacroVote *cur_vote )
{
    4878:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    487c:	460d      	mov	r5, r1
    487e:	4e38      	ldr	r6, [pc, #224]	; (4960 <Trigger_evalShortTriggerMacroVote+0xe8>)
	// Lookup full index
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    4880:	7889      	ldrb	r1, [r1, #2]
{
    4882:	6833      	ldr	r3, [r6, #0]
    4884:	9301      	str	r3, [sp, #4]
    4886:	4604      	mov	r4, r0
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    4888:	7828      	ldrb	r0, [r5, #0]
{
    488a:	4690      	mov	r8, r2
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    488c:	f7fe f820 	bl	28d0 <KLL_TriggerIndex_loopkup>
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    4890:	78a1      	ldrb	r1, [r4, #2]
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    4892:	4681      	mov	r9, r0
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    4894:	7820      	ldrb	r0, [r4, #0]
    4896:	f7fe f81b 	bl	28d0 <KLL_TriggerIndex_loopkup>

	// Return value
	TriggerMacroVote vote = TriggerMacroVote_Invalid;

	// Depending on key type
	switch ( guide->type )
    489a:	782b      	ldrb	r3, [r5, #0]
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    489c:	4607      	mov	r7, r0
	switch ( guide->type )
    489e:	2b15      	cmp	r3, #21
    48a0:	d857      	bhi.n	4952 <Trigger_evalShortTriggerMacroVote+0xda>
    48a2:	e8df f003 	tbb	[pc, r3]
    48a6:	0b0b      	.short	0x0b0b
    48a8:	390b0b0b 	.word	0x390b0b0b
    48ac:	0b393939 	.word	0x0b393939
    48b0:	3e0b0b0b 	.word	0x3e0b0b0b
    48b4:	0b3e3e3e 	.word	0x0b3e3e3e
    48b8:	4a0b0b0b 	.word	0x4a0b0b0b
	case TriggerType_Inactive1:
	case TriggerType_Active1:
		// For short TriggerMacros completely ignore incorrect keys
		// Only monitor 0x70 bits if set in the guide, otherwise ensure they are 0x00
		// Used for Layer state information
		if (
    48bc:	4581      	cmp	r9, r0
    48be:	d129      	bne.n	4914 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide_index == event_index &&
    48c0:	7822      	ldrb	r2, [r4, #0]
    48c2:	429a      	cmp	r2, r3
    48c4:	d126      	bne.n	4914 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide->type == event->type &&
			(
				(guide->state & 0x70) == (event->state & 0x70) ||
    48c6:	786b      	ldrb	r3, [r5, #1]
    48c8:	7860      	ldrb	r0, [r4, #1]
    48ca:	ea83 0200 	eor.w	r2, r3, r0
			guide->type == event->type &&
    48ce:	f012 0f70 	tst.w	r2, #112	; 0x70
    48d2:	d002      	beq.n	48da <Trigger_evalShortTriggerMacroVote+0x62>
				(guide->state & 0x70) == (event->state & 0x70) ||
    48d4:	f013 0f70 	tst.w	r3, #112	; 0x70
    48d8:	d11c      	bne.n	4914 <Trigger_evalShortTriggerMacroVote+0x9c>
				(guide->state & 0x70) == 0x00
			)
		)
		{
			// If this trigger is generic, we can just vote based on the incoming state
			if ( guide->state & ScheduleType_Gen )
    48da:	061b      	lsls	r3, r3, #24
    48dc:	d517      	bpl.n	490e <Trigger_evalShortTriggerMacroVote+0x96>
			{
				vote = Trigger_evalShortTriggerMacroVote_PHRO( event->state );
    48de:	f7ff ff9b 	bl	4818 <Trigger_evalShortTriggerMacroVote_PHRO>
		erro_print("Invalid State Type. This is a bug.");
		break;
	}

	// If this is a combo macro, make a preference for TriggerMacroVote_Pass instead of TriggerMacroVote_PassRelease
	if ( *cur_vote != TriggerMacroVote_Invalid && event_index == guide_index )
    48e2:	f898 3000 	ldrb.w	r3, [r8]
    48e6:	b163      	cbz	r3, 4902 <Trigger_evalShortTriggerMacroVote+0x8a>
    48e8:	45b9      	cmp	r9, r7
    48ea:	d10a      	bne.n	4902 <Trigger_evalShortTriggerMacroVote+0x8a>
	{
		// Make sure the votes are different and one of them are Pass
		if ( *cur_vote != vote
    48ec:	4283      	cmp	r3, r0
    48ee:	d008      	beq.n	4902 <Trigger_evalShortTriggerMacroVote+0x8a>
			&& ( *cur_vote == TriggerMacroVote_Pass || vote == TriggerMacroVote_Pass )
    48f0:	2b08      	cmp	r3, #8
    48f2:	d030      	beq.n	4956 <Trigger_evalShortTriggerMacroVote+0xde>
    48f4:	2808      	cmp	r0, #8
    48f6:	d104      	bne.n	4902 <Trigger_evalShortTriggerMacroVote+0x8a>
			&& ( *cur_vote == TriggerMacroVote_PassRelease || vote == TriggerMacroVote_PassRelease )
    48f8:	2b18      	cmp	r3, #24
		)
		{
			*cur_vote = TriggerMacroVote_Pass;
    48fa:	bf04      	itt	eq
    48fc:	2008      	moveq	r0, #8
    48fe:	f888 0000 	strbeq.w	r0, [r8]
			vote = TriggerMacroVote_Pass;
		}
	}

	return vote;
}
    4902:	9a01      	ldr	r2, [sp, #4]
    4904:	6833      	ldr	r3, [r6, #0]
    4906:	429a      	cmp	r2, r3
    4908:	d027      	beq.n	495a <Trigger_evalShortTriggerMacroVote+0xe2>
    490a:	f7fc fe0b 	bl	1524 <__stack_chk_fail>
			erro_print("State Scheduling not implemented yet...");
    490e:	4815      	ldr	r0, [pc, #84]	; (4964 <Trigger_evalShortTriggerMacroVote+0xec>)
    4910:	f004 fdba 	bl	9488 <_print>
		vote = TriggerMacroVote_DoNothing;
    4914:	2002      	movs	r0, #2
    4916:	e7e4      	b.n	48e2 <Trigger_evalShortTriggerMacroVote+0x6a>
		erro_print("Analog State Type - Not implemented...");
    4918:	4813      	ldr	r0, [pc, #76]	; (4968 <Trigger_evalShortTriggerMacroVote+0xf0>)
		erro_print("Invalid State Type. This is a bug.");
    491a:	f004 fdb5 	bl	9488 <_print>
	TriggerMacroVote vote = TriggerMacroVote_Invalid;
    491e:	2000      	movs	r0, #0
		break;
    4920:	e7df      	b.n	48e2 <Trigger_evalShortTriggerMacroVote+0x6a>
		if (
    4922:	4581      	cmp	r9, r0
    4924:	d1f6      	bne.n	4914 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide_index == event_index &&
    4926:	7822      	ldrb	r2, [r4, #0]
    4928:	429a      	cmp	r2, r3
    492a:	d1f3      	bne.n	4914 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide->state == event->state
    492c:	786b      	ldrb	r3, [r5, #1]
			guide->type == event->type &&
    492e:	7860      	ldrb	r0, [r4, #1]
    4930:	4298      	cmp	r0, r3
    4932:	d1ef      	bne.n	4914 <Trigger_evalShortTriggerMacroVote+0x9c>
			vote = Trigger_evalShortTriggerMacroVote_DRO( event->state );
    4934:	f7ff ff8c 	bl	4850 <Trigger_evalShortTriggerMacroVote_DRO>
			break;
    4938:	e7d3      	b.n	48e2 <Trigger_evalShortTriggerMacroVote+0x6a>
		if (
    493a:	4581      	cmp	r9, r0
    493c:	d1ea      	bne.n	4914 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide_index == event_index &&
    493e:	7823      	ldrb	r3, [r4, #0]
    4940:	2b15      	cmp	r3, #21
    4942:	d1e7      	bne.n	4914 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide->type == event->type &&
    4944:	7868      	ldrb	r0, [r5, #1]
    4946:	7863      	ldrb	r3, [r4, #1]
			vote = Trigger_evalShortTriggerMacroVote_PHRO( ScheduleType_P );
    4948:	4298      	cmp	r0, r3
    494a:	bf14      	ite	ne
    494c:	2002      	movne	r0, #2
    494e:	2008      	moveq	r0, #8
    4950:	e7c7      	b.n	48e2 <Trigger_evalShortTriggerMacroVote+0x6a>
		erro_print("Invalid State Type. This is a bug.");
    4952:	4806      	ldr	r0, [pc, #24]	; (496c <Trigger_evalShortTriggerMacroVote+0xf4>)
    4954:	e7e1      	b.n	491a <Trigger_evalShortTriggerMacroVote+0xa2>
			&& ( *cur_vote == TriggerMacroVote_PassRelease || vote == TriggerMacroVote_PassRelease )
    4956:	2818      	cmp	r0, #24
    4958:	e7cf      	b.n	48fa <Trigger_evalShortTriggerMacroVote+0x82>
}
    495a:	b003      	add	sp, #12
    495c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    4960:	1fffe9d0 	.word	0x1fffe9d0
    4964:	0000be9d 	.word	0x0000be9d
    4968:	0000bedc 	.word	0x0000bedc
    496c:	0000bf1a 	.word	0x0000bf1a

00004970 <Trigger_evalLongTriggerMacroVote>:


// Votes on the given key vs. guide, long macros
// A long macro is defined as a guide with more than 1 combo
TriggerMacroVote Trigger_evalLongTriggerMacroVote( TriggerEvent *event, TriggerGuide *guide, TriggerMacroVote *cur_vote )
{
    4970:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    4972:	460d      	mov	r5, r1
    4974:	4e2e      	ldr	r6, [pc, #184]	; (4a30 <Trigger_evalLongTriggerMacroVote+0xc0>)
	// Lookup full index
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    4976:	7889      	ldrb	r1, [r1, #2]
{
    4978:	6833      	ldr	r3, [r6, #0]
    497a:	9301      	str	r3, [sp, #4]
    497c:	4604      	mov	r4, r0
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    497e:	7828      	ldrb	r0, [r5, #0]
    4980:	f7fd ffa6 	bl	28d0 <KLL_TriggerIndex_loopkup>
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    4984:	78a1      	ldrb	r1, [r4, #2]
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    4986:	4607      	mov	r7, r0
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    4988:	7820      	ldrb	r0, [r4, #0]
    498a:	f7fd ffa1 	bl	28d0 <KLL_TriggerIndex_loopkup>

	// Depending on key type
	switch ( guide->type )
    498e:	782a      	ldrb	r2, [r5, #0]
    4990:	2a15      	cmp	r2, #21
    4992:	d844      	bhi.n	4a1e <Trigger_evalLongTriggerMacroVote+0xae>
    4994:	e8df f002 	tbb	[pc, r2]
    4998:	0b0b0b0b 	.word	0x0b0b0b0b
    499c:	2d2d2d0b 	.word	0x2d2d2d0b
    49a0:	0b0b0b2d 	.word	0x0b0b0b2d
    49a4:	3232320b 	.word	0x3232320b
    49a8:	0b0b0b32 	.word	0x0b0b0b32
    49ac:	410b      	.short	0x410b
	case TriggerType_Active1:
		// Depending on the state of the buffered key, make voting decision
		// Only monitor 0x70 bits if set in the guide, otherwise ensure they are 0x00
		// Used for Layer state information
		// Correct key
		if (
    49ae:	4287      	cmp	r7, r0
    49b0:	7863      	ldrb	r3, [r4, #1]
    49b2:	d117      	bne.n	49e4 <Trigger_evalLongTriggerMacroVote+0x74>
			guide_index == event_index &&
    49b4:	7821      	ldrb	r1, [r4, #0]
    49b6:	4291      	cmp	r1, r2
    49b8:	d114      	bne.n	49e4 <Trigger_evalLongTriggerMacroVote+0x74>
			guide->type == event->type &&
			(
				(guide->state & 0x70) == (event->state & 0x70) ||
    49ba:	786a      	ldrb	r2, [r5, #1]
    49bc:	ea82 0103 	eor.w	r1, r2, r3
			guide->type == event->type &&
    49c0:	f011 0f70 	tst.w	r1, #112	; 0x70
    49c4:	d002      	beq.n	49cc <Trigger_evalLongTriggerMacroVote+0x5c>
				(guide->state & 0x70) == (event->state & 0x70) ||
    49c6:	f012 0f70 	tst.w	r2, #112	; 0x70
    49ca:	d10b      	bne.n	49e4 <Trigger_evalLongTriggerMacroVote+0x74>
    49cc:	1e58      	subs	r0, r3, #1
    49ce:	b2c0      	uxtb	r0, r0
    49d0:	2802      	cmp	r0, #2
    49d2:	d828      	bhi.n	4a26 <Trigger_evalLongTriggerMacroVote+0xb6>
    49d4:	4b17      	ldr	r3, [pc, #92]	; (4a34 <Trigger_evalLongTriggerMacroVote+0xc4>)
    49d6:	5c18      	ldrb	r0, [r3, r0]
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
}
    49d8:	9a01      	ldr	r2, [sp, #4]
    49da:	6833      	ldr	r3, [r6, #0]
    49dc:	429a      	cmp	r2, r3
    49de:	d024      	beq.n	4a2a <Trigger_evalLongTriggerMacroVote+0xba>
    49e0:	f7fc fda0 	bl	1524 <__stack_chk_fail>
		switch ( state )
    49e4:	2b02      	cmp	r3, #2
    49e6:	d01c      	beq.n	4a22 <Trigger_evalLongTriggerMacroVote+0xb2>
			return TriggerMacroVote_Fail;
    49e8:	2b03      	cmp	r3, #3
    49ea:	bf0c      	ite	eq
    49ec:	2006      	moveq	r0, #6
    49ee:	2001      	movne	r0, #1
    49f0:	e7f2      	b.n	49d8 <Trigger_evalLongTriggerMacroVote+0x68>
		erro_print("Analog State Type - Not implemented...");
    49f2:	4811      	ldr	r0, [pc, #68]	; (4a38 <Trigger_evalLongTriggerMacroVote+0xc8>)
		erro_print("Invalid State Type. This is a bug.");
    49f4:	f004 fd48 	bl	9488 <_print>
	return TriggerMacroVote_Invalid;
    49f8:	2000      	movs	r0, #0
		break;
    49fa:	e7ed      	b.n	49d8 <Trigger_evalLongTriggerMacroVote+0x68>
		if (
    49fc:	4287      	cmp	r7, r0
    49fe:	d112      	bne.n	4a26 <Trigger_evalLongTriggerMacroVote+0xb6>
			guide_index == event_index &&
    4a00:	7823      	ldrb	r3, [r4, #0]
    4a02:	4293      	cmp	r3, r2
    4a04:	d10f      	bne.n	4a26 <Trigger_evalLongTriggerMacroVote+0xb6>
			guide->state == event->state
    4a06:	786a      	ldrb	r2, [r5, #1]
			guide->type == event->type &&
    4a08:	7863      	ldrb	r3, [r4, #1]
    4a0a:	4293      	cmp	r3, r2
    4a0c:	d10b      	bne.n	4a26 <Trigger_evalLongTriggerMacroVote+0xb6>
		switch ( state )
    4a0e:	3b06      	subs	r3, #6
			return TriggerMacroVote_Pass;
    4a10:	2b01      	cmp	r3, #1
    4a12:	bf8c      	ite	hi
    4a14:	2001      	movhi	r0, #1
    4a16:	2008      	movls	r0, #8
    4a18:	e7de      	b.n	49d8 <Trigger_evalLongTriggerMacroVote+0x68>
		erro_print("Rotation State Type (Long Macros) - Not implemented...");
    4a1a:	4808      	ldr	r0, [pc, #32]	; (4a3c <Trigger_evalLongTriggerMacroVote+0xcc>)
    4a1c:	e7ea      	b.n	49f4 <Trigger_evalLongTriggerMacroVote+0x84>
		erro_print("Invalid State Type. This is a bug.");
    4a1e:	4808      	ldr	r0, [pc, #32]	; (4a40 <Trigger_evalLongTriggerMacroVote+0xd0>)
    4a20:	e7e8      	b.n	49f4 <Trigger_evalLongTriggerMacroVote+0x84>
			return TriggerMacroVote_DoNothing;
    4a22:	4618      	mov	r0, r3
    4a24:	e7d8      	b.n	49d8 <Trigger_evalLongTriggerMacroVote+0x68>
    4a26:	2001      	movs	r0, #1
    4a28:	e7d6      	b.n	49d8 <Trigger_evalLongTriggerMacroVote+0x68>
}
    4a2a:	b003      	add	sp, #12
    4a2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4a2e:	bf00      	nop
    4a30:	1fffe9d0 	.word	0x1fffe9d0
    4a34:	0000be4c 	.word	0x0000be4c
    4a38:	0000bedc 	.word	0x0000bedc
    4a3c:	0000be4f 	.word	0x0000be4f
    4a40:	0000bf1a 	.word	0x0000bf1a

00004a44 <Trigger_overallVote>:
	const TriggerMacro *macro,
	TriggerMacroRecord *record,
	uint8_t long_trigger_macro,
	var_uint_t pos
)
{
    4a44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4a48:	492b      	ldr	r1, [pc, #172]	; (4af8 <Trigger_overallVote+0xb4>)
    4a4a:	b085      	sub	sp, #20
    4a4c:	4690      	mov	r8, r2
    4a4e:	680a      	ldr	r2, [r1, #0]
    4a50:	9203      	str	r2, [sp, #12]
	// Length of the combo being processed
	uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    4a52:	6802      	ldr	r2, [r0, #0]
    4a54:	9101      	str	r1, [sp, #4]
    4a56:	5cd2      	ldrb	r2, [r2, r3]
    4a58:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    4a5c:	fa5f fa82 	uxtb.w	sl, r2
	// Once all keys have been pressed/held (only those keys), entered TriggerMacro_Press state (passing)
	// Transition to the next combo (if it exists) when a single key is released (TriggerMacro_Release state)
	// On scan after position increment, change to TriggerMacro_Waiting state
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    4a60:	1c5d      	adds	r5, r3, #1
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    4a62:	2200      	movs	r2, #0
{
    4a64:	4681      	mov	r9, r0
    4a66:	469b      	mov	fp, r3
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    4a68:	f88d 200b 	strb.w	r2, [sp, #11]
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    4a6c:	b2ed      	uxtb	r5, r5
    4a6e:	eb0b 020a 	add.w	r2, fp, sl
    4a72:	42aa      	cmp	r2, r5
    4a74:	da08      	bge.n	4a88 <Trigger_overallVote+0x44>
		// After voting, append to overall vote
		overallVote |= vote;
	}

	return overallVote;
}
    4a76:	9b01      	ldr	r3, [sp, #4]
    4a78:	9a03      	ldr	r2, [sp, #12]
    4a7a:	681b      	ldr	r3, [r3, #0]
    4a7c:	f89d 000b 	ldrb.w	r0, [sp, #11]
    4a80:	429a      	cmp	r2, r3
    4a82:	d036      	beq.n	4af2 <Trigger_overallVote+0xae>
    4a84:	f7fc fd4e 	bl	1524 <__stack_chk_fail>
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    4a88:	f8d9 7000 	ldr.w	r7, [r9]
		for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    4a8c:	2600      	movs	r6, #0
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    4a8e:	442f      	add	r7, r5
		TriggerMacroVote vote = TriggerMacroVote_Invalid;
    4a90:	4634      	mov	r4, r6
		for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    4a92:	4b1a      	ldr	r3, [pc, #104]	; (4afc <Trigger_overallVote+0xb8>)
    4a94:	8819      	ldrh	r1, [r3, #0]
    4a96:	b2b2      	uxth	r2, r6
    4a98:	4291      	cmp	r1, r2
    4a9a:	d812      	bhi.n	4ac2 <Trigger_overallVote+0x7e>
		if ( vote >= TriggerMacroVote_Pass )
    4a9c:	2c07      	cmp	r4, #7
    4a9e:	d924      	bls.n	4aea <Trigger_overallVote+0xa6>
			vote &= TriggerMacroVote_Release | TriggerMacroVote_PassRelease | TriggerMacroVote_Pass;
    4aa0:	f004 0418 	and.w	r4, r4, #24
		if ( !long_trigger_macro && vote < TriggerMacroVote_Pass )
    4aa4:	f1b8 0f00 	cmp.w	r8, #0
    4aa8:	d103      	bne.n	4ab2 <Trigger_overallVote+0x6e>
    4aaa:	2c07      	cmp	r4, #7
    4aac:	d801      	bhi.n	4ab2 <Trigger_overallVote+0x6e>
			vote |= TriggerMacroVote_Fail;
    4aae:	f044 0401 	orr.w	r4, r4, #1
		overallVote |= vote;
    4ab2:	f89d 000b 	ldrb.w	r0, [sp, #11]
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    4ab6:	3503      	adds	r5, #3
		overallVote |= vote;
    4ab8:	4304      	orrs	r4, r0
    4aba:	f88d 400b 	strb.w	r4, [sp, #11]
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    4abe:	b2ed      	uxtb	r5, r5
    4ac0:	e7d5      	b.n	4a6e <Trigger_overallVote+0x2a>
			TriggerEvent *triggerInfo = &macroTriggerEventBuffer[ key ];
    4ac2:	b2b0      	uxth	r0, r6
    4ac4:	4b0e      	ldr	r3, [pc, #56]	; (4b00 <Trigger_overallVote+0xbc>)
    4ac6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    4aca:	4418      	add	r0, r3
				? Trigger_evalLongTriggerMacroVote( triggerInfo, guide, &overallVote )
    4acc:	f10d 020b 	add.w	r2, sp, #11
    4ad0:	4639      	mov	r1, r7
				: Trigger_evalShortTriggerMacroVote( triggerInfo, guide, &overallVote );
    4ad2:	f1b8 0f00 	cmp.w	r8, #0
    4ad6:	d005      	beq.n	4ae4 <Trigger_overallVote+0xa0>
				? Trigger_evalLongTriggerMacroVote( triggerInfo, guide, &overallVote )
    4ad8:	f7ff ff4a 	bl	4970 <Trigger_evalLongTriggerMacroVote>
			vote |= long_trigger_macro
    4adc:	4304      	orrs	r4, r0
    4ade:	b2e4      	uxtb	r4, r4
    4ae0:	3601      	adds	r6, #1
    4ae2:	e7d6      	b.n	4a92 <Trigger_overallVote+0x4e>
				: Trigger_evalShortTriggerMacroVote( triggerInfo, guide, &overallVote );
    4ae4:	f7ff fec8 	bl	4878 <Trigger_evalShortTriggerMacroVote>
    4ae8:	e7f8      	b.n	4adc <Trigger_overallVote+0x98>
		if ( !long_trigger_macro && vote < TriggerMacroVote_Pass )
    4aea:	f1b8 0f00 	cmp.w	r8, #0
    4aee:	d0de      	beq.n	4aae <Trigger_overallVote+0x6a>
    4af0:	e7df      	b.n	4ab2 <Trigger_overallVote+0x6e>
}
    4af2:	b005      	add	sp, #20
    4af4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4af8:	1fffe9d0 	.word	0x1fffe9d0
    4afc:	1ffffcb0 	.word	0x1ffffcb0
    4b00:	1ffffcb5 	.word	0x1ffffcb5

00004b04 <Trigger_evalTriggerMacro>:


// Evaluate/Update TriggerMacro
TriggerMacroEval Trigger_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    4b04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4b08:	4c75      	ldr	r4, [pc, #468]	; (4ce0 <Trigger_evalTriggerMacro+0x1dc>)
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    4b0a:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 4cf8 <Trigger_evalTriggerMacro+0x1f4>
{
    4b0e:	6823      	ldr	r3, [r4, #0]
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    4b10:	4f74      	ldr	r7, [pc, #464]	; (4ce4 <Trigger_evalTriggerMacro+0x1e0>)
{
    4b12:	b085      	sub	sp, #20
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    4b14:	00c6      	lsls	r6, r0, #3
{
    4b16:	9303      	str	r3, [sp, #12]
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    4b18:	2106      	movs	r1, #6
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    4b1a:	eb06 0308 	add.w	r3, r6, r8
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    4b1e:	fb01 fb00 	mul.w	fp, r1, r0
{
    4b22:	4605      	mov	r5, r0

	// Check if this is a long Trigger Macro
	uint8_t long_trigger_macro = Trigger_isLongTriggerMacro( macro );
    4b24:	4618      	mov	r0, r3
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    4b26:	9300      	str	r3, [sp, #0]
	uint8_t long_trigger_macro = Trigger_isLongTriggerMacro( macro );
    4b28:	f7ff fe60 	bl	47ec <Trigger_isLongTriggerMacro>
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    4b2c:	eb0b 0a07 	add.w	sl, fp, r7
    4b30:	f83b 3007 	ldrh.w	r3, [fp, r7]
    4b34:	9401      	str	r4, [sp, #4]

	// Long Macro
	if ( long_trigger_macro )
    4b36:	4681      	mov	r9, r0
    4b38:	4644      	mov	r4, r8
    4b3a:	2800      	cmp	r0, #0
    4b3c:	f000 8089 	beq.w	4c52 <Trigger_evalTriggerMacro+0x14e>
	{
		// Check if macro has finished and should be incremented sequence elements
		if ( record->state != TriggerMacro_Waiting )
    4b40:	f89a 2004 	ldrb.w	r2, [sl, #4]
    4b44:	f858 8035 	ldr.w	r8, [r8, r5, lsl #3]
    4b48:	b14a      	cbz	r2, 4b5e <Trigger_evalTriggerMacro+0x5a>
		{
			record->prevPos = record->pos;
    4b4a:	f8aa 3002 	strh.w	r3, [sl, #2]
			record->pos = record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1;
    4b4e:	f818 2003 	ldrb.w	r2, [r8, r3]
    4b52:	3301      	adds	r3, #1
    4b54:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    4b58:	4413      	add	r3, r2
    4b5a:	f82b 3007 	strh.w	r3, [fp, r7]
		}

		// Current Macro position
		var_uint_t pos = record->pos;
    4b5e:	2306      	movs	r3, #6
    4b60:	436b      	muls	r3, r5
    4b62:	5afe      	ldrh	r6, [r7, r3]

		// Length of the combo being processed
		uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    4b64:	f818 0006 	ldrb.w	r0, [r8, r6]
    4b68:	eb00 0040 	add.w	r0, r0, r0, lsl #1

		TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
		// Iterate through the items in the combo, voting the on the key state
		// If any of the pressed keys do not match, fail the macro
		if ( comboLength != 0 )
    4b6c:	f010 0bff 	ands.w	fp, r0, #255	; 0xff
    4b70:	d034      	beq.n	4bdc <Trigger_evalTriggerMacro+0xd8>
		{
			overallVote |= Trigger_overallVote( macro, record, long_trigger_macro, pos );
    4b72:	4633      	mov	r3, r6
    4b74:	464a      	mov	r2, r9
    4b76:	4651      	mov	r1, sl
    4b78:	9800      	ldr	r0, [sp, #0]
    4b7a:	f7ff ff63 	bl	4a44 <Trigger_overallVote>
    4b7e:	4604      	mov	r4, r0
		}

		// If this is a sequence, and have processed at least one vote already
		// then we need to keep track of releases
		if ( pos != 0 )
    4b80:	b156      	cbz	r6, 4b98 <Trigger_evalTriggerMacro+0x94>
		{
			overallVote |= Trigger_overallVote( macro, record, long_trigger_macro, record->prevPos );
    4b82:	2306      	movs	r3, #6
    4b84:	fb03 7305 	mla	r3, r3, r5, r7
    4b88:	464a      	mov	r2, r9
    4b8a:	885b      	ldrh	r3, [r3, #2]
    4b8c:	9800      	ldr	r0, [sp, #0]
    4b8e:	4651      	mov	r1, sl
    4b90:	f7ff ff58 	bl	4a44 <Trigger_overallVote>
    4b94:	4304      	orrs	r4, r0
    4b96:	b2e4      	uxtb	r4, r4
		}

		// If no pass vote was found after scanning the entire combo
		// And this is the first position in the combo, just remove it (nothing important happened)
		if ( overallVote & TriggerMacroVote_DoNothingRelease && pos == 0 )
    4b98:	0762      	lsls	r2, r4, #29
    4b9a:	d503      	bpl.n	4ba4 <Trigger_evalTriggerMacro+0xa0>
    4b9c:	b916      	cbnz	r6, 4ba4 <Trigger_evalTriggerMacro+0xa0>
		{
			overallVote |= TriggerMacroVote_Fail;
    4b9e:	f044 0401 	orr.w	r4, r4, #1
    4ba2:	b2e4      	uxtb	r4, r4
		}

		// Vote Debug
		switch ( voteDebugMode )
    4ba4:	4b50      	ldr	r3, [pc, #320]	; (4ce8 <Trigger_evalTriggerMacro+0x1e4>)
    4ba6:	781b      	ldrb	r3, [r3, #0]
    4ba8:	2b01      	cmp	r3, #1
    4baa:	d10c      	bne.n	4bc6 <Trigger_evalTriggerMacro+0xc2>
		{
		case 1:
			Trigger_showTriggerMacroVote( overallVote, long_trigger_macro );
    4bac:	4649      	mov	r1, r9
    4bae:	4620      	mov	r0, r4
    4bb0:	f7ff fda4 	bl	46fc <Trigger_showTriggerMacroVote>
			print(" TriggerMacroList[");
    4bb4:	484d      	ldr	r0, [pc, #308]	; (4cec <Trigger_evalTriggerMacro+0x1e8>)
    4bb6:	f004 fc67 	bl	9488 <_print>
			printInt16( triggerMacroIndex );
    4bba:	4628      	mov	r0, r5
    4bbc:	f004 fd04 	bl	95c8 <printInt16>
			print("]");
    4bc0:	484b      	ldr	r0, [pc, #300]	; (4cf0 <Trigger_evalTriggerMacro+0x1ec>)
    4bc2:	f004 fc61 	bl	9488 <_print>
			break;
		}

		// Decide new state of macro after voting
		// Fail macro, remove from pending list
		if ( overallVote & TriggerMacroVote_Fail )
    4bc6:	f014 0001 	ands.w	r0, r4, #1
    4bca:	f040 8084 	bne.w	4cd6 <Trigger_evalTriggerMacro+0x1d2>
		{
			return TriggerMacroEval_Remove;
		}
		// Do nothing, incorrect key is being held or released
		else if ( overallVote & TriggerMacroVote_DoNothing )
    4bce:	07a3      	lsls	r3, r4, #30
    4bd0:	d506      	bpl.n	4be0 <Trigger_evalTriggerMacro+0xdc>
		{
			record->state = TriggerMacro_Waiting;
    4bd2:	2306      	movs	r3, #6
    4bd4:	fb03 7505 	mla	r5, r3, r5, r7
		else if ( overallVote & TriggerMacroVote_Release )
		{
			// Long result macro (more than 1 combo) are ignored (only on press)
			if ( !Trigger_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
			{
				record->state = TriggerMacro_Release;
    4bd8:	7128      	strb	r0, [r5, #4]

				return TriggerMacroEval_DoResultAndRemove;
    4bda:	e01f      	b.n	4c1c <Trigger_evalTriggerMacro+0x118>
		TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    4bdc:	465c      	mov	r4, fp
    4bde:	e7cf      	b.n	4b80 <Trigger_evalTriggerMacro+0x7c>
		else if ( ( overallVote & TriggerMacroVote_PassRelease ) == TriggerMacroVote_PassRelease )
    4be0:	f004 0318 	and.w	r3, r4, #24
    4be4:	2b18      	cmp	r3, #24
    4be6:	d10a      	bne.n	4bfe <Trigger_evalTriggerMacro+0xfa>
			record->state = TriggerMacro_PressRelease;
    4be8:	2306      	movs	r3, #6
    4bea:	fb03 7505 	mla	r5, r3, r5, r7
    4bee:	2303      	movs	r3, #3
			if ( macro->guide[ pos + comboLength + 1 ] == 0 )
    4bf0:	4446      	add	r6, r8
    4bf2:	445e      	add	r6, fp
			record->state = TriggerMacro_Press;
    4bf4:	712b      	strb	r3, [r5, #4]
			if ( macro->guide[ pos + comboLength + 1 ] == 0 )
    4bf6:	7870      	ldrb	r0, [r6, #1]
			return TriggerMacroEval_Remove;
    4bf8:	fab0 f080 	clz	r0, r0
    4bfc:	e017      	b.n	4c2e <Trigger_evalTriggerMacro+0x12a>
		else if ( overallVote & TriggerMacroVote_Release && record->state & TriggerMacro_Press )
    4bfe:	06e1      	lsls	r1, r4, #27
    4c00:	d517      	bpl.n	4c32 <Trigger_evalTriggerMacro+0x12e>
    4c02:	2306      	movs	r3, #6
    4c04:	fb03 7305 	mla	r3, r3, r5, r7
    4c08:	791a      	ldrb	r2, [r3, #4]
    4c0a:	07d2      	lsls	r2, r2, #31
    4c0c:	d511      	bpl.n	4c32 <Trigger_evalTriggerMacro+0x12e>
			if ( macro->guide[ pos + comboLength + 1 ] == 0 || comboLength == 0 )
    4c0e:	4446      	add	r6, r8
			record->state = TriggerMacro_Release;
    4c10:	2202      	movs	r2, #2
			if ( macro->guide[ pos + comboLength + 1 ] == 0 || comboLength == 0 )
    4c12:	445e      	add	r6, fp
			record->state = TriggerMacro_Release;
    4c14:	711a      	strb	r2, [r3, #4]
			if ( macro->guide[ pos + comboLength + 1 ] == 0 || comboLength == 0 )
    4c16:	7873      	ldrb	r3, [r6, #1]
    4c18:	b93b      	cbnz	r3, 4c2a <Trigger_evalTriggerMacro+0x126>
				return TriggerMacroEval_DoResult;
    4c1a:	2001      	movs	r0, #1
		// The state can be rebuilt on the next iteration
		return TriggerMacroEval_Remove;
	}

	return TriggerMacroEval_DoNothing;
}
    4c1c:	9b01      	ldr	r3, [sp, #4]
    4c1e:	9a03      	ldr	r2, [sp, #12]
    4c20:	681b      	ldr	r3, [r3, #0]
    4c22:	429a      	cmp	r2, r3
    4c24:	d059      	beq.n	4cda <Trigger_evalTriggerMacro+0x1d6>
    4c26:	f7fc fc7d 	bl	1524 <__stack_chk_fail>
			return TriggerMacroEval_Remove;
    4c2a:	fabb f08b 	clz	r0, fp
    4c2e:	0940      	lsrs	r0, r0, #5
    4c30:	e7f4      	b.n	4c1c <Trigger_evalTriggerMacro+0x118>
		else if ( overallVote & TriggerMacroVote_Pass
    4c32:	f014 0008 	ands.w	r0, r4, #8
    4c36:	d0f1      	beq.n	4c1c <Trigger_evalTriggerMacro+0x118>
			&& ( record->state == TriggerMacro_Waiting || record->state & TriggerMacro_Press ) )
    4c38:	2306      	movs	r3, #6
    4c3a:	fb03 7305 	mla	r3, r3, r5, r7
    4c3e:	7918      	ldrb	r0, [r3, #4]
    4c40:	b110      	cbz	r0, 4c48 <Trigger_evalTriggerMacro+0x144>
    4c42:	f010 0001 	ands.w	r0, r0, #1
    4c46:	d0e9      	beq.n	4c1c <Trigger_evalTriggerMacro+0x118>
			record->state = TriggerMacro_Press;
    4c48:	2306      	movs	r3, #6
    4c4a:	fb03 7505 	mla	r5, r3, r5, r7
    4c4e:	2301      	movs	r3, #1
    4c50:	e7ce      	b.n	4bf0 <Trigger_evalTriggerMacro+0xec>
		TriggerMacroVote overallVote = Trigger_overallVote( macro, record, long_trigger_macro, pos );
    4c52:	4602      	mov	r2, r0
    4c54:	4651      	mov	r1, sl
    4c56:	9800      	ldr	r0, [sp, #0]
    4c58:	f7ff fef4 	bl	4a44 <Trigger_overallVote>
		switch ( voteDebugMode )
    4c5c:	4b22      	ldr	r3, [pc, #136]	; (4ce8 <Trigger_evalTriggerMacro+0x1e4>)
    4c5e:	781b      	ldrb	r3, [r3, #0]
    4c60:	2b01      	cmp	r3, #1
		TriggerMacroVote overallVote = Trigger_overallVote( macro, record, long_trigger_macro, pos );
    4c62:	4680      	mov	r8, r0
		switch ( voteDebugMode )
    4c64:	d10b      	bne.n	4c7e <Trigger_evalTriggerMacro+0x17a>
			Trigger_showTriggerMacroVote( overallVote, long_trigger_macro );
    4c66:	4649      	mov	r1, r9
    4c68:	f7ff fd48 	bl	46fc <Trigger_showTriggerMacroVote>
			print(" TriggerMacroList[");
    4c6c:	481f      	ldr	r0, [pc, #124]	; (4cec <Trigger_evalTriggerMacro+0x1e8>)
    4c6e:	f004 fc0b 	bl	9488 <_print>
			printInt16( triggerMacroIndex );
    4c72:	4628      	mov	r0, r5
    4c74:	f004 fca8 	bl	95c8 <printInt16>
			print("]");
    4c78:	481d      	ldr	r0, [pc, #116]	; (4cf0 <Trigger_evalTriggerMacro+0x1ec>)
    4c7a:	f004 fc05 	bl	9488 <_print>
		if ( overallVote & TriggerMacroVote_Fail )
    4c7e:	f018 0f01 	tst.w	r8, #1
    4c82:	d128      	bne.n	4cd6 <Trigger_evalTriggerMacro+0x1d2>
		else if ( overallVote & TriggerMacroVote_Pass
    4c84:	f018 0f08 	tst.w	r8, #8
    4c88:	d015      	beq.n	4cb6 <Trigger_evalTriggerMacro+0x1b2>
			&& ( record->state == TriggerMacro_Waiting || record->state == TriggerMacro_Press )
    4c8a:	2306      	movs	r3, #6
    4c8c:	fb03 7305 	mla	r3, r3, r5, r7
    4c90:	791a      	ldrb	r2, [r3, #4]
    4c92:	2a01      	cmp	r2, #1
    4c94:	d80f      	bhi.n	4cb6 <Trigger_evalTriggerMacro+0x1b2>
			if ( Trigger_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    4c96:	4434      	add	r4, r6
			record->state = TriggerMacro_Press;
    4c98:	2201      	movs	r2, #1
    4c9a:	711a      	strb	r2, [r3, #4]
			if ( Trigger_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    4c9c:	88a0      	ldrh	r0, [r4, #4]
    4c9e:	4b15      	ldr	r3, [pc, #84]	; (4cf4 <Trigger_evalTriggerMacro+0x1f0>)
    4ca0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    4ca4:	f7ff fd80 	bl	47a8 <Trigger_isLongResultMacro>
    4ca8:	2800      	cmp	r0, #0
    4caa:	d0b6      	beq.n	4c1a <Trigger_evalTriggerMacro+0x116>
				if ( overallVote == TriggerMacroVote_Pass )
    4cac:	f1b8 0f08 	cmp.w	r8, #8
    4cb0:	d111      	bne.n	4cd6 <Trigger_evalTriggerMacro+0x1d2>
					return TriggerMacroEval_DoResultAndRemove;
    4cb2:	2002      	movs	r0, #2
    4cb4:	e7b2      	b.n	4c1c <Trigger_evalTriggerMacro+0x118>
		else if ( overallVote & TriggerMacroVote_Release )
    4cb6:	f018 0f10 	tst.w	r8, #16
    4cba:	d00c      	beq.n	4cd6 <Trigger_evalTriggerMacro+0x1d2>
			if ( !Trigger_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    4cbc:	4434      	add	r4, r6
    4cbe:	4b0d      	ldr	r3, [pc, #52]	; (4cf4 <Trigger_evalTriggerMacro+0x1f0>)
    4cc0:	88a0      	ldrh	r0, [r4, #4]
    4cc2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    4cc6:	f7ff fd6f 	bl	47a8 <Trigger_isLongResultMacro>
    4cca:	b920      	cbnz	r0, 4cd6 <Trigger_evalTriggerMacro+0x1d2>
				record->state = TriggerMacro_Release;
    4ccc:	2306      	movs	r3, #6
    4cce:	fb03 7505 	mla	r5, r3, r5, r7
    4cd2:	2002      	movs	r0, #2
    4cd4:	e780      	b.n	4bd8 <Trigger_evalTriggerMacro+0xd4>
		return TriggerMacroEval_Remove;
    4cd6:	2003      	movs	r0, #3
    4cd8:	e7a0      	b.n	4c1c <Trigger_evalTriggerMacro+0x118>
}
    4cda:	b005      	add	sp, #20
    4cdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4ce0:	1fffe9d0 	.word	0x1fffe9d0
    4ce4:	1ffffe3a 	.word	0x1ffffe3a
    4ce8:	1ffffcb2 	.word	0x1ffffcb2
    4cec:	0000bf54 	.word	0x0000bf54
    4cf0:	0000bf67 	.word	0x0000bf67
    4cf4:	0000a224 	.word	0x0000a224
    4cf8:	0000a39c 	.word	0x0000a39c

00004cfc <Trigger_updateTriggerMacroPendingList>:


// Update pending trigger list
void Trigger_updateTriggerMacroPendingList()
{
    4cfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4d00:	4b2d      	ldr	r3, [pc, #180]	; (4db8 <Trigger_updateTriggerMacroPendingList+0xbc>)
			//  triggerList needs to be added
			var_uint_t pending = 0;
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
			{
				// Stop scanning if the trigger macro index is found in the pending list
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    4d02:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 4dc4 <Trigger_updateTriggerMacroPendingList+0xc8>
{
    4d06:	681a      	ldr	r2, [r3, #0]
    4d08:	b085      	sub	sp, #20
	for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    4d0a:	2500      	movs	r5, #0
{
    4d0c:	9203      	str	r2, [sp, #12]
    4d0e:	9301      	str	r3, [sp, #4]
	for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    4d10:	4b2a      	ldr	r3, [pc, #168]	; (4dbc <Trigger_updateTriggerMacroPendingList+0xc0>)
    4d12:	881a      	ldrh	r2, [r3, #0]
    4d14:	b2ab      	uxth	r3, r5
    4d16:	429a      	cmp	r2, r3
    4d18:	d806      	bhi.n	4d28 <Trigger_updateTriggerMacroPendingList+0x2c>
				TriggerMacroRecordList[ triggerMacroIndex ].prevPos = 0;
				TriggerMacroRecordList[ triggerMacroIndex ].state   = TriggerMacro_Waiting;
			}
		}
	}
}
    4d1a:	9b01      	ldr	r3, [sp, #4]
    4d1c:	9a03      	ldr	r2, [sp, #12]
    4d1e:	681b      	ldr	r3, [r3, #0]
    4d20:	429a      	cmp	r2, r3
    4d22:	d046      	beq.n	4db2 <Trigger_updateTriggerMacroPendingList+0xb6>
    4d24:	f7fc fbfe 	bl	1524 <__stack_chk_fail>
    4d28:	b2a8      	uxth	r0, r5
		uint8_t latch_expire = event->state == ScheduleType_R;
    4d2a:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    4d2e:	4824      	ldr	r0, [pc, #144]	; (4dc0 <Trigger_updateTriggerMacroPendingList+0xc4>)
    4d30:	4418      	add	r0, r3
    4d32:	7841      	ldrb	r1, [r0, #1]
		nat_ptr_t *triggerList = Layer_layerLookup( event, latch_expire );
    4d34:	1ecb      	subs	r3, r1, #3
    4d36:	4259      	negs	r1, r3
    4d38:	4159      	adcs	r1, r3
    4d3a:	f7fe f861 	bl	2e00 <Layer_layerLookup>
		if ( triggerList == 0 )
    4d3e:	b198      	cbz	r0, 4d68 <Trigger_updateTriggerMacroPendingList+0x6c>
		nat_ptr_t triggerListSize = triggerList[0];
    4d40:	6803      	ldr	r3, [r0, #0]
    4d42:	f8df c084 	ldr.w	ip, [pc, #132]	; 4dc8 <Trigger_updateTriggerMacroPendingList+0xcc>
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    4d46:	f8df e084 	ldr.w	lr, [pc, #132]	; 4dcc <Trigger_updateTriggerMacroPendingList+0xd0>
    4d4a:	f8bc 2000 	ldrh.w	r2, [ip]
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    4d4e:	2101      	movs	r1, #1
    4d50:	2600      	movs	r6, #0
    4d52:	440b      	add	r3, r1
    4d54:	9300      	str	r3, [sp, #0]
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    4d56:	f04f 0a06 	mov.w	sl, #6
    4d5a:	4637      	mov	r7, r6
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    4d5c:	9b00      	ldr	r3, [sp, #0]
    4d5e:	4299      	cmp	r1, r3
    4d60:	d304      	bcc.n	4d6c <Trigger_updateTriggerMacroPendingList+0x70>
    4d62:	b10e      	cbz	r6, 4d68 <Trigger_updateTriggerMacroPendingList+0x6c>
    4d64:	f8ac 2000 	strh.w	r2, [ip]
    4d68:	3501      	adds	r5, #1
    4d6a:	e7d1      	b.n	4d10 <Trigger_updateTriggerMacroPendingList+0x14>
			var_uint_t triggerMacroIndex = triggerList[ macro ];
    4d6c:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    4d70:	2400      	movs	r4, #0
			var_uint_t triggerMacroIndex = triggerList[ macro ];
    4d72:	fa1f f983 	uxth.w	r9, r3
    4d76:	fa1f fb84 	uxth.w	fp, r4
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    4d7a:	4593      	cmp	fp, r2
    4d7c:	d30f      	bcc.n	4d9e <Trigger_updateTriggerMacroPendingList+0xa2>
			if ( pending == macroTriggerMacroPendingListSize )
    4d7e:	d115      	bne.n	4dac <Trigger_updateTriggerMacroPendingList+0xb0>
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    4d80:	b29b      	uxth	r3, r3
    4d82:	fb0a f303 	mul.w	r3, sl, r3
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    4d86:	f828 9014 	strh.w	r9, [r8, r4, lsl #1]
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    4d8a:	eb0e 0403 	add.w	r4, lr, r3
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    4d8e:	3201      	adds	r2, #1
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    4d90:	f82e 7003 	strh.w	r7, [lr, r3]
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    4d94:	b292      	uxth	r2, r2
				TriggerMacroRecordList[ triggerMacroIndex ].prevPos = 0;
    4d96:	8067      	strh	r7, [r4, #2]
				TriggerMacroRecordList[ triggerMacroIndex ].state   = TriggerMacro_Waiting;
    4d98:	7127      	strb	r7, [r4, #4]
    4d9a:	2601      	movs	r6, #1
    4d9c:	e006      	b.n	4dac <Trigger_updateTriggerMacroPendingList+0xb0>
    4d9e:	3401      	adds	r4, #1
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    4da0:	eb08 0b44 	add.w	fp, r8, r4, lsl #1
    4da4:	f83b bc02 	ldrh.w	fp, [fp, #-2]
    4da8:	45cb      	cmp	fp, r9
    4daa:	d1e4      	bne.n	4d76 <Trigger_updateTriggerMacroPendingList+0x7a>
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    4dac:	3101      	adds	r1, #1
    4dae:	b289      	uxth	r1, r1
    4db0:	e7d4      	b.n	4d5c <Trigger_updateTriggerMacroPendingList+0x60>
}
    4db2:	b005      	add	sp, #20
    4db4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4db8:	1fffe9d0 	.word	0x1fffe9d0
    4dbc:	1ffffcb0 	.word	0x1ffffcb0
    4dc0:	1ffffcb5 	.word	0x1ffffcb5
    4dc4:	1ffff3a2 	.word	0x1ffff3a2
    4dc8:	1ffff460 	.word	0x1ffff460
    4dcc:	1ffffe3a 	.word	0x1ffffe3a

00004dd0 <Trigger_setup>:


void Trigger_setup()
{
    4dd0:	b507      	push	{r0, r1, r2, lr}
    4dd2:	4a0b      	ldr	r2, [pc, #44]	; (4e00 <Trigger_setup+0x30>)
    4dd4:	6813      	ldr	r3, [r2, #0]
    4dd6:	9301      	str	r3, [sp, #4]
    4dd8:	4b0a      	ldr	r3, [pc, #40]	; (4e04 <Trigger_setup+0x34>)
	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
	{
		TriggerMacroRecordList[ macro ].pos     = 0;
    4dda:	2100      	movs	r1, #0
    4ddc:	f203 203a 	addw	r0, r3, #570	; 0x23a
    4de0:	8019      	strh	r1, [r3, #0]
		TriggerMacroRecordList[ macro ].prevPos = 0;
    4de2:	8059      	strh	r1, [r3, #2]
		TriggerMacroRecordList[ macro ].state   = TriggerMacro_Waiting;
    4de4:	7119      	strb	r1, [r3, #4]
    4de6:	3306      	adds	r3, #6
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    4de8:	4283      	cmp	r3, r0
    4dea:	d1f9      	bne.n	4de0 <Trigger_setup+0x10>
	}
}
    4dec:	9901      	ldr	r1, [sp, #4]
    4dee:	6813      	ldr	r3, [r2, #0]
    4df0:	4299      	cmp	r1, r3
    4df2:	d001      	beq.n	4df8 <Trigger_setup+0x28>
    4df4:	f7fc fb96 	bl	1524 <__stack_chk_fail>
    4df8:	b003      	add	sp, #12
    4dfa:	f85d fb04 	ldr.w	pc, [sp], #4
    4dfe:	bf00      	nop
    4e00:	1fffe9d0 	.word	0x1fffe9d0
    4e04:	1ffffe3a 	.word	0x1ffffe3a

00004e08 <Trigger_process>:


void Trigger_process()
{
    4e08:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    4e0c:	4d35      	ldr	r5, [pc, #212]	; (4ee4 <Trigger_process+0xdc>)
    4e0e:	f8df 9100 	ldr.w	r9, [pc, #256]	; 4f10 <Trigger_process+0x108>
    4e12:	682b      	ldr	r3, [r5, #0]
    4e14:	9301      	str	r3, [sp, #4]
	// Update pending trigger list, before processing TriggerMacros
	Trigger_updateTriggerMacroPendingList();
    4e16:	f7ff ff71 	bl	4cfc <Trigger_updateTriggerMacroPendingList>
	// Tail pointer for macroTriggerMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroTriggerMacroPendingListTail = 0;

	// Display trigger information before processing
	if ( triggerPendingDebugMode )
    4e1a:	4b33      	ldr	r3, [pc, #204]	; (4ee8 <Trigger_process+0xe0>)
    4e1c:	781b      	ldrb	r3, [r3, #0]
    4e1e:	b183      	cbz	r3, 4e42 <Trigger_process+0x3a>
	{
		print("\033[1;30mTPe\033[0m");
    4e20:	4832      	ldr	r0, [pc, #200]	; (4eec <Trigger_process+0xe4>)
		for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
		{
			print(" ");
    4e22:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 4f14 <Trigger_process+0x10c>
			printInt8( macroTriggerMacroPendingList[ macro ] );
    4e26:	4f32      	ldr	r7, [pc, #200]	; (4ef0 <Trigger_process+0xe8>)
		print("\033[1;30mTPe\033[0m");
    4e28:	f004 fb2e 	bl	9488 <_print>
		for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    4e2c:	2400      	movs	r4, #0
    4e2e:	f8b9 2000 	ldrh.w	r2, [r9]
    4e32:	b2a3      	uxth	r3, r4
    4e34:	429a      	cmp	r2, r3
    4e36:	f104 0601 	add.w	r6, r4, #1
    4e3a:	d814      	bhi.n	4e66 <Trigger_process+0x5e>
		}
		print(NL);
    4e3c:	482d      	ldr	r0, [pc, #180]	; (4ef4 <Trigger_process+0xec>)
    4e3e:	f004 fb23 	bl	9488 <_print>
		default:
			if ( voteDebugMode )
			{
				print(" _" NL);
			}
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = cur_macro;
    4e42:	2400      	movs	r4, #0
		index_uint_t cur_macro = macroTriggerMacroPendingList[ macro ];
    4e44:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 4ef0 <Trigger_process+0xe8>
    4e48:	4f2b      	ldr	r7, [pc, #172]	; (4ef8 <Trigger_process+0xf0>)
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = cur_macro;
    4e4a:	4626      	mov	r6, r4
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    4e4c:	f8b9 2000 	ldrh.w	r2, [r9]
    4e50:	b2a3      	uxth	r3, r4
    4e52:	429a      	cmp	r2, r3
    4e54:	d811      	bhi.n	4e7a <Trigger_process+0x72>
		}
	}

	// Update the macroTriggerMacroPendingListSize with the tail pointer
	macroTriggerMacroPendingListSize = macroTriggerMacroPendingListTail;
}
    4e56:	9a01      	ldr	r2, [sp, #4]
    4e58:	682b      	ldr	r3, [r5, #0]
	macroTriggerMacroPendingListSize = macroTriggerMacroPendingListTail;
    4e5a:	f8a9 6000 	strh.w	r6, [r9]
}
    4e5e:	429a      	cmp	r2, r3
    4e60:	d03d      	beq.n	4ede <Trigger_process+0xd6>
    4e62:	f7fc fb5f 	bl	1524 <__stack_chk_fail>
			printInt8( macroTriggerMacroPendingList[ macro ] );
    4e66:	b2a4      	uxth	r4, r4
			print(" ");
    4e68:	4640      	mov	r0, r8
    4e6a:	f004 fb0d 	bl	9488 <_print>
			printInt8( macroTriggerMacroPendingList[ macro ] );
    4e6e:	f817 0014 	ldrb.w	r0, [r7, r4, lsl #1]
    4e72:	f004 fb73 	bl	955c <printInt8>
    4e76:	4634      	mov	r4, r6
    4e78:	e7d9      	b.n	4e2e <Trigger_process+0x26>
		index_uint_t cur_macro = macroTriggerMacroPendingList[ macro ];
    4e7a:	b2a3      	uxth	r3, r4
    4e7c:	f83a 8013 	ldrh.w	r8, [sl, r3, lsl #1]
		switch ( Trigger_evalTriggerMacro( cur_macro ) )
    4e80:	4640      	mov	r0, r8
    4e82:	f7ff fe3f 	bl	4b04 <Trigger_evalTriggerMacro>
    4e86:	2802      	cmp	r0, #2
    4e88:	d018      	beq.n	4ebc <Trigger_process+0xb4>
    4e8a:	2803      	cmp	r0, #3
    4e8c:	d020      	beq.n	4ed0 <Trigger_process+0xc8>
    4e8e:	2801      	cmp	r0, #1
    4e90:	d109      	bne.n	4ea6 <Trigger_process+0x9e>
			if ( voteDebugMode )
    4e92:	783b      	ldrb	r3, [r7, #0]
    4e94:	b113      	cbz	r3, 4e9c <Trigger_process+0x94>
				print(" DR");
    4e96:	4819      	ldr	r0, [pc, #100]	; (4efc <Trigger_process+0xf4>)
    4e98:	f004 faf6 	bl	9488 <_print>
			Result_appendResultMacroToPendingList(
    4e9c:	4818      	ldr	r0, [pc, #96]	; (4f00 <Trigger_process+0xf8>)
    4e9e:	eb00 00c8 	add.w	r0, r0, r8, lsl #3
    4ea2:	f7ff fa93 	bl	43cc <Result_appendResultMacroToPendingList>
			if ( voteDebugMode )
    4ea6:	783b      	ldrb	r3, [r7, #0]
    4ea8:	b113      	cbz	r3, 4eb0 <Trigger_process+0xa8>
				print(" _" NL);
    4eaa:	4816      	ldr	r0, [pc, #88]	; (4f04 <Trigger_process+0xfc>)
    4eac:	f004 faec 	bl	9488 <_print>
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = cur_macro;
    4eb0:	1c73      	adds	r3, r6, #1
    4eb2:	f82a 8016 	strh.w	r8, [sl, r6, lsl #1]
    4eb6:	b29e      	uxth	r6, r3
    4eb8:	3401      	adds	r4, #1
    4eba:	e7c7      	b.n	4e4c <Trigger_process+0x44>
			if ( voteDebugMode )
    4ebc:	783b      	ldrb	r3, [r7, #0]
    4ebe:	b113      	cbz	r3, 4ec6 <Trigger_process+0xbe>
				print(" DRaR");
    4ec0:	4811      	ldr	r0, [pc, #68]	; (4f08 <Trigger_process+0x100>)
    4ec2:	f004 fae1 	bl	9488 <_print>
			Result_appendResultMacroToPendingList(
    4ec6:	480e      	ldr	r0, [pc, #56]	; (4f00 <Trigger_process+0xf8>)
    4ec8:	eb00 00c8 	add.w	r0, r0, r8, lsl #3
    4ecc:	f7ff fa7e 	bl	43cc <Result_appendResultMacroToPendingList>
			if ( voteDebugMode )
    4ed0:	783b      	ldrb	r3, [r7, #0]
    4ed2:	2b00      	cmp	r3, #0
    4ed4:	d0f0      	beq.n	4eb8 <Trigger_process+0xb0>
				print(" R" NL);
    4ed6:	480d      	ldr	r0, [pc, #52]	; (4f0c <Trigger_process+0x104>)
    4ed8:	f004 fad6 	bl	9488 <_print>
    4edc:	e7ec      	b.n	4eb8 <Trigger_process+0xb0>
}
    4ede:	b002      	add	sp, #8
    4ee0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4ee4:	1fffe9d0 	.word	0x1fffe9d0
    4ee8:	1ffffcae 	.word	0x1ffffcae
    4eec:	0000bf69 	.word	0x0000bf69
    4ef0:	1ffff3a2 	.word	0x1ffff3a2
    4ef4:	0000d348 	.word	0x0000d348
    4ef8:	1ffffcb2 	.word	0x1ffffcb2
    4efc:	0000bf78 	.word	0x0000bf78
    4f00:	0000a39c 	.word	0x0000a39c
    4f04:	0000bf7c 	.word	0x0000bf7c
    4f08:	0000bf81 	.word	0x0000bf81
    4f0c:	0000bf87 	.word	0x0000bf87
    4f10:	1ffff460 	.word	0x1ffff460
    4f14:	0000d6a4 	.word	0x0000d6a4

00004f18 <HIDIO_supported_0_call>:
	// TODO
}

// Supported Ids call
HIDIO_Return HIDIO_supported_0_call( uint16_t buf_pos, uint8_t irq )
{
    4f18:	b507      	push	{r0, r1, r2, lr}
    4f1a:	4b07      	ldr	r3, [pc, #28]	; (4f38 <HIDIO_supported_0_call+0x20>)
    4f1c:	681a      	ldr	r2, [r3, #0]
    4f1e:	9201      	str	r2, [sp, #4]
	// TODO
	return HIDIO_Return__Ok;
}
    4f20:	9a01      	ldr	r2, [sp, #4]
    4f22:	681b      	ldr	r3, [r3, #0]
    4f24:	429a      	cmp	r2, r3
    4f26:	f04f 0000 	mov.w	r0, #0
    4f2a:	d001      	beq.n	4f30 <HIDIO_supported_0_call+0x18>
    4f2c:	f7fc fafa 	bl	1524 <__stack_chk_fail>
    4f30:	b003      	add	sp, #12
    4f32:	f85d fb04 	ldr.w	pc, [sp], #4
    4f36:	bf00      	nop
    4f38:	1fffe9d0 	.word	0x1fffe9d0

00004f3c <HIDIO_supported_0_reply>:

// Supported Ids reply
HIDIO_Return HIDIO_supported_0_reply( HIDIO_Buffer_Entry *buf, uint8_t irq )
{
    4f3c:	b507      	push	{r0, r1, r2, lr}
    4f3e:	4b07      	ldr	r3, [pc, #28]	; (4f5c <HIDIO_supported_0_reply+0x20>)
    4f40:	681a      	ldr	r2, [r3, #0]
    4f42:	9201      	str	r2, [sp, #4]
	// TODO
	return HIDIO_Return__Ok;
}
    4f44:	9a01      	ldr	r2, [sp, #4]
    4f46:	681b      	ldr	r3, [r3, #0]
    4f48:	429a      	cmp	r2, r3
    4f4a:	f04f 0000 	mov.w	r0, #0
    4f4e:	d001      	beq.n	4f54 <HIDIO_supported_0_reply+0x18>
    4f50:	f7fc fae8 	bl	1524 <__stack_chk_fail>
    4f54:	b003      	add	sp, #12
    4f56:	f85d fb04 	ldr.w	pc, [sp], #4
    4f5a:	bf00      	nop
    4f5c:	1fffe9d0 	.word	0x1fffe9d0

00004f60 <HIDIO_test_2_reply>:
	return HIDIO_Return__Ok;
}

// Test reply
HIDIO_Return HIDIO_test_2_reply( HIDIO_Buffer_Entry *buf, uint8_t irq )
{
    4f60:	b537      	push	{r0, r1, r2, r4, r5, lr}
    4f62:	4b11      	ldr	r3, [pc, #68]	; (4fa8 <HIDIO_test_2_reply+0x48>)
    4f64:	681a      	ldr	r2, [r3, #0]
    4f66:	9201      	str	r2, [sp, #4]
	// TODO (HaaTa) - Add option to process optionally inside irqs
	if ( irq )
    4f68:	b9d1      	cbnz	r1, 4fa0 <HIDIO_test_2_reply+0x40>
	{
		return HIDIO_Return__Delay;
	}

	// Make sure entry is ready
	if ( !buf->done )
    4f6a:	7982      	ldrb	r2, [r0, #6]
    4f6c:	b1c2      	cbz	r2, 4fa0 <HIDIO_test_2_reply+0x40>
    4f6e:	8884      	ldrh	r4, [r0, #4]
    4f70:	f100 0208 	add.w	r2, r0, #8
    4f74:	4414      	add	r4, r2
	{
		return HIDIO_Return__Delay;
	}

	// Get size and iterate through payload, start after id
	uint16_t transitions = 0;
    4f76:	4608      	mov	r0, r1
	uint8_t last_byte = 0;
	for ( uint16_t pos = 0; pos < buf->size; pos++ )
    4f78:	42a2      	cmp	r2, r4
    4f7a:	d109      	bne.n	4f90 <HIDIO_test_2_reply+0x30>
		return HIDIO_Return__Delay;
    4f7c:	2801      	cmp	r0, #1
    4f7e:	bf94      	ite	ls
    4f80:	2000      	movls	r0, #0
    4f82:	2001      	movhi	r0, #1
		return HIDIO_Return__InBuffer_Fail;
	}

	// Buffer is automatically released for us
	return HIDIO_Return__Ok;
}
    4f84:	9a01      	ldr	r2, [sp, #4]
    4f86:	681b      	ldr	r3, [r3, #0]
    4f88:	429a      	cmp	r2, r3
    4f8a:	d00b      	beq.n	4fa4 <HIDIO_test_2_reply+0x44>
    4f8c:	f7fc faca 	bl	1524 <__stack_chk_fail>
		uint8_t byte = buf->data[ pos ];
    4f90:	f812 5b01 	ldrb.w	r5, [r2], #1
		if ( byte != last_byte )
    4f94:	428d      	cmp	r5, r1
			transitions++;
    4f96:	bf1c      	itt	ne
    4f98:	3001      	addne	r0, #1
    4f9a:	b280      	uxthne	r0, r0
		uint8_t byte = buf->data[ pos ];
    4f9c:	4629      	mov	r1, r5
    4f9e:	e7eb      	b.n	4f78 <HIDIO_test_2_reply+0x18>
		return HIDIO_Return__Delay;
    4fa0:	2003      	movs	r0, #3
    4fa2:	e7ef      	b.n	4f84 <HIDIO_test_2_reply+0x24>
}
    4fa4:	b003      	add	sp, #12
    4fa6:	bd30      	pop	{r4, r5, pc}
    4fa8:	1fffe9d0 	.word	0x1fffe9d0

00004fac <HIDIO_info_1_reply>:
    4fac:	b507      	push	{r0, r1, r2, lr}
    4fae:	4b07      	ldr	r3, [pc, #28]	; (4fcc <HIDIO_info_1_reply+0x20>)
    4fb0:	681a      	ldr	r2, [r3, #0]
    4fb2:	9201      	str	r2, [sp, #4]
    4fb4:	9a01      	ldr	r2, [sp, #4]
    4fb6:	681b      	ldr	r3, [r3, #0]
    4fb8:	429a      	cmp	r2, r3
    4fba:	f04f 0000 	mov.w	r0, #0
    4fbe:	d001      	beq.n	4fc4 <HIDIO_info_1_reply+0x18>
    4fc0:	f7fc fab0 	bl	1524 <__stack_chk_fail>
    4fc4:	b003      	add	sp, #12
    4fc6:	f85d fb04 	ldr.w	pc, [sp], #4
    4fca:	bf00      	nop
    4fcc:	1fffe9d0 	.word	0x1fffe9d0

00004fd0 <HIDIO_info_1_call>:
    4fd0:	b507      	push	{r0, r1, r2, lr}
    4fd2:	4b07      	ldr	r3, [pc, #28]	; (4ff0 <HIDIO_info_1_call+0x20>)
    4fd4:	681a      	ldr	r2, [r3, #0]
    4fd6:	9201      	str	r2, [sp, #4]
    4fd8:	9a01      	ldr	r2, [sp, #4]
    4fda:	681b      	ldr	r3, [r3, #0]
    4fdc:	429a      	cmp	r2, r3
    4fde:	f04f 0000 	mov.w	r0, #0
    4fe2:	d001      	beq.n	4fe8 <HIDIO_info_1_call+0x18>
    4fe4:	f7fc fa9e 	bl	1524 <__stack_chk_fail>
    4fe8:	b003      	add	sp, #12
    4fea:	f85d fb04 	ldr.w	pc, [sp], #4
    4fee:	bf00      	nop
    4ff0:	1fffe9d0 	.word	0x1fffe9d0

00004ff4 <HIDIO_buffer_munch>:
{
    4ff4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4ff8:	460d      	mov	r5, r1
    4ffa:	4611      	mov	r1, r2
    4ffc:	4a12      	ldr	r2, [pc, #72]	; (5048 <HIDIO_buffer_munch+0x54>)
	if ( buf_pos + len < buffer->len )
    4ffe:	8904      	ldrh	r4, [r0, #8]
{
    5000:	461f      	mov	r7, r3
    5002:	6813      	ldr	r3, [r2, #0]
    5004:	9301      	str	r3, [sp, #4]
	if ( buf_pos + len < buffer->len )
    5006:	19cb      	adds	r3, r1, r7
    5008:	42a3      	cmp	r3, r4
{
    500a:	4606      	mov	r6, r0
    500c:	4690      	mov	r8, r2
    500e:	68c0      	ldr	r0, [r0, #12]
	if ( buf_pos + len < buffer->len )
    5010:	da07      	bge.n	5022 <HIDIO_buffer_munch+0x2e>
		return &(buffer->data[ buf_pos ]);
    5012:	4408      	add	r0, r1
}
    5014:	9a01      	ldr	r2, [sp, #4]
    5016:	f8d8 3000 	ldr.w	r3, [r8]
    501a:	429a      	cmp	r2, r3
    501c:	d011      	beq.n	5042 <HIDIO_buffer_munch+0x4e>
    501e:	f7fc fa81 	bl	1524 <__stack_chk_fail>
	if ( len == 1 )
    5022:	2f01      	cmp	r7, #1
    5024:	d0f6      	beq.n	5014 <HIDIO_buffer_munch+0x20>
	uint16_t cur_len = buffer->len - buf_pos;
    5026:	1a64      	subs	r4, r4, r1
    5028:	b2a4      	uxth	r4, r4
	memcpy( buf, &(buffer->data[ buf_pos ]), cur_len );
    502a:	4401      	add	r1, r0
    502c:	4622      	mov	r2, r4
    502e:	4628      	mov	r0, r5
    5030:	f7fc fa9c 	bl	156c <memcpy>
	memcpy( &buf[ cur_len ], buffer->data, len - cur_len );
    5034:	1b3a      	subs	r2, r7, r4
    5036:	68f1      	ldr	r1, [r6, #12]
    5038:	1928      	adds	r0, r5, r4
    503a:	f7fc fa97 	bl	156c <memcpy>
	return buf;
    503e:	4628      	mov	r0, r5
    5040:	e7e8      	b.n	5014 <HIDIO_buffer_munch+0x20>
}
    5042:	b002      	add	sp, #8
    5044:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5048:	1fffe9d0 	.word	0x1fffe9d0

0000504c <HIDIO_buffer_push_byte>:
{
    504c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    504e:	4b0b      	ldr	r3, [pc, #44]	; (507c <HIDIO_buffer_push_byte+0x30>)
	if ( buffer->tail == buffer->len )
    5050:	8844      	ldrh	r4, [r0, #2]
{
    5052:	681a      	ldr	r2, [r3, #0]
    5054:	9201      	str	r2, [sp, #4]
	if ( buffer->tail == buffer->len )
    5056:	8902      	ldrh	r2, [r0, #8]
    5058:	4294      	cmp	r4, r2
		buffer->tail = 0;
    505a:	bf04      	itt	eq
    505c:	2200      	moveq	r2, #0
    505e:	8042      	strheq	r2, [r0, #2]
	buffer->data[ buffer->tail++ ] = byte;
    5060:	8842      	ldrh	r2, [r0, #2]
    5062:	68c4      	ldr	r4, [r0, #12]
    5064:	1c55      	adds	r5, r2, #1
    5066:	8045      	strh	r5, [r0, #2]
    5068:	54a1      	strb	r1, [r4, r2]
}
    506a:	9a01      	ldr	r2, [sp, #4]
    506c:	681b      	ldr	r3, [r3, #0]
    506e:	429a      	cmp	r2, r3
    5070:	d001      	beq.n	5076 <HIDIO_buffer_push_byte+0x2a>
    5072:	f7fc fa57 	bl	1524 <__stack_chk_fail>
    5076:	b003      	add	sp, #12
    5078:	bd30      	pop	{r4, r5, pc}
    507a:	bf00      	nop
    507c:	1fffe9d0 	.word	0x1fffe9d0

00005080 <HIDIO_modify_buffer>:
{
    5080:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5082:	4f0f      	ldr	r7, [pc, #60]	; (50c0 <HIDIO_modify_buffer+0x40>)
    5084:	b296      	uxth	r6, r2
    5086:	683d      	ldr	r5, [r7, #0]
    5088:	9501      	str	r5, [sp, #4]
    508a:	1b89      	subs	r1, r1, r6
    508c:	b294      	uxth	r4, r2
	for ( uint16_t c = 0; c < len; c++ )
    508e:	1ba5      	subs	r5, r4, r6
    5090:	b2ad      	uxth	r5, r5
    5092:	42ab      	cmp	r3, r5
    5094:	d805      	bhi.n	50a2 <HIDIO_modify_buffer+0x22>
}
    5096:	9a01      	ldr	r2, [sp, #4]
    5098:	683b      	ldr	r3, [r7, #0]
    509a:	429a      	cmp	r2, r3
    509c:	d00e      	beq.n	50bc <HIDIO_modify_buffer+0x3c>
    509e:	f7fc fa41 	bl	1524 <__stack_chk_fail>
		if ( pos >= buffer->len )
    50a2:	8905      	ldrh	r5, [r0, #8]
		buffer->data[pos] = data[c];
    50a4:	f812 cb01 	ldrb.w	ip, [r2], #1
    50a8:	440c      	add	r4, r1
    50aa:	b2a4      	uxth	r4, r4
		if ( pos >= buffer->len )
    50ac:	42a5      	cmp	r5, r4
			pos -= buffer->len;
    50ae:	bf9c      	itt	ls
    50b0:	1b64      	subls	r4, r4, r5
    50b2:	b2a4      	uxthls	r4, r4
		buffer->data[pos] = data[c];
    50b4:	68c5      	ldr	r5, [r0, #12]
    50b6:	f805 c004 	strb.w	ip, [r5, r4]
    50ba:	e7e7      	b.n	508c <HIDIO_modify_buffer+0xc>
}
    50bc:	b003      	add	sp, #12
    50be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    50c0:	1fffe9d0 	.word	0x1fffe9d0

000050c4 <HIDIO_buffer_pop_bytes>:
{
    50c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    50c6:	4604      	mov	r4, r0
    50c8:	4d13      	ldr	r5, [pc, #76]	; (5118 <HIDIO_buffer_pop_bytes+0x54>)
	if ( len > buffer->len )
    50ca:	8900      	ldrh	r0, [r0, #8]
{
    50cc:	682a      	ldr	r2, [r5, #0]
    50ce:	9201      	str	r2, [sp, #4]
	if ( len > buffer->len )
    50d0:	4288      	cmp	r0, r1
{
    50d2:	460e      	mov	r6, r1
	if ( len > buffer->len )
    50d4:	d215      	bcs.n	5102 <HIDIO_buffer_pop_bytes+0x3e>
		erro_msg("Requested HIDIO buffer pop larger than entire buffer: ");
    50d6:	4811      	ldr	r0, [pc, #68]	; (511c <HIDIO_buffer_pop_bytes+0x58>)
    50d8:	f004 f9d6 	bl	9488 <_print>
		printInt16( len );
    50dc:	4630      	mov	r0, r6
    50de:	f004 fa73 	bl	95c8 <printInt16>
		print(":");
    50e2:	480f      	ldr	r0, [pc, #60]	; (5120 <HIDIO_buffer_pop_bytes+0x5c>)
    50e4:	f004 f9d0 	bl	9488 <_print>
		printInt16( buffer->len );
    50e8:	8920      	ldrh	r0, [r4, #8]
    50ea:	f004 fa6d 	bl	95c8 <printInt16>
		print(NL);
    50ee:	480d      	ldr	r0, [pc, #52]	; (5124 <HIDIO_buffer_pop_bytes+0x60>)
    50f0:	f004 f9ca 	bl	9488 <_print>
    50f4:	2000      	movs	r0, #0
}
    50f6:	9a01      	ldr	r2, [sp, #4]
    50f8:	682b      	ldr	r3, [r5, #0]
    50fa:	429a      	cmp	r2, r3
    50fc:	d00a      	beq.n	5114 <HIDIO_buffer_pop_bytes+0x50>
    50fe:	f7fc fa11 	bl	1524 <__stack_chk_fail>
	if ( len + buffer->head > buffer->len )
    5102:	8822      	ldrh	r2, [r4, #0]
    5104:	1851      	adds	r1, r2, r1
    5106:	b28b      	uxth	r3, r1
    5108:	4281      	cmp	r1, r0
		buffer->head = len + buffer->head - buffer->len;
    510a:	bfc8      	it	gt
    510c:	1a1b      	subgt	r3, r3, r0
		buffer->head += len;
    510e:	8023      	strh	r3, [r4, #0]
	return 1;
    5110:	2001      	movs	r0, #1
    5112:	e7f0      	b.n	50f6 <HIDIO_buffer_pop_bytes+0x32>
}
    5114:	b002      	add	sp, #8
    5116:	bd70      	pop	{r4, r5, r6, pc}
    5118:	1fffe9d0 	.word	0x1fffe9d0
    511c:	0000c00c 	.word	0x0000c00c
    5120:	0000d681 	.word	0x0000d681
    5124:	0000d348 	.word	0x0000d348

00005128 <HIDIO_buffer_free_bytes>:
{
    5128:	b507      	push	{r0, r1, r2, lr}
    512a:	4a0a      	ldr	r2, [pc, #40]	; (5154 <HIDIO_buffer_free_bytes+0x2c>)
	if ( buffer->head <= buffer->tail )
    512c:	8841      	ldrh	r1, [r0, #2]
{
    512e:	6813      	ldr	r3, [r2, #0]
    5130:	9301      	str	r3, [sp, #4]
	if ( buffer->head <= buffer->tail )
    5132:	8803      	ldrh	r3, [r0, #0]
    5134:	428b      	cmp	r3, r1
		return buffer->len - (buffer->tail - buffer->head);
    5136:	bf9b      	ittet	ls
    5138:	8900      	ldrhls	r0, [r0, #8]
    513a:	18c0      	addls	r0, r0, r3
		return buffer->head - buffer->tail;
    513c:	1a58      	subhi	r0, r3, r1
		return buffer->len - (buffer->tail - buffer->head);
    513e:	1a40      	subls	r0, r0, r1
}
    5140:	9901      	ldr	r1, [sp, #4]
    5142:	6813      	ldr	r3, [r2, #0]
    5144:	4299      	cmp	r1, r3
		return buffer->head - buffer->tail;
    5146:	b280      	uxth	r0, r0
}
    5148:	d001      	beq.n	514e <HIDIO_buffer_free_bytes+0x26>
    514a:	f7fc f9eb 	bl	1524 <__stack_chk_fail>
    514e:	b003      	add	sp, #12
    5150:	f85d fb04 	ldr.w	pc, [sp], #4
    5154:	1fffe9d0 	.word	0x1fffe9d0

00005158 <HIDIO_buffer_position>:
{
    5158:	b513      	push	{r0, r1, r4, lr}
    515a:	4c0a      	ldr	r4, [pc, #40]	; (5184 <HIDIO_buffer_position+0x2c>)
    515c:	6823      	ldr	r3, [r4, #0]
    515e:	9301      	str	r3, [sp, #4]
	if ( cur_pos + distance >= buffer->len )
    5160:	8903      	ldrh	r3, [r0, #8]
    5162:	1888      	adds	r0, r1, r2
    5164:	4298      	cmp	r0, r3
		return buffer->len - (cur_pos + distance);
    5166:	bfa4      	itt	ge
    5168:	1a9b      	subge	r3, r3, r2
    516a:	1a59      	subge	r1, r3, r1
}
    516c:	9a01      	ldr	r2, [sp, #4]
    516e:	6823      	ldr	r3, [r4, #0]
		return buffer->len - (cur_pos + distance);
    5170:	bfac      	ite	ge
    5172:	b288      	uxthge	r0, r1
		return cur_pos + distance;
    5174:	b280      	uxthlt	r0, r0
}
    5176:	429a      	cmp	r2, r3
    5178:	d001      	beq.n	517e <HIDIO_buffer_position+0x26>
    517a:	f7fc f9d3 	bl	1524 <__stack_chk_fail>
    517e:	b002      	add	sp, #8
    5180:	bd10      	pop	{r4, pc}
    5182:	bf00      	nop
    5184:	1fffe9d0 	.word	0x1fffe9d0

00005188 <HIDIO_buffer_id>:
{
    5188:	b507      	push	{r0, r1, r2, lr}
    518a:	4b09      	ldr	r3, [pc, #36]	; (51b0 <HIDIO_buffer_id+0x28>)
    518c:	681a      	ldr	r2, [r3, #0]
    518e:	9201      	str	r2, [sp, #4]
	if ( packet->id_width == 0 )
    5190:	7802      	ldrb	r2, [r0, #0]
    5192:	06d2      	lsls	r2, r2, #27
}
    5194:	9a01      	ldr	r2, [sp, #4]
    5196:	681b      	ldr	r3, [r3, #0]
		id = pkt->id;
    5198:	bf54      	ite	pl
    519a:	8840      	ldrhpl	r0, [r0, #2]
		id = pkt->id;
    519c:	f8d0 0002 	ldrmi.w	r0, [r0, #2]
}
    51a0:	429a      	cmp	r2, r3
    51a2:	d001      	beq.n	51a8 <HIDIO_buffer_id+0x20>
    51a4:	f7fc f9be 	bl	1524 <__stack_chk_fail>
    51a8:	b003      	add	sp, #12
    51aa:	f85d fb04 	ldr.w	pc, [sp], #4
    51ae:	bf00      	nop
    51b0:	1fffe9d0 	.word	0x1fffe9d0

000051b4 <HIDIO_payload_start>:
{
    51b4:	b507      	push	{r0, r1, r2, lr}
    51b6:	4b08      	ldr	r3, [pc, #32]	; (51d8 <HIDIO_payload_start+0x24>)
    51b8:	681a      	ldr	r2, [r3, #0]
    51ba:	9201      	str	r2, [sp, #4]
	if ( packet->id_width == 0 )
    51bc:	7802      	ldrb	r2, [r0, #0]
    51be:	06d2      	lsls	r2, r2, #27
}
    51c0:	9a01      	ldr	r2, [sp, #4]
    51c2:	681b      	ldr	r3, [r3, #0]
		data = pkt->data;
    51c4:	bf54      	ite	pl
    51c6:	3004      	addpl	r0, #4
		data = pkt->data;
    51c8:	3006      	addmi	r0, #6
}
    51ca:	429a      	cmp	r2, r3
    51cc:	d001      	beq.n	51d2 <HIDIO_payload_start+0x1e>
    51ce:	f7fc f9a9 	bl	1524 <__stack_chk_fail>
    51d2:	b003      	add	sp, #12
    51d4:	f85d fb04 	ldr.w	pc, [sp], #4
    51d8:	1fffe9d0 	.word	0x1fffe9d0

000051dc <HIDIO_buffer_generate_packet>:
{
    51dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    51e0:	b08d      	sub	sp, #52	; 0x34
    51e2:	460c      	mov	r4, r1
    51e4:	9301      	str	r3, [sp, #4]
    51e6:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    51ea:	9302      	str	r3, [sp, #8]
    51ec:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
    51f0:	9303      	str	r3, [sp, #12]
    51f2:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
    51f6:	4b6f      	ldr	r3, [pc, #444]	; (53b4 <HIDIO_buffer_generate_packet+0x1d8>)
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    51f8:	496f      	ldr	r1, [pc, #444]	; (53b8 <HIDIO_buffer_generate_packet+0x1dc>)
{
    51fa:	681b      	ldr	r3, [r3, #0]
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    51fc:	f8b1 a000 	ldrh.w	sl, [r1]
{
    5200:	930b      	str	r3, [sp, #44]	; 0x2c
		width = 2;
    5202:	f5bb 3f80 	cmp.w	fp, #65536	; 0x10000
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    5206:	bf2c      	ite	cs
    5208:	2304      	movcs	r3, #4
    520a:	2302      	movcc	r3, #2
    520c:	ebaa 0a03 	sub.w	sl, sl, r3
    5210:	fa1f fa8a 	uxth.w	sl, sl
    5214:	f1aa 0902 	sub.w	r9, sl, #2
{
    5218:	4607      	mov	r7, r0
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    521a:	fa1f f989 	uxth.w	r9, r9
	if ( payload_len != 0 )
    521e:	4690      	mov	r8, r2
    5220:	2a00      	cmp	r2, #0
    5222:	d031      	beq.n	5288 <HIDIO_buffer_generate_packet+0xac>
		packet_count = payload_len / max_payload;
    5224:	fbb2 f2f9 	udiv	r2, r2, r9
		cur_packet = pos / max_payload;
    5228:	fbb4 f6f9 	udiv	r6, r4, r9
		packet_count += payload_len % max_payload != 0 ? 1 : 0;
    522c:	fb09 8112 	mls	r1, r9, r2, r8
    5230:	b289      	uxth	r1, r1
    5232:	2900      	cmp	r1, #0
    5234:	bf18      	it	ne
    5236:	3201      	addne	r2, #1
    5238:	b292      	uxth	r2, r2
    523a:	9200      	str	r2, [sp, #0]
		cur_packet += pos % max_payload != 0 ? 1 : 0;
    523c:	fb09 4216 	mls	r2, r9, r6, r4
    5240:	b292      	uxth	r2, r2
    5242:	2a00      	cmp	r2, #0
    5244:	bf18      	it	ne
    5246:	3601      	addne	r6, #1
    5248:	b2b6      	uxth	r6, r6
    524a:	9304      	str	r3, [sp, #16]
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    524c:	9b00      	ldr	r3, [sp, #0]
    524e:	eba8 0204 	sub.w	r2, r8, r4
    5252:	1b9d      	subs	r5, r3, r6
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    5254:	4638      	mov	r0, r7
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    5256:	eb02 0545 	add.w	r5, r2, r5, lsl #1
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    525a:	f7ff ff65 	bl	5128 <HIDIO_buffer_free_bytes>
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    525e:	b2ad      	uxth	r5, r5
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    5260:	42a8      	cmp	r0, r5
    5262:	d315      	bcc.n	5290 <HIDIO_buffer_generate_packet+0xb4>
			uint16_t packet_len = bytes_left + width;
    5264:	9b04      	ldr	r3, [sp, #16]
    5266:	eb09 0203 	add.w	r2, r9, r3
    526a:	b292      	uxth	r2, r2
			uint16_t cur_payload_len = payload_len - pos + width;
    526c:	4443      	add	r3, r8
			uint16_t packet_len = bytes_left + width;
    526e:	9204      	str	r2, [sp, #16]
			uint16_t cur_payload_len = payload_len - pos + width;
    5270:	9305      	str	r3, [sp, #20]
	for ( ; pos < payload_len || payload_len == 0; pos++ )
    5272:	4544      	cmp	r4, r8
    5274:	d32f      	bcc.n	52d6 <HIDIO_buffer_generate_packet+0xfa>
    5276:	f1b8 0f00 	cmp.w	r8, #0
    527a:	d02c      	beq.n	52d6 <HIDIO_buffer_generate_packet+0xfa>
	if ( pos == payload_len )
    527c:	4544      	cmp	r4, r8
		buf->packets_ready++;
    527e:	bf02      	ittt	eq
    5280:	897b      	ldrheq	r3, [r7, #10]
    5282:	3301      	addeq	r3, #1
    5284:	817b      	strheq	r3, [r7, #10]
    5286:	e01e      	b.n	52c6 <HIDIO_buffer_generate_packet+0xea>
	uint16_t cur_packet = 0;
    5288:	4616      	mov	r6, r2
	uint16_t packet_count = 1;
    528a:	2201      	movs	r2, #1
    528c:	9200      	str	r2, [sp, #0]
    528e:	e7dc      	b.n	524a <HIDIO_buffer_generate_packet+0x6e>
		erro_msg("Not enough bytes in HIDIO buffer: ");
    5290:	484a      	ldr	r0, [pc, #296]	; (53bc <HIDIO_buffer_generate_packet+0x1e0>)
    5292:	f004 f8f9 	bl	9488 <_print>
		printInt16( HIDIO_buffer_free_bytes( buf ) );
    5296:	4638      	mov	r0, r7
    5298:	f7ff ff46 	bl	5128 <HIDIO_buffer_free_bytes>
    529c:	f004 f994 	bl	95c8 <printInt16>
		print(" bytes left, ");
    52a0:	4847      	ldr	r0, [pc, #284]	; (53c0 <HIDIO_buffer_generate_packet+0x1e4>)
    52a2:	f004 f8f1 	bl	9488 <_print>
		printInt16( buf->len );
    52a6:	8938      	ldrh	r0, [r7, #8]
    52a8:	f004 f98e 	bl	95c8 <printInt16>
		print(" bytes total ");
    52ac:	4845      	ldr	r0, [pc, #276]	; (53c4 <HIDIO_buffer_generate_packet+0x1e8>)
    52ae:	f004 f8eb 	bl	9488 <_print>
		printInt16( requested );
    52b2:	4628      	mov	r0, r5
    52b4:	f004 f988 	bl	95c8 <printInt16>
		print(" bytes requested");
    52b8:	4843      	ldr	r0, [pc, #268]	; (53c8 <HIDIO_buffer_generate_packet+0x1ec>)
    52ba:	f004 f8e5 	bl	9488 <_print>
		print(NL);
    52be:	4843      	ldr	r0, [pc, #268]	; (53cc <HIDIO_buffer_generate_packet+0x1f0>)
    52c0:	f004 f8e2 	bl	9488 <_print>
		return payload_len;
    52c4:	4644      	mov	r4, r8
}
    52c6:	4b3b      	ldr	r3, [pc, #236]	; (53b4 <HIDIO_buffer_generate_packet+0x1d8>)
    52c8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    52ca:	681b      	ldr	r3, [r3, #0]
    52cc:	429a      	cmp	r2, r3
    52ce:	4620      	mov	r0, r4
    52d0:	d06c      	beq.n	53ac <HIDIO_buffer_generate_packet+0x1d0>
    52d2:	f7fc f927 	bl	1524 <__stack_chk_fail>
		uint16_t bytes_left = pos % max_payload;
    52d6:	fbb4 f5f9 	udiv	r5, r4, r9
    52da:	fb09 4515 	mls	r5, r9, r5, r4
    52de:	b2ad      	uxth	r5, r5
		if ( bytes_left == 0 )
    52e0:	2d00      	cmp	r5, #0
    52e2:	d135      	bne.n	5350 <HIDIO_buffer_generate_packet+0x174>
			if ( pos != 0 )
    52e4:	b114      	cbz	r4, 52ec <HIDIO_buffer_generate_packet+0x110>
				buf->packets_ready++;
    52e6:	897b      	ldrh	r3, [r7, #10]
    52e8:	3301      	adds	r3, #1
    52ea:	817b      	strh	r3, [r7, #10]
			uint16_t cur_payload_len = payload_len - pos + width;
    52ec:	9b05      	ldr	r3, [sp, #20]
			uint8_t p_cont = cur_packet == packet_count ? 0 : 1;
    52ee:	9900      	ldr	r1, [sp, #0]
			uint16_t cur_payload_len = payload_len - pos + width;
    52f0:	1b1a      	subs	r2, r3, r4
    52f2:	9b04      	ldr	r3, [sp, #16]
    52f4:	b292      	uxth	r2, r2
			cur_packet++;
    52f6:	3601      	adds	r6, #1
    52f8:	429a      	cmp	r2, r3
    52fa:	b2b6      	uxth	r6, r6
    52fc:	bf28      	it	cs
    52fe:	461a      	movcs	r2, r3
			uint8_t p_type = cur_packet == 1 ? type : HIDIO_Packet_Type__Continued;
    5300:	2e01      	cmp	r6, #1
    5302:	9b03      	ldr	r3, [sp, #12]
    5304:	bf18      	it	ne
    5306:	2304      	movne	r3, #4
			uint8_t p_cont = cur_packet == packet_count ? 0 : 1;
    5308:	1b88      	subs	r0, r1, r6
    530a:	bf18      	it	ne
    530c:	2001      	movne	r0, #1
    530e:	f003 0307 	and.w	r3, r3, #7
			if ( id <= 0xFFFF )
    5312:	f5bb 3f80 	cmp.w	fp, #65536	; 0x10000
    5316:	f3c2 2101 	ubfx	r1, r2, #8, #2
				HIDIO_Packet16 packet = {
    531a:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3
    531e:	b2d2      	uxtb	r2, r2
    5320:	f04f 0500 	mov.w	r5, #0
			if ( id <= 0xFFFF )
    5324:	d22b      	bcs.n	537e <HIDIO_buffer_generate_packet+0x1a2>
				HIDIO_Packet16 packet = {
    5326:	f361 1387 	bfi	r3, r1, #6, #2
    532a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    532e:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
					.id = (uint16_t)id,
    5332:	f8ad b026 	strh.w	fp, [sp, #38]	; 0x26
					HIDIO_buffer_push_byte( buf, ((uint8_t*)&packet)[ byte ] );
    5336:	ab09      	add	r3, sp, #36	; 0x24
    5338:	5d59      	ldrb	r1, [r3, r5]
    533a:	9306      	str	r3, [sp, #24]
    533c:	4638      	mov	r0, r7
    533e:	3501      	adds	r5, #1
    5340:	f7ff fe84 	bl	504c <HIDIO_buffer_push_byte>
				for ( uint8_t byte = 0; byte < sizeof(HIDIO_Packet16); byte++ )
    5344:	2d04      	cmp	r5, #4
    5346:	9b06      	ldr	r3, [sp, #24]
    5348:	d1f6      	bne.n	5338 <HIDIO_buffer_generate_packet+0x15c>
				bytes_left -= sizeof(HIDIO_Packet16);
    534a:	f1aa 0506 	sub.w	r5, sl, #6
				bytes_left -= sizeof(HIDIO_Packet32);
    534e:	b2ad      	uxth	r5, r5
    5350:	9b02      	ldr	r3, [sp, #8]
    5352:	18e2      	adds	r2, r4, r3
		for ( ; byte < data_len && bytes_left > 0; byte++, pos++, bytes_left-- )
    5354:	9b01      	ldr	r3, [sp, #4]
    5356:	441d      	add	r5, r3
    5358:	b292      	uxth	r2, r2
    535a:	b2ad      	uxth	r5, r5
    535c:	42a2      	cmp	r2, r4
    535e:	d08d      	beq.n	527c <HIDIO_buffer_generate_packet+0xa0>
    5360:	b299      	uxth	r1, r3
    5362:	3401      	adds	r4, #1
    5364:	428d      	cmp	r5, r1
    5366:	b2a4      	uxth	r4, r4
    5368:	d083      	beq.n	5272 <HIDIO_buffer_generate_packet+0x96>
			HIDIO_buffer_push_byte( buf, data[ byte ] );
    536a:	f813 1b01 	ldrb.w	r1, [r3], #1
    536e:	9207      	str	r2, [sp, #28]
    5370:	4638      	mov	r0, r7
    5372:	9306      	str	r3, [sp, #24]
    5374:	f7ff fe6a 	bl	504c <HIDIO_buffer_push_byte>
    5378:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
    537c:	e7ee      	b.n	535c <HIDIO_buffer_generate_packet+0x180>
				HIDIO_Packet32 packet = {
    537e:	f043 0310 	orr.w	r3, r3, #16
    5382:	f361 1387 	bfi	r3, r1, #6, #2
    5386:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    538a:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
    538e:	f8cd b026 	str.w	fp, [sp, #38]	; 0x26
					HIDIO_buffer_push_byte( buf, ((uint8_t*)&packet)[ byte ] );
    5392:	ab09      	add	r3, sp, #36	; 0x24
    5394:	5d59      	ldrb	r1, [r3, r5]
    5396:	9306      	str	r3, [sp, #24]
    5398:	4638      	mov	r0, r7
    539a:	3501      	adds	r5, #1
    539c:	f7ff fe56 	bl	504c <HIDIO_buffer_push_byte>
				for ( uint8_t byte = 0; byte < sizeof(HIDIO_Packet32); byte++ )
    53a0:	2d06      	cmp	r5, #6
    53a2:	9b06      	ldr	r3, [sp, #24]
    53a4:	d1f6      	bne.n	5394 <HIDIO_buffer_generate_packet+0x1b8>
				bytes_left -= sizeof(HIDIO_Packet32);
    53a6:	f1aa 0508 	sub.w	r5, sl, #8
    53aa:	e7d0      	b.n	534e <HIDIO_buffer_generate_packet+0x172>
}
    53ac:	b00d      	add	sp, #52	; 0x34
    53ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    53b2:	bf00      	nop
    53b4:	1fffe9d0 	.word	0x1fffe9d0
    53b8:	200003a4 	.word	0x200003a4
    53bc:	0000bfa7 	.word	0x0000bfa7
    53c0:	0000bfdf 	.word	0x0000bfdf
    53c4:	0000bfed 	.word	0x0000bfed
    53c8:	0000bffb 	.word	0x0000bffb
    53cc:	0000d348 	.word	0x0000d348

000053d0 <HIDIO_test_2_call>:
{
    53d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    53d4:	4b2c      	ldr	r3, [pc, #176]	; (5488 <HIDIO_test_2_call+0xb8>)
    53d6:	b08b      	sub	sp, #44	; 0x2c
    53d8:	681a      	ldr	r2, [r3, #0]
    53da:	9209      	str	r2, [sp, #36]	; 0x24
    53dc:	4605      	mov	r5, r0
	if ( irq )
    53de:	460c      	mov	r4, r1
    53e0:	4698      	mov	r8, r3
    53e2:	2900      	cmp	r1, #0
    53e4:	d14b      	bne.n	547e <HIDIO_test_2_call+0xae>
	uint8_t *buf = HIDIO_buffer_munch( &HIDIO_assembly_buf, (uint8_t*)&tmpbuf, buf_pos, sizeof(HIDIO_Buffer_Entry) );
    53e6:	4e29      	ldr	r6, [pc, #164]	; (548c <HIDIO_test_2_call+0xbc>)
    53e8:	2308      	movs	r3, #8
    53ea:	4602      	mov	r2, r0
    53ec:	a907      	add	r1, sp, #28
    53ee:	4630      	mov	r0, r6
    53f0:	f7ff fe00 	bl	4ff4 <HIDIO_buffer_munch>
	if ( !entry->done )
    53f4:	7983      	ldrb	r3, [r0, #6]
	uint8_t *buf = HIDIO_buffer_munch( &HIDIO_assembly_buf, (uint8_t*)&tmpbuf, buf_pos, sizeof(HIDIO_Buffer_Entry) );
    53f6:	4681      	mov	r9, r0
	if ( !entry->done )
    53f8:	2b00      	cmp	r3, #0
    53fa:	d040      	beq.n	547e <HIDIO_test_2_call+0xae>
	uint8_t last_byte = 0;
    53fc:	f88d 401b 	strb.w	r4, [sp, #27]
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    5400:	3508      	adds	r5, #8
	for ( uint16_t pos = 0; pos < entry->size; pos++ )
    5402:	f8b0 b004 	ldrh.w	fp, [r0, #4]
	if ( buf_pos + len < buffer->len )
    5406:	8933      	ldrh	r3, [r6, #8]
		return &(buffer->data[0]);
    5408:	f8d6 a00c 	ldr.w	sl, [r6, #12]
	uint16_t transitions = 0;
    540c:	4627      	mov	r7, r4
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    540e:	b2ad      	uxth	r5, r5
    5410:	b2a2      	uxth	r2, r4
	for ( uint16_t pos = 0; pos < entry->size; pos++ )
    5412:	455a      	cmp	r2, fp
    5414:	d310      	bcc.n	5438 <HIDIO_test_2_call+0x68>
	if ( transitions > 1 )
    5416:	2f01      	cmp	r7, #1
    5418:	d82f      	bhi.n	547a <HIDIO_test_2_call+0xaa>
		pos = HIDIO_buffer_generate_packet(
    541a:	4d1d      	ldr	r5, [pc, #116]	; (5490 <HIDIO_test_2_call+0xc0>)
	uint16_t pos = 0;
    541c:	2100      	movs	r1, #0
		pos = HIDIO_buffer_generate_packet(
    541e:	2402      	movs	r4, #2
	while ( pos < entry->size )
    5420:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    5424:	4291      	cmp	r1, r2
    5426:	d31d      	bcc.n	5464 <HIDIO_test_2_call+0x94>
	return HIDIO_Return__Ok;
    5428:	2000      	movs	r0, #0
}
    542a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    542c:	f8d8 3000 	ldr.w	r3, [r8]
    5430:	429a      	cmp	r2, r3
    5432:	d026      	beq.n	5482 <HIDIO_test_2_call+0xb2>
    5434:	f7fc f876 	bl	1524 <__stack_chk_fail>
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    5438:	4629      	mov	r1, r5
    543a:	4630      	mov	r0, r6
    543c:	9305      	str	r3, [sp, #20]
    543e:	f7ff fe8b 	bl	5158 <HIDIO_buffer_position>
	if ( buf_pos + len < buffer->len )
    5442:	9b05      	ldr	r3, [sp, #20]
		if ( *byte != last_byte )
    5444:	f89d 101b 	ldrb.w	r1, [sp, #27]
	if ( buf_pos + len < buffer->len )
    5448:	1c42      	adds	r2, r0, #1
    544a:	429a      	cmp	r2, r3
		return &(buffer->data[ buf_pos ]);
    544c:	bfb4      	ite	lt
    544e:	4450      	addlt	r0, sl
		return &(buffer->data[0]);
    5450:	4650      	movge	r0, sl
    5452:	3401      	adds	r4, #1
		if ( *byte != last_byte )
    5454:	7802      	ldrb	r2, [r0, #0]
    5456:	4291      	cmp	r1, r2
			transitions++;
    5458:	bf1e      	ittt	ne
    545a:	3701      	addne	r7, #1
    545c:	b2bf      	uxthne	r7, r7
			last_byte = *byte;
    545e:	f88d 201b 	strbne.w	r2, [sp, #27]
    5462:	e7d5      	b.n	5410 <HIDIO_test_2_call+0x40>
		pos = HIDIO_buffer_generate_packet(
    5464:	2301      	movs	r3, #1
    5466:	e9cd 3300 	strd	r3, r3, [sp]
    546a:	9402      	str	r4, [sp, #8]
    546c:	f10d 031b 	add.w	r3, sp, #27
    5470:	4628      	mov	r0, r5
    5472:	f7ff feb3 	bl	51dc <HIDIO_buffer_generate_packet>
    5476:	4601      	mov	r1, r0
    5478:	e7d2      	b.n	5420 <HIDIO_test_2_call+0x50>
		return HIDIO_Return__InBuffer_Fail;
    547a:	2001      	movs	r0, #1
    547c:	e7d5      	b.n	542a <HIDIO_test_2_call+0x5a>
		return HIDIO_Return__Delay;
    547e:	2003      	movs	r0, #3
    5480:	e7d3      	b.n	542a <HIDIO_test_2_call+0x5a>
}
    5482:	b00b      	add	sp, #44	; 0x2c
    5484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5488:	1fffe9d0 	.word	0x1fffe9d0
    548c:	2000064c 	.word	0x2000064c
    5490:	2000054c 	.word	0x2000054c

00005494 <HIDIO_nopayload_ack>:
{
    5494:	b510      	push	{r4, lr}
    5496:	4c0b      	ldr	r4, [pc, #44]	; (54c4 <HIDIO_nopayload_ack+0x30>)
    5498:	b086      	sub	sp, #24
    549a:	6823      	ldr	r3, [r4, #0]
    549c:	9305      	str	r3, [sp, #20]
	HIDIO_buffer_generate_packet(
    549e:	2201      	movs	r2, #1
    54a0:	2300      	movs	r3, #0
    54a2:	e9cd 3200 	strd	r3, r2, [sp]
    54a6:	9002      	str	r0, [sp, #8]
    54a8:	461a      	mov	r2, r3
    54aa:	4619      	mov	r1, r3
    54ac:	4806      	ldr	r0, [pc, #24]	; (54c8 <HIDIO_nopayload_ack+0x34>)
    54ae:	f7ff fe95 	bl	51dc <HIDIO_buffer_generate_packet>
}
    54b2:	9a05      	ldr	r2, [sp, #20]
    54b4:	6823      	ldr	r3, [r4, #0]
    54b6:	429a      	cmp	r2, r3
    54b8:	d001      	beq.n	54be <HIDIO_nopayload_ack+0x2a>
    54ba:	f7fc f833 	bl	1524 <__stack_chk_fail>
    54be:	b006      	add	sp, #24
    54c0:	bd10      	pop	{r4, pc}
    54c2:	bf00      	nop
    54c4:	1fffe9d0 	.word	0x1fffe9d0
    54c8:	2000054c 	.word	0x2000054c

000054cc <HIDIO_register_id>:
// ----- Functions -----

// Register HID-IO callbacks
// If an Id is not registered, it is ignored and automatically NAK'd
void HIDIO_register_id( uint32_t id, void* incoming_call_func, void* incoming_reply_func )
{
    54cc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    54ce:	4c14      	ldr	r4, [pc, #80]	; (5520 <HIDIO_register_id+0x54>)
    54d0:	6823      	ldr	r3, [r4, #0]
    54d2:	9301      	str	r3, [sp, #4]
	// Check if there is any room left in the list
	if ( HIDIO_Id_List_Size >= HIDIO_Id_List_MaxSize )
    54d4:	4b13      	ldr	r3, [pc, #76]	; (5524 <HIDIO_register_id+0x58>)
{
    54d6:	4606      	mov	r6, r0
	if ( HIDIO_Id_List_Size >= HIDIO_Id_List_MaxSize )
    54d8:	6818      	ldr	r0, [r3, #0]
    54da:	2813      	cmp	r0, #19
    54dc:	d911      	bls.n	5502 <HIDIO_register_id+0x36>
	{
		erro_msg("HIDIO_Id_List is full, cannot register Id: ");
    54de:	4812      	ldr	r0, [pc, #72]	; (5528 <HIDIO_register_id+0x5c>)
    54e0:	f003 ffd2 	bl	9488 <_print>
		printInt32( id );
    54e4:	4630      	mov	r0, r6
    54e6:	f004 f8a5 	bl	9634 <printInt32>
		print( NL );
    54ea:	9a01      	ldr	r2, [sp, #4]
    54ec:	6823      	ldr	r3, [r4, #0]
    54ee:	429a      	cmp	r2, r3
    54f0:	d001      	beq.n	54f6 <HIDIO_register_id+0x2a>
	// Add id to unsorted list (no reason to sort, as Ids may not be contiguous)
	HIDIO_Id_Entry *entry = &HIDIO_Id_List[ HIDIO_Id_List_Size++ ];
	entry->id = id;
	entry->call_func = incoming_call_func;
	entry->reply_func = incoming_reply_func;
}
    54f2:	f7fc f817 	bl	1524 <__stack_chk_fail>
		print( NL );
    54f6:	480d      	ldr	r0, [pc, #52]	; (552c <HIDIO_register_id+0x60>)
}
    54f8:	b002      	add	sp, #8
    54fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print( NL );
    54fe:	f003 bfc3 	b.w	9488 <_print>
	HIDIO_Id_Entry *entry = &HIDIO_Id_List[ HIDIO_Id_List_Size++ ];
    5502:	1c45      	adds	r5, r0, #1
    5504:	601d      	str	r5, [r3, #0]
	entry->id = id;
    5506:	4d0a      	ldr	r5, [pc, #40]	; (5530 <HIDIO_register_id+0x64>)
    5508:	230c      	movs	r3, #12
    550a:	4343      	muls	r3, r0
    550c:	18e8      	adds	r0, r5, r3
    550e:	50ee      	str	r6, [r5, r3]
	entry->reply_func = incoming_reply_func;
    5510:	e9c0 1201 	strd	r1, r2, [r0, #4]
}
    5514:	9a01      	ldr	r2, [sp, #4]
    5516:	6823      	ldr	r3, [r4, #0]
    5518:	429a      	cmp	r2, r3
    551a:	d1ea      	bne.n	54f2 <HIDIO_register_id+0x26>
    551c:	b002      	add	sp, #8
    551e:	bd70      	pop	{r4, r5, r6, pc}
    5520:	1fffe9d0 	.word	0x1fffe9d0
    5524:	200003a0 	.word	0x200003a0
    5528:	0000c127 	.word	0x0000c127
    552c:	0000d348 	.word	0x0000d348
    5530:	2000055c 	.word	0x2000055c

00005534 <HIDIO_call_id>:
// Initiate registered call function
// id - Function id
// buf_pos - Index in ring buffer
// irq - Set to 1 if called from an IRQ
HIDIO_Return HIDIO_call_id( uint32_t id, uint16_t buf_pos, uint8_t irq )
{
    5534:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5538:	4e24      	ldr	r6, [pc, #144]	; (55cc <HIDIO_call_id+0x98>)
	HIDIO_Return retval = HIDIO_Return__Unknown;

	// Find id
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    553a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 55dc <HIDIO_call_id+0xa8>
{
    553e:	6833      	ldr	r3, [r6, #0]
	{
		// Match id
		if ( HIDIO_Id_List[ pos ].id == id )
    5540:	4f23      	ldr	r7, [pc, #140]	; (55d0 <HIDIO_call_id+0x9c>)
{
    5542:	b087      	sub	sp, #28
    5544:	4693      	mov	fp, r2
    5546:	4681      	mov	r9, r0
    5548:	468a      	mov	sl, r1
    554a:	9305      	str	r3, [sp, #20]
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    554c:	2400      	movs	r4, #0
	HIDIO_Return retval = HIDIO_Return__Unknown;
    554e:	2504      	movs	r5, #4
		if ( HIDIO_Id_List[ pos ].id == id )
    5550:	220c      	movs	r2, #12
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    5552:	f8d8 1000 	ldr.w	r1, [r8]
    5556:	b2a3      	uxth	r3, r4
    5558:	4299      	cmp	r1, r3
    555a:	d809      	bhi.n	5570 <HIDIO_call_id+0x3c>
	// Enough space to store header
	uint8_t tmpdata[sizeof(HIDIO_Buffer_Entry)];
	uint16_t datasize;
	HIDIO_Buffer_Entry *entry;

	switch ( retval )
    555c:	b1b5      	cbz	r5, 558c <HIDIO_call_id+0x58>
    555e:	2d01      	cmp	r5, #1
    5560:	d02c      	beq.n	55bc <HIDIO_call_id+0x88>
	default:
		break;
	}

	return retval;
}
    5562:	9a05      	ldr	r2, [sp, #20]
    5564:	6833      	ldr	r3, [r6, #0]
    5566:	429a      	cmp	r2, r3
    5568:	4628      	mov	r0, r5
    556a:	d02b      	beq.n	55c4 <HIDIO_call_id+0x90>
    556c:	f7fb ffda 	bl	1524 <__stack_chk_fail>
		if ( HIDIO_Id_List[ pos ].id == id )
    5570:	4353      	muls	r3, r2
    5572:	18f9      	adds	r1, r7, r3
    5574:	58fb      	ldr	r3, [r7, r3]
    5576:	454b      	cmp	r3, r9
    5578:	d106      	bne.n	5588 <HIDIO_call_id+0x54>
			retval = func( buf_pos, irq );
    557a:	684b      	ldr	r3, [r1, #4]
    557c:	9201      	str	r2, [sp, #4]
    557e:	4659      	mov	r1, fp
    5580:	4650      	mov	r0, sl
    5582:	4798      	blx	r3
    5584:	9a01      	ldr	r2, [sp, #4]
    5586:	4605      	mov	r5, r0
    5588:	3401      	adds	r4, #1
    558a:	e7e2      	b.n	5552 <HIDIO_call_id+0x1e>
		entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch( &HIDIO_assembly_buf, tmpdata, HIDIO_assembly_buf.head, sizeof(tmpdata) );
    558c:	4c11      	ldr	r4, [pc, #68]	; (55d4 <HIDIO_call_id+0xa0>)
    558e:	2308      	movs	r3, #8
    5590:	8822      	ldrh	r2, [r4, #0]
    5592:	a903      	add	r1, sp, #12
    5594:	4620      	mov	r0, r4
    5596:	f7ff fd2d 	bl	4ff4 <HIDIO_buffer_munch>
		datasize = sizeof(HIDIO_Buffer_Entry) + entry->size;
    559a:	8881      	ldrh	r1, [r0, #4]
    559c:	3108      	adds	r1, #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_assembly_buf, datasize ) )
    559e:	b289      	uxth	r1, r1
    55a0:	4620      	mov	r0, r4
    55a2:	f7ff fd8f 	bl	50c4 <HIDIO_buffer_pop_bytes>
    55a6:	4623      	mov	r3, r4
    55a8:	b128      	cbz	r0, 55b6 <HIDIO_call_id+0x82>
			HIDIO_assembly_buf.packets_ready--;
    55aa:	8962      	ldrh	r2, [r4, #10]
    55ac:	3a01      	subs	r2, #1
    55ae:	8162      	strh	r2, [r4, #10]
		HIDIO_assembly_buf.waiting = 0;
    55b0:	2200      	movs	r2, #0
    55b2:	719a      	strb	r2, [r3, #6]
    55b4:	e7d5      	b.n	5562 <HIDIO_call_id+0x2e>
			HIDIO_assembly_buf.packets_ready = 0;
    55b6:	8165      	strh	r5, [r4, #10]
			HIDIO_assembly_buf.head = 0;
    55b8:	6025      	str	r5, [r4, #0]
    55ba:	e7f9      	b.n	55b0 <HIDIO_call_id+0x7c>
		print("FAIL"NL);
    55bc:	4806      	ldr	r0, [pc, #24]	; (55d8 <HIDIO_call_id+0xa4>)
    55be:	f003 ff63 	bl	9488 <_print>
		break;
    55c2:	e7ce      	b.n	5562 <HIDIO_call_id+0x2e>
}
    55c4:	b007      	add	sp, #28
    55c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    55ca:	bf00      	nop
    55cc:	1fffe9d0 	.word	0x1fffe9d0
    55d0:	2000055c 	.word	0x2000055c
    55d4:	2000064c 	.word	0x2000064c
    55d8:	0000c058 	.word	0x0000c058
    55dc:	200003a0 	.word	0x200003a0

000055e0 <HIDIO_reply_id>:
// Initiate registered reply function
// id - Function id
// buf - Pointer to the ack buffer
// irq - Set to 1 if called from an IRQ
HIDIO_Return HIDIO_reply_id( uint32_t id, uint8_t *buf, uint8_t irq )
{
    55e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    55e2:	4e24      	ldr	r6, [pc, #144]	; (5674 <HIDIO_reply_id+0x94>)

	// Find id
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
	{
		// Match id
		if ( HIDIO_Id_List[ pos ].id == id )
    55e4:	4d24      	ldr	r5, [pc, #144]	; (5678 <HIDIO_reply_id+0x98>)
{
    55e6:	6833      	ldr	r3, [r6, #0]
    55e8:	b085      	sub	sp, #20
    55ea:	468c      	mov	ip, r1
    55ec:	9303      	str	r3, [sp, #12]
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    55ee:	4b23      	ldr	r3, [pc, #140]	; (567c <HIDIO_reply_id+0x9c>)
    55f0:	681f      	ldr	r7, [r3, #0]
    55f2:	2400      	movs	r4, #0
		if ( HIDIO_Id_List[ pos ].id == id )
    55f4:	210c      	movs	r1, #12
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    55f6:	b2a3      	uxth	r3, r4
    55f8:	429f      	cmp	r7, r3
    55fa:	d801      	bhi.n	5600 <HIDIO_reply_id+0x20>
	HIDIO_Return retval = HIDIO_Return__Unknown;
    55fc:	2504      	movs	r5, #4
    55fe:	e010      	b.n	5622 <HIDIO_reply_id+0x42>
		if ( HIDIO_Id_List[ pos ].id == id )
    5600:	434b      	muls	r3, r1
    5602:	eb05 0e03 	add.w	lr, r5, r3
    5606:	58eb      	ldr	r3, [r5, r3]
    5608:	4283      	cmp	r3, r0
    560a:	f104 0401 	add.w	r4, r4, #1
    560e:	d1f2      	bne.n	55f6 <HIDIO_reply_id+0x16>
			// Map function pointer
			HIDIO_Return (*func)(HIDIO_Buffer_Entry*, uint8_t) = \
				(HIDIO_Return(*)(HIDIO_Buffer_Entry*, uint8_t))(HIDIO_Id_List[ pos ].reply_func);

			// Call function
			retval = func( (HIDIO_Buffer_Entry*)buf, irq );
    5610:	f8de 3008 	ldr.w	r3, [lr, #8]
    5614:	4611      	mov	r1, r2
    5616:	4660      	mov	r0, ip
    5618:	4798      	blx	r3
	// Enough space to store header
	uint8_t tmpdata[6];
	uint16_t datasize;
	HIDIO_Packet *packet;

	switch ( retval )
    561a:	4605      	mov	r5, r0
    561c:	b140      	cbz	r0, 5630 <HIDIO_reply_id+0x50>
    561e:	2801      	cmp	r0, #1
    5620:	d021      	beq.n	5666 <HIDIO_reply_id+0x86>
	default:
		break;
	}

	return retval;
}
    5622:	9a03      	ldr	r2, [sp, #12]
    5624:	6833      	ldr	r3, [r6, #0]
    5626:	429a      	cmp	r2, r3
    5628:	4628      	mov	r0, r5
    562a:	d020      	beq.n	566e <HIDIO_reply_id+0x8e>
    562c:	f7fb ff7a 	bl	1524 <__stack_chk_fail>
		packet = (HIDIO_Packet*)HIDIO_buffer_munch( &HIDIO_tx_buf, tmpdata, HIDIO_tx_buf.head, sizeof(tmpdata) );
    5630:	4c13      	ldr	r4, [pc, #76]	; (5680 <HIDIO_reply_id+0xa0>)
    5632:	2306      	movs	r3, #6
    5634:	8822      	ldrh	r2, [r4, #0]
    5636:	a901      	add	r1, sp, #4
    5638:	4620      	mov	r0, r4
    563a:	f7ff fcdb 	bl	4ff4 <HIDIO_buffer_munch>
		datasize = (packet->upper_len << 8) | packet->len;
    563e:	7801      	ldrb	r1, [r0, #0]
    5640:	098b      	lsrs	r3, r1, #6
    5642:	7841      	ldrb	r1, [r0, #1]
    5644:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_tx_buf, datasize + 2 ) )
    5648:	3102      	adds	r1, #2
    564a:	4620      	mov	r0, r4
    564c:	f7ff fd3a 	bl	50c4 <HIDIO_buffer_pop_bytes>
    5650:	4623      	mov	r3, r4
    5652:	b128      	cbz	r0, 5660 <HIDIO_reply_id+0x80>
			HIDIO_tx_buf.packets_ready--;
    5654:	8962      	ldrh	r2, [r4, #10]
    5656:	3a01      	subs	r2, #1
    5658:	8162      	strh	r2, [r4, #10]
		HIDIO_tx_buf.waiting = 0;
    565a:	2200      	movs	r2, #0
    565c:	719a      	strb	r2, [r3, #6]
    565e:	e7e0      	b.n	5622 <HIDIO_reply_id+0x42>
			HIDIO_tx_buf.packets_ready = 0;
    5660:	8165      	strh	r5, [r4, #10]
			HIDIO_tx_buf.head = 0;
    5662:	6025      	str	r5, [r4, #0]
    5664:	e7f9      	b.n	565a <HIDIO_reply_id+0x7a>
		print("FAIL"NL);
    5666:	4807      	ldr	r0, [pc, #28]	; (5684 <HIDIO_reply_id+0xa4>)
    5668:	f003 ff0e 	bl	9488 <_print>
		break;
    566c:	e7d9      	b.n	5622 <HIDIO_reply_id+0x42>
}
    566e:	b005      	add	sp, #20
    5670:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5672:	bf00      	nop
    5674:	1fffe9d0 	.word	0x1fffe9d0
    5678:	2000055c 	.word	0x2000055c
    567c:	200003a0 	.word	0x200003a0
    5680:	2000065c 	.word	0x2000065c
    5684:	0000c058 	.word	0x0000c058

00005688 <HIDIO_setup>:
	print("YAY");
}

// HID-IO Module Setup
inline void HIDIO_setup()
{
    5688:	b537      	push	{r0, r1, r2, r4, r5, lr}
    568a:	4d26      	ldr	r5, [pc, #152]	; (5724 <HIDIO_setup+0x9c>)
	HIDIO_assembly_buf.tail = 0;
	HIDIO_assembly_buf.cur_buf_head = 0;
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
	HIDIO_assembly_buf.packets_ready = 0;
	HIDIO_assembly_buf.waiting = 0;
	HIDIO_assembly_buf.data = HIDIO_assembly_buf_data;
    568c:	4926      	ldr	r1, [pc, #152]	; (5728 <HIDIO_setup+0xa0>)
{
    568e:	682b      	ldr	r3, [r5, #0]
    5690:	9301      	str	r3, [sp, #4]
	HIDIO_Packet_Size = 8;
    5692:	4b26      	ldr	r3, [pc, #152]	; (572c <HIDIO_setup+0xa4>)
	HIDIO_tx_buf.packets_ready = 0;
	HIDIO_tx_buf.waiting = 0;
	HIDIO_tx_buf.data = HIDIO_tx_buf_data;

	// Register Output CLI dictionary
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    5694:	4826      	ldr	r0, [pc, #152]	; (5730 <HIDIO_setup+0xa8>)
	HIDIO_Packet_Size = 8;
    5696:	2208      	movs	r2, #8
    5698:	801a      	strh	r2, [r3, #0]
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    569a:	4b26      	ldr	r3, [pc, #152]	; (5734 <HIDIO_setup+0xac>)
	HIDIO_assembly_buf.head = 0;
    569c:	2400      	movs	r4, #0
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    569e:	22d0      	movs	r2, #208	; 0xd0
	HIDIO_assembly_buf.head = 0;
    56a0:	601c      	str	r4, [r3, #0]
	HIDIO_assembly_buf.tail = 0;
    56a2:	809c      	strh	r4, [r3, #4]
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    56a4:	609a      	str	r2, [r3, #8]
	HIDIO_assembly_buf.cur_buf_head = 0;
    56a6:	719c      	strb	r4, [r3, #6]
	HIDIO_assembly_buf.data = HIDIO_assembly_buf_data;
    56a8:	60d9      	str	r1, [r3, #12]
	HIDIO_ack_buf = (HIDIO_Buffer_Entry*)HIDIO_ack_buf_data;
    56aa:	4b23      	ldr	r3, [pc, #140]	; (5738 <HIDIO_setup+0xb0>)
    56ac:	4923      	ldr	r1, [pc, #140]	; (573c <HIDIO_setup+0xb4>)
	HIDIO_ack_buf->id = 0;
    56ae:	701c      	strb	r4, [r3, #0]
    56b0:	705c      	strb	r4, [r3, #1]
    56b2:	709c      	strb	r4, [r3, #2]
    56b4:	70dc      	strb	r4, [r3, #3]
	HIDIO_ack_buf->size = 0;
    56b6:	711c      	strb	r4, [r3, #4]
    56b8:	715c      	strb	r4, [r3, #5]
	HIDIO_ack_buf->done = 0;
    56ba:	719c      	strb	r4, [r3, #6]
	HIDIO_ack_buf = (HIDIO_Buffer_Entry*)HIDIO_ack_buf_data;
    56bc:	600b      	str	r3, [r1, #0]
	HIDIO_ack_send_buf.len = sizeof(HIDIO_ack_send_data);
    56be:	4b20      	ldr	r3, [pc, #128]	; (5740 <HIDIO_setup+0xb8>)
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    56c0:	4920      	ldr	r1, [pc, #128]	; (5744 <HIDIO_setup+0xbc>)
	HIDIO_ack_send_buf.len = sizeof(HIDIO_ack_send_data);
    56c2:	609a      	str	r2, [r3, #8]
	HIDIO_ack_send_buf.data = HIDIO_ack_send_data;
    56c4:	4a20      	ldr	r2, [pc, #128]	; (5748 <HIDIO_setup+0xc0>)
    56c6:	60da      	str	r2, [r3, #12]
	HIDIO_ack_send_buf.head = 0;
    56c8:	601c      	str	r4, [r3, #0]
	HIDIO_ack_send_buf.tail = 0;
    56ca:	809c      	strh	r4, [r3, #4]
	HIDIO_ack_send_buf.cur_buf_head = 0;
    56cc:	719c      	strb	r4, [r3, #6]
	HIDIO_tx_buf.len = sizeof(HIDIO_tx_buf_data);
    56ce:	4b1f      	ldr	r3, [pc, #124]	; (574c <HIDIO_setup+0xc4>)
    56d0:	22ca      	movs	r2, #202	; 0xca
    56d2:	609a      	str	r2, [r3, #8]
	HIDIO_tx_buf.head = 0;
    56d4:	601c      	str	r4, [r3, #0]
	HIDIO_tx_buf.data = HIDIO_tx_buf_data;
    56d6:	4a1e      	ldr	r2, [pc, #120]	; (5750 <HIDIO_setup+0xc8>)
	HIDIO_tx_buf.tail = 0;
    56d8:	809c      	strh	r4, [r3, #4]
	HIDIO_tx_buf.cur_buf_head = 0;
    56da:	719c      	strb	r4, [r3, #6]
	HIDIO_tx_buf.data = HIDIO_tx_buf_data;
    56dc:	60da      	str	r2, [r3, #12]
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    56de:	f003 fa63 	bl	8ba8 <CLI_registerDictionary>

	// Allocate latency resource
	hidioLatencyResource = Latency_add_resource("HID-IO", LatencyOption_Ticks);
    56e2:	4621      	mov	r1, r4
    56e4:	481b      	ldr	r0, [pc, #108]	; (5754 <HIDIO_setup+0xcc>)
    56e6:	f003 fd85 	bl	91f4 <Latency_add_resource>
    56ea:	4b1b      	ldr	r3, [pc, #108]	; (5758 <HIDIO_setup+0xd0>)

	// Reset internal id list
	HIDIO_Id_List_Size = 0;

	// Register internal Ids
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    56ec:	4a1b      	ldr	r2, [pc, #108]	; (575c <HIDIO_setup+0xd4>)
	hidioLatencyResource = Latency_add_resource("HID-IO", LatencyOption_Ticks);
    56ee:	7018      	strb	r0, [r3, #0]
	HIDIO_Id_List_Size = 0;
    56f0:	4b1b      	ldr	r3, [pc, #108]	; (5760 <HIDIO_setup+0xd8>)
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    56f2:	491c      	ldr	r1, [pc, #112]	; (5764 <HIDIO_setup+0xdc>)
	HIDIO_Id_List_Size = 0;
    56f4:	601c      	str	r4, [r3, #0]
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    56f6:	4620      	mov	r0, r4
    56f8:	f7ff fee8 	bl	54cc <HIDIO_register_id>
	HIDIO_register_id( 1, (void*)HIDIO_info_1_call, (void*)HIDIO_info_1_reply );
    56fc:	4a1a      	ldr	r2, [pc, #104]	; (5768 <HIDIO_setup+0xe0>)
    56fe:	491b      	ldr	r1, [pc, #108]	; (576c <HIDIO_setup+0xe4>)
    5700:	2001      	movs	r0, #1
    5702:	f7ff fee3 	bl	54cc <HIDIO_register_id>
	HIDIO_register_id( 2, (void*)HIDIO_test_2_call, (void*)HIDIO_test_2_reply );
    5706:	9a01      	ldr	r2, [sp, #4]
    5708:	682b      	ldr	r3, [r5, #0]
    570a:	429a      	cmp	r2, r3
    570c:	d001      	beq.n	5712 <HIDIO_setup+0x8a>
    570e:	f7fb ff09 	bl	1524 <__stack_chk_fail>
    5712:	4a17      	ldr	r2, [pc, #92]	; (5770 <HIDIO_setup+0xe8>)
    5714:	4917      	ldr	r1, [pc, #92]	; (5774 <HIDIO_setup+0xec>)
    5716:	2002      	movs	r0, #2
}
    5718:	b003      	add	sp, #12
    571a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	HIDIO_register_id( 2, (void*)HIDIO_test_2_call, (void*)HIDIO_test_2_reply );
    571e:	f7ff bed5 	b.w	54cc <HIDIO_register_id>
    5722:	bf00      	nop
    5724:	1fffe9d0 	.word	0x1fffe9d0
    5728:	200003a6 	.word	0x200003a6
    572c:	200003a4 	.word	0x200003a4
    5730:	0000c170 	.word	0x0000c170
    5734:	2000064c 	.word	0x2000064c
    5738:	20000350 	.word	0x20000350
    573c:	20000478 	.word	0x20000478
    5740:	2000054c 	.word	0x2000054c
    5744:	0000c17c 	.word	0x0000c17c
    5748:	2000047c 	.word	0x2000047c
    574c:	2000065c 	.word	0x2000065c
    5750:	2000066c 	.word	0x2000066c
    5754:	0000c168 	.word	0x0000c168
    5758:	1ffff462 	.word	0x1ffff462
    575c:	00004f3d 	.word	0x00004f3d
    5760:	200003a0 	.word	0x200003a0
    5764:	00004f19 	.word	0x00004f19
    5768:	00004fad 	.word	0x00004fad
    576c:	00004fd1 	.word	0x00004fd1
    5770:	00004f61 	.word	0x00004f61
    5774:	000053d1 	.word	0x000053d1

00005778 <HIDIO_process_incoming_packet>:

// HID-IO Process Packet
void HIDIO_process_incoming_packet( uint8_t *buf, uint8_t irq )
{
    5778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    577c:	b08f      	sub	sp, #60	; 0x3c
    577e:	4680      	mov	r8, r0
    5780:	9105      	str	r1, [sp, #20]
    5782:	4980      	ldr	r1, [pc, #512]	; (5984 <HIDIO_process_incoming_packet+0x20c>)
    5784:	9106      	str	r1, [sp, #24]
    5786:	680b      	ldr	r3, [r1, #0]
    5788:	930d      	str	r3, [sp, #52]	; 0x34
	// Map structure to packet data
	HIDIO_Packet *packet = (HIDIO_Packet*)buf;

	// Check header packet type to see if a valid packet
	if ( packet->type > HIDIO_Packet_Type__Continued )
    578a:	7803      	ldrb	r3, [r0, #0]
    578c:	f3c3 0b02 	ubfx	fp, r3, #0, #3
    5790:	fa5f f48b 	uxtb.w	r4, fp
    5794:	2c04      	cmp	r4, #4
    5796:	f200 80c4 	bhi.w	5922 <HIDIO_process_incoming_packet+0x1aa>
		return;

	// Check if the length is valid
	uint16_t packet_len = (packet->upper_len << 8) | packet->len;
    579a:	7841      	ldrb	r1, [r0, #1]
    579c:	099e      	lsrs	r6, r3, #6
    579e:	ea41 2606 	orr.w	r6, r1, r6, lsl #8
	if ( packet_len > HIDIO_Packet_Size )
    57a2:	4979      	ldr	r1, [pc, #484]	; (5988 <HIDIO_process_incoming_packet+0x210>)
    57a4:	8809      	ldrh	r1, [r1, #0]
    57a6:	42b1      	cmp	r1, r6
    57a8:	f0c0 80bb 	bcc.w	5922 <HIDIO_process_incoming_packet+0x1aa>
	return id_width ? 4 : 2;
    57ac:	f013 0f10 	tst.w	r3, #16
    57b0:	bf14      	ite	ne
    57b2:	2104      	movne	r1, #4
    57b4:	2102      	moveq	r1, #2
	uint16_t payload_len = packet_len - id_width_len;

	// Check if valid Id
	uint32_t id = 0;
	uint8_t *data = 0;
	switch ( type )
    57b6:	2c03      	cmp	r4, #3
    57b8:	d02a      	beq.n	5810 <HIDIO_process_incoming_packet+0x98>
    57ba:	2c04      	cmp	r4, #4
    57bc:	d02d      	beq.n	581a <HIDIO_process_incoming_packet+0xa2>
		// Modify type so we know what to do with the payload
		type = HIDIO_ack_buf->done ? HIDIO_Packet_Type__Data : HIDIO_Packet_Type__ACK;

	// Most packet types
	default:
		id = HIDIO_buffer_id( packet );
    57be:	4640      	mov	r0, r8
    57c0:	9307      	str	r3, [sp, #28]
	uint16_t payload_len = packet_len - id_width_len;
    57c2:	1a76      	subs	r6, r6, r1
		id = HIDIO_buffer_id( packet );
    57c4:	f7ff fce0 	bl	5188 <HIDIO_buffer_id>
    57c8:	4607      	mov	r7, r0

		// Data start
		data = HIDIO_payload_start( packet );
    57ca:	4640      	mov	r0, r8
    57cc:	f7ff fcf2 	bl	51b4 <HIDIO_payload_start>
	uint16_t payload_len = packet_len - id_width_len;
    57d0:	b2b6      	uxth	r6, r6
		data = HIDIO_payload_start( packet );
    57d2:	4682      	mov	sl, r0
		break;
	}

	// Process packet
	switch ( type )
    57d4:	9b07      	ldr	r3, [sp, #28]
    57d6:	b33c      	cbz	r4, 5828 <HIDIO_process_incoming_packet+0xb0>
    57d8:	2c02      	cmp	r4, #2
    57da:	d81c      	bhi.n	5816 <HIDIO_process_incoming_packet+0x9e>

	case HIDIO_Packet_Type__ACK:
	case HIDIO_Packet_Type__NAK:
		// ACK/NAK packets have their own assembly buffer
		// Setup entry
		HIDIO_ack_buf->id = id;
    57dc:	4c6b      	ldr	r4, [pc, #428]	; (598c <HIDIO_process_incoming_packet+0x214>)
		HIDIO_ack_buf->size = payload_len;
		HIDIO_ack_buf->done = packet->cont ? 0 : 1;
    57de:	f083 0308 	eor.w	r3, r3, #8
		HIDIO_ack_buf->id = id;
    57e2:	6820      	ldr	r0, [r4, #0]
		HIDIO_ack_buf->done = packet->cont ? 0 : 1;
    57e4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    57e8:	7183      	strb	r3, [r0, #6]
		HIDIO_ack_buf->id = id;
    57ea:	6007      	str	r7, [r0, #0]
		HIDIO_ack_buf->size = payload_len;
    57ec:	8086      	strh	r6, [r0, #4]
		HIDIO_ack_buf->type = packet->type;
    57ee:	f880 b007 	strb.w	fp, [r0, #7]

		// Copy to buffer
		memcpy( &(HIDIO_ack_buf->data[0]), data, payload_len );
    57f2:	4651      	mov	r1, sl
    57f4:	4632      	mov	r2, r6
    57f6:	3008      	adds	r0, #8
    57f8:	f7fb feb8 	bl	156c <memcpy>

		// If finished, send to appropriate registered callback
		if ( HIDIO_ack_buf->done )
    57fc:	6821      	ldr	r1, [r4, #0]
    57fe:	798b      	ldrb	r3, [r1, #6]
    5800:	2b00      	cmp	r3, #0
    5802:	f000 808e 	beq.w	5922 <HIDIO_process_incoming_packet+0x1aa>
		{
			HIDIO_reply_id( id, (uint8_t*)HIDIO_ack_buf, irq );
    5806:	9a05      	ldr	r2, [sp, #20]
    5808:	4638      	mov	r0, r7
    580a:	f7ff fee9 	bl	55e0 <HIDIO_reply_id>
    580e:	e088      	b.n	5922 <HIDIO_process_incoming_packet+0x1aa>
		print("SYNC");
    5810:	485f      	ldr	r0, [pc, #380]	; (5990 <HIDIO_process_incoming_packet+0x218>)
    5812:	f003 fe39 	bl	9488 <_print>
		break;
		break;

	default:
		// TODO (HaaTa)
		print("TODO!"NL);
    5816:	485f      	ldr	r0, [pc, #380]	; (5994 <HIDIO_process_incoming_packet+0x21c>)
    5818:	e012      	b.n	5840 <HIDIO_process_incoming_packet+0xc8>
		type = HIDIO_ack_buf->done ? HIDIO_Packet_Type__Data : HIDIO_Packet_Type__ACK;
    581a:	485c      	ldr	r0, [pc, #368]	; (598c <HIDIO_process_incoming_packet+0x214>)
    581c:	6800      	ldr	r0, [r0, #0]
    581e:	7984      	ldrb	r4, [r0, #6]
    5820:	fab4 f484 	clz	r4, r4
    5824:	0964      	lsrs	r4, r4, #5
    5826:	e7ca      	b.n	57be <HIDIO_process_incoming_packet+0x46>
		if ( !HIDIO_assembly_buf.waiting )
    5828:	f8df 918c 	ldr.w	r9, [pc, #396]	; 59b8 <HIDIO_process_incoming_packet+0x240>
    582c:	f899 1006 	ldrb.w	r1, [r9, #6]
    5830:	464d      	mov	r5, r9
    5832:	2900      	cmp	r1, #0
    5834:	d17c      	bne.n	5930 <HIDIO_process_incoming_packet+0x1b8>
			if ( packet->type == HIDIO_Packet_Type__Continued )
    5836:	f003 0107 	and.w	r1, r3, #7
    583a:	2904      	cmp	r1, #4
    583c:	d103      	bne.n	5846 <HIDIO_process_incoming_packet+0xce>
				warn_print("Dropping incoming Continued Data packet...");
    583e:	4856      	ldr	r0, [pc, #344]	; (5998 <HIDIO_process_incoming_packet+0x220>)
		print("TODO!"NL);
    5840:	f003 fe22 	bl	9488 <_print>
    5844:	e06d      	b.n	5922 <HIDIO_process_incoming_packet+0x1aa>
			if ( HIDIO_buffer_free_bytes( &HIDIO_assembly_buf ) < sizeof(HIDIO_Buffer_Entry) + payload_len )
    5846:	4648      	mov	r0, r9
    5848:	9307      	str	r3, [sp, #28]
    584a:	f7ff fc6d 	bl	5128 <HIDIO_buffer_free_bytes>
    584e:	f106 0108 	add.w	r1, r6, #8
    5852:	4288      	cmp	r0, r1
    5854:	9b07      	ldr	r3, [sp, #28]
    5856:	d222      	bcs.n	589e <HIDIO_process_incoming_packet+0x126>
				warn_print("Dropping incoming Data packet, not enough buffer space...");
    5858:	4850      	ldr	r0, [pc, #320]	; (599c <HIDIO_process_incoming_packet+0x224>)
    585a:	9105      	str	r1, [sp, #20]
    585c:	f003 fe14 	bl	9488 <_print>
				print("head: ");
    5860:	484f      	ldr	r0, [pc, #316]	; (59a0 <HIDIO_process_incoming_packet+0x228>)
    5862:	f003 fe11 	bl	9488 <_print>
				printInt16( HIDIO_assembly_buf.head );
    5866:	f8b9 0000 	ldrh.w	r0, [r9]
    586a:	f003 fead 	bl	95c8 <printInt16>
				print(" tail: ");
    586e:	484d      	ldr	r0, [pc, #308]	; (59a4 <HIDIO_process_incoming_packet+0x22c>)
    5870:	f003 fe0a 	bl	9488 <_print>
				printInt16( HIDIO_assembly_buf.tail );
    5874:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    5878:	f003 fea6 	bl	95c8 <printInt16>
				print(" bytes_left: ");
    587c:	484a      	ldr	r0, [pc, #296]	; (59a8 <HIDIO_process_incoming_packet+0x230>)
    587e:	f003 fe03 	bl	9488 <_print>
				printInt16( HIDIO_buffer_free_bytes( &HIDIO_assembly_buf ) );
    5882:	4648      	mov	r0, r9
    5884:	f7ff fc50 	bl	5128 <HIDIO_buffer_free_bytes>
    5888:	f003 fe9e 	bl	95c8 <printInt16>
				print(" request: ");
    588c:	4847      	ldr	r0, [pc, #284]	; (59ac <HIDIO_process_incoming_packet+0x234>)
    588e:	f003 fdfb 	bl	9488 <_print>
				printInt16( sizeof(HIDIO_Buffer_Entry) + payload_len );
    5892:	9905      	ldr	r1, [sp, #20]
    5894:	b288      	uxth	r0, r1
    5896:	f003 fe97 	bl	95c8 <printInt16>
				print(NL);
    589a:	4845      	ldr	r0, [pc, #276]	; (59b0 <HIDIO_process_incoming_packet+0x238>)
    589c:	e7d0      	b.n	5840 <HIDIO_process_incoming_packet+0xc8>
			entry.done = packet->cont ? 0 : 1;
    589e:	f083 0308 	eor.w	r3, r3, #8
    58a2:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    58a6:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
			HIDIO_assembly_buf.cur_buf_head = HIDIO_assembly_buf.tail;
    58aa:	f8b9 3002 	ldrh.w	r3, [r9, #2]
			entry.type = packet->type;
    58ae:	f88d b02b 	strb.w	fp, [sp, #43]	; 0x2b
			entry.id = id;
    58b2:	9709      	str	r7, [sp, #36]	; 0x24
			entry.size = payload_len;
    58b4:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
			HIDIO_assembly_buf.cur_buf_head = HIDIO_assembly_buf.tail;
    58b8:	f8a9 3004 	strh.w	r3, [r9, #4]
				HIDIO_buffer_push_byte( &HIDIO_assembly_buf, ((uint8_t*)&entry)[c] );
    58bc:	f10d 0b24 	add.w	fp, sp, #36	; 0x24
    58c0:	f81b 1004 	ldrb.w	r1, [fp, r4]
    58c4:	4648      	mov	r0, r9
    58c6:	3401      	adds	r4, #1
    58c8:	f7ff fbc0 	bl	504c <HIDIO_buffer_push_byte>
			for ( uint8_t c = 0; c < sizeof(HIDIO_Buffer_Entry); c++ )
    58cc:	2c08      	cmp	r4, #8
    58ce:	d1f7      	bne.n	58c0 <HIDIO_process_incoming_packet+0x148>
		HIDIO_assembly_buf.waiting = packet->cont;
    58d0:	f898 3000 	ldrb.w	r3, [r8]
			HIDIO_buffer_push_byte( &HIDIO_assembly_buf, data[c] );
    58d4:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 59b8 <HIDIO_process_incoming_packet+0x240>
		HIDIO_assembly_buf.waiting = packet->cont;
    58d8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    58dc:	71ab      	strb	r3, [r5, #6]
		for ( uint16_t c = 0; c < payload_len; c++ )
    58de:	4654      	mov	r4, sl
    58e0:	eba4 030a 	sub.w	r3, r4, sl
    58e4:	b29b      	uxth	r3, r3
    58e6:	42b3      	cmp	r3, r6
    58e8:	d33e      	bcc.n	5968 <HIDIO_process_incoming_packet+0x1f0>
		HIDIO_assembly_buf.packets_ready++;
    58ea:	896b      	ldrh	r3, [r5, #10]
		if ( !HIDIO_assembly_buf.waiting )
    58ec:	79ac      	ldrb	r4, [r5, #6]
		HIDIO_assembly_buf.packets_ready++;
    58ee:	3301      	adds	r3, #1
    58f0:	816b      	strh	r3, [r5, #10]
		if ( !HIDIO_assembly_buf.waiting )
    58f2:	2c00      	cmp	r4, #0
    58f4:	d13e      	bne.n	5974 <HIDIO_process_incoming_packet+0x1fc>
			HIDIO_Return retval = HIDIO_call_id( id, HIDIO_assembly_buf.cur_buf_head, irq );
    58f6:	9a05      	ldr	r2, [sp, #20]
    58f8:	88a9      	ldrh	r1, [r5, #4]
    58fa:	4638      	mov	r0, r7
    58fc:	f7ff fe1a 	bl	5534 <HIDIO_call_id>
			switch ( retval )
    5900:	2804      	cmp	r0, #4
    5902:	d10e      	bne.n	5922 <HIDIO_process_incoming_packet+0x1aa>
				HIDIO_assembly_buf.packets_ready--;
    5904:	896b      	ldrh	r3, [r5, #10]
				HIDIO_buffer_generate_packet(
    5906:	482b      	ldr	r0, [pc, #172]	; (59b4 <HIDIO_process_incoming_packet+0x23c>)
				HIDIO_assembly_buf.packets_ready--;
    5908:	3b01      	subs	r3, #1
    590a:	816b      	strh	r3, [r5, #10]
				HIDIO_assembly_buf.head = HIDIO_assembly_buf.tail;
    590c:	886b      	ldrh	r3, [r5, #2]
    590e:	802b      	strh	r3, [r5, #0]
				HIDIO_buffer_generate_packet(
    5910:	2302      	movs	r3, #2
    5912:	e9cd 4300 	strd	r4, r3, [sp]
    5916:	9702      	str	r7, [sp, #8]
    5918:	4623      	mov	r3, r4
    591a:	4622      	mov	r2, r4
    591c:	4621      	mov	r1, r4
    591e:	f7ff fc5d 	bl	51dc <HIDIO_buffer_generate_packet>
	{
		printChar( (char)(data[ pos ]) );
	}
	print( NL );
	*/
}
    5922:	9b06      	ldr	r3, [sp, #24]
    5924:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    5926:	681b      	ldr	r3, [r3, #0]
    5928:	429a      	cmp	r2, r3
    592a:	d027      	beq.n	597c <HIDIO_process_incoming_packet+0x204>
    592c:	f7fb fdfa 	bl	1524 <__stack_chk_fail>
			HIDIO_Buffer_Entry *entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch(
    5930:	ac0b      	add	r4, sp, #44	; 0x2c
    5932:	2308      	movs	r3, #8
    5934:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    5938:	4621      	mov	r1, r4
    593a:	4648      	mov	r0, r9
    593c:	f7ff fb5a 	bl	4ff4 <HIDIO_buffer_munch>
			entry->size += payload_len;
    5940:	8883      	ldrh	r3, [r0, #4]
    5942:	4433      	add	r3, r6
    5944:	8083      	strh	r3, [r0, #4]
			entry->done = packet->cont ? 0 : 1;
    5946:	f898 3000 	ldrb.w	r3, [r8]
    594a:	f083 0308 	eor.w	r3, r3, #8
    594e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
			if ( tmpbuf == (uint8_t*)entry )
    5952:	42a0      	cmp	r0, r4
			HIDIO_Buffer_Entry *entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch(
    5954:	4602      	mov	r2, r0
			entry->done = packet->cont ? 0 : 1;
    5956:	7183      	strb	r3, [r0, #6]
			if ( tmpbuf == (uint8_t*)entry )
    5958:	d1ba      	bne.n	58d0 <HIDIO_process_incoming_packet+0x158>
				HIDIO_modify_buffer(
    595a:	2308      	movs	r3, #8
    595c:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    5960:	4648      	mov	r0, r9
    5962:	f7ff fb8d 	bl	5080 <HIDIO_modify_buffer>
    5966:	e7b3      	b.n	58d0 <HIDIO_process_incoming_packet+0x158>
			HIDIO_buffer_push_byte( &HIDIO_assembly_buf, data[c] );
    5968:	f814 1b01 	ldrb.w	r1, [r4], #1
    596c:	4640      	mov	r0, r8
    596e:	f7ff fb6d 	bl	504c <HIDIO_buffer_push_byte>
    5972:	e7b5      	b.n	58e0 <HIDIO_process_incoming_packet+0x168>
			HIDIO_nopayload_ack( id );
    5974:	4638      	mov	r0, r7
    5976:	f7ff fd8d 	bl	5494 <HIDIO_nopayload_ack>
    597a:	e7d2      	b.n	5922 <HIDIO_process_incoming_packet+0x1aa>
}
    597c:	b00f      	add	sp, #60	; 0x3c
    597e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5982:	bf00      	nop
    5984:	1fffe9d0 	.word	0x1fffe9d0
    5988:	200003a4 	.word	0x200003a4
    598c:	20000478 	.word	0x20000478
    5990:	0000c05f 	.word	0x0000c05f
    5994:	0000c11f 	.word	0x0000c11f
    5998:	0000c064 	.word	0x0000c064
    599c:	0000c0a6 	.word	0x0000c0a6
    59a0:	0000c0f7 	.word	0x0000c0f7
    59a4:	0000c0fe 	.word	0x0000c0fe
    59a8:	0000c106 	.word	0x0000c106
    59ac:	0000c114 	.word	0x0000c114
    59b0:	0000d348 	.word	0x0000d348
    59b4:	2000054c 	.word	0x2000054c
    59b8:	2000064c 	.word	0x2000064c

000059bc <HIDIO_process>:

// HID-IO Processing Loop
inline void HIDIO_process()
{
    59bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    59c0:	4d28      	ldr	r5, [pc, #160]	; (5a64 <HIDIO_process+0xa8>)
	// Start latency measurement
	Latency_start_time( hidioLatencyResource );
    59c2:	4e29      	ldr	r6, [pc, #164]	; (5a68 <HIDIO_process+0xac>)
{
    59c4:	682b      	ldr	r3, [r5, #0]
	Latency_start_time( hidioLatencyResource );
    59c6:	7830      	ldrb	r0, [r6, #0]
{
    59c8:	b092      	sub	sp, #72	; 0x48
    59ca:	9311      	str	r3, [sp, #68]	; 0x44
	Latency_start_time( hidioLatencyResource );
    59cc:	f003 fc8a 	bl	92e4 <Latency_start_time>

	// TODO (HaaTa): Handle timeouts and lost packets

	// Retrieve incoming packets
	while ( Output_rawio_availablechar() )
    59d0:	f000 f9e8 	bl	5da4 <Output_rawio_availablechar>
    59d4:	b9e0      	cbnz	r0, 5a10 <HIDIO_process+0x54>
		// Process Packet, regular process (no interrupt)
		HIDIO_process_incoming_packet( tmpdata, 0 );
	}

	// Send all ACK packets
	while ( HIDIO_ack_send_buf.packets_ready > 0 )
    59d6:	4c25      	ldr	r4, [pc, #148]	; (5a6c <HIDIO_process+0xb0>)
	{
		// Prepare 64 byte packet
		// TODO (HaaTa): Handle internal max size
		uint8_t tmpdata[64];
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_ack_send_buf, tmpdata, HIDIO_ack_send_buf.head, HIDIO_Packet_Size );
    59d8:	4f25      	ldr	r7, [pc, #148]	; (5a70 <HIDIO_process+0xb4>)
	while ( HIDIO_ack_send_buf.packets_ready > 0 )
    59da:	8963      	ldrh	r3, [r4, #10]
    59dc:	bb03      	cbnz	r3, 5a20 <HIDIO_process+0x64>
		}
	}

	// Send outgoing packet, we can only send one at a time
	// and the next one can only be sent after an ACK is recieved
	if ( HIDIO_tx_buf.packets_ready > 0 && HIDIO_tx_buf.waiting == 0 )
    59de:	4c25      	ldr	r4, [pc, #148]	; (5a74 <HIDIO_process+0xb8>)
    59e0:	8963      	ldrh	r3, [r4, #10]
    59e2:	b163      	cbz	r3, 59fe <HIDIO_process+0x42>
    59e4:	79a3      	ldrb	r3, [r4, #6]
    59e6:	b953      	cbnz	r3, 59fe <HIDIO_process+0x42>
	{
		// Prepare 64 byte packet
		// TODO (HaaTa): Handle internal max size
		uint8_t tmpdata[64];
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_tx_buf, tmpdata, HIDIO_tx_buf.head, HIDIO_Packet_Size );
    59e8:	4b21      	ldr	r3, [pc, #132]	; (5a70 <HIDIO_process+0xb4>)
    59ea:	8822      	ldrh	r2, [r4, #0]
    59ec:	881b      	ldrh	r3, [r3, #0]
    59ee:	a901      	add	r1, sp, #4
    59f0:	4620      	mov	r0, r4
    59f2:	f7ff faff 	bl	4ff4 <HIDIO_buffer_munch>
		HIDIO_Packet *packet = (HIDIO_Packet*)buf;

		// Send packet
		// TODO (HaaTa): Check error?
		Output_rawio_sendbuffer( (char*)packet );
    59f6:	f000 f9f9 	bl	5dec <Output_rawio_sendbuffer>

		// Indicate waiting for ACK packet
		// Once ACK has been received (or NAK) the packet will be released
		HIDIO_tx_buf.waiting = 1;
    59fa:	2301      	movs	r3, #1
    59fc:	71a3      	strb	r3, [r4, #6]
	}

	// End latency measurement
	Latency_end_time( hidioLatencyResource );
    59fe:	7830      	ldrb	r0, [r6, #0]
    5a00:	f003 fc8e 	bl	9320 <Latency_end_time>
}
    5a04:	9a11      	ldr	r2, [sp, #68]	; 0x44
    5a06:	682b      	ldr	r3, [r5, #0]
    5a08:	429a      	cmp	r2, r3
    5a0a:	d027      	beq.n	5a5c <HIDIO_process+0xa0>
    5a0c:	f7fb fd8a 	bl	1524 <__stack_chk_fail>
		Output_rawio_getbuffer( (char*)&tmpdata );
    5a10:	a801      	add	r0, sp, #4
    5a12:	f000 f9d9 	bl	5dc8 <Output_rawio_getbuffer>
		HIDIO_process_incoming_packet( tmpdata, 0 );
    5a16:	2100      	movs	r1, #0
    5a18:	a801      	add	r0, sp, #4
    5a1a:	f7ff fead 	bl	5778 <HIDIO_process_incoming_packet>
    5a1e:	e7d7      	b.n	59d0 <HIDIO_process+0x14>
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_ack_send_buf, tmpdata, HIDIO_ack_send_buf.head, HIDIO_Packet_Size );
    5a20:	883b      	ldrh	r3, [r7, #0]
    5a22:	8822      	ldrh	r2, [r4, #0]
    5a24:	a901      	add	r1, sp, #4
    5a26:	4620      	mov	r0, r4
    5a28:	f7ff fae4 	bl	4ff4 <HIDIO_buffer_munch>
    5a2c:	4680      	mov	r8, r0
		Output_rawio_sendbuffer( (char*)buf );
    5a2e:	f000 f9dd 	bl	5dec <Output_rawio_sendbuffer>
		HIDIO_ack_send_buf.waiting = 1;
    5a32:	2301      	movs	r3, #1
    5a34:	71a3      	strb	r3, [r4, #6]
		uint16_t datasize = (packet->upper_len << 8) | packet->len;
    5a36:	f898 1000 	ldrb.w	r1, [r8]
    5a3a:	098b      	lsrs	r3, r1, #6
    5a3c:	f898 1001 	ldrb.w	r1, [r8, #1]
    5a40:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_ack_send_buf, datasize + 2 ) )
    5a44:	3102      	adds	r1, #2
    5a46:	4620      	mov	r0, r4
    5a48:	f7ff fb3c 	bl	50c4 <HIDIO_buffer_pop_bytes>
    5a4c:	b118      	cbz	r0, 5a56 <HIDIO_process+0x9a>
			HIDIO_ack_send_buf.packets_ready--;
    5a4e:	8963      	ldrh	r3, [r4, #10]
    5a50:	3b01      	subs	r3, #1
    5a52:	8163      	strh	r3, [r4, #10]
    5a54:	e7c1      	b.n	59da <HIDIO_process+0x1e>
			HIDIO_ack_send_buf.packets_ready = 0;
    5a56:	8160      	strh	r0, [r4, #10]
			HIDIO_ack_send_buf.head = 0;
    5a58:	6020      	str	r0, [r4, #0]
    5a5a:	e7be      	b.n	59da <HIDIO_process+0x1e>
}
    5a5c:	b012      	add	sp, #72	; 0x48
    5a5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5a62:	bf00      	nop
    5a64:	1fffe9d0 	.word	0x1fffe9d0
    5a68:	1ffff462 	.word	0x1ffff462
    5a6c:	2000054c 	.word	0x2000054c
    5a70:	200003a4 	.word	0x200003a4
    5a74:	2000065c 	.word	0x2000065c

00005a78 <cliFunc_outputDebug>:
	print(" mA");
}


void cliFunc_outputDebug( char* args )
{
    5a78:	b530      	push	{r4, r5, lr}
    5a7a:	4c0e      	ldr	r4, [pc, #56]	; (5ab4 <cliFunc_outputDebug+0x3c>)
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    5a7c:	4d0e      	ldr	r5, [pc, #56]	; (5ab8 <cliFunc_outputDebug+0x40>)
{
    5a7e:	6823      	ldr	r3, [r4, #0]
    5a80:	b085      	sub	sp, #20
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5a82:	aa02      	add	r2, sp, #8
    5a84:	a901      	add	r1, sp, #4
{
    5a86:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5a88:	f002 ffd0 	bl	8a2c <CLI_argumentIsolation>
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    5a8c:	782b      	ldrb	r3, [r5, #0]

	if ( arg1Ptr[0] != '\0' )
    5a8e:	9801      	ldr	r0, [sp, #4]
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    5a90:	fab3 f383 	clz	r3, r3
    5a94:	095b      	lsrs	r3, r3, #5
    5a96:	702b      	strb	r3, [r5, #0]
	if ( arg1Ptr[0] != '\0' )
    5a98:	7803      	ldrb	r3, [r0, #0]
    5a9a:	b113      	cbz	r3, 5aa2 <cliFunc_outputDebug+0x2a>
	{
		Output_DebugMode = (uint16_t)numToInt( arg1Ptr );
    5a9c:	f003 fec4 	bl	9828 <numToInt>
    5aa0:	7028      	strb	r0, [r5, #0]
	}
}
    5aa2:	9a03      	ldr	r2, [sp, #12]
    5aa4:	6823      	ldr	r3, [r4, #0]
    5aa6:	429a      	cmp	r2, r3
    5aa8:	d001      	beq.n	5aae <cliFunc_outputDebug+0x36>
    5aaa:	f7fb fd3b 	bl	1524 <__stack_chk_fail>
    5aae:	b005      	add	sp, #20
    5ab0:	bd30      	pop	{r4, r5, pc}
    5ab2:	bf00      	nop
    5ab4:	1fffe9d0 	.word	0x1fffe9d0
    5ab8:	20000736 	.word	0x20000736

00005abc <Output_flashMode_capability>:
{
    5abc:	b507      	push	{r0, r1, r2, lr}
    5abe:	4b0e      	ldr	r3, [pc, #56]	; (5af8 <Output_flashMode_capability+0x3c>)
    5ac0:	6818      	ldr	r0, [r3, #0]
    5ac2:	9001      	str	r0, [sp, #4]
	if ( stateType == 0xFF && state == 0xFF )
    5ac4:	2aff      	cmp	r2, #255	; 0xff
    5ac6:	4618      	mov	r0, r3
		print("Output_flashMode()");
    5ac8:	9a01      	ldr	r2, [sp, #4]
	if ( stateType == 0xFF && state == 0xFF )
    5aca:	d10c      	bne.n	5ae6 <Output_flashMode_capability+0x2a>
    5acc:	29ff      	cmp	r1, #255	; 0xff
    5ace:	d10a      	bne.n	5ae6 <Output_flashMode_capability+0x2a>
		print("Output_flashMode()");
    5ad0:	681b      	ldr	r3, [r3, #0]
    5ad2:	429a      	cmp	r2, r3
    5ad4:	d001      	beq.n	5ada <Output_flashMode_capability+0x1e>
	Output_firmwareReload();
    5ad6:	f7fb fd25 	bl	1524 <__stack_chk_fail>
		print("Output_flashMode()");
    5ada:	4808      	ldr	r0, [pc, #32]	; (5afc <Output_flashMode_capability+0x40>)
}
    5adc:	b003      	add	sp, #12
    5ade:	f85d eb04 	ldr.w	lr, [sp], #4
		print("Output_flashMode()");
    5ae2:	f003 bcd1 	b.w	9488 <_print>
	Output_firmwareReload();
    5ae6:	6803      	ldr	r3, [r0, #0]
    5ae8:	429a      	cmp	r2, r3
    5aea:	d1f4      	bne.n	5ad6 <Output_flashMode_capability+0x1a>
}
    5aec:	b003      	add	sp, #12
    5aee:	f85d eb04 	ldr.w	lr, [sp], #4
	Output_firmwareReload();
    5af2:	f000 b8fd 	b.w	5cf0 <Output_firmwareReload>
    5af6:	bf00      	nop
    5af8:	1fffe9d0 	.word	0x1fffe9d0
    5afc:	0000c193 	.word	0x0000c193

00005b00 <OutputGen_setup>:
{
    5b00:	b513      	push	{r0, r1, r4, lr}
    5b02:	4c0c      	ldr	r4, [pc, #48]	; (5b34 <OutputGen_setup+0x34>)
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    5b04:	490c      	ldr	r1, [pc, #48]	; (5b38 <OutputGen_setup+0x38>)
{
    5b06:	6823      	ldr	r3, [r4, #0]
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    5b08:	480c      	ldr	r0, [pc, #48]	; (5b3c <OutputGen_setup+0x3c>)
{
    5b0a:	9301      	str	r3, [sp, #4]
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    5b0c:	f003 f84c 	bl	8ba8 <CLI_registerDictionary>
	Output_Available = 0;
    5b10:	4a0b      	ldr	r2, [pc, #44]	; (5b40 <OutputGen_setup+0x40>)
    5b12:	2300      	movs	r3, #0
    5b14:	7013      	strb	r3, [r2, #0]
	Output_DebugMode = 0;
    5b16:	4a0b      	ldr	r2, [pc, #44]	; (5b44 <OutputGen_setup+0x44>)
    5b18:	7013      	strb	r3, [r2, #0]
	Output_ExtCurrent_Available = 0;
    5b1a:	4a0b      	ldr	r2, [pc, #44]	; (5b48 <OutputGen_setup+0x48>)
    5b1c:	8013      	strh	r3, [r2, #0]
	Output_USBCurrent_Available = 0;
    5b1e:	4a0b      	ldr	r2, [pc, #44]	; (5b4c <OutputGen_setup+0x4c>)
    5b20:	8013      	strh	r3, [r2, #0]
}
    5b22:	9a01      	ldr	r2, [sp, #4]
    5b24:	6823      	ldr	r3, [r4, #0]
    5b26:	429a      	cmp	r2, r3
    5b28:	d001      	beq.n	5b2e <OutputGen_setup+0x2e>
    5b2a:	f7fb fcfb 	bl	1524 <__stack_chk_fail>
    5b2e:	b002      	add	sp, #8
    5b30:	bd10      	pop	{r4, pc}
    5b32:	bf00      	nop
    5b34:	1fffe9d0 	.word	0x1fffe9d0
    5b38:	0000c268 	.word	0x0000c268
    5b3c:	0000c244 	.word	0x0000c244
    5b40:	2000073a 	.word	0x2000073a
    5b44:	20000736 	.word	0x20000736
    5b48:	20000738 	.word	0x20000738
    5b4c:	2000073c 	.word	0x2000073c

00005b50 <Output_current_available>:
{
    5b50:	b507      	push	{r0, r1, r2, lr}
    5b52:	4b09      	ldr	r3, [pc, #36]	; (5b78 <Output_current_available+0x28>)
    5b54:	681a      	ldr	r2, [r3, #0]
    5b56:	9201      	str	r2, [sp, #4]
	total_current += Output_USBCurrent_Available;
    5b58:	4a08      	ldr	r2, [pc, #32]	; (5b7c <Output_current_available+0x2c>)
    5b5a:	8810      	ldrh	r0, [r2, #0]
	total_current += Output_ExtCurrent_Available;
    5b5c:	4a08      	ldr	r2, [pc, #32]	; (5b80 <Output_current_available+0x30>)
    5b5e:	8812      	ldrh	r2, [r2, #0]
		total_current = 100;
    5b60:	1880      	adds	r0, r0, r2
}
    5b62:	9a01      	ldr	r2, [sp, #4]
    5b64:	681b      	ldr	r3, [r3, #0]
    5b66:	bf08      	it	eq
    5b68:	2064      	moveq	r0, #100	; 0x64
    5b6a:	429a      	cmp	r2, r3
    5b6c:	d001      	beq.n	5b72 <Output_current_available+0x22>
    5b6e:	f7fb fcd9 	bl	1524 <__stack_chk_fail>
    5b72:	b003      	add	sp, #12
    5b74:	f85d fb04 	ldr.w	pc, [sp], #4
    5b78:	1fffe9d0 	.word	0x1fffe9d0
    5b7c:	2000073c 	.word	0x2000073c
    5b80:	20000738 	.word	0x20000738

00005b84 <Output_update_usb_current>:
{
    5b84:	b513      	push	{r0, r1, r4, lr}
    5b86:	4c0d      	ldr	r4, [pc, #52]	; (5bbc <Output_update_usb_current+0x38>)
    5b88:	6823      	ldr	r3, [r4, #0]
    5b8a:	9301      	str	r3, [sp, #4]
	if ( current == Output_USBCurrent_Available )
    5b8c:	4b0c      	ldr	r3, [pc, #48]	; (5bc0 <Output_update_usb_current+0x3c>)
    5b8e:	881a      	ldrh	r2, [r3, #0]
    5b90:	4282      	cmp	r2, r0
    5b92:	d00d      	beq.n	5bb0 <Output_update_usb_current+0x2c>
	Output_USBCurrent_Available = current;
    5b94:	8018      	strh	r0, [r3, #0]
	Scan_currentChange( Output_current_available() );
    5b96:	f7ff ffdb 	bl	5b50 <Output_current_available>
    5b9a:	9a01      	ldr	r2, [sp, #4]
    5b9c:	6823      	ldr	r3, [r4, #0]
    5b9e:	429a      	cmp	r2, r3
    5ba0:	d001      	beq.n	5ba6 <Output_update_usb_current+0x22>
}
    5ba2:	f7fb fcbf 	bl	1524 <__stack_chk_fail>
    5ba6:	b002      	add	sp, #8
    5ba8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Scan_currentChange( Output_current_available() );
    5bac:	f7fc be7e 	b.w	28ac <Scan_currentChange>
}
    5bb0:	9a01      	ldr	r2, [sp, #4]
    5bb2:	6823      	ldr	r3, [r4, #0]
    5bb4:	429a      	cmp	r2, r3
    5bb6:	d1f4      	bne.n	5ba2 <Output_update_usb_current+0x1e>
    5bb8:	b002      	add	sp, #8
    5bba:	bd10      	pop	{r4, pc}
    5bbc:	1fffe9d0 	.word	0x1fffe9d0
    5bc0:	2000073c 	.word	0x2000073c

00005bc4 <Output_update_external_current>:
{
    5bc4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    5bc6:	4c13      	ldr	r4, [pc, #76]	; (5c14 <Output_update_external_current+0x50>)
    5bc8:	6823      	ldr	r3, [r4, #0]
    5bca:	9301      	str	r3, [sp, #4]
	if ( current == Output_ExtCurrent_Available )
    5bcc:	4b12      	ldr	r3, [pc, #72]	; (5c18 <Output_update_external_current+0x54>)
    5bce:	881a      	ldrh	r2, [r3, #0]
    5bd0:	4282      	cmp	r2, r0
    5bd2:	d019      	beq.n	5c08 <Output_update_external_current+0x44>
	Output_ExtCurrent_Available = current;
    5bd4:	8018      	strh	r0, [r3, #0]
	unsigned int total_current = Output_current_available();
    5bd6:	f7ff ffbb 	bl	5b50 <Output_current_available>
    5bda:	4605      	mov	r5, r0
	info_msg("External Available Current Changed. Total Available: ");
    5bdc:	480f      	ldr	r0, [pc, #60]	; (5c1c <Output_update_external_current+0x58>)
    5bde:	f003 fc53 	bl	9488 <_print>
	printInt32( total_current );
    5be2:	4628      	mov	r0, r5
    5be4:	f003 fd26 	bl	9634 <printInt32>
	print(" mA" NL);
    5be8:	480d      	ldr	r0, [pc, #52]	; (5c20 <Output_update_external_current+0x5c>)
    5bea:	f003 fc4d 	bl	9488 <_print>
	Scan_currentChange( Output_current_available() );
    5bee:	f7ff ffaf 	bl	5b50 <Output_current_available>
    5bf2:	9a01      	ldr	r2, [sp, #4]
    5bf4:	6823      	ldr	r3, [r4, #0]
    5bf6:	429a      	cmp	r2, r3
    5bf8:	d001      	beq.n	5bfe <Output_update_external_current+0x3a>
}
    5bfa:	f7fb fc93 	bl	1524 <__stack_chk_fail>
    5bfe:	b003      	add	sp, #12
    5c00:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	Scan_currentChange( Output_current_available() );
    5c04:	f7fc be52 	b.w	28ac <Scan_currentChange>
}
    5c08:	9a01      	ldr	r2, [sp, #4]
    5c0a:	6823      	ldr	r3, [r4, #0]
    5c0c:	429a      	cmp	r2, r3
    5c0e:	d1f4      	bne.n	5bfa <Output_update_external_current+0x36>
    5c10:	b003      	add	sp, #12
    5c12:	bd30      	pop	{r4, r5, pc}
    5c14:	1fffe9d0 	.word	0x1fffe9d0
    5c18:	20000738 	.word	0x20000738
    5c1c:	0000c1a6 	.word	0x0000c1a6
    5c20:	0000c1ee 	.word	0x0000c1ee

00005c24 <cliFunc_current>:
{
    5c24:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    5c26:	4c12      	ldr	r4, [pc, #72]	; (5c70 <cliFunc_current+0x4c>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5c28:	aa02      	add	r2, sp, #8
{
    5c2a:	6823      	ldr	r3, [r4, #0]
    5c2c:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5c2e:	a901      	add	r1, sp, #4
    5c30:	f002 fefc 	bl	8a2c <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    5c34:	9801      	ldr	r0, [sp, #4]
    5c36:	7803      	ldrb	r3, [r0, #0]
    5c38:	b11b      	cbz	r3, 5c42 <cliFunc_current+0x1e>
		Output_update_external_current( (unsigned int)numToInt( arg1Ptr ) );
    5c3a:	f003 fdf5 	bl	9828 <numToInt>
    5c3e:	f7ff ffc1 	bl	5bc4 <Output_update_external_current>
	print( NL );
    5c42:	480c      	ldr	r0, [pc, #48]	; (5c74 <cliFunc_current+0x50>)
    5c44:	f003 fc20 	bl	9488 <_print>
	info_msg("Current available: ");
    5c48:	480b      	ldr	r0, [pc, #44]	; (5c78 <cliFunc_current+0x54>)
    5c4a:	f003 fc1d 	bl	9488 <_print>
	printInt16( Output_current_available() );
    5c4e:	f7ff ff7f 	bl	5b50 <Output_current_available>
    5c52:	b280      	uxth	r0, r0
    5c54:	f003 fcb8 	bl	95c8 <printInt16>
	print(" mA");
    5c58:	4808      	ldr	r0, [pc, #32]	; (5c7c <cliFunc_current+0x58>)
    5c5a:	f003 fc15 	bl	9488 <_print>
}
    5c5e:	9a03      	ldr	r2, [sp, #12]
    5c60:	6823      	ldr	r3, [r4, #0]
    5c62:	429a      	cmp	r2, r3
    5c64:	d001      	beq.n	5c6a <cliFunc_current+0x46>
    5c66:	f7fb fc5d 	bl	1524 <__stack_chk_fail>
    5c6a:	b004      	add	sp, #16
    5c6c:	bd10      	pop	{r4, pc}
    5c6e:	bf00      	nop
    5c70:	1fffe9d0 	.word	0x1fffe9d0
    5c74:	0000d348 	.word	0x0000d348
    5c78:	0000c1f4 	.word	0x0000c1f4
    5c7c:	0000c21a 	.word	0x0000c21a

00005c80 <Output_setup>:

// ----- Functions -----

// Output Module Setup
inline void Output_setup()
{
    5c80:	b513      	push	{r0, r1, r4, lr}
    5c82:	4c08      	ldr	r4, [pc, #32]	; (5ca4 <Output_setup+0x24>)
    5c84:	6823      	ldr	r3, [r4, #0]
    5c86:	9301      	str	r3, [sp, #4]
	// Initialize Interface module
	OutputGen_setup();
    5c88:	f7ff ff3a 	bl	5b00 <OutputGen_setup>

	// Initialize the USB module
	USB_setup();
    5c8c:	9a01      	ldr	r2, [sp, #4]
    5c8e:	6823      	ldr	r3, [r4, #0]
    5c90:	429a      	cmp	r2, r3
    5c92:	d001      	beq.n	5c98 <Output_setup+0x18>
    5c94:	f7fb fc46 	bl	1524 <__stack_chk_fail>
}
    5c98:	b002      	add	sp, #8
    5c9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USB_setup();
    5c9e:	f000 bcf5 	b.w	668c <USB_setup>
    5ca2:	bf00      	nop
    5ca4:	1fffe9d0 	.word	0x1fffe9d0

00005ca8 <Output_poll>:


// Output Module Data Poll
inline void Output_poll()
{
    5ca8:	b507      	push	{r0, r1, r2, lr}
    5caa:	4b07      	ldr	r3, [pc, #28]	; (5cc8 <Output_poll+0x20>)
    5cac:	681a      	ldr	r2, [r3, #0]
    5cae:	9201      	str	r2, [sp, #4]
	USB_poll();
    5cb0:	9a01      	ldr	r2, [sp, #4]
    5cb2:	681b      	ldr	r3, [r3, #0]
    5cb4:	429a      	cmp	r2, r3
    5cb6:	d001      	beq.n	5cbc <Output_poll+0x14>
    5cb8:	f7fb fc34 	bl	1524 <__stack_chk_fail>
}
    5cbc:	b003      	add	sp, #12
    5cbe:	f85d eb04 	ldr.w	lr, [sp], #4
	USB_poll();
    5cc2:	f000 bd41 	b.w	6748 <USB_poll>
    5cc6:	bf00      	nop
    5cc8:	1fffe9d0 	.word	0x1fffe9d0

00005ccc <Output_periodic>:


// Output Module Data Periodic
inline void Output_periodic()
{
    5ccc:	b507      	push	{r0, r1, r2, lr}
    5cce:	4b07      	ldr	r3, [pc, #28]	; (5cec <Output_periodic+0x20>)
    5cd0:	681a      	ldr	r2, [r3, #0]
    5cd2:	9201      	str	r2, [sp, #4]
	USB_periodic();
    5cd4:	9a01      	ldr	r2, [sp, #4]
    5cd6:	681b      	ldr	r3, [r3, #0]
    5cd8:	429a      	cmp	r2, r3
    5cda:	d001      	beq.n	5ce0 <Output_periodic+0x14>
    5cdc:	f7fb fc22 	bl	1524 <__stack_chk_fail>
}
    5ce0:	b003      	add	sp, #12
    5ce2:	f85d eb04 	ldr.w	lr, [sp], #4
	USB_periodic();
    5ce6:	f000 bd95 	b.w	6814 <USB_periodic>
    5cea:	bf00      	nop
    5cec:	1fffe9d0 	.word	0x1fffe9d0

00005cf0 <Output_firmwareReload>:


// Sets the device into firmware reload mode
inline void Output_firmwareReload()
{
    5cf0:	b507      	push	{r0, r1, r2, lr}
    5cf2:	4b07      	ldr	r3, [pc, #28]	; (5d10 <Output_firmwareReload+0x20>)
    5cf4:	681a      	ldr	r2, [r3, #0]
    5cf6:	9201      	str	r2, [sp, #4]
	USB_firmwareReload();
    5cf8:	9a01      	ldr	r2, [sp, #4]
    5cfa:	681b      	ldr	r3, [r3, #0]
    5cfc:	429a      	cmp	r2, r3
    5cfe:	d001      	beq.n	5d04 <Output_firmwareReload+0x14>
    5d00:	f7fb fc10 	bl	1524 <__stack_chk_fail>
}
    5d04:	b003      	add	sp, #12
    5d06:	f85d eb04 	ldr.w	lr, [sp], #4
	USB_firmwareReload();
    5d0a:	f000 bea7 	b.w	6a5c <USB_firmwareReload>
    5d0e:	bf00      	nop
    5d10:	1fffe9d0 	.word	0x1fffe9d0

00005d14 <Output_softReset>:


// Soft Chip Reset
inline void Output_softReset()
{
    5d14:	b507      	push	{r0, r1, r2, lr}
    5d16:	4b07      	ldr	r3, [pc, #28]	; (5d34 <Output_softReset+0x20>)
    5d18:	681a      	ldr	r2, [r3, #0]
    5d1a:	9201      	str	r2, [sp, #4]
	USB_softReset();
    5d1c:	9a01      	ldr	r2, [sp, #4]
    5d1e:	681b      	ldr	r3, [r3, #0]
    5d20:	429a      	cmp	r2, r3
    5d22:	d001      	beq.n	5d28 <Output_softReset+0x14>
    5d24:	f7fb fbfe 	bl	1524 <__stack_chk_fail>
}
    5d28:	b003      	add	sp, #12
    5d2a:	f85d eb04 	ldr.w	lr, [sp], #4
	USB_softReset();
    5d2e:	f000 bea7 	b.w	6a80 <USB_softReset>
    5d32:	bf00      	nop
    5d34:	1fffe9d0 	.word	0x1fffe9d0

00005d38 <Output_availablechar>:


// USB Input buffer available
inline unsigned int Output_availablechar()
{
    5d38:	b507      	push	{r0, r1, r2, lr}
    5d3a:	4b07      	ldr	r3, [pc, #28]	; (5d58 <Output_availablechar+0x20>)
    5d3c:	681a      	ldr	r2, [r3, #0]
    5d3e:	9201      	str	r2, [sp, #4]
	return USB_availablechar();
    5d40:	9a01      	ldr	r2, [sp, #4]
    5d42:	681b      	ldr	r3, [r3, #0]
    5d44:	429a      	cmp	r2, r3
    5d46:	d001      	beq.n	5d4c <Output_availablechar+0x14>
    5d48:	f7fb fbec 	bl	1524 <__stack_chk_fail>
}
    5d4c:	b003      	add	sp, #12
    5d4e:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_availablechar();
    5d52:	f000 beab 	b.w	6aac <USB_availablechar>
    5d56:	bf00      	nop
    5d58:	1fffe9d0 	.word	0x1fffe9d0

00005d5c <Output_getchar>:


// USB Get Character from input buffer
inline int Output_getchar()
{
    5d5c:	b507      	push	{r0, r1, r2, lr}
    5d5e:	4b07      	ldr	r3, [pc, #28]	; (5d7c <Output_getchar+0x20>)
    5d60:	681a      	ldr	r2, [r3, #0]
    5d62:	9201      	str	r2, [sp, #4]
	return USB_getchar();
    5d64:	9a01      	ldr	r2, [sp, #4]
    5d66:	681b      	ldr	r3, [r3, #0]
    5d68:	429a      	cmp	r2, r3
    5d6a:	d001      	beq.n	5d70 <Output_getchar+0x14>
    5d6c:	f7fb fbda 	bl	1524 <__stack_chk_fail>
}
    5d70:	b003      	add	sp, #12
    5d72:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_getchar();
    5d76:	f000 beab 	b.w	6ad0 <USB_getchar>
    5d7a:	bf00      	nop
    5d7c:	1fffe9d0 	.word	0x1fffe9d0

00005d80 <Output_putstr>:
}


// USB Send String to output buffer, null terminated
inline int Output_putstr( char* str )
{
    5d80:	b507      	push	{r0, r1, r2, lr}
    5d82:	4b07      	ldr	r3, [pc, #28]	; (5da0 <Output_putstr+0x20>)
    5d84:	681a      	ldr	r2, [r3, #0]
    5d86:	9201      	str	r2, [sp, #4]
	return USB_putstr( str );
    5d88:	9a01      	ldr	r2, [sp, #4]
    5d8a:	681b      	ldr	r3, [r3, #0]
    5d8c:	429a      	cmp	r2, r3
    5d8e:	d001      	beq.n	5d94 <Output_putstr+0x14>
    5d90:	f7fb fbc8 	bl	1524 <__stack_chk_fail>
}
    5d94:	b003      	add	sp, #12
    5d96:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_putstr( str );
    5d9a:	f000 beab 	b.w	6af4 <USB_putstr>
    5d9e:	bf00      	nop
    5da0:	1fffe9d0 	.word	0x1fffe9d0

00005da4 <Output_rawio_availablechar>:


// USB RawIO buffer available
unsigned int Output_rawio_availablechar()
{
    5da4:	b507      	push	{r0, r1, r2, lr}
    5da6:	4b07      	ldr	r3, [pc, #28]	; (5dc4 <Output_rawio_availablechar+0x20>)
    5da8:	681a      	ldr	r2, [r3, #0]
    5daa:	9201      	str	r2, [sp, #4]
	return USB_rawio_availablechar();
    5dac:	9a01      	ldr	r2, [sp, #4]
    5dae:	681b      	ldr	r3, [r3, #0]
    5db0:	429a      	cmp	r2, r3
    5db2:	d001      	beq.n	5db8 <Output_rawio_availablechar+0x14>
    5db4:	f7fb fbb6 	bl	1524 <__stack_chk_fail>
}
    5db8:	b003      	add	sp, #12
    5dba:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_rawio_availablechar();
    5dbe:	f000 beb1 	b.w	6b24 <USB_rawio_availablechar>
    5dc2:	bf00      	nop
    5dc4:	1fffe9d0 	.word	0x1fffe9d0

00005dc8 <Output_rawio_getbuffer>:


// USB RawIO get buffer
int Output_rawio_getbuffer( char* buffer )
{
    5dc8:	b507      	push	{r0, r1, r2, lr}
    5dca:	4b07      	ldr	r3, [pc, #28]	; (5de8 <Output_rawio_getbuffer+0x20>)
    5dcc:	681a      	ldr	r2, [r3, #0]
    5dce:	9201      	str	r2, [sp, #4]
	return USB_rawio_getbuffer( buffer );
    5dd0:	9a01      	ldr	r2, [sp, #4]
    5dd2:	681b      	ldr	r3, [r3, #0]
    5dd4:	429a      	cmp	r2, r3
    5dd6:	d001      	beq.n	5ddc <Output_rawio_getbuffer+0x14>
    5dd8:	f7fb fba4 	bl	1524 <__stack_chk_fail>
}
    5ddc:	b003      	add	sp, #12
    5dde:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_rawio_getbuffer( buffer );
    5de2:	f000 beb1 	b.w	6b48 <USB_rawio_getbuffer>
    5de6:	bf00      	nop
    5de8:	1fffe9d0 	.word	0x1fffe9d0

00005dec <Output_rawio_sendbuffer>:


// USB RawIO send buffer
int Output_rawio_sendbuffer( char* buffer )
{
    5dec:	b507      	push	{r0, r1, r2, lr}
    5dee:	4b07      	ldr	r3, [pc, #28]	; (5e0c <Output_rawio_sendbuffer+0x20>)
    5df0:	681a      	ldr	r2, [r3, #0]
    5df2:	9201      	str	r2, [sp, #4]
	return USB_rawio_sendbuffer( buffer );
    5df4:	9a01      	ldr	r2, [sp, #4]
    5df6:	681b      	ldr	r3, [r3, #0]
    5df8:	429a      	cmp	r2, r3
    5dfa:	d001      	beq.n	5e00 <Output_rawio_sendbuffer+0x14>
    5dfc:	f7fb fb92 	bl	1524 <__stack_chk_fail>
}
    5e00:	b003      	add	sp, #12
    5e02:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_rawio_sendbuffer( buffer );
    5e06:	f000 beb1 	b.w	6b6c <USB_rawio_sendbuffer>
    5e0a:	bf00      	nop
    5e0c:	1fffe9d0 	.word	0x1fffe9d0

00005e10 <cliFunc_readLEDs>:
	}
}


void cliFunc_readLEDs( char* args )
{
    5e10:	b513      	push	{r0, r1, r4, lr}
    5e12:	4c0b      	ldr	r4, [pc, #44]	; (5e40 <cliFunc_readLEDs+0x30>)
	print( NL );
    5e14:	480b      	ldr	r0, [pc, #44]	; (5e44 <cliFunc_readLEDs+0x34>)
{
    5e16:	6823      	ldr	r3, [r4, #0]
    5e18:	9301      	str	r3, [sp, #4]
	print( NL );
    5e1a:	f003 fb35 	bl	9488 <_print>
	info_msg("LED State: ");
    5e1e:	480a      	ldr	r0, [pc, #40]	; (5e48 <cliFunc_readLEDs+0x38>)
    5e20:	f003 fb32 	bl	9488 <_print>
	printInt8( USBKeys_LEDs );
    5e24:	4b09      	ldr	r3, [pc, #36]	; (5e4c <cliFunc_readLEDs+0x3c>)
    5e26:	7818      	ldrb	r0, [r3, #0]
    5e28:	9a01      	ldr	r2, [sp, #4]
    5e2a:	6823      	ldr	r3, [r4, #0]
    5e2c:	429a      	cmp	r2, r3
    5e2e:	b2c0      	uxtb	r0, r0
    5e30:	d001      	beq.n	5e36 <cliFunc_readLEDs+0x26>
    5e32:	f7fb fb77 	bl	1524 <__stack_chk_fail>
}
    5e36:	b002      	add	sp, #8
    5e38:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( USBKeys_LEDs );
    5e3c:	f003 bb8e 	b.w	955c <printInt8>
    5e40:	1fffe9d0 	.word	0x1fffe9d0
    5e44:	0000d348 	.word	0x0000d348
    5e48:	0000c719 	.word	0x0000c719
    5e4c:	2000079b 	.word	0x2000079b

00005e50 <cliFunc_usbAddr>:


void cliFunc_usbAddr( char* args )
{
    5e50:	b513      	push	{r0, r1, r4, lr}
    5e52:	4c0b      	ldr	r4, [pc, #44]	; (5e80 <cliFunc_usbAddr+0x30>)
	print(NL);
    5e54:	480b      	ldr	r0, [pc, #44]	; (5e84 <cliFunc_usbAddr+0x34>)
{
    5e56:	6823      	ldr	r3, [r4, #0]
    5e58:	9301      	str	r3, [sp, #4]
	print(NL);
    5e5a:	f003 fb15 	bl	9488 <_print>
	info_msg("USB Address: ");
    5e5e:	480a      	ldr	r0, [pc, #40]	; (5e88 <cliFunc_usbAddr+0x38>)
    5e60:	f003 fb12 	bl	9488 <_print>
	printInt8( USBDev_Address );
    5e64:	4b09      	ldr	r3, [pc, #36]	; (5e8c <cliFunc_usbAddr+0x3c>)
    5e66:	7818      	ldrb	r0, [r3, #0]
    5e68:	9a01      	ldr	r2, [sp, #4]
    5e6a:	6823      	ldr	r3, [r4, #0]
    5e6c:	429a      	cmp	r2, r3
    5e6e:	b2c0      	uxtb	r0, r0
    5e70:	d001      	beq.n	5e76 <cliFunc_usbAddr+0x26>
    5e72:	f7fb fb57 	bl	1524 <__stack_chk_fail>
}
    5e76:	b002      	add	sp, #8
    5e78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( USBDev_Address );
    5e7c:	f003 bb6e 	b.w	955c <printInt8>
    5e80:	1fffe9d0 	.word	0x1fffe9d0
    5e84:	0000d348 	.word	0x0000d348
    5e88:	0000c737 	.word	0x0000c737
    5e8c:	20000772 	.word	0x20000772

00005e90 <cliFunc_idle>:
{
    5e90:	b530      	push	{r4, r5, lr}
    5e92:	4c15      	ldr	r4, [pc, #84]	; (5ee8 <cliFunc_idle+0x58>)
    5e94:	b085      	sub	sp, #20
    5e96:	6823      	ldr	r3, [r4, #0]
    5e98:	9303      	str	r3, [sp, #12]
    5e9a:	4605      	mov	r5, r0
	print( NL );
    5e9c:	4813      	ldr	r0, [pc, #76]	; (5eec <cliFunc_idle+0x5c>)
    5e9e:	f003 faf3 	bl	9488 <_print>
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5ea2:	4628      	mov	r0, r5
    5ea4:	aa02      	add	r2, sp, #8
    5ea6:	a901      	add	r1, sp, #4
    5ea8:	f002 fdc0 	bl	8a2c <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    5eac:	9801      	ldr	r0, [sp, #4]
    5eae:	4d10      	ldr	r5, [pc, #64]	; (5ef0 <cliFunc_idle+0x60>)
    5eb0:	7803      	ldrb	r3, [r0, #0]
    5eb2:	b11b      	cbz	r3, 5ebc <cliFunc_idle+0x2c>
		uint8_t idle = (uint8_t)numToInt( arg1Ptr );
    5eb4:	f003 fcb8 	bl	9828 <numToInt>
    5eb8:	b2c0      	uxtb	r0, r0
		USBKeys_Idle_Config = idle;
    5eba:	7028      	strb	r0, [r5, #0]
	info_msg("USB Idle Config: ");
    5ebc:	480d      	ldr	r0, [pc, #52]	; (5ef4 <cliFunc_idle+0x64>)
    5ebe:	f003 fae3 	bl	9488 <_print>
	printInt16( 4 * USBKeys_Idle_Config );
    5ec2:	7828      	ldrb	r0, [r5, #0]
    5ec4:	0080      	lsls	r0, r0, #2
    5ec6:	f003 fb7f 	bl	95c8 <printInt16>
	print(" ms - ");
    5eca:	480b      	ldr	r0, [pc, #44]	; (5ef8 <cliFunc_idle+0x68>)
    5ecc:	f003 fadc 	bl	9488 <_print>
	printInt8( USBKeys_Idle_Config );
    5ed0:	7828      	ldrb	r0, [r5, #0]
    5ed2:	f003 fb43 	bl	955c <printInt8>
}
    5ed6:	9a03      	ldr	r2, [sp, #12]
    5ed8:	6823      	ldr	r3, [r4, #0]
    5eda:	429a      	cmp	r2, r3
    5edc:	d001      	beq.n	5ee2 <cliFunc_idle+0x52>
    5ede:	f7fb fb21 	bl	1524 <__stack_chk_fail>
    5ee2:	b005      	add	sp, #20
    5ee4:	bd30      	pop	{r4, r5, pc}
    5ee6:	bf00      	nop
    5ee8:	1fffe9d0 	.word	0x1fffe9d0
    5eec:	0000d348 	.word	0x0000d348
    5ef0:	1ffff463 	.word	0x1ffff463
    5ef4:	0000c697 	.word	0x0000c697
    5ef8:	0000c6bb 	.word	0x0000c6bb

00005efc <cliFunc_usbConf>:


void cliFunc_usbConf( char* args )
{
    5efc:	b513      	push	{r0, r1, r4, lr}
    5efe:	4c0b      	ldr	r4, [pc, #44]	; (5f2c <cliFunc_usbConf+0x30>)
	print(NL);
    5f00:	480b      	ldr	r0, [pc, #44]	; (5f30 <cliFunc_usbConf+0x34>)
{
    5f02:	6823      	ldr	r3, [r4, #0]
    5f04:	9301      	str	r3, [sp, #4]
	print(NL);
    5f06:	f003 fabf 	bl	9488 <_print>
	info_msg("USB Configured: ");
    5f0a:	480a      	ldr	r0, [pc, #40]	; (5f34 <cliFunc_usbConf+0x38>)
    5f0c:	f003 fabc 	bl	9488 <_print>
#if !defined(_host_)
	printInt8( usb_configured() );
    5f10:	f001 fd94 	bl	7a3c <usb_configured>
    5f14:	9a01      	ldr	r2, [sp, #4]
    5f16:	6823      	ldr	r3, [r4, #0]
    5f18:	429a      	cmp	r2, r3
    5f1a:	d001      	beq.n	5f20 <cliFunc_usbConf+0x24>
    5f1c:	f7fb fb02 	bl	1524 <__stack_chk_fail>
#endif
}
    5f20:	b002      	add	sp, #8
    5f22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( usb_configured() );
    5f26:	f003 bb19 	b.w	955c <printInt8>
    5f2a:	bf00      	nop
    5f2c:	1fffe9d0 	.word	0x1fffe9d0
    5f30:	0000d348 	.word	0x0000d348
    5f34:	0000c757 	.word	0x0000c757

00005f38 <cliFunc_usbInitTime>:


void cliFunc_usbInitTime( char* args )
{
    5f38:	b513      	push	{r0, r1, r4, lr}
    5f3a:	4c11      	ldr	r4, [pc, #68]	; (5f80 <cliFunc_usbInitTime+0x48>)
	// Calculate overall USB initialization time
	// XXX A protocol analyzer will be more accurate, however, this is built-in and easier to collect data
	print(NL);
    5f3c:	4811      	ldr	r0, [pc, #68]	; (5f84 <cliFunc_usbInitTime+0x4c>)
{
    5f3e:	6823      	ldr	r3, [r4, #0]
    5f40:	9301      	str	r3, [sp, #4]
	print(NL);
    5f42:	f003 faa1 	bl	9488 <_print>
	info_msg("USB Init Time: ");
    5f46:	4810      	ldr	r0, [pc, #64]	; (5f88 <cliFunc_usbInitTime+0x50>)
    5f48:	f003 fa9e 	bl	9488 <_print>
	printInt32( USBInit_TimeEnd - USBInit_TimeStart );
    5f4c:	4b0f      	ldr	r3, [pc, #60]	; (5f8c <cliFunc_usbInitTime+0x54>)
    5f4e:	6818      	ldr	r0, [r3, #0]
    5f50:	4b0f      	ldr	r3, [pc, #60]	; (5f90 <cliFunc_usbInitTime+0x58>)
    5f52:	681b      	ldr	r3, [r3, #0]
    5f54:	1ac0      	subs	r0, r0, r3
    5f56:	f003 fb6d 	bl	9634 <printInt32>
	print(" ms - ");
    5f5a:	480e      	ldr	r0, [pc, #56]	; (5f94 <cliFunc_usbInitTime+0x5c>)
    5f5c:	f003 fa94 	bl	9488 <_print>
	printInt16( USBInit_Ticks );
    5f60:	4b0d      	ldr	r3, [pc, #52]	; (5f98 <cliFunc_usbInitTime+0x60>)
    5f62:	8818      	ldrh	r0, [r3, #0]
    5f64:	f003 fb30 	bl	95c8 <printInt16>
	print(" ticks");
    5f68:	9a01      	ldr	r2, [sp, #4]
    5f6a:	6823      	ldr	r3, [r4, #0]
    5f6c:	429a      	cmp	r2, r3
    5f6e:	d001      	beq.n	5f74 <cliFunc_usbInitTime+0x3c>
    5f70:	f7fb fad8 	bl	1524 <__stack_chk_fail>
    5f74:	4809      	ldr	r0, [pc, #36]	; (5f9c <cliFunc_usbInitTime+0x64>)
}
    5f76:	b002      	add	sp, #8
    5f78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print(" ticks");
    5f7c:	f003 ba84 	b.w	9488 <_print>
    5f80:	1fffe9d0 	.word	0x1fffe9d0
    5f84:	0000d348 	.word	0x0000d348
    5f88:	0000c77a 	.word	0x0000c77a
    5f8c:	20000744 	.word	0x20000744
    5f90:	200007a4 	.word	0x200007a4
    5f94:	0000c6bb 	.word	0x0000c6bb
    5f98:	2000074e 	.word	0x2000074e
    5f9c:	0000c79c 	.word	0x0000c79c

00005fa0 <cliFunc_kbdProtocol>:
{
    5fa0:	b530      	push	{r4, r5, lr}
    5fa2:	4c15      	ldr	r4, [pc, #84]	; (5ff8 <cliFunc_kbdProtocol+0x58>)
    5fa4:	b085      	sub	sp, #20
    5fa6:	6823      	ldr	r3, [r4, #0]
    5fa8:	9303      	str	r3, [sp, #12]
    5faa:	4605      	mov	r5, r0
	print( NL );
    5fac:	4813      	ldr	r0, [pc, #76]	; (5ffc <cliFunc_kbdProtocol+0x5c>)
    5fae:	f003 fa6b 	bl	9488 <_print>
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5fb2:	4628      	mov	r0, r5
    5fb4:	aa02      	add	r2, sp, #8
    5fb6:	a901      	add	r1, sp, #4
    5fb8:	f002 fd38 	bl	8a2c <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    5fbc:	9801      	ldr	r0, [sp, #4]
    5fbe:	7803      	ldrb	r3, [r0, #0]
    5fc0:	b1b3      	cbz	r3, 5ff0 <cliFunc_kbdProtocol+0x50>
		uint8_t mode = (uint8_t)numToInt( arg1Ptr );
    5fc2:	f003 fc31 	bl	9828 <numToInt>
    5fc6:	b2c0      	uxtb	r0, r0
		if ( mode == 0 || mode == 1 )
    5fc8:	2801      	cmp	r0, #1
    5fca:	d80b      	bhi.n	5fe4 <cliFunc_kbdProtocol+0x44>
			USBKeys_Protocol_New = mode;
    5fcc:	4b0c      	ldr	r3, [pc, #48]	; (6000 <cliFunc_kbdProtocol+0x60>)
    5fce:	7018      	strb	r0, [r3, #0]
			USBKeys_Protocol_Change = 1;
    5fd0:	4b0c      	ldr	r3, [pc, #48]	; (6004 <cliFunc_kbdProtocol+0x64>)
			info_msg("Setting Keyboard Protocol to: ");
    5fd2:	480d      	ldr	r0, [pc, #52]	; (6008 <cliFunc_kbdProtocol+0x68>)
			USBKeys_Protocol_Change = 1;
    5fd4:	2201      	movs	r2, #1
    5fd6:	701a      	strb	r2, [r3, #0]
		info_msg("Keyboard Protocol: ");
    5fd8:	f003 fa56 	bl	9488 <_print>
		printInt8( USBKeys_Protocol );
    5fdc:	4b0b      	ldr	r3, [pc, #44]	; (600c <cliFunc_kbdProtocol+0x6c>)
    5fde:	7818      	ldrb	r0, [r3, #0]
    5fe0:	f003 fabc 	bl	955c <printInt8>
}
    5fe4:	9a03      	ldr	r2, [sp, #12]
    5fe6:	6823      	ldr	r3, [r4, #0]
    5fe8:	429a      	cmp	r2, r3
    5fea:	d003      	beq.n	5ff4 <cliFunc_kbdProtocol+0x54>
    5fec:	f7fb fa9a 	bl	1524 <__stack_chk_fail>
		info_msg("Keyboard Protocol: ");
    5ff0:	4807      	ldr	r0, [pc, #28]	; (6010 <cliFunc_kbdProtocol+0x70>)
    5ff2:	e7f1      	b.n	5fd8 <cliFunc_kbdProtocol+0x38>
}
    5ff4:	b005      	add	sp, #20
    5ff6:	bd30      	pop	{r4, r5, pc}
    5ff8:	1fffe9d0 	.word	0x1fffe9d0
    5ffc:	0000d348 	.word	0x0000d348
    6000:	1fffeba9 	.word	0x1fffeba9
    6004:	200007a0 	.word	0x200007a0
    6008:	0000c6c2 	.word	0x0000c6c2
    600c:	1fffeba8 	.word	0x1fffeba8
    6010:	0000c6f3 	.word	0x0000c6f3

00006014 <Output_consCtrlSend_capability>:
{
    6014:	b573      	push	{r0, r1, r4, r5, r6, lr}
    6016:	4d20      	ldr	r5, [pc, #128]	; (6098 <Output_consCtrlSend_capability+0x84>)
    6018:	4608      	mov	r0, r1
    601a:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    601c:	4611      	mov	r1, r2
{
    601e:	682b      	ldr	r3, [r5, #0]
    6020:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6022:	f7fc fc81 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    6026:	2802      	cmp	r0, #2
    6028:	462e      	mov	r6, r5
    602a:	d025      	beq.n	6078 <Output_consCtrlSend_capability+0x64>
    602c:	d807      	bhi.n	603e <Output_consCtrlSend_capability+0x2a>
    602e:	2801      	cmp	r0, #1
    6030:	d018      	beq.n	6064 <Output_consCtrlSend_capability+0x50>
}
    6032:	9a01      	ldr	r2, [sp, #4]
    6034:	6833      	ldr	r3, [r6, #0]
    6036:	429a      	cmp	r2, r3
    6038:	d112      	bne.n	6060 <Output_consCtrlSend_capability+0x4c>
    603a:	b002      	add	sp, #8
    603c:	bd70      	pop	{r4, r5, r6, pc}
	switch ( cstate )
    603e:	2803      	cmp	r0, #3
    6040:	d017      	beq.n	6072 <Output_consCtrlSend_capability+0x5e>
    6042:	28ff      	cmp	r0, #255	; 0xff
    6044:	d1f5      	bne.n	6032 <Output_consCtrlSend_capability+0x1e>
		print("Output_consCtrlSend(consCode)");
    6046:	4815      	ldr	r0, [pc, #84]	; (609c <Output_consCtrlSend_capability+0x88>)
    6048:	f003 fa1e 	bl	9488 <_print>
		if ( args != 0 )
    604c:	2c00      	cmp	r4, #0
    604e:	d0f0      	beq.n	6032 <Output_consCtrlSend_capability+0x1e>
			print(" -> ");
    6050:	4813      	ldr	r0, [pc, #76]	; (60a0 <Output_consCtrlSend_capability+0x8c>)
			uint16_t key = *(uint16_t*)(&args[0]);
    6052:	8824      	ldrh	r4, [r4, #0]
			print(" -> ");
    6054:	f003 fa18 	bl	9488 <_print>
			printInt16( key );
    6058:	9a01      	ldr	r2, [sp, #4]
    605a:	682b      	ldr	r3, [r5, #0]
    605c:	429a      	cmp	r2, r3
    605e:	d015      	beq.n	608c <Output_consCtrlSend_capability+0x78>
}
    6060:	f7fb fa60 	bl	1524 <__stack_chk_fail>
		USBKeys_primary.changed |= USBKeyChangeState_Consumer;
    6064:	4a0f      	ldr	r2, [pc, #60]	; (60a4 <Output_consCtrlSend_capability+0x90>)
    6066:	f892 3020 	ldrb.w	r3, [r2, #32]
    606a:	f043 0308 	orr.w	r3, r3, #8
    606e:	f882 3020 	strb.w	r3, [r2, #32]
	USBKeys_primary.cons_ctrl = *(uint16_t*)(&args[0]);
    6072:	8822      	ldrh	r2, [r4, #0]
    6074:	4b0b      	ldr	r3, [pc, #44]	; (60a4 <Output_consCtrlSend_capability+0x90>)
    6076:	e007      	b.n	6088 <Output_consCtrlSend_capability+0x74>
		USBKeys_primary.changed |= USBKeyChangeState_Consumer;
    6078:	4b0a      	ldr	r3, [pc, #40]	; (60a4 <Output_consCtrlSend_capability+0x90>)
    607a:	f893 2020 	ldrb.w	r2, [r3, #32]
    607e:	f042 0208 	orr.w	r2, r2, #8
    6082:	f883 2020 	strb.w	r2, [r3, #32]
		USBKeys_primary.cons_ctrl = 0;
    6086:	2200      	movs	r2, #0
	USBKeys_primary.cons_ctrl = *(uint16_t*)(&args[0]);
    6088:	83da      	strh	r2, [r3, #30]
    608a:	e7d2      	b.n	6032 <Output_consCtrlSend_capability+0x1e>
			printInt16( key );
    608c:	4620      	mov	r0, r4
}
    608e:	b002      	add	sp, #8
    6090:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    6094:	f003 ba98 	b.w	95c8 <printInt16>
    6098:	1fffe9d0 	.word	0x1fffe9d0
    609c:	0000c46b 	.word	0x0000c46b
    60a0:	00009ed1 	.word	0x00009ed1
    60a4:	20000776 	.word	0x20000776

000060a8 <Output_noneSend_capability>:
{
    60a8:	b513      	push	{r0, r1, r4, lr}
    60aa:	4c0c      	ldr	r4, [pc, #48]	; (60dc <Output_noneSend_capability+0x34>)
    60ac:	4608      	mov	r0, r1
    60ae:	6823      	ldr	r3, [r4, #0]
    60b0:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    60b2:	4611      	mov	r1, r2
    60b4:	f7fc fc38 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    60b8:	28ff      	cmp	r0, #255	; 0xff
		print("Output_noneSend()");
    60ba:	9a01      	ldr	r2, [sp, #4]
    60bc:	6823      	ldr	r3, [r4, #0]
	switch ( cstate )
    60be:	d109      	bne.n	60d4 <Output_noneSend_capability+0x2c>
		print("Output_noneSend()");
    60c0:	429a      	cmp	r2, r3
    60c2:	d001      	beq.n	60c8 <Output_noneSend_capability+0x20>
}
    60c4:	f7fb fa2e 	bl	1524 <__stack_chk_fail>
		print("Output_noneSend()");
    60c8:	4805      	ldr	r0, [pc, #20]	; (60e0 <Output_noneSend_capability+0x38>)
}
    60ca:	b002      	add	sp, #8
    60cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		print("Output_noneSend()");
    60d0:	f003 b9da 	b.w	9488 <_print>
}
    60d4:	429a      	cmp	r2, r3
    60d6:	d1f5      	bne.n	60c4 <Output_noneSend_capability+0x1c>
    60d8:	b002      	add	sp, #8
    60da:	bd10      	pop	{r4, pc}
    60dc:	1fffe9d0 	.word	0x1fffe9d0
    60e0:	0000c4bb 	.word	0x0000c4bb

000060e4 <Output_sysCtrlSend_capability>:
{
    60e4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    60e6:	4d20      	ldr	r5, [pc, #128]	; (6168 <Output_sysCtrlSend_capability+0x84>)
    60e8:	4608      	mov	r0, r1
    60ea:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    60ec:	4611      	mov	r1, r2
{
    60ee:	682b      	ldr	r3, [r5, #0]
    60f0:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    60f2:	f7fc fc19 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    60f6:	2802      	cmp	r0, #2
    60f8:	462e      	mov	r6, r5
    60fa:	d025      	beq.n	6148 <Output_sysCtrlSend_capability+0x64>
    60fc:	d807      	bhi.n	610e <Output_sysCtrlSend_capability+0x2a>
    60fe:	2801      	cmp	r0, #1
    6100:	d018      	beq.n	6134 <Output_sysCtrlSend_capability+0x50>
}
    6102:	9a01      	ldr	r2, [sp, #4]
    6104:	6833      	ldr	r3, [r6, #0]
    6106:	429a      	cmp	r2, r3
    6108:	d112      	bne.n	6130 <Output_sysCtrlSend_capability+0x4c>
    610a:	b002      	add	sp, #8
    610c:	bd70      	pop	{r4, r5, r6, pc}
	switch ( cstate )
    610e:	2803      	cmp	r0, #3
    6110:	d017      	beq.n	6142 <Output_sysCtrlSend_capability+0x5e>
    6112:	28ff      	cmp	r0, #255	; 0xff
    6114:	d1f5      	bne.n	6102 <Output_sysCtrlSend_capability+0x1e>
		print("Output_sysCtrlSend(sysCode)");
    6116:	4815      	ldr	r0, [pc, #84]	; (616c <Output_sysCtrlSend_capability+0x88>)
    6118:	f003 f9b6 	bl	9488 <_print>
		if ( args != 0 )
    611c:	2c00      	cmp	r4, #0
    611e:	d0f0      	beq.n	6102 <Output_sysCtrlSend_capability+0x1e>
			print(" -> ");
    6120:	4813      	ldr	r0, [pc, #76]	; (6170 <Output_sysCtrlSend_capability+0x8c>)
			uint8_t key = args[0];
    6122:	7824      	ldrb	r4, [r4, #0]
			print(" -> ");
    6124:	f003 f9b0 	bl	9488 <_print>
			printInt8( key );
    6128:	9a01      	ldr	r2, [sp, #4]
    612a:	682b      	ldr	r3, [r5, #0]
    612c:	429a      	cmp	r2, r3
    612e:	d015      	beq.n	615c <Output_sysCtrlSend_capability+0x78>
}
    6130:	f7fb f9f8 	bl	1524 <__stack_chk_fail>
		USBKeys_primary.changed |= USBKeyChangeState_System;
    6134:	4a0f      	ldr	r2, [pc, #60]	; (6174 <Output_sysCtrlSend_capability+0x90>)
    6136:	f892 3020 	ldrb.w	r3, [r2, #32]
    613a:	f043 0304 	orr.w	r3, r3, #4
    613e:	f882 3020 	strb.w	r3, [r2, #32]
	USBKeys_primary.sys_ctrl = args[0];
    6142:	7822      	ldrb	r2, [r4, #0]
    6144:	4b0b      	ldr	r3, [pc, #44]	; (6174 <Output_sysCtrlSend_capability+0x90>)
    6146:	e007      	b.n	6158 <Output_sysCtrlSend_capability+0x74>
		USBKeys_primary.changed |= USBKeyChangeState_System;
    6148:	4b0a      	ldr	r3, [pc, #40]	; (6174 <Output_sysCtrlSend_capability+0x90>)
    614a:	f893 2020 	ldrb.w	r2, [r3, #32]
    614e:	f042 0204 	orr.w	r2, r2, #4
    6152:	f883 2020 	strb.w	r2, [r3, #32]
		USBKeys_primary.sys_ctrl = 0;
    6156:	2200      	movs	r2, #0
	USBKeys_primary.sys_ctrl = args[0];
    6158:	775a      	strb	r2, [r3, #29]
    615a:	e7d2      	b.n	6102 <Output_sysCtrlSend_capability+0x1e>
			printInt8( key );
    615c:	4620      	mov	r0, r4
}
    615e:	b002      	add	sp, #8
    6160:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt8( key );
    6164:	f003 b9fa 	b.w	955c <printInt8>
    6168:	1fffe9d0 	.word	0x1fffe9d0
    616c:	0000c4cd 	.word	0x0000c4cd
    6170:	00009ed1 	.word	0x00009ed1
    6174:	20000776 	.word	0x20000776

00006178 <Output_usbCodeSend_capability>:
{
    6178:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    617a:	4e80      	ldr	r6, [pc, #512]	; (637c <Output_usbCodeSend_capability+0x204>)
    617c:	4608      	mov	r0, r1
    617e:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6180:	4611      	mov	r1, r2
{
    6182:	6833      	ldr	r3, [r6, #0]
    6184:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6186:	f7fc fbcf 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    618a:	2802      	cmp	r0, #2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    618c:	4607      	mov	r7, r0
    618e:	4635      	mov	r5, r6
	switch ( cstate )
    6190:	d019      	beq.n	61c6 <Output_usbCodeSend_capability+0x4e>
    6192:	28ff      	cmp	r0, #255	; 0xff
    6194:	d003      	beq.n	619e <Output_usbCodeSend_capability+0x26>
    6196:	2801      	cmp	r0, #1
    6198:	d132      	bne.n	6200 <Output_usbCodeSend_capability+0x88>
		keyPress = 1;
    619a:	4606      	mov	r6, r0
    619c:	e014      	b.n	61c8 <Output_usbCodeSend_capability+0x50>
		print("Output_usbCodeSend(usbCode)");
    619e:	4878      	ldr	r0, [pc, #480]	; (6380 <Output_usbCodeSend_capability+0x208>)
    61a0:	f003 f972 	bl	9488 <_print>
		if ( args != 0 )
    61a4:	b364      	cbz	r4, 6200 <Output_usbCodeSend_capability+0x88>
			print(" -> ");
    61a6:	4877      	ldr	r0, [pc, #476]	; (6384 <Output_usbCodeSend_capability+0x20c>)
			uint8_t key = args[0];
    61a8:	7824      	ldrb	r4, [r4, #0]
			print(" -> ");
    61aa:	f003 f96d 	bl	9488 <_print>
			printInt8( key );
    61ae:	9a01      	ldr	r2, [sp, #4]
    61b0:	6833      	ldr	r3, [r6, #0]
    61b2:	429a      	cmp	r2, r3
    61b4:	d001      	beq.n	61ba <Output_usbCodeSend_capability+0x42>
}
    61b6:	f7fb f9b5 	bl	1524 <__stack_chk_fail>
			printInt8( key );
    61ba:	4620      	mov	r0, r4
}
    61bc:	b003      	add	sp, #12
    61be:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			printInt8( key );
    61c2:	f003 b9cb 	b.w	955c <printInt8>
	uint8_t keyPress = 0; // Default to key release
    61c6:	2600      	movs	r6, #0
	if ( Output_DebugMode > 1 )
    61c8:	4b6f      	ldr	r3, [pc, #444]	; (6388 <Output_usbCodeSend_capability+0x210>)
	uint8_t key = args[0];
    61ca:	7824      	ldrb	r4, [r4, #0]
	if ( Output_DebugMode > 1 )
    61cc:	781b      	ldrb	r3, [r3, #0]
    61ce:	2b01      	cmp	r3, #1
    61d0:	d90f      	bls.n	61f2 <Output_usbCodeSend_capability+0x7a>
		print("\033[1;34mUSB\033[0m ");
    61d2:	486e      	ldr	r0, [pc, #440]	; (638c <Output_usbCodeSend_capability+0x214>)
    61d4:	f003 f958 	bl	9488 <_print>
		printInt8( key );
    61d8:	4620      	mov	r0, r4
    61da:	f003 f9bf 	bl	955c <printInt8>
		print(" ");
    61de:	486c      	ldr	r0, [pc, #432]	; (6390 <Output_usbCodeSend_capability+0x218>)
    61e0:	f003 f952 	bl	9488 <_print>
		switch ( cstate )
    61e4:	2f01      	cmp	r7, #1
    61e6:	d011      	beq.n	620c <Output_usbCodeSend_capability+0x94>
    61e8:	2f02      	cmp	r7, #2
    61ea:	d013      	beq.n	6214 <Output_usbCodeSend_capability+0x9c>
		print( NL );
    61ec:	4869      	ldr	r0, [pc, #420]	; (6394 <Output_usbCodeSend_capability+0x21c>)
    61ee:	f003 f94b 	bl	9488 <_print>
	switch ( USBKeys_Protocol )
    61f2:	4b69      	ldr	r3, [pc, #420]	; (6398 <Output_usbCodeSend_capability+0x220>)
    61f4:	781b      	ldrb	r3, [r3, #0]
    61f6:	f003 07ff 	and.w	r7, r3, #255	; 0xff
    61fa:	b16b      	cbz	r3, 6218 <Output_usbCodeSend_capability+0xa0>
    61fc:	2f01      	cmp	r7, #1
    61fe:	d06f      	beq.n	62e0 <Output_usbCodeSend_capability+0x168>
}
    6200:	9a01      	ldr	r2, [sp, #4]
    6202:	682b      	ldr	r3, [r5, #0]
    6204:	429a      	cmp	r2, r3
    6206:	d1d6      	bne.n	61b6 <Output_usbCodeSend_capability+0x3e>
    6208:	b003      	add	sp, #12
    620a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			print("\033[1;33mP\033[0m");
    620c:	4863      	ldr	r0, [pc, #396]	; (639c <Output_usbCodeSend_capability+0x224>)
			print("\033[1;35mR\033[0m");
    620e:	f003 f93b 	bl	9488 <_print>
			break;
    6212:	e7eb      	b.n	61ec <Output_usbCodeSend_capability+0x74>
			print("\033[1;35mR\033[0m");
    6214:	4862      	ldr	r0, [pc, #392]	; (63a0 <Output_usbCodeSend_capability+0x228>)
    6216:	e7fa      	b.n	620e <Output_usbCodeSend_capability+0x96>
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    6218:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    621c:	2be0      	cmp	r3, #224	; 0xe0
    621e:	d14a      	bne.n	62b6 <Output_usbCodeSend_capability+0x13e>
    6220:	f084 01e0 	eor.w	r1, r4, #224	; 0xe0
    6224:	4b5f      	ldr	r3, [pc, #380]	; (63a4 <Output_usbCodeSend_capability+0x22c>)
    6226:	2401      	movs	r4, #1
    6228:	408c      	lsls	r4, r1
    622a:	b264      	sxtb	r4, r4
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    622c:	781a      	ldrb	r2, [r3, #0]
			if ( keyPress )
    622e:	b14e      	cbz	r6, 6244 <Output_usbCodeSend_capability+0xcc>
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    6230:	4314      	orrs	r4, r2
    6232:	b2e4      	uxtb	r4, r4
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    6234:	701c      	strb	r4, [r3, #0]
			USBKeys_primary.changed |= USBKeyChangeState_Modifiers;
    6236:	f893 2020 	ldrb.w	r2, [r3, #32]
    623a:	f042 0201 	orr.w	r2, r2, #1
    623e:	f883 2020 	strb.w	r2, [r3, #32]
			break;
    6242:	e7dd      	b.n	6200 <Output_usbCodeSend_capability+0x88>
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    6244:	ea22 0404 	bic.w	r4, r2, r4
    6248:	e7f4      	b.n	6234 <Output_usbCodeSend_capability+0xbc>
				if ( keyPress && USBKeys_primary.keys[newkey] == key )
    624a:	b12e      	cbz	r6, 6258 <Output_usbCodeSend_capability+0xe0>
    624c:	4413      	add	r3, r2
    624e:	785b      	ldrb	r3, [r3, #1]
    6250:	42a3      	cmp	r3, r4
    6252:	d128      	bne.n	62a6 <Output_usbCodeSend_capability+0x12e>
					keyFound = 1;
    6254:	4633      	mov	r3, r6
    6256:	e011      	b.n	627c <Output_usbCodeSend_capability+0x104>
				if ( !keyPress && USBKeys_primary.keys[newkey] == key )
    6258:	eb02 0c03 	add.w	ip, r2, r3
    625c:	f89c c001 	ldrb.w	ip, [ip, #1]
    6260:	45a4      	cmp	ip, r4
    6262:	d120      	bne.n	62a6 <Output_usbCodeSend_capability+0x12e>
					for ( uint8_t pos = newkey; pos < USBKeys_Sent - 1; pos++ )
    6264:	7801      	ldrb	r1, [r0, #0]
    6266:	3901      	subs	r1, #1
    6268:	428b      	cmp	r3, r1
    626a:	db14      	blt.n	6296 <Output_usbCodeSend_capability+0x11e>
					USBKeys_Sent--;
    626c:	7803      	ldrb	r3, [r0, #0]
    626e:	3b01      	subs	r3, #1
    6270:	b2db      	uxtb	r3, r3
    6272:	7003      	strb	r3, [r0, #0]
					USBKeys_primary.changed = USBKeyChangeState_Keys;
    6274:	2302      	movs	r3, #2
    6276:	f882 3020 	strb.w	r3, [r2, #32]
					keyFound = 1;
    627a:	2301      	movs	r3, #1
			if ( USBKeys_Sent >= USB_BOOT_MAX_KEYS )
    627c:	7802      	ldrb	r2, [r0, #0]
    627e:	2a05      	cmp	r2, #5
    6280:	d91e      	bls.n	62c0 <Output_usbCodeSend_capability+0x148>
				warn_print("USB Key limit reached");
    6282:	9a01      	ldr	r2, [sp, #4]
    6284:	682b      	ldr	r3, [r5, #0]
    6286:	429a      	cmp	r2, r3
    6288:	d195      	bne.n	61b6 <Output_usbCodeSend_capability+0x3e>
    628a:	4847      	ldr	r0, [pc, #284]	; (63a8 <Output_usbCodeSend_capability+0x230>)
}
    628c:	b003      	add	sp, #12
    628e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			print( NL );
    6292:	f003 b8f9 	b.w	9488 <_print>
						USBKeys_primary.keys[pos] = USBKeys_primary.keys[pos + 1];
    6296:	1c5f      	adds	r7, r3, #1
    6298:	19d1      	adds	r1, r2, r7
    629a:	4413      	add	r3, r2
    629c:	7849      	ldrb	r1, [r1, #1]
    629e:	b2c9      	uxtb	r1, r1
    62a0:	7059      	strb	r1, [r3, #1]
					for ( uint8_t pos = newkey; pos < USBKeys_Sent - 1; pos++ )
    62a2:	b2fb      	uxtb	r3, r7
    62a4:	e7de      	b.n	6264 <Output_usbCodeSend_capability+0xec>
    62a6:	3101      	adds	r1, #1
			for ( uint8_t newkey = 0; newkey < USBKeys_Sent; newkey++ )
    62a8:	f897 c000 	ldrb.w	ip, [r7]
    62ac:	b2cb      	uxtb	r3, r1
    62ae:	459c      	cmp	ip, r3
    62b0:	d8cb      	bhi.n	624a <Output_usbCodeSend_capability+0xd2>
			uint8_t keyFound = 0;
    62b2:	2300      	movs	r3, #0
    62b4:	e7e2      	b.n	627c <Output_usbCodeSend_capability+0x104>
    62b6:	4639      	mov	r1, r7
			for ( uint8_t newkey = 0; newkey < USBKeys_Sent; newkey++ )
    62b8:	4f3c      	ldr	r7, [pc, #240]	; (63ac <Output_usbCodeSend_capability+0x234>)
    62ba:	4a3a      	ldr	r2, [pc, #232]	; (63a4 <Output_usbCodeSend_capability+0x22c>)
    62bc:	4638      	mov	r0, r7
    62be:	e7f3      	b.n	62a8 <Output_usbCodeSend_capability+0x130>
			if ( keyPress && !keyFound )
    62c0:	2e00      	cmp	r6, #0
    62c2:	d09d      	beq.n	6200 <Output_usbCodeSend_capability+0x88>
    62c4:	2b00      	cmp	r3, #0
    62c6:	d19b      	bne.n	6200 <Output_usbCodeSend_capability+0x88>
				USBKeys_primary.keys[USBKeys_Sent++] = key;
    62c8:	7803      	ldrb	r3, [r0, #0]
    62ca:	b2db      	uxtb	r3, r3
    62cc:	1c5a      	adds	r2, r3, #1
    62ce:	b2d2      	uxtb	r2, r2
    62d0:	7002      	strb	r2, [r0, #0]
    62d2:	4a34      	ldr	r2, [pc, #208]	; (63a4 <Output_usbCodeSend_capability+0x22c>)
    62d4:	4413      	add	r3, r2
    62d6:	705c      	strb	r4, [r3, #1]
				USBKeys_primary.changed = USBKeyChangeState_Keys;
    62d8:	2302      	movs	r3, #2
			USBKeys_primary.changed |= USBKeyChangeState_Keys;
    62da:	f882 3020 	strb.w	r3, [r2, #32]
			break;
    62de:	e78f      	b.n	6200 <Output_usbCodeSend_capability+0x88>
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    62e0:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    62e4:	2be0      	cmp	r3, #224	; 0xe0
    62e6:	d10e      	bne.n	6306 <Output_usbCodeSend_capability+0x18e>
    62e8:	f084 04e0 	eor.w	r4, r4, #224	; 0xe0
    62ec:	4b2d      	ldr	r3, [pc, #180]	; (63a4 <Output_usbCodeSend_capability+0x22c>)
    62ee:	fa07 f104 	lsl.w	r1, r7, r4
    62f2:	b249      	sxtb	r1, r1
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    62f4:	781c      	ldrb	r4, [r3, #0]
			if ( keyPress )
    62f6:	b11e      	cbz	r6, 6300 <Output_usbCodeSend_capability+0x188>
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    62f8:	4321      	orrs	r1, r4
    62fa:	b2c9      	uxtb	r1, r1
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    62fc:	7019      	strb	r1, [r3, #0]
    62fe:	e79a      	b.n	6236 <Output_usbCodeSend_capability+0xbe>
    6300:	ea24 0101 	bic.w	r1, r4, r1
    6304:	e7fa      	b.n	62fc <Output_usbCodeSend_capability+0x184>
		else if ( key >= 1 && key <= 221 )
    6306:	1e62      	subs	r2, r4, #1
    6308:	b2d2      	uxtb	r2, r2
    630a:	2adc      	cmp	r2, #220	; 0xdc
    630c:	d819      	bhi.n	6342 <Output_usbCodeSend_capability+0x1ca>
    630e:	4b28      	ldr	r3, [pc, #160]	; (63b0 <Output_usbCodeSend_capability+0x238>)
    6310:	4826      	ldr	r0, [pc, #152]	; (63ac <Output_usbCodeSend_capability+0x234>)
    6312:	5c9c      	ldrb	r4, [r3, r2]
    6314:	4b27      	ldr	r3, [pc, #156]	; (63b4 <Output_usbCodeSend_capability+0x23c>)
    6316:	5c9b      	ldrb	r3, [r3, r2]
			USBKeys_primary.changed |= USBKeyChangeState_Keys;
    6318:	4a22      	ldr	r2, [pc, #136]	; (63a4 <Output_usbCodeSend_capability+0x22c>)
    631a:	f892 1020 	ldrb.w	r1, [r2, #32]
    631e:	f041 0102 	orr.w	r1, r1, #2
    6322:	f882 1020 	strb.w	r1, [r2, #32]
    6326:	fa07 f103 	lsl.w	r1, r7, r3
    632a:	b249      	sxtb	r1, r1
    632c:	1913      	adds	r3, r2, r4
		if ( keyPress )
    632e:	b1ee      	cbz	r6, 636c <Output_usbCodeSend_capability+0x1f4>
			USBKeys_primary.keys[bytePosition] |= (1 << byteShift);
    6330:	785a      	ldrb	r2, [r3, #1]
    6332:	4311      	orrs	r1, r2
    6334:	b2c9      	uxtb	r1, r1
    6336:	7059      	strb	r1, [r3, #1]
			USBKeys_Sent--;
    6338:	7803      	ldrb	r3, [r0, #0]
    633a:	3b01      	subs	r3, #1
			USBKeys_Sent++;
    633c:	b2db      	uxtb	r3, r3
    633e:	7003      	strb	r3, [r0, #0]
    6340:	e75e      	b.n	6200 <Output_usbCodeSend_capability+0x88>
		else if ( key == 0x00 )
    6342:	b92c      	cbnz	r4, 6350 <Output_usbCodeSend_capability+0x1d8>
			USBKeys_primary.changed |= USBKeyChangeState_Keys;
    6344:	4a17      	ldr	r2, [pc, #92]	; (63a4 <Output_usbCodeSend_capability+0x22c>)
    6346:	f892 3020 	ldrb.w	r3, [r2, #32]
    634a:	f043 0302 	orr.w	r3, r3, #2
    634e:	e7c4      	b.n	62da <Output_usbCodeSend_capability+0x162>
			warn_msg("USB Code not within 4-155 (0x4-0x9B), 157-164 (0x9D-0xA4), 176-221 (0xB0-0xDD) or 224-231 (0xE0-0xE7) NKRO Mode: ");
    6350:	4819      	ldr	r0, [pc, #100]	; (63b8 <Output_usbCodeSend_capability+0x240>)
    6352:	f003 f899 	bl	9488 <_print>
			printHex( key );
    6356:	4639      	mov	r1, r7
    6358:	4620      	mov	r0, r4
    635a:	f003 f9bb 	bl	96d4 <printHex_op>
			print( NL );
    635e:	9a01      	ldr	r2, [sp, #4]
    6360:	682b      	ldr	r3, [r5, #0]
    6362:	429a      	cmp	r2, r3
    6364:	f47f af27 	bne.w	61b6 <Output_usbCodeSend_capability+0x3e>
    6368:	480a      	ldr	r0, [pc, #40]	; (6394 <Output_usbCodeSend_capability+0x21c>)
    636a:	e78f      	b.n	628c <Output_usbCodeSend_capability+0x114>
			USBKeys_primary.keys[bytePosition] &= ~(1 << byteShift);
    636c:	785a      	ldrb	r2, [r3, #1]
    636e:	ea22 0101 	bic.w	r1, r2, r1
    6372:	7059      	strb	r1, [r3, #1]
			USBKeys_Sent++;
    6374:	7803      	ldrb	r3, [r0, #0]
    6376:	3301      	adds	r3, #1
    6378:	e7e0      	b.n	633c <Output_usbCodeSend_capability+0x1c4>
    637a:	bf00      	nop
    637c:	1fffe9d0 	.word	0x1fffe9d0
    6380:	0000c504 	.word	0x0000c504
    6384:	00009ed1 	.word	0x00009ed1
    6388:	20000736 	.word	0x20000736
    638c:	0000c520 	.word	0x0000c520
    6390:	0000d6a4 	.word	0x0000d6a4
    6394:	0000d348 	.word	0x0000d348
    6398:	1fffeba8 	.word	0x1fffeba8
    639c:	000099c4 	.word	0x000099c4
    63a0:	000099de 	.word	0x000099de
    63a4:	20000776 	.word	0x20000776
    63a8:	0000c530 	.word	0x0000c530
    63ac:	20000773 	.word	0x20000773
    63b0:	0000c2ad 	.word	0x0000c2ad
    63b4:	0000c38c 	.word	0x0000c38c
    63b8:	0000c55d 	.word	0x0000c55d

000063bc <Output_usbMouse_capability>:
{
    63bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    63be:	4f29      	ldr	r7, [pc, #164]	; (6464 <Output_usbMouse_capability+0xa8>)
    63c0:	461c      	mov	r4, r3
    63c2:	4608      	mov	r0, r1
    63c4:	683b      	ldr	r3, [r7, #0]
    63c6:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    63c8:	4611      	mov	r1, r2
    63ca:	f7fc faad 	bl	2928 <KLL_CapabilityState>
	uint16_t mouse_button = *(uint16_t*)(&args[0]);
    63ce:	8822      	ldrh	r2, [r4, #0]
	int16_t mouse_x = *(int16_t*)(&args[2]);
    63d0:	f9b4 5002 	ldrsh.w	r5, [r4, #2]
	int16_t mouse_y = *(int16_t*)(&args[4]);
    63d4:	f9b4 4004 	ldrsh.w	r4, [r4, #4]
	uint16_t mouse_button_shift = mouse_button - 1;
    63d8:	1e53      	subs	r3, r2, #1
	switch ( cstate )
    63da:	2802      	cmp	r0, #2
	uint16_t mouse_button_shift = mouse_button - 1;
    63dc:	b299      	uxth	r1, r3
    63de:	463e      	mov	r6, r7
	switch ( cstate )
    63e0:	d02a      	beq.n	6438 <Output_usbMouse_capability+0x7c>
    63e2:	d807      	bhi.n	63f4 <Output_usbMouse_capability+0x38>
    63e4:	2801      	cmp	r0, #1
    63e6:	d00f      	beq.n	6408 <Output_usbMouse_capability+0x4c>
}
    63e8:	9a01      	ldr	r2, [sp, #4]
    63ea:	6833      	ldr	r3, [r6, #0]
    63ec:	429a      	cmp	r2, r3
    63ee:	d109      	bne.n	6404 <Output_usbMouse_capability+0x48>
    63f0:	b003      	add	sp, #12
    63f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch ( cstate )
    63f4:	2803      	cmp	r0, #3
    63f6:	d007      	beq.n	6408 <Output_usbMouse_capability+0x4c>
    63f8:	28ff      	cmp	r0, #255	; 0xff
    63fa:	d1f5      	bne.n	63e8 <Output_usbMouse_capability+0x2c>
		print("Output_usbMouse(mouseButton,relX,relY)");
    63fc:	9a01      	ldr	r2, [sp, #4]
    63fe:	683b      	ldr	r3, [r7, #0]
    6400:	429a      	cmp	r2, r3
    6402:	d028      	beq.n	6456 <Output_usbMouse_capability+0x9a>
}
    6404:	f7fb f88e 	bl	1524 <__stack_chk_fail>
		if ( mouse_button )
    6408:	b132      	cbz	r2, 6418 <Output_usbMouse_capability+0x5c>
			USBMouse_Buttons |= (1 << mouse_button_shift);
    640a:	4817      	ldr	r0, [pc, #92]	; (6468 <Output_usbMouse_capability+0xac>)
    640c:	2301      	movs	r3, #1
    640e:	8807      	ldrh	r7, [r0, #0]
    6410:	408b      	lsls	r3, r1
    6412:	433b      	orrs	r3, r7
    6414:	b29b      	uxth	r3, r3
    6416:	8003      	strh	r3, [r0, #0]
		if ( mouse_x )
    6418:	b10d      	cbz	r5, 641e <Output_usbMouse_capability+0x62>
			USBMouse_Relative_x = mouse_x;
    641a:	4b14      	ldr	r3, [pc, #80]	; (646c <Output_usbMouse_capability+0xb0>)
    641c:	801d      	strh	r5, [r3, #0]
		if ( mouse_y )
    641e:	b10c      	cbz	r4, 6424 <Output_usbMouse_capability+0x68>
			USBMouse_Relative_y = mouse_y;
    6420:	4b13      	ldr	r3, [pc, #76]	; (6470 <Output_usbMouse_capability+0xb4>)
    6422:	801c      	strh	r4, [r3, #0]
	if ( mouse_button )
    6424:	b98a      	cbnz	r2, 644a <Output_usbMouse_capability+0x8e>
	if ( mouse_x || mouse_y )
    6426:	b90d      	cbnz	r5, 642c <Output_usbMouse_capability+0x70>
    6428:	2c00      	cmp	r4, #0
    642a:	d0dd      	beq.n	63e8 <Output_usbMouse_capability+0x2c>
		USBMouse_Changed |= USBMouseChangeState_Relative;
    642c:	4a11      	ldr	r2, [pc, #68]	; (6474 <Output_usbMouse_capability+0xb8>)
    642e:	7813      	ldrb	r3, [r2, #0]
    6430:	f043 0302 	orr.w	r3, r3, #2
    6434:	7013      	strb	r3, [r2, #0]
    6436:	e7d7      	b.n	63e8 <Output_usbMouse_capability+0x2c>
		if ( mouse_button )
    6438:	2a00      	cmp	r2, #0
    643a:	d0f4      	beq.n	6426 <Output_usbMouse_capability+0x6a>
			USBMouse_Buttons &= ~(1 << mouse_button_shift);
    643c:	480a      	ldr	r0, [pc, #40]	; (6468 <Output_usbMouse_capability+0xac>)
    643e:	2301      	movs	r3, #1
    6440:	8802      	ldrh	r2, [r0, #0]
    6442:	408b      	lsls	r3, r1
    6444:	ea22 0303 	bic.w	r3, r2, r3
    6448:	8003      	strh	r3, [r0, #0]
		USBMouse_Changed |= USBMouseChangeState_Buttons;
    644a:	4a0a      	ldr	r2, [pc, #40]	; (6474 <Output_usbMouse_capability+0xb8>)
    644c:	7813      	ldrb	r3, [r2, #0]
    644e:	f043 0301 	orr.w	r3, r3, #1
    6452:	7013      	strb	r3, [r2, #0]
    6454:	e7e7      	b.n	6426 <Output_usbMouse_capability+0x6a>
		print("Output_usbMouse(mouseButton,relX,relY)");
    6456:	4808      	ldr	r0, [pc, #32]	; (6478 <Output_usbMouse_capability+0xbc>)
}
    6458:	b003      	add	sp, #12
    645a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		print("Output_usbMouse(mouseButton,relX,relY)");
    645e:	f003 b813 	b.w	9488 <_print>
    6462:	bf00      	nop
    6464:	1fffe9d0 	.word	0x1fffe9d0
    6468:	20000748 	.word	0x20000748
    646c:	20000798 	.word	0x20000798
    6470:	2000074c 	.word	0x2000074c
    6474:	20000741 	.word	0x20000741
    6478:	0000c604 	.word	0x0000c604

0000647c <Output_usbMouseWheel_capability>:
{
    647c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    647e:	4c1a      	ldr	r4, [pc, #104]	; (64e8 <Output_usbMouseWheel_capability+0x6c>)
    6480:	4608      	mov	r0, r1
    6482:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6484:	4611      	mov	r1, r2
{
    6486:	6823      	ldr	r3, [r4, #0]
    6488:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    648a:	f7fc fa4d 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    648e:	2803      	cmp	r0, #3
    6490:	4626      	mov	r6, r4
    6492:	d003      	beq.n	649c <Output_usbMouseWheel_capability+0x20>
    6494:	28ff      	cmp	r0, #255	; 0xff
    6496:	d01b      	beq.n	64d0 <Output_usbMouseWheel_capability+0x54>
    6498:	2801      	cmp	r0, #1
    649a:	d113      	bne.n	64c4 <Output_usbMouseWheel_capability+0x48>
	int8_t wheel_vert = *(int8_t*)(&args[0]);
    649c:	f995 1000 	ldrsb.w	r1, [r5]
	int8_t wheel_hori = *(int8_t*)(&args[2]);
    64a0:	f995 2002 	ldrsb.w	r2, [r5, #2]
		if ( wheel_vert )
    64a4:	b131      	cbz	r1, 64b4 <Output_usbMouseWheel_capability+0x38>
			USBMouse_VertWheel = wheel_vert;
    64a6:	4b11      	ldr	r3, [pc, #68]	; (64ec <Output_usbMouseWheel_capability+0x70>)
    64a8:	7019      	strb	r1, [r3, #0]
			USBMouse_Changed |= USBMouseChangeState_WheelVert;
    64aa:	4911      	ldr	r1, [pc, #68]	; (64f0 <Output_usbMouseWheel_capability+0x74>)
    64ac:	780b      	ldrb	r3, [r1, #0]
    64ae:	f043 0304 	orr.w	r3, r3, #4
    64b2:	700b      	strb	r3, [r1, #0]
		if ( wheel_hori )
    64b4:	b132      	cbz	r2, 64c4 <Output_usbMouseWheel_capability+0x48>
			USBMouse_HoriWheel = wheel_hori;
    64b6:	4b0f      	ldr	r3, [pc, #60]	; (64f4 <Output_usbMouseWheel_capability+0x78>)
    64b8:	701a      	strb	r2, [r3, #0]
			USBMouse_Changed |= USBMouseChangeState_WheelHori;
    64ba:	4a0d      	ldr	r2, [pc, #52]	; (64f0 <Output_usbMouseWheel_capability+0x74>)
    64bc:	7813      	ldrb	r3, [r2, #0]
    64be:	f043 0308 	orr.w	r3, r3, #8
    64c2:	7013      	strb	r3, [r2, #0]
}
    64c4:	9a01      	ldr	r2, [sp, #4]
    64c6:	6833      	ldr	r3, [r6, #0]
    64c8:	429a      	cmp	r2, r3
    64ca:	d105      	bne.n	64d8 <Output_usbMouseWheel_capability+0x5c>
    64cc:	b002      	add	sp, #8
    64ce:	bd70      	pop	{r4, r5, r6, pc}
		print("Output_usbMouseWheel(vert,hori)");
    64d0:	9a01      	ldr	r2, [sp, #4]
    64d2:	6823      	ldr	r3, [r4, #0]
    64d4:	429a      	cmp	r2, r3
    64d6:	d001      	beq.n	64dc <Output_usbMouseWheel_capability+0x60>
}
    64d8:	f7fb f824 	bl	1524 <__stack_chk_fail>
		print("Output_usbMouseWheel(vert,hori)");
    64dc:	4806      	ldr	r0, [pc, #24]	; (64f8 <Output_usbMouseWheel_capability+0x7c>)
}
    64de:	b002      	add	sp, #8
    64e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Output_usbMouseWheel(vert,hori)");
    64e4:	f002 bfd0 	b.w	9488 <_print>
    64e8:	1fffe9d0 	.word	0x1fffe9d0
    64ec:	2000074a 	.word	0x2000074a
    64f0:	20000741 	.word	0x20000741
    64f4:	2000079a 	.word	0x2000079a
    64f8:	0000c5e4 	.word	0x0000c5e4

000064fc <USB_flushBuffers>:
{
    64fc:	b513      	push	{r0, r1, r4, lr}
    64fe:	4c0e      	ldr	r4, [pc, #56]	; (6538 <USB_flushBuffers+0x3c>)
	memset( (void*)&USBKeys_primary, 0, sizeof( USBKeys ) );
    6500:	480e      	ldr	r0, [pc, #56]	; (653c <USB_flushBuffers+0x40>)
{
    6502:	6823      	ldr	r3, [r4, #0]
    6504:	9301      	str	r3, [sp, #4]
	memset( (void*)&USBKeys_primary, 0, sizeof( USBKeys ) );
    6506:	2222      	movs	r2, #34	; 0x22
    6508:	2100      	movs	r1, #0
    650a:	f7fb f819 	bl	1540 <memset>
	memset( (void*)&USBKeys_idle, 0, sizeof( USBKeys ) );
    650e:	2222      	movs	r2, #34	; 0x22
    6510:	2100      	movs	r1, #0
    6512:	480b      	ldr	r0, [pc, #44]	; (6540 <USB_flushBuffers+0x44>)
    6514:	f7fb f814 	bl	1540 <memset>
	USBKeys_Idle_Expiry = 0;
    6518:	4a0a      	ldr	r2, [pc, #40]	; (6544 <USB_flushBuffers+0x48>)
    651a:	2300      	movs	r3, #0
    651c:	6013      	str	r3, [r2, #0]
	USBKeys_Idle_Count = 0;
    651e:	4a0a      	ldr	r2, [pc, #40]	; (6548 <USB_flushBuffers+0x4c>)
    6520:	7013      	strb	r3, [r2, #0]
	USBKeys_Sent = 0;
    6522:	4a0a      	ldr	r2, [pc, #40]	; (654c <USB_flushBuffers+0x50>)
    6524:	7013      	strb	r3, [r2, #0]
}
    6526:	9a01      	ldr	r2, [sp, #4]
    6528:	6823      	ldr	r3, [r4, #0]
    652a:	429a      	cmp	r2, r3
    652c:	d001      	beq.n	6532 <USB_flushBuffers+0x36>
    652e:	f7fa fff9 	bl	1524 <__stack_chk_fail>
    6532:	b002      	add	sp, #8
    6534:	bd10      	pop	{r4, pc}
    6536:	bf00      	nop
    6538:	1fffe9d0 	.word	0x1fffe9d0
    653c:	20000776 	.word	0x20000776
    6540:	20000750 	.word	0x20000750
    6544:	2000079c 	.word	0x2000079c
    6548:	20000740 	.word	0x20000740
    654c:	20000773 	.word	0x20000773

00006550 <Output_kbdProtocolBoot_capability>:
{
    6550:	b573      	push	{r0, r1, r4, r5, r6, lr}
    6552:	4d14      	ldr	r5, [pc, #80]	; (65a4 <Output_kbdProtocolBoot_capability+0x54>)
    6554:	4608      	mov	r0, r1
    6556:	682b      	ldr	r3, [r5, #0]
    6558:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    655a:	4611      	mov	r1, r2
    655c:	f7fc f9e4 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    6560:	2801      	cmp	r0, #1
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6562:	4604      	mov	r4, r0
    6564:	462e      	mov	r6, r5
	switch ( cstate )
    6566:	d00d      	beq.n	6584 <Output_kbdProtocolBoot_capability+0x34>
    6568:	28ff      	cmp	r0, #255	; 0xff
    656a:	d115      	bne.n	6598 <Output_kbdProtocolBoot_capability+0x48>
		print("Output_kbdProtocolBoot()");
    656c:	9a01      	ldr	r2, [sp, #4]
    656e:	682b      	ldr	r3, [r5, #0]
    6570:	429a      	cmp	r2, r3
    6572:	d001      	beq.n	6578 <Output_kbdProtocolBoot_capability+0x28>
}
    6574:	f7fa ffd6 	bl	1524 <__stack_chk_fail>
		print("Output_kbdProtocolBoot()");
    6578:	480b      	ldr	r0, [pc, #44]	; (65a8 <Output_kbdProtocolBoot_capability+0x58>)
}
    657a:	b002      	add	sp, #8
    657c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Output_kbdProtocolBoot()");
    6580:	f002 bf82 	b.w	9488 <_print>
	if ( USBKeys_Protocol == 0 )
    6584:	4b09      	ldr	r3, [pc, #36]	; (65ac <Output_kbdProtocolBoot_capability+0x5c>)
    6586:	781b      	ldrb	r3, [r3, #0]
    6588:	b133      	cbz	r3, 6598 <Output_kbdProtocolBoot_capability+0x48>
	USB_flushBuffers();
    658a:	f7ff ffb7 	bl	64fc <USB_flushBuffers>
	USBKeys_Protocol_New = 0;
    658e:	4b08      	ldr	r3, [pc, #32]	; (65b0 <Output_kbdProtocolBoot_capability+0x60>)
    6590:	2200      	movs	r2, #0
    6592:	701a      	strb	r2, [r3, #0]
	USBKeys_Protocol_Change = 1;
    6594:	4b07      	ldr	r3, [pc, #28]	; (65b4 <Output_kbdProtocolBoot_capability+0x64>)
    6596:	701c      	strb	r4, [r3, #0]
}
    6598:	9a01      	ldr	r2, [sp, #4]
    659a:	6833      	ldr	r3, [r6, #0]
    659c:	429a      	cmp	r2, r3
    659e:	d1e9      	bne.n	6574 <Output_kbdProtocolBoot_capability+0x24>
    65a0:	b002      	add	sp, #8
    65a2:	bd70      	pop	{r4, r5, r6, pc}
    65a4:	1fffe9d0 	.word	0x1fffe9d0
    65a8:	0000c489 	.word	0x0000c489
    65ac:	1fffeba8 	.word	0x1fffeba8
    65b0:	1fffeba9 	.word	0x1fffeba9
    65b4:	200007a0 	.word	0x200007a0

000065b8 <Output_kbdProtocolNKRO_capability>:
{
    65b8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    65ba:	4d14      	ldr	r5, [pc, #80]	; (660c <Output_kbdProtocolNKRO_capability+0x54>)
    65bc:	4608      	mov	r0, r1
    65be:	682b      	ldr	r3, [r5, #0]
    65c0:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    65c2:	4611      	mov	r1, r2
    65c4:	f7fc f9b0 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    65c8:	2801      	cmp	r0, #1
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    65ca:	4604      	mov	r4, r0
    65cc:	462e      	mov	r6, r5
	switch ( cstate )
    65ce:	d00d      	beq.n	65ec <Output_kbdProtocolNKRO_capability+0x34>
    65d0:	28ff      	cmp	r0, #255	; 0xff
    65d2:	d115      	bne.n	6600 <Output_kbdProtocolNKRO_capability+0x48>
		print("Output_kbdProtocolNKRO()");
    65d4:	9a01      	ldr	r2, [sp, #4]
    65d6:	682b      	ldr	r3, [r5, #0]
    65d8:	429a      	cmp	r2, r3
    65da:	d001      	beq.n	65e0 <Output_kbdProtocolNKRO_capability+0x28>
}
    65dc:	f7fa ffa2 	bl	1524 <__stack_chk_fail>
		print("Output_kbdProtocolNKRO()");
    65e0:	480b      	ldr	r0, [pc, #44]	; (6610 <Output_kbdProtocolNKRO_capability+0x58>)
}
    65e2:	b002      	add	sp, #8
    65e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Output_kbdProtocolNKRO()");
    65e8:	f002 bf4e 	b.w	9488 <_print>
	if ( USBKeys_Protocol == 1 )
    65ec:	4b09      	ldr	r3, [pc, #36]	; (6614 <Output_kbdProtocolNKRO_capability+0x5c>)
    65ee:	781b      	ldrb	r3, [r3, #0]
    65f0:	2b01      	cmp	r3, #1
    65f2:	d005      	beq.n	6600 <Output_kbdProtocolNKRO_capability+0x48>
	USB_flushBuffers();
    65f4:	f7ff ff82 	bl	64fc <USB_flushBuffers>
	USBKeys_Protocol_New = 1;
    65f8:	4b07      	ldr	r3, [pc, #28]	; (6618 <Output_kbdProtocolNKRO_capability+0x60>)
    65fa:	701c      	strb	r4, [r3, #0]
	USBKeys_Protocol_Change = 1;
    65fc:	4b07      	ldr	r3, [pc, #28]	; (661c <Output_kbdProtocolNKRO_capability+0x64>)
    65fe:	701c      	strb	r4, [r3, #0]
}
    6600:	9a01      	ldr	r2, [sp, #4]
    6602:	6833      	ldr	r3, [r6, #0]
    6604:	429a      	cmp	r2, r3
    6606:	d1e9      	bne.n	65dc <Output_kbdProtocolNKRO_capability+0x24>
    6608:	b002      	add	sp, #8
    660a:	bd70      	pop	{r4, r5, r6, pc}
    660c:	1fffe9d0 	.word	0x1fffe9d0
    6610:	0000c4a2 	.word	0x0000c4a2
    6614:	1fffeba8 	.word	0x1fffeba8
    6618:	1fffeba9 	.word	0x1fffeba9
    661c:	200007a0 	.word	0x200007a0

00006620 <Output_toggleKbdProtocol_capability>:
{
    6620:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6622:	4c15      	ldr	r4, [pc, #84]	; (6678 <Output_toggleKbdProtocol_capability+0x58>)
    6624:	4608      	mov	r0, r1
    6626:	6823      	ldr	r3, [r4, #0]
    6628:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    662a:	4611      	mov	r1, r2
    662c:	f7fc f97c 	bl	2928 <KLL_CapabilityState>
	switch ( cstate )
    6630:	2802      	cmp	r0, #2
    6632:	4625      	mov	r5, r4
    6634:	d00d      	beq.n	6652 <Output_toggleKbdProtocol_capability+0x32>
    6636:	28ff      	cmp	r0, #255	; 0xff
    6638:	d117      	bne.n	666a <Output_toggleKbdProtocol_capability+0x4a>
		print("Output_toggleKbdProtocol()");
    663a:	9a01      	ldr	r2, [sp, #4]
    663c:	6823      	ldr	r3, [r4, #0]
    663e:	429a      	cmp	r2, r3
    6640:	d001      	beq.n	6646 <Output_toggleKbdProtocol_capability+0x26>
}
    6642:	f7fa ff6f 	bl	1524 <__stack_chk_fail>
		print("Output_toggleKbdProtocol()");
    6646:	480d      	ldr	r0, [pc, #52]	; (667c <Output_toggleKbdProtocol_capability+0x5c>)
}
    6648:	b003      	add	sp, #12
    664a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		print("Output_toggleKbdProtocol()");
    664e:	f002 bf1b 	b.w	9488 <_print>
	USB_flushBuffers();
    6652:	f7ff ff53 	bl	64fc <USB_flushBuffers>
	USBKeys_Protocol_New = !USBKeys_Protocol;
    6656:	4b0a      	ldr	r3, [pc, #40]	; (6680 <Output_toggleKbdProtocol_capability+0x60>)
    6658:	4a0a      	ldr	r2, [pc, #40]	; (6684 <Output_toggleKbdProtocol_capability+0x64>)
    665a:	781b      	ldrb	r3, [r3, #0]
    665c:	fab3 f383 	clz	r3, r3
    6660:	095b      	lsrs	r3, r3, #5
    6662:	7013      	strb	r3, [r2, #0]
	USBKeys_Protocol_Change = 1;
    6664:	4b08      	ldr	r3, [pc, #32]	; (6688 <Output_toggleKbdProtocol_capability+0x68>)
    6666:	2201      	movs	r2, #1
    6668:	701a      	strb	r2, [r3, #0]
}
    666a:	9a01      	ldr	r2, [sp, #4]
    666c:	682b      	ldr	r3, [r5, #0]
    666e:	429a      	cmp	r2, r3
    6670:	d1e7      	bne.n	6642 <Output_toggleKbdProtocol_capability+0x22>
    6672:	b003      	add	sp, #12
    6674:	bd30      	pop	{r4, r5, pc}
    6676:	bf00      	nop
    6678:	1fffe9d0 	.word	0x1fffe9d0
    667c:	0000c4e9 	.word	0x0000c4e9
    6680:	1fffeba8 	.word	0x1fffeba8
    6684:	1fffeba9 	.word	0x1fffeba9
    6688:	200007a0 	.word	0x200007a0

0000668c <USB_setup>:
{
    668c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    668e:	4d1c      	ldr	r5, [pc, #112]	; (6700 <USB_setup+0x74>)
    6690:	682b      	ldr	r3, [r5, #0]
    6692:	9301      	str	r3, [sp, #4]
	usb_init();
    6694:	f001 f934 	bl	7900 <usb_init>
	CLI_registerDictionary( usbCLIDict, usbCLIDictName );
    6698:	491a      	ldr	r1, [pc, #104]	; (6704 <USB_setup+0x78>)
    669a:	481b      	ldr	r0, [pc, #108]	; (6708 <USB_setup+0x7c>)
    669c:	f002 fa84 	bl	8ba8 <CLI_registerDictionary>
	USBKeys_Protocol_Change = 0;
    66a0:	4b1a      	ldr	r3, [pc, #104]	; (670c <USB_setup+0x80>)
    66a2:	2400      	movs	r4, #0
    66a4:	701c      	strb	r4, [r3, #0]
	USBKeys_LEDs_prev = 0;
    66a6:	4b1a      	ldr	r3, [pc, #104]	; (6710 <USB_setup+0x84>)
    66a8:	701c      	strb	r4, [r3, #0]
	USBKeys_LEDs = 0;
    66aa:	4b1a      	ldr	r3, [pc, #104]	; (6714 <USB_setup+0x88>)
    66ac:	701c      	strb	r4, [r3, #0]
	USBMouse_Buttons = 0;
    66ae:	4b1a      	ldr	r3, [pc, #104]	; (6718 <USB_setup+0x8c>)
    66b0:	801c      	strh	r4, [r3, #0]
	USBMouse_Relative_x = 0;
    66b2:	4b1a      	ldr	r3, [pc, #104]	; (671c <USB_setup+0x90>)
    66b4:	801c      	strh	r4, [r3, #0]
	USBMouse_Relative_y = 0;
    66b6:	4b1a      	ldr	r3, [pc, #104]	; (6720 <USB_setup+0x94>)
    66b8:	801c      	strh	r4, [r3, #0]
	USBMouse_VertWheel = 0;
    66ba:	4b1a      	ldr	r3, [pc, #104]	; (6724 <USB_setup+0x98>)
    66bc:	701c      	strb	r4, [r3, #0]
	USBMouse_HoriWheel = 0;
    66be:	4b1a      	ldr	r3, [pc, #104]	; (6728 <USB_setup+0x9c>)
    66c0:	701c      	strb	r4, [r3, #0]
	USBMouse_Changed = 0;
    66c2:	4b1a      	ldr	r3, [pc, #104]	; (672c <USB_setup+0xa0>)
    66c4:	701c      	strb	r4, [r3, #0]
	USBDev_Address = 0;
    66c6:	4b1a      	ldr	r3, [pc, #104]	; (6730 <USB_setup+0xa4>)
    66c8:	701c      	strb	r4, [r3, #0]
	USB_flushBuffers();
    66ca:	f7ff ff17 	bl	64fc <USB_flushBuffers>
	VBAT_SECURE1 = 0;
    66ce:	4b19      	ldr	r3, [pc, #100]	; (6734 <USB_setup+0xa8>)
    66d0:	601c      	str	r4, [r3, #0]
	VBAT_SECURE2 = 0;
    66d2:	605c      	str	r4, [r3, #4]
	HIDIO_setup();
    66d4:	f7fe ffd8 	bl	5688 <HIDIO_setup>
	outputPeriodicLatencyResource = Latency_add_resource("USBOutputPeri", LatencyOption_Ticks);
    66d8:	4621      	mov	r1, r4
    66da:	4817      	ldr	r0, [pc, #92]	; (6738 <USB_setup+0xac>)
    66dc:	f002 fd8a 	bl	91f4 <Latency_add_resource>
    66e0:	4b16      	ldr	r3, [pc, #88]	; (673c <USB_setup+0xb0>)
	outputPollLatencyResource = Latency_add_resource("USBOutputPoll", LatencyOption_Ticks);
    66e2:	4621      	mov	r1, r4
	outputPeriodicLatencyResource = Latency_add_resource("USBOutputPeri", LatencyOption_Ticks);
    66e4:	7018      	strb	r0, [r3, #0]
	outputPollLatencyResource = Latency_add_resource("USBOutputPoll", LatencyOption_Ticks);
    66e6:	4816      	ldr	r0, [pc, #88]	; (6740 <USB_setup+0xb4>)
    66e8:	f002 fd84 	bl	91f4 <Latency_add_resource>
    66ec:	4b15      	ldr	r3, [pc, #84]	; (6744 <USB_setup+0xb8>)
}
    66ee:	9a01      	ldr	r2, [sp, #4]
	outputPollLatencyResource = Latency_add_resource("USBOutputPoll", LatencyOption_Ticks);
    66f0:	7018      	strb	r0, [r3, #0]
}
    66f2:	682b      	ldr	r3, [r5, #0]
    66f4:	429a      	cmp	r2, r3
    66f6:	d001      	beq.n	66fc <USB_setup+0x70>
    66f8:	f7fa ff14 	bl	1524 <__stack_chk_fail>
    66fc:	b003      	add	sp, #12
    66fe:	bd30      	pop	{r4, r5, pc}
    6700:	1fffe9d0 	.word	0x1fffe9d0
    6704:	0000c910 	.word	0x0000c910
    6708:	0000c8bc 	.word	0x0000c8bc
    670c:	200007a0 	.word	0x200007a0
    6710:	20000774 	.word	0x20000774
    6714:	2000079b 	.word	0x2000079b
    6718:	20000748 	.word	0x20000748
    671c:	20000798 	.word	0x20000798
    6720:	2000074c 	.word	0x2000074c
    6724:	2000074a 	.word	0x2000074a
    6728:	2000079a 	.word	0x2000079a
    672c:	20000741 	.word	0x20000741
    6730:	20000772 	.word	0x20000772
    6734:	4003e018 	.word	0x4003e018
    6738:	0000c67b 	.word	0x0000c67b
    673c:	1ffff464 	.word	0x1ffff464
    6740:	0000c689 	.word	0x0000c689
    6744:	1ffff465 	.word	0x1ffff465

00006748 <USB_poll>:
{
    6748:	b537      	push	{r0, r1, r2, r4, r5, lr}
    674a:	4d0c      	ldr	r5, [pc, #48]	; (677c <USB_poll+0x34>)
	Latency_start_time( outputPollLatencyResource );
    674c:	4c0c      	ldr	r4, [pc, #48]	; (6780 <USB_poll+0x38>)
{
    674e:	682b      	ldr	r3, [r5, #0]
	Latency_start_time( outputPollLatencyResource );
    6750:	7820      	ldrb	r0, [r4, #0]
{
    6752:	9301      	str	r3, [sp, #4]
	Latency_start_time( outputPollLatencyResource );
    6754:	f002 fdc6 	bl	92e4 <Latency_start_time>
	usb_device_check();
    6758:	f000 fa5c 	bl	6c14 <usb_device_check>
	usb_keyboard_idle_update();
    675c:	f001 fa8a 	bl	7c74 <usb_keyboard_idle_update>
	HIDIO_process();
    6760:	f7ff f92c 	bl	59bc <HIDIO_process>
	Latency_end_time( outputPollLatencyResource );
    6764:	9a01      	ldr	r2, [sp, #4]
    6766:	682b      	ldr	r3, [r5, #0]
    6768:	429a      	cmp	r2, r3
    676a:	d001      	beq.n	6770 <USB_poll+0x28>
    676c:	f7fa feda 	bl	1524 <__stack_chk_fail>
    6770:	7820      	ldrb	r0, [r4, #0]
}
    6772:	b003      	add	sp, #12
    6774:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	Latency_end_time( outputPollLatencyResource );
    6778:	f002 bdd2 	b.w	9320 <Latency_end_time>
    677c:	1fffe9d0 	.word	0x1fffe9d0
    6780:	1ffff465 	.word	0x1ffff465

00006784 <USB_indicator_update>:
{
    6784:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6788:	4c1f      	ldr	r4, [pc, #124]	; (6808 <USB_indicator_update+0x84>)
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    678a:	4e20      	ldr	r6, [pc, #128]	; (680c <USB_indicator_update+0x88>)
{
    678c:	6823      	ldr	r3, [r4, #0]
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    678e:	4d20      	ldr	r5, [pc, #128]	; (6810 <USB_indicator_update+0x8c>)
{
    6790:	9301      	str	r3, [sp, #4]
    6792:	4637      	mov	r7, r6
    6794:	2300      	movs	r3, #0
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    6796:	2101      	movs	r1, #1
    6798:	7830      	ldrb	r0, [r6, #0]
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    679a:	f895 e000 	ldrb.w	lr, [r5]
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    679e:	fa01 f803 	lsl.w	r8, r1, r3
    67a2:	fa4f f288 	sxtb.w	r2, r8
    67a6:	b2c0      	uxtb	r0, r0
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    67a8:	fa5f fe8e 	uxtb.w	lr, lr
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    67ac:	ea02 0c00 	and.w	ip, r2, r0
		if ( cur == 0 && cur == prev )
    67b0:	ea40 000e 	orr.w	r0, r0, lr
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    67b4:	ea02 020e 	and.w	r2, r2, lr
		if ( cur == 0 && cur == prev )
    67b8:	ea10 0f08 	tst.w	r0, r8
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    67bc:	fa4f fc8c 	sxtb.w	ip, ip
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    67c0:	b252      	sxtb	r2, r2
    67c2:	eb03 0801 	add.w	r8, r3, r1
		if ( cur == 0 && cur == prev )
    67c6:	d009      	beq.n	67dc <USB_indicator_update+0x58>
		else if ( cur && cur == prev )
    67c8:	f1bc 0f00 	cmp.w	ip, #0
    67cc:	d012      	beq.n	67f4 <USB_indicator_update+0x70>
    67ce:	4594      	cmp	ip, r2
    67d0:	fa1f f088 	uxth.w	r0, r8
    67d4:	d100      	bne.n	67d8 <USB_indicator_update+0x54>
			Macro_ledState( id, ScheduleType_On );
    67d6:	2102      	movs	r1, #2
			Macro_ledState( id, ScheduleType_D );
    67d8:	f7fd f974 	bl	3ac4 <Macro_ledState>
    67dc:	4643      	mov	r3, r8
	for ( uint8_t bit = 0; bit < LED_KANA_5; bit++ )
    67de:	2b05      	cmp	r3, #5
    67e0:	d1d9      	bne.n	6796 <USB_indicator_update+0x12>
	USBKeys_LEDs_prev = USBKeys_LEDs;
    67e2:	783b      	ldrb	r3, [r7, #0]
    67e4:	b2db      	uxtb	r3, r3
    67e6:	702b      	strb	r3, [r5, #0]
}
    67e8:	9a01      	ldr	r2, [sp, #4]
    67ea:	6823      	ldr	r3, [r4, #0]
    67ec:	429a      	cmp	r2, r3
    67ee:	d007      	beq.n	6800 <USB_indicator_update+0x7c>
    67f0:	f7fa fe98 	bl	1524 <__stack_chk_fail>
		else if ( prev )
    67f4:	2a00      	cmp	r2, #0
    67f6:	d0f1      	beq.n	67dc <USB_indicator_update+0x58>
			Macro_ledState( id, ScheduleType_D );
    67f8:	2103      	movs	r1, #3
    67fa:	fa1f f088 	uxth.w	r0, r8
    67fe:	e7eb      	b.n	67d8 <USB_indicator_update+0x54>
}
    6800:	b002      	add	sp, #8
    6802:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    6806:	bf00      	nop
    6808:	1fffe9d0 	.word	0x1fffe9d0
    680c:	2000079b 	.word	0x2000079b
    6810:	20000774 	.word	0x20000774

00006814 <USB_periodic>:
{
    6814:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6818:	4e2b      	ldr	r6, [pc, #172]	; (68c8 <USB_periodic+0xb4>)
	Latency_start_time( outputPeriodicLatencyResource );
    681a:	4d2c      	ldr	r5, [pc, #176]	; (68cc <USB_periodic+0xb8>)
{
    681c:	6833      	ldr	r3, [r6, #0]
	Latency_start_time( outputPeriodicLatencyResource );
    681e:	7828      	ldrb	r0, [r5, #0]
{
    6820:	9301      	str	r3, [sp, #4]
	Latency_start_time( outputPeriodicLatencyResource );
    6822:	f002 fd5f 	bl	92e4 <Latency_start_time>
	while ( USBMouse_Changed )
    6826:	4c2a      	ldr	r4, [pc, #168]	; (68d0 <USB_periodic+0xbc>)
    6828:	f894 8000 	ldrb.w	r8, [r4]
    682c:	f1b8 0f00 	cmp.w	r8, #0
    6830:	d124      	bne.n	687c <USB_periodic+0x68>
	if ( USBKeys_Protocol_Change )
    6832:	4f28      	ldr	r7, [pc, #160]	; (68d4 <USB_periodic+0xc0>)
    6834:	4c28      	ldr	r4, [pc, #160]	; (68d8 <USB_periodic+0xc4>)
    6836:	783b      	ldrb	r3, [r7, #0]
    6838:	b143      	cbz	r3, 684c <USB_periodic+0x38>
		usb_keyboard_clear( USBKeys_Protocol );
    683a:	7820      	ldrb	r0, [r4, #0]
    683c:	f001 fa4c 	bl	7cd8 <usb_keyboard_clear>
		USBKeys_Protocol = USBKeys_Protocol_New;
    6840:	4b26      	ldr	r3, [pc, #152]	; (68dc <USB_periodic+0xc8>)
    6842:	781b      	ldrb	r3, [r3, #0]
    6844:	b2db      	uxtb	r3, r3
    6846:	7023      	strb	r3, [r4, #0]
		USBKeys_Protocol_Change = 0;
    6848:	f887 8000 	strb.w	r8, [r7]
	if ( USBKeys_Protocol == 0 )
    684c:	7823      	ldrb	r3, [r4, #0]
    684e:	4f24      	ldr	r7, [pc, #144]	; (68e0 <USB_periodic+0xcc>)
    6850:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    6854:	b1ab      	cbz	r3, 6882 <USB_periodic+0x6e>
		usb_keyboard_send( (USBKeys*)&USBKeys_primary, USBKeys_Protocol );
    6856:	f8df 8088 	ldr.w	r8, [pc, #136]	; 68e0 <USB_periodic+0xcc>
	while ( USBKeys_primary.changed )
    685a:	f897 3020 	ldrb.w	r3, [r7, #32]
    685e:	b9d3      	cbnz	r3, 6896 <USB_periodic+0x82>
	switch ( USBKeys_Protocol )
    6860:	7823      	ldrb	r3, [r4, #0]
    6862:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    6866:	b1db      	cbz	r3, 68a0 <USB_periodic+0x8c>
    6868:	2a01      	cmp	r2, #1
    686a:	d023      	beq.n	68b4 <USB_periodic+0xa0>
	USB_indicator_update();
    686c:	f7ff ff8a 	bl	6784 <USB_indicator_update>
	Latency_end_time( outputPeriodicLatencyResource );
    6870:	9a01      	ldr	r2, [sp, #4]
    6872:	6833      	ldr	r3, [r6, #0]
    6874:	429a      	cmp	r2, r3
    6876:	d020      	beq.n	68ba <USB_periodic+0xa6>
    6878:	f7fa fe54 	bl	1524 <__stack_chk_fail>
		usb_mouse_send();
    687c:	f001 faaa 	bl	7dd4 <usb_mouse_send>
    6880:	e7d2      	b.n	6828 <USB_periodic+0x14>
		for ( uint8_t c = USBKeys_Sent; c < USB_BOOT_MAX_KEYS; c++ )
    6882:	4b18      	ldr	r3, [pc, #96]	; (68e4 <USB_periodic+0xd0>)
    6884:	781b      	ldrb	r3, [r3, #0]
    6886:	b2db      	uxtb	r3, r3
    6888:	b2d9      	uxtb	r1, r3
    688a:	2905      	cmp	r1, #5
    688c:	d8e3      	bhi.n	6856 <USB_periodic+0x42>
			USBKeys_primary.keys[c] = 0;
    688e:	18f9      	adds	r1, r7, r3
    6890:	3301      	adds	r3, #1
    6892:	704a      	strb	r2, [r1, #1]
    6894:	e7f8      	b.n	6888 <USB_periodic+0x74>
		usb_keyboard_send( (USBKeys*)&USBKeys_primary, USBKeys_Protocol );
    6896:	7821      	ldrb	r1, [r4, #0]
    6898:	4640      	mov	r0, r8
    689a:	f001 f8e3 	bl	7a64 <usb_keyboard_send>
    689e:	e7dc      	b.n	685a <USB_periodic+0x46>
		Scan_finishedWithOutput( USBKeys_Sent <= USB_BOOT_MAX_KEYS ? USBKeys_Sent : USB_BOOT_MAX_KEYS );
    68a0:	4b10      	ldr	r3, [pc, #64]	; (68e4 <USB_periodic+0xd0>)
    68a2:	781a      	ldrb	r2, [r3, #0]
    68a4:	2a06      	cmp	r2, #6
    68a6:	bf96      	itet	ls
    68a8:	7818      	ldrbls	r0, [r3, #0]
    68aa:	2006      	movhi	r0, #6
    68ac:	b2c0      	uxtbls	r0, r0
		Scan_finishedWithOutput( USBKeys_Sent );
    68ae:	f7fb ffed 	bl	288c <Scan_finishedWithOutput>
		break;
    68b2:	e7db      	b.n	686c <USB_periodic+0x58>
		Scan_finishedWithOutput( USBKeys_Sent );
    68b4:	4b0b      	ldr	r3, [pc, #44]	; (68e4 <USB_periodic+0xd0>)
    68b6:	7818      	ldrb	r0, [r3, #0]
    68b8:	e7f9      	b.n	68ae <USB_periodic+0x9a>
	Latency_end_time( outputPeriodicLatencyResource );
    68ba:	7828      	ldrb	r0, [r5, #0]
}
    68bc:	b002      	add	sp, #8
    68be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	Latency_end_time( outputPeriodicLatencyResource );
    68c2:	f002 bd2d 	b.w	9320 <Latency_end_time>
    68c6:	bf00      	nop
    68c8:	1fffe9d0 	.word	0x1fffe9d0
    68cc:	1ffff464 	.word	0x1ffff464
    68d0:	20000741 	.word	0x20000741
    68d4:	200007a0 	.word	0x200007a0
    68d8:	1fffeba8 	.word	0x1fffeba8
    68dc:	1fffeba9 	.word	0x1fffeba9
    68e0:	20000776 	.word	0x20000776
    68e4:	20000773 	.word	0x20000773

000068e8 <USB_SysCtrlDebug>:
{
    68e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    68ea:	4c0b      	ldr	r4, [pc, #44]	; (6918 <USB_SysCtrlDebug+0x30>)
    68ec:	4605      	mov	r5, r0
    68ee:	6823      	ldr	r3, [r4, #0]
	print("\033[1;34mSysCtrl\033[0m[");
    68f0:	480a      	ldr	r0, [pc, #40]	; (691c <USB_SysCtrlDebug+0x34>)
{
    68f2:	9301      	str	r3, [sp, #4]
	print("\033[1;34mSysCtrl\033[0m[");
    68f4:	f002 fdc8 	bl	9488 <_print>
	printHex_op( buffer->sys_ctrl, 2 );
    68f8:	2102      	movs	r1, #2
    68fa:	7f68      	ldrb	r0, [r5, #29]
    68fc:	f002 feea 	bl	96d4 <printHex_op>
	print( "] " NL );
    6900:	9a01      	ldr	r2, [sp, #4]
    6902:	6823      	ldr	r3, [r4, #0]
    6904:	429a      	cmp	r2, r3
    6906:	d001      	beq.n	690c <USB_SysCtrlDebug+0x24>
    6908:	f7fa fe0c 	bl	1524 <__stack_chk_fail>
    690c:	4804      	ldr	r0, [pc, #16]	; (6920 <USB_SysCtrlDebug+0x38>)
}
    690e:	b003      	add	sp, #12
    6910:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	print( "] " NL );
    6914:	f002 bdb8 	b.w	9488 <_print>
    6918:	1fffe9d0 	.word	0x1fffe9d0
    691c:	0000c662 	.word	0x0000c662
    6920:	0000c676 	.word	0x0000c676

00006924 <USB_ConsCtrlDebug>:
{
    6924:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6926:	4c0b      	ldr	r4, [pc, #44]	; (6954 <USB_ConsCtrlDebug+0x30>)
    6928:	4605      	mov	r5, r0
    692a:	6823      	ldr	r3, [r4, #0]
	print("\033[1;34mConsCtrl\033[0m[");
    692c:	480a      	ldr	r0, [pc, #40]	; (6958 <USB_ConsCtrlDebug+0x34>)
{
    692e:	9301      	str	r3, [sp, #4]
	print("\033[1;34mConsCtrl\033[0m[");
    6930:	f002 fdaa 	bl	9488 <_print>
	printHex_op( buffer->cons_ctrl, 2 );
    6934:	2102      	movs	r1, #2
    6936:	8be8      	ldrh	r0, [r5, #30]
    6938:	f002 fecc 	bl	96d4 <printHex_op>
	print( "] " NL );
    693c:	9a01      	ldr	r2, [sp, #4]
    693e:	6823      	ldr	r3, [r4, #0]
    6940:	429a      	cmp	r2, r3
    6942:	d001      	beq.n	6948 <USB_ConsCtrlDebug+0x24>
    6944:	f7fa fdee 	bl	1524 <__stack_chk_fail>
    6948:	4804      	ldr	r0, [pc, #16]	; (695c <USB_ConsCtrlDebug+0x38>)
}
    694a:	b003      	add	sp, #12
    694c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	print( "] " NL );
    6950:	f002 bd9a 	b.w	9488 <_print>
    6954:	1fffe9d0 	.word	0x1fffe9d0
    6958:	0000c63c 	.word	0x0000c63c
    695c:	0000c676 	.word	0x0000c676

00006960 <USB_6KRODebug>:
{
    6960:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6962:	4d1c      	ldr	r5, [pc, #112]	; (69d4 <USB_6KRODebug+0x74>)
    6964:	4604      	mov	r4, r0
    6966:	682b      	ldr	r3, [r5, #0]
	print("\033[1;34m6KRO\033[0m ");
    6968:	481b      	ldr	r0, [pc, #108]	; (69d8 <USB_6KRODebug+0x78>)
{
    696a:	9301      	str	r3, [sp, #4]
	print("\033[1;34m6KRO\033[0m ");
    696c:	f002 fd8c 	bl	9488 <_print>
	printHex_op( buffer->modifiers, 2 );
    6970:	2102      	movs	r1, #2
    6972:	7820      	ldrb	r0, [r4, #0]
    6974:	f002 feae 	bl	96d4 <printHex_op>
	print(" ");
    6978:	4818      	ldr	r0, [pc, #96]	; (69dc <USB_6KRODebug+0x7c>)
    697a:	f002 fd85 	bl	9488 <_print>
	printHex( 0 );
    697e:	2101      	movs	r1, #1
    6980:	2000      	movs	r0, #0
    6982:	f002 fea7 	bl	96d4 <printHex_op>
	print(" ");
    6986:	4815      	ldr	r0, [pc, #84]	; (69dc <USB_6KRODebug+0x7c>)
    6988:	f002 fd7e 	bl	9488 <_print>
	printHex_op( buffer->keys[0], 2 );
    698c:	2102      	movs	r1, #2
    698e:	7860      	ldrb	r0, [r4, #1]
    6990:	f002 fea0 	bl	96d4 <printHex_op>
	printHex_op( buffer->keys[1], 2 );
    6994:	2102      	movs	r1, #2
    6996:	78a0      	ldrb	r0, [r4, #2]
    6998:	f002 fe9c 	bl	96d4 <printHex_op>
	printHex_op( buffer->keys[2], 2 );
    699c:	2102      	movs	r1, #2
    699e:	78e0      	ldrb	r0, [r4, #3]
    69a0:	f002 fe98 	bl	96d4 <printHex_op>
	printHex_op( buffer->keys[3], 2 );
    69a4:	2102      	movs	r1, #2
    69a6:	7920      	ldrb	r0, [r4, #4]
    69a8:	f002 fe94 	bl	96d4 <printHex_op>
	printHex_op( buffer->keys[4], 2 );
    69ac:	2102      	movs	r1, #2
    69ae:	7960      	ldrb	r0, [r4, #5]
    69b0:	f002 fe90 	bl	96d4 <printHex_op>
	printHex_op( buffer->keys[5], 2 );
    69b4:	2102      	movs	r1, #2
    69b6:	79a0      	ldrb	r0, [r4, #6]
    69b8:	f002 fe8c 	bl	96d4 <printHex_op>
	print( NL );
    69bc:	9a01      	ldr	r2, [sp, #4]
    69be:	682b      	ldr	r3, [r5, #0]
    69c0:	429a      	cmp	r2, r3
    69c2:	d001      	beq.n	69c8 <USB_6KRODebug+0x68>
    69c4:	f7fa fdae 	bl	1524 <__stack_chk_fail>
    69c8:	4805      	ldr	r0, [pc, #20]	; (69e0 <USB_6KRODebug+0x80>)
}
    69ca:	b003      	add	sp, #12
    69cc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	print( NL );
    69d0:	f002 bd5a 	b.w	9488 <_print>
    69d4:	1fffe9d0 	.word	0x1fffe9d0
    69d8:	0000c62b 	.word	0x0000c62b
    69dc:	0000d6a4 	.word	0x0000d6a4
    69e0:	0000d348 	.word	0x0000d348

000069e4 <USB_NKRODebug>:
{
    69e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    69e6:	4604      	mov	r4, r0
    69e8:	4e18      	ldr	r6, [pc, #96]	; (6a4c <USB_NKRODebug+0x68>)
	print("\033[1;34mNKRO\033[0m ");
    69ea:	4819      	ldr	r0, [pc, #100]	; (6a50 <USB_NKRODebug+0x6c>)
{
    69ec:	6833      	ldr	r3, [r6, #0]
    69ee:	9301      	str	r3, [sp, #4]
	printHex_op( buffer->modifiers, 2 );
    69f0:	4625      	mov	r5, r4
	print("\033[1;34mNKRO\033[0m ");
    69f2:	f002 fd49 	bl	9488 <_print>
	printHex_op( buffer->modifiers, 2 );
    69f6:	2102      	movs	r1, #2
    69f8:	f815 0b01 	ldrb.w	r0, [r5], #1
    69fc:	f002 fe6a 	bl	96d4 <printHex_op>
	print(" ");
    6a00:	4814      	ldr	r0, [pc, #80]	; (6a54 <USB_NKRODebug+0x70>)
    6a02:	f002 fd41 	bl	9488 <_print>
    6a06:	f104 0716 	add.w	r7, r4, #22
		printHex_op( buffer->keys[ c ], 2 );
    6a0a:	f815 0b01 	ldrb.w	r0, [r5], #1
    6a0e:	2102      	movs	r1, #2
    6a10:	f002 fe60 	bl	96d4 <printHex_op>
	for ( uint8_t c = 0; c < 21; c++ )
    6a14:	42bd      	cmp	r5, r7
    6a16:	d1f8      	bne.n	6a0a <USB_NKRODebug+0x26>
	print(" ");
    6a18:	480e      	ldr	r0, [pc, #56]	; (6a54 <USB_NKRODebug+0x70>)
    6a1a:	f002 fd35 	bl	9488 <_print>
    6a1e:	f104 0517 	add.w	r5, r4, #23
    6a22:	341d      	adds	r4, #29
		printHex_op( buffer->keys[ c ], 2 );
    6a24:	f815 0b01 	ldrb.w	r0, [r5], #1
    6a28:	2102      	movs	r1, #2
    6a2a:	f002 fe53 	bl	96d4 <printHex_op>
	for ( uint8_t c = 22; c < 28; c++ )
    6a2e:	42a5      	cmp	r5, r4
    6a30:	d1f8      	bne.n	6a24 <USB_NKRODebug+0x40>
	print( NL );
    6a32:	9a01      	ldr	r2, [sp, #4]
    6a34:	6833      	ldr	r3, [r6, #0]
    6a36:	429a      	cmp	r2, r3
    6a38:	d001      	beq.n	6a3e <USB_NKRODebug+0x5a>
    6a3a:	f7fa fd73 	bl	1524 <__stack_chk_fail>
    6a3e:	4806      	ldr	r0, [pc, #24]	; (6a58 <USB_NKRODebug+0x74>)
}
    6a40:	b003      	add	sp, #12
    6a42:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	print( NL );
    6a46:	f002 bd1f 	b.w	9488 <_print>
    6a4a:	bf00      	nop
    6a4c:	1fffe9d0 	.word	0x1fffe9d0
    6a50:	0000c651 	.word	0x0000c651
    6a54:	0000d6a4 	.word	0x0000d6a4
    6a58:	0000d348 	.word	0x0000d348

00006a5c <USB_firmwareReload>:
{
    6a5c:	b507      	push	{r0, r1, r2, lr}
    6a5e:	4b07      	ldr	r3, [pc, #28]	; (6a7c <USB_firmwareReload+0x20>)
    6a60:	681a      	ldr	r2, [r3, #0]
    6a62:	9201      	str	r2, [sp, #4]
	usb_device_reload();
    6a64:	9a01      	ldr	r2, [sp, #4]
    6a66:	681b      	ldr	r3, [r3, #0]
    6a68:	429a      	cmp	r2, r3
    6a6a:	d001      	beq.n	6a70 <USB_firmwareReload+0x14>
    6a6c:	f7fa fd5a 	bl	1524 <__stack_chk_fail>
}
    6a70:	b003      	add	sp, #12
    6a72:	f85d eb04 	ldr.w	lr, [sp], #4
	usb_device_reload();
    6a76:	f000 bd3f 	b.w	74f8 <usb_device_reload>
    6a7a:	bf00      	nop
    6a7c:	1fffe9d0 	.word	0x1fffe9d0

00006a80 <USB_softReset>:
{
    6a80:	b507      	push	{r0, r1, r2, lr}
    6a82:	4b07      	ldr	r3, [pc, #28]	; (6aa0 <USB_softReset+0x20>)
	usb_device_software_reset();
    6a84:	4907      	ldr	r1, [pc, #28]	; (6aa4 <USB_softReset+0x24>)
{
    6a86:	681a      	ldr	r2, [r3, #0]
    6a88:	9201      	str	r2, [sp, #4]
	usb_device_software_reset();
    6a8a:	4a07      	ldr	r2, [pc, #28]	; (6aa8 <USB_softReset+0x28>)
    6a8c:	6011      	str	r1, [r2, #0]
}
    6a8e:	9a01      	ldr	r2, [sp, #4]
    6a90:	681b      	ldr	r3, [r3, #0]
    6a92:	429a      	cmp	r2, r3
    6a94:	d001      	beq.n	6a9a <USB_softReset+0x1a>
    6a96:	f7fa fd45 	bl	1524 <__stack_chk_fail>
    6a9a:	b003      	add	sp, #12
    6a9c:	f85d fb04 	ldr.w	pc, [sp], #4
    6aa0:	1fffe9d0 	.word	0x1fffe9d0
    6aa4:	05fa0004 	.word	0x05fa0004
    6aa8:	e000ed0c 	.word	0xe000ed0c

00006aac <USB_availablechar>:
{
    6aac:	b507      	push	{r0, r1, r2, lr}
    6aae:	4b07      	ldr	r3, [pc, #28]	; (6acc <USB_availablechar+0x20>)
    6ab0:	681a      	ldr	r2, [r3, #0]
    6ab2:	9201      	str	r2, [sp, #4]
	return usb_serial_available();
    6ab4:	9a01      	ldr	r2, [sp, #4]
    6ab6:	681b      	ldr	r3, [r3, #0]
    6ab8:	429a      	cmp	r2, r3
    6aba:	d001      	beq.n	6ac0 <USB_availablechar+0x14>
    6abc:	f7fa fd32 	bl	1524 <__stack_chk_fail>
}
    6ac0:	b003      	add	sp, #12
    6ac2:	f85d eb04 	ldr.w	lr, [sp], #4
	return usb_serial_available();
    6ac6:	f001 bae5 	b.w	8094 <usb_serial_available>
    6aca:	bf00      	nop
    6acc:	1fffe9d0 	.word	0x1fffe9d0

00006ad0 <USB_getchar>:
{
    6ad0:	b507      	push	{r0, r1, r2, lr}
    6ad2:	4b07      	ldr	r3, [pc, #28]	; (6af0 <USB_getchar+0x20>)
    6ad4:	681a      	ldr	r2, [r3, #0]
    6ad6:	9201      	str	r2, [sp, #4]
	return (int)usb_serial_getchar();
    6ad8:	9a01      	ldr	r2, [sp, #4]
    6ada:	681b      	ldr	r3, [r3, #0]
    6adc:	429a      	cmp	r2, r3
    6ade:	d001      	beq.n	6ae4 <USB_getchar+0x14>
    6ae0:	f7fa fd20 	bl	1524 <__stack_chk_fail>
}
    6ae4:	b003      	add	sp, #12
    6ae6:	f85d eb04 	ldr.w	lr, [sp], #4
	return (int)usb_serial_getchar();
    6aea:	f001 baa1 	b.w	8030 <usb_serial_getchar>
    6aee:	bf00      	nop
    6af0:	1fffe9d0 	.word	0x1fffe9d0

00006af4 <USB_putstr>:
{
    6af4:	b513      	push	{r0, r1, r4, lr}
    6af6:	4b0a      	ldr	r3, [pc, #40]	; (6b20 <USB_putstr+0x2c>)
    6af8:	681a      	ldr	r2, [r3, #0]
    6afa:	9201      	str	r2, [sp, #4]
	while ( str[count] != '\0' )
    6afc:	4602      	mov	r2, r0
    6afe:	1a11      	subs	r1, r2, r0
    6b00:	f812 4b01 	ldrb.w	r4, [r2], #1
    6b04:	2c00      	cmp	r4, #0
    6b06:	d1fa      	bne.n	6afe <USB_putstr+0xa>
	return usb_serial_write( str, count );
    6b08:	9a01      	ldr	r2, [sp, #4]
    6b0a:	681b      	ldr	r3, [r3, #0]
    6b0c:	429a      	cmp	r2, r3
    6b0e:	d001      	beq.n	6b14 <USB_putstr+0x20>
    6b10:	f7fa fd08 	bl	1524 <__stack_chk_fail>
}
    6b14:	b002      	add	sp, #8
    6b16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return usb_serial_write( str, count );
    6b1a:	f001 bad7 	b.w	80cc <usb_serial_write>
    6b1e:	bf00      	nop
    6b20:	1fffe9d0 	.word	0x1fffe9d0

00006b24 <USB_rawio_availablechar>:
{
    6b24:	b507      	push	{r0, r1, r2, lr}
    6b26:	4b07      	ldr	r3, [pc, #28]	; (6b44 <USB_rawio_availablechar+0x20>)
    6b28:	681a      	ldr	r2, [r3, #0]
    6b2a:	9201      	str	r2, [sp, #4]
	return usb_rawio_available();
    6b2c:	9a01      	ldr	r2, [sp, #4]
    6b2e:	681b      	ldr	r3, [r3, #0]
    6b30:	429a      	cmp	r2, r3
    6b32:	d001      	beq.n	6b38 <USB_rawio_availablechar+0x14>
    6b34:	f7fa fcf6 	bl	1524 <__stack_chk_fail>
}
    6b38:	b003      	add	sp, #12
    6b3a:	f85d eb04 	ldr.w	lr, [sp], #4
	return usb_rawio_available();
    6b3e:	f001 b9d1 	b.w	7ee4 <usb_rawio_available>
    6b42:	bf00      	nop
    6b44:	1fffe9d0 	.word	0x1fffe9d0

00006b48 <USB_rawio_getbuffer>:
{
    6b48:	b507      	push	{r0, r1, r2, lr}
    6b4a:	4b07      	ldr	r3, [pc, #28]	; (6b68 <USB_rawio_getbuffer+0x20>)
    6b4c:	681a      	ldr	r2, [r3, #0]
    6b4e:	9201      	str	r2, [sp, #4]
	return usb_rawio_rx( (void*)buffer, 0 );
    6b50:	9a01      	ldr	r2, [sp, #4]
    6b52:	681b      	ldr	r3, [r3, #0]
    6b54:	429a      	cmp	r2, r3
    6b56:	d001      	beq.n	6b5c <USB_rawio_getbuffer+0x14>
    6b58:	f7fa fce4 	bl	1524 <__stack_chk_fail>
    6b5c:	2100      	movs	r1, #0
}
    6b5e:	b003      	add	sp, #12
    6b60:	f85d eb04 	ldr.w	lr, [sp], #4
	return usb_rawio_rx( (void*)buffer, 0 );
    6b64:	f001 b9d8 	b.w	7f18 <usb_rawio_rx>
    6b68:	1fffe9d0 	.word	0x1fffe9d0

00006b6c <USB_rawio_sendbuffer>:
{
    6b6c:	b507      	push	{r0, r1, r2, lr}
    6b6e:	4b07      	ldr	r3, [pc, #28]	; (6b8c <USB_rawio_sendbuffer+0x20>)
    6b70:	681a      	ldr	r2, [r3, #0]
    6b72:	9201      	str	r2, [sp, #4]
	return usb_rawio_tx( (void*)buffer, 0 );
    6b74:	9a01      	ldr	r2, [sp, #4]
    6b76:	681b      	ldr	r3, [r3, #0]
    6b78:	429a      	cmp	r2, r3
    6b7a:	d001      	beq.n	6b80 <USB_rawio_sendbuffer+0x14>
    6b7c:	f7fa fcd2 	bl	1524 <__stack_chk_fail>
    6b80:	2100      	movs	r1, #0
}
    6b82:	b003      	add	sp, #12
    6b84:	f85d eb04 	ldr.w	lr, [sp], #4
	return usb_rawio_tx( (void*)buffer, 0 );
    6b88:	f001 ba08 	b.w	7f9c <usb_rawio_tx>
    6b8c:	1fffe9d0 	.word	0x1fffe9d0

00006b90 <usb_set_config_descriptor_size>:
	{0, 0, NULL, 0}
};

// Simplifies defines for USB descriptors
void usb_set_config_descriptor_size()
{
    6b90:	b507      	push	{r0, r1, r2, lr}
    6b92:	4b08      	ldr	r3, [pc, #32]	; (6bb4 <usb_set_config_descriptor_size+0x24>)
    6b94:	681a      	ldr	r2, [r3, #0]
    6b96:	9201      	str	r2, [sp, #4]
	config_descriptor[2] = LSB( sizeof( config_descriptor ) );
    6b98:	4a07      	ldr	r2, [pc, #28]	; (6bb8 <usb_set_config_descriptor_size+0x28>)
    6b9a:	21cf      	movs	r1, #207	; 0xcf
    6b9c:	7091      	strb	r1, [r2, #2]
	config_descriptor[3] = MSB( sizeof( config_descriptor ) );
    6b9e:	2100      	movs	r1, #0
    6ba0:	70d1      	strb	r1, [r2, #3]
}
    6ba2:	9a01      	ldr	r2, [sp, #4]
    6ba4:	681b      	ldr	r3, [r3, #0]
    6ba6:	429a      	cmp	r2, r3
    6ba8:	d001      	beq.n	6bae <usb_set_config_descriptor_size+0x1e>
    6baa:	f7fa fcbb 	bl	1524 <__stack_chk_fail>
    6bae:	b003      	add	sp, #12
    6bb0:	f85d fb04 	ldr.w	pc, [sp], #4
    6bb4:	1fffe9d0 	.word	0x1fffe9d0
    6bb8:	1fffebaa 	.word	0x1fffebaa

00006bbc <endpoint0_transmit>:
	udd_ctrl_stall_data();
#endif
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
    6bbc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6bbe:	4c11      	ldr	r4, [pc, #68]	; (6c04 <endpoint0_transmit+0x48>)
#if defined(_kinetis_)
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6bc0:	4d11      	ldr	r5, [pc, #68]	; (6c08 <endpoint0_transmit+0x4c>)
{
    6bc2:	6823      	ldr	r3, [r4, #0]
    6bc4:	9301      	str	r3, [sp, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6bc6:	782b      	ldrb	r3, [r5, #0]
    6bc8:	4f10      	ldr	r7, [pc, #64]	; (6c0c <endpoint0_transmit+0x50>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6bca:	4e11      	ldr	r6, [pc, #68]	; (6c10 <endpoint0_transmit+0x54>)
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6bcc:	f043 0c02 	orr.w	ip, r3, #2
    6bd0:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    6bd4:	f083 0301 	eor.w	r3, r3, #1
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    6bd8:	6050      	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6bda:	7832      	ldrb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    6bdc:	702b      	strb	r3, [r5, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6bde:	2a00      	cmp	r2, #0
	ep0_tx_data_toggle ^= 1;
    6be0:	f082 0201 	eor.w	r2, r2, #1
    6be4:	7032      	strb	r2, [r6, #0]
#elif defined(_sam_)
	udd_set_setup_payload((uint8_t*)data, len);
#endif
}
    6be6:	9a01      	ldr	r2, [sp, #4]
    6be8:	6823      	ldr	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6bea:	bf14      	ite	ne
    6bec:	20c8      	movne	r0, #200	; 0xc8
    6bee:	2088      	moveq	r0, #136	; 0x88
    6bf0:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
}
    6bf4:	429a      	cmp	r2, r3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    6bf6:	f847 103c 	str.w	r1, [r7, ip, lsl #3]
}
    6bfa:	d001      	beq.n	6c00 <endpoint0_transmit+0x44>
    6bfc:	f7fa fc92 	bl	1524 <__stack_chk_fail>
    6c00:	b003      	add	sp, #12
    6c02:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6c04:	1fffe9d0 	.word	0x1fffe9d0
    6c08:	1ffff4e8 	.word	0x1ffff4e8
    6c0c:	1fffe000 	.word	0x1fffe000
    6c10:	1ffff4e9 	.word	0x1ffff4e9

00006c14 <usb_device_check>:
}

// Used to check any USB state changes that may not have a proper interrupt
// Called once per scan loop, should take minimal processing time or it may affect other modules
void usb_device_check()
{
    6c14:	b513      	push	{r0, r1, r4, lr}
    6c16:	4b11      	ldr	r3, [pc, #68]	; (6c5c <usb_device_check+0x48>)
	// Check to see if we're still waiting for the next USB request after Get Configuration Descriptor
	// If still waiting, restart the USB initialization with a lower power requirement
	if ( power_neg_delay )
    6c18:	4911      	ldr	r1, [pc, #68]	; (6c60 <usb_device_check+0x4c>)
{
    6c1a:	681a      	ldr	r2, [r3, #0]
    6c1c:	9201      	str	r2, [sp, #4]
	if ( power_neg_delay )
    6c1e:	780a      	ldrb	r2, [r1, #0]
    6c20:	4618      	mov	r0, r3
    6c22:	b1a2      	cbz	r2, 6c4e <usb_device_check+0x3a>
	{
		// Check if 100 ms has elapsed
		if ( systick_millis_count - power_neg_time > 100 )
    6c24:	4a0f      	ldr	r2, [pc, #60]	; (6c64 <usb_device_check+0x50>)
    6c26:	4c10      	ldr	r4, [pc, #64]	; (6c68 <usb_device_check+0x54>)
    6c28:	6812      	ldr	r2, [r2, #0]
    6c2a:	6824      	ldr	r4, [r4, #0]
    6c2c:	1b12      	subs	r2, r2, r4
    6c2e:	2a64      	cmp	r2, #100	; 0x64
    6c30:	d90d      	bls.n	6c4e <usb_device_check+0x3a>
		{
			power_neg_delay = 0;
    6c32:	2200      	movs	r2, #0
    6c34:	700a      	strb	r2, [r1, #0]
			*usb_bMaxPower = 50;

			// Re-initialize USB
			usb_reinit();
#else
			warn_msg("USB Low Power Negotation Disabled, condition detected.");
    6c36:	9a01      	ldr	r2, [sp, #4]
    6c38:	681b      	ldr	r3, [r3, #0]
    6c3a:	429a      	cmp	r2, r3
    6c3c:	d001      	beq.n	6c42 <usb_device_check+0x2e>
#endif
		}
	}
}
    6c3e:	f7fa fc71 	bl	1524 <__stack_chk_fail>
			warn_msg("USB Low Power Negotation Disabled, condition detected.");
    6c42:	480a      	ldr	r0, [pc, #40]	; (6c6c <usb_device_check+0x58>)
}
    6c44:	b002      	add	sp, #8
    6c46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			warn_msg("USB Low Power Negotation Disabled, condition detected.");
    6c4a:	f002 bc1d 	b.w	9488 <_print>
}
    6c4e:	9a01      	ldr	r2, [sp, #4]
    6c50:	6803      	ldr	r3, [r0, #0]
    6c52:	429a      	cmp	r2, r3
    6c54:	d1f3      	bne.n	6c3e <usb_device_check+0x2a>
    6c56:	b002      	add	sp, #8
    6c58:	bd10      	pop	{r4, pc}
    6c5a:	bf00      	nop
    6c5c:	1fffe9d0 	.word	0x1fffe9d0
    6c60:	1ffff4f0 	.word	0x1ffff4f0
    6c64:	1ffff048 	.word	0x1ffff048
    6c68:	1ffff4f4 	.word	0x1ffff4f4
    6c6c:	0000cb1b 	.word	0x0000cb1b

00006c70 <usb_set_configuration>:

void usb_set_configuration(uint8_t config) {
    6c70:	b507      	push	{r0, r1, r2, lr}
    6c72:	4a09      	ldr	r2, [pc, #36]	; (6c98 <usb_set_configuration+0x28>)
	usb_configuration = config;
	Output_Available = usb_configuration;
    6c74:	4909      	ldr	r1, [pc, #36]	; (6c9c <usb_set_configuration+0x2c>)
void usb_set_configuration(uint8_t config) {
    6c76:	6813      	ldr	r3, [r2, #0]
    6c78:	9301      	str	r3, [sp, #4]
	usb_configuration = config;
    6c7a:	4b09      	ldr	r3, [pc, #36]	; (6ca0 <usb_set_configuration+0x30>)
    6c7c:	7018      	strb	r0, [r3, #0]
	Output_Available = usb_configuration;
    6c7e:	781b      	ldrb	r3, [r3, #0]
    6c80:	b2db      	uxtb	r3, r3
    6c82:	700b      	strb	r3, [r1, #0]
#if defined(_sam_)
	// Instead of using a callback to set the address for the CLI, just query it after USB is configured
	USBDev_Address = udd_getaddress();
#endif
}
    6c84:	9901      	ldr	r1, [sp, #4]
    6c86:	6813      	ldr	r3, [r2, #0]
    6c88:	4299      	cmp	r1, r3
    6c8a:	d001      	beq.n	6c90 <usb_set_configuration+0x20>
    6c8c:	f7fa fc4a 	bl	1524 <__stack_chk_fail>
    6c90:	b003      	add	sp, #12
    6c92:	f85d fb04 	ldr.w	pc, [sp], #4
    6c96:	bf00      	nop
    6c98:	1fffe9d0 	.word	0x1fffe9d0
    6c9c:	2000073a 	.word	0x2000073a
    6ca0:	1ffff5b2 	.word	0x1ffff5b2

00006ca4 <usb_setup>:

void usb_setup()
{
    6ca4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6ca8:	4ebe      	ldr	r6, [pc, #760]	; (6fa4 <usb_setup+0x300>)
	uint32_t datalen = 0;
	const usb_descriptor_list_t *list;
	uint32_t size;

	// Reset USB Init timer
	USBInit_TimeEnd = systick_millis_count;
    6caa:	4fbf      	ldr	r7, [pc, #764]	; (6fa8 <usb_setup+0x304>)
{
    6cac:	6833      	ldr	r3, [r6, #0]
    6cae:	b085      	sub	sp, #20
    6cb0:	9303      	str	r3, [sp, #12]
	USBInit_TimeEnd = systick_millis_count;
    6cb2:	4bbe      	ldr	r3, [pc, #760]	; (6fac <usb_setup+0x308>)
    6cb4:	683a      	ldr	r2, [r7, #0]
    6cb6:	601a      	str	r2, [r3, #0]
	USBInit_Ticks++;
    6cb8:	4abd      	ldr	r2, [pc, #756]	; (6fb0 <usb_setup+0x30c>)
    6cba:	8813      	ldrh	r3, [r2, #0]
    6cbc:	3301      	adds	r3, #1
    6cbe:	b29b      	uxth	r3, r3
    6cc0:	8013      	strh	r3, [r2, #0]
	setup = *(setup_t*)&udd_g_ctrlreq.req;
#endif

	// If another request is made, disable the power negotiation check
	// See GET_DESCRIPTOR - Configuration
	if ( power_neg_delay )
    6cc2:	4abc      	ldr	r2, [pc, #752]	; (6fb4 <usb_setup+0x310>)
    6cc4:	7813      	ldrb	r3, [r2, #0]
    6cc6:	b10b      	cbz	r3, 6ccc <usb_setup+0x28>
	{
		power_neg_delay = 0;
    6cc8:	2300      	movs	r3, #0
    6cca:	7013      	strb	r3, [r2, #0]
	}

	switch ( setup.wRequestAndType )
    6ccc:	4cba      	ldr	r4, [pc, #744]	; (6fb8 <usb_setup+0x314>)
    6cce:	8823      	ldrh	r3, [r4, #0]
    6cd0:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    6cd4:	4625      	mov	r5, r4
    6cd6:	f000 80ff 	beq.w	6ed8 <usb_setup+0x234>
    6cda:	d84f      	bhi.n	6d7c <usb_setup+0xd8>
    6cdc:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    6ce0:	f000 81d2 	beq.w	7088 <usb_setup+0x3e4>
    6ce4:	d82d      	bhi.n	6d42 <usb_setup+0x9e>
    6ce6:	2b82      	cmp	r3, #130	; 0x82
    6ce8:	f000 81b3 	beq.w	7052 <usb_setup+0x3ae>
    6cec:	d80f      	bhi.n	6d0e <usb_setup+0x6a>
    6cee:	2b80      	cmp	r3, #128	; 0x80
    6cf0:	f000 81a0 	beq.w	7034 <usb_setup+0x390>
    6cf4:	2b81      	cmp	r3, #129	; 0x81
    6cf6:	f000 81a8 	beq.w	704a <usb_setup+0x3a6>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    6cfa:	4bb0      	ldr	r3, [pc, #704]	; (6fbc <usb_setup+0x318>)
    6cfc:	220f      	movs	r2, #15
    6cfe:	701a      	strb	r2, [r3, #0]
	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
#elif defined(_sam_)
	endpoint0_transmit( data, size );
#endif
}
    6d00:	9a03      	ldr	r2, [sp, #12]
    6d02:	6833      	ldr	r3, [r6, #0]
    6d04:	429a      	cmp	r2, r3
    6d06:	f000 8270 	beq.w	71ea <usb_setup+0x546>
    6d0a:	f7fa fc0b 	bl	1524 <__stack_chk_fail>
	switch ( setup.wRequestAndType )
    6d0e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    6d12:	f000 81b2 	beq.w	707a <usb_setup+0x3d6>
    6d16:	f240 1201 	movw	r2, #257	; 0x101
    6d1a:	4293      	cmp	r3, r2
    6d1c:	d1ed      	bne.n	6cfa <usb_setup+0x56>
		warn_msg("CLEAR_FEATURE - Interface wValue(");
    6d1e:	48a8      	ldr	r0, [pc, #672]	; (6fc0 <usb_setup+0x31c>)
    6d20:	f002 fbb2 	bl	9488 <_print>
		printHex( setup.wValue );
    6d24:	2101      	movs	r1, #1
    6d26:	8860      	ldrh	r0, [r4, #2]
    6d28:	f002 fcd4 	bl	96d4 <printHex_op>
		print(") wIndex(");
    6d2c:	48a5      	ldr	r0, [pc, #660]	; (6fc4 <usb_setup+0x320>)
    6d2e:	f002 fbab 	bl	9488 <_print>
		printHex( setup.wIndex );
    6d32:	88a0      	ldrh	r0, [r4, #4]
    6d34:	2101      	movs	r1, #1
    6d36:	f002 fccd 	bl	96d4 <printHex_op>
		print( ")" NL );
    6d3a:	48a3      	ldr	r0, [pc, #652]	; (6fc8 <usb_setup+0x324>)
    6d3c:	f002 fba4 	bl	9488 <_print>
    6d40:	e7db      	b.n	6cfa <usb_setup+0x56>
	switch ( setup.wRequestAndType )
    6d42:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    6d46:	f000 81b3 	beq.w	70b0 <usb_setup+0x40c>
    6d4a:	d80a      	bhi.n	6d62 <usb_setup+0xbe>
    6d4c:	f240 12a1 	movw	r2, #417	; 0x1a1
    6d50:	4293      	cmp	r3, r2
    6d52:	f000 80b0 	beq.w	6eb6 <usb_setup+0x212>
    6d56:	f240 22a1 	movw	r2, #673	; 0x2a1
    6d5a:	4293      	cmp	r3, r2
    6d5c:	d1cd      	bne.n	6cfa <usb_setup+0x56>
		reply_buffer[0] = USBKeys_Idle_Config;
    6d5e:	4b9b      	ldr	r3, [pc, #620]	; (6fcc <usb_setup+0x328>)
    6d60:	e165      	b.n	702e <usb_setup+0x38a>
	switch ( setup.wRequestAndType )
    6d62:	f240 3202 	movw	r2, #770	; 0x302
    6d66:	4293      	cmp	r3, r2
    6d68:	f000 81ba 	beq.w	70e0 <usb_setup+0x43c>
    6d6c:	f0c0 81b6 	bcc.w	70dc <usb_setup+0x438>
    6d70:	f240 32a1 	movw	r2, #929	; 0x3a1
    6d74:	4293      	cmp	r3, r2
    6d76:	d1c0      	bne.n	6cfa <usb_setup+0x56>
		reply_buffer[0] = USBKeys_Protocol_New; // Must be the same data set by SET_PROTOCOL
    6d78:	4b95      	ldr	r3, [pc, #596]	; (6fd0 <usb_setup+0x32c>)
    6d7a:	e158      	b.n	702e <usb_setup+0x38a>
	switch ( setup.wRequestAndType )
    6d7c:	f640 2181 	movw	r1, #2689	; 0xa81
    6d80:	428b      	cmp	r3, r1
    6d82:	f000 81bc 	beq.w	70fe <usb_setup+0x45a>
    6d86:	d86f      	bhi.n	6e68 <usb_setup+0x1c4>
    6d88:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    6d8c:	f000 814e 	beq.w	702c <usb_setup+0x388>
    6d90:	d81b      	bhi.n	6dca <usb_setup+0x126>
    6d92:	f5a3 63d0 	sub.w	r3, r3, #1664	; 0x680
    6d96:	2b01      	cmp	r3, #1
    6d98:	d8af      	bhi.n	6cfa <usb_setup+0x56>
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    6d9a:	8861      	ldrh	r1, [r4, #2]
    6d9c:	88a0      	ldrh	r0, [r4, #4]
		for ( list = usb_descriptor_list; 1; list++ )
    6d9e:	4b8d      	ldr	r3, [pc, #564]	; (6fd4 <usb_setup+0x330>)
			if ( list->addr == NULL )
    6da0:	685c      	ldr	r4, [r3, #4]
    6da2:	2c00      	cmp	r4, #0
    6da4:	d0a9      	beq.n	6cfa <usb_setup+0x56>
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    6da6:	f8b3 c000 	ldrh.w	ip, [r3]
    6daa:	458c      	cmp	ip, r1
    6dac:	f040 81e6 	bne.w	717c <usb_setup+0x4d8>
    6db0:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    6db4:	4584      	cmp	ip, r0
    6db6:	f040 81e1 	bne.w	717c <usb_setup+0x4d8>
				if ( (setup.wValue >> 8) == 3 )
    6dba:	ea4f 2c11 	mov.w	ip, r1, lsr #8
    6dbe:	f1bc 0f03 	cmp.w	ip, #3
    6dc2:	f040 81cf 	bne.w	7164 <usb_setup+0x4c0>
					datalen = *(list->addr);
    6dc6:	7823      	ldrb	r3, [r4, #0]
    6dc8:	e1a1      	b.n	710e <usb_setup+0x46a>
	switch ( setup.wRequestAndType )
    6dca:	f640 1221 	movw	r2, #2337	; 0x921
    6dce:	4293      	cmp	r3, r2
    6dd0:	f000 81d9 	beq.w	7186 <usb_setup+0x4e2>
    6dd4:	f640 2221 	movw	r2, #2593	; 0xa21
    6dd8:	4293      	cmp	r3, r2
    6dda:	f000 81e8 	beq.w	71ae <usb_setup+0x50a>
    6dde:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    6de2:	d18a      	bne.n	6cfa <usb_setup+0x56>
		usb_set_configuration(setup.wValue);
    6de4:	78a0      	ldrb	r0, [r4, #2]
			if ( table[i].desc & BDT_OWN )
    6de6:	f8df 8224 	ldr.w	r8, [pc, #548]	; 700c <usb_setup+0x368>
		usb_set_configuration(setup.wValue);
    6dea:	f7ff ff41 	bl	6c70 <usb_set_configuration>
		Output_update_usb_current( *usb_bMaxPower * 2 );
    6dee:	4b7a      	ldr	r3, [pc, #488]	; (6fd8 <usb_setup+0x334>)
    6df0:	681b      	ldr	r3, [r3, #0]
    6df2:	7818      	ldrb	r0, [r3, #0]
    6df4:	0040      	lsls	r0, r0, #1
    6df6:	f7fe fec5 	bl	5b84 <Output_update_usb_current>
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
    6dfa:	2704      	movs	r7, #4
    6dfc:	4644      	mov	r4, r8
			if ( table[i].desc & BDT_OWN )
    6dfe:	f858 2037 	ldr.w	r2, [r8, r7, lsl #3]
    6e02:	0611      	lsls	r1, r2, #24
    6e04:	ea4f 03c7 	mov.w	r3, r7, lsl #3
    6e08:	d504      	bpl.n	6e14 <usb_setup+0x170>
				usb_free( (usb_packet_t *)((uint8_t *)(table[ i ].addr) - 8) );
    6e0a:	4443      	add	r3, r8
    6e0c:	6858      	ldr	r0, [r3, #4]
    6e0e:	3808      	subs	r0, #8
    6e10:	f000 ffa8 	bl	7d64 <usb_free>
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
    6e14:	3701      	adds	r7, #1
    6e16:	2f2c      	cmp	r7, #44	; 0x2c
    6e18:	d1f1      	bne.n	6dfe <usb_setup+0x15a>
			p = rx_first[i];
    6e1a:	4f70      	ldr	r7, [pc, #448]	; (6fdc <usb_setup+0x338>)
			rx_last[ i ] = NULL;
    6e1c:	f8df 81f0 	ldr.w	r8, [pc, #496]	; 7010 <usb_setup+0x36c>
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
    6e20:	f04f 0a00 	mov.w	sl, #0
    6e24:	46b9      	mov	r9, r7
			p = rx_first[i];
    6e26:	f857 002a 	ldr.w	r0, [r7, sl, lsl #2]
    6e2a:	ea4f 0b8a 	mov.w	fp, sl, lsl #2
			while ( p )
    6e2e:	2800      	cmp	r0, #0
    6e30:	d156      	bne.n	6ee0 <usb_setup+0x23c>
			p = tx_first[i];
    6e32:	4b6b      	ldr	r3, [pc, #428]	; (6fe0 <usb_setup+0x33c>)
			rx_first[ i ] = NULL;
    6e34:	f849 000b 	str.w	r0, [r9, fp]
			rx_last[ i ] = NULL;
    6e38:	f84b 0008 	str.w	r0, [fp, r8]
			p = tx_first[i];
    6e3c:	f85b 0003 	ldr.w	r0, [fp, r3]
			while (p)
    6e40:	2800      	cmp	r0, #0
    6e42:	d154      	bne.n	6eee <usb_setup+0x24a>
			tx_first[ i ] = NULL;
    6e44:	f843 000b 	str.w	r0, [r3, fp]
			tx_last[ i ] = NULL;
    6e48:	4b66      	ldr	r3, [pc, #408]	; (6fe4 <usb_setup+0x340>)
			switch ( tx_state[ i ] )
    6e4a:	4a67      	ldr	r2, [pc, #412]	; (6fe8 <usb_setup+0x344>)
			tx_last[ i ] = NULL;
    6e4c:	f84b 0003 	str.w	r0, [fp, r3]
			usb_rx_byte_count_data[i] = 0;
    6e50:	4b66      	ldr	r3, [pc, #408]	; (6fec <usb_setup+0x348>)
    6e52:	f823 001a 	strh.w	r0, [r3, sl, lsl #1]
			switch ( tx_state[ i ] )
    6e56:	f812 300a 	ldrb.w	r3, [r2, sl]
    6e5a:	3b02      	subs	r3, #2
    6e5c:	2b03      	cmp	r3, #3
    6e5e:	d852      	bhi.n	6f06 <usb_setup+0x262>
    6e60:	e8df f003 	tbb	[pc, r3]
    6e64:	934e934e 	.word	0x934e934e
	switch ( setup.wRequestAndType )
    6e68:	f640 4282 	movw	r2, #3202	; 0xc82
    6e6c:	4293      	cmp	r3, r2
    6e6e:	f000 816b 	beq.w	7148 <usb_setup+0x4a4>
    6e72:	d80f      	bhi.n	6e94 <usb_setup+0x1f0>
    6e74:	f640 3201 	movw	r2, #2817	; 0xb01
    6e78:	4293      	cmp	r3, r2
    6e7a:	f000 815c 	beq.w	7136 <usb_setup+0x492>
    6e7e:	f640 3221 	movw	r2, #2849	; 0xb21
    6e82:	4293      	cmp	r3, r2
    6e84:	f47f af39 	bne.w	6cfa <usb_setup+0x56>
		USBKeys_Protocol_New = setup.wValue & 0xFF; // 0 - Boot Mode, 1 - NKRO Mode
    6e88:	4b51      	ldr	r3, [pc, #324]	; (6fd0 <usb_setup+0x32c>)
    6e8a:	78a2      	ldrb	r2, [r4, #2]
    6e8c:	701a      	strb	r2, [r3, #0]
		USBKeys_Protocol_Change = 1;
    6e8e:	4b58      	ldr	r3, [pc, #352]	; (6ff0 <usb_setup+0x34c>)
    6e90:	2201      	movs	r2, #1
    6e92:	e023      	b.n	6edc <usb_setup+0x238>
	switch ( setup.wRequestAndType )
    6e94:	f242 12a1 	movw	r2, #8609	; 0x21a1
    6e98:	4293      	cmp	r3, r2
    6e9a:	f000 8190 	beq.w	71be <usb_setup+0x51a>
    6e9e:	f242 2221 	movw	r2, #8737	; 0x2221
    6ea2:	4293      	cmp	r3, r2
    6ea4:	f000 816c 	beq.w	7180 <usb_setup+0x4dc>
    6ea8:	f242 0221 	movw	r2, #8225	; 0x2021
    6eac:	4293      	cmp	r3, r2
    6eae:	f47f af24 	bne.w	6cfa <usb_setup+0x56>
	uint32_t datalen = 0;
    6eb2:	2300      	movs	r3, #0
    6eb4:	e0fa      	b.n	70ac <usb_setup+0x408>
			if ( setup.wIndex == list->wIndex )
    6eb6:	88a2      	ldrh	r2, [r4, #4]
		for ( list = usb_descriptor_list; 1; list++ )
    6eb8:	4b46      	ldr	r3, [pc, #280]	; (6fd4 <usb_setup+0x330>)
			if ( list->addr == NULL )
    6eba:	685c      	ldr	r4, [r3, #4]
    6ebc:	2c00      	cmp	r4, #0
    6ebe:	f43f af1c 	beq.w	6cfa <usb_setup+0x56>
			if ( list->wValue != 0x2200 )
    6ec2:	8819      	ldrh	r1, [r3, #0]
    6ec4:	f5b1 5f08 	cmp.w	r1, #8704	; 0x2200
    6ec8:	f040 816f 	bne.w	71aa <usb_setup+0x506>
			if ( setup.wIndex == list->wIndex )
    6ecc:	8859      	ldrh	r1, [r3, #2]
    6ece:	4291      	cmp	r1, r2
    6ed0:	f040 816b 	bne.w	71aa <usb_setup+0x506>
				datalen = list->length;
    6ed4:	891b      	ldrh	r3, [r3, #8]
				goto send;
    6ed6:	e11a      	b.n	710e <usb_setup+0x46a>
		USBDev_Address = setup.wValue;
    6ed8:	78a2      	ldrb	r2, [r4, #2]
    6eda:	4b46      	ldr	r3, [pc, #280]	; (6ff4 <usb_setup+0x350>)
		USBKeys_Protocol_Change = 1;
    6edc:	701a      	strb	r2, [r3, #0]
    6ede:	e7e8      	b.n	6eb2 <usb_setup+0x20e>
				n = p->next;
    6ee0:	6843      	ldr	r3, [r0, #4]
    6ee2:	9300      	str	r3, [sp, #0]
				usb_free(p);
    6ee4:	f000 ff3e 	bl	7d64 <usb_free>
				p = n;
    6ee8:	9b00      	ldr	r3, [sp, #0]
    6eea:	4618      	mov	r0, r3
    6eec:	e79f      	b.n	6e2e <usb_setup+0x18a>
				n = p->next;
    6eee:	6842      	ldr	r2, [r0, #4]
    6ef0:	9301      	str	r3, [sp, #4]
    6ef2:	9200      	str	r2, [sp, #0]
				usb_free(p);
    6ef4:	f000 ff36 	bl	7d64 <usb_free>
				p = n;
    6ef8:	9a00      	ldr	r2, [sp, #0]
    6efa:	9b01      	ldr	r3, [sp, #4]
    6efc:	4610      	mov	r0, r2
    6efe:	e79f      	b.n	6e40 <usb_setup+0x19c>
				tx_state[ i ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    6f00:	2300      	movs	r3, #0
				tx_state[ i ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6f02:	f802 300a 	strb.w	r3, [r2, sl]
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
    6f06:	f10a 0a01 	add.w	sl, sl, #1
    6f0a:	f1ba 0f0a 	cmp.w	sl, #10
    6f0e:	d18a      	bne.n	6e26 <usb_setup+0x182>
		usb_rx_memory_needed = 0;
    6f10:	4b39      	ldr	r3, [pc, #228]	; (6ff8 <usb_setup+0x354>)
    6f12:	4f3a      	ldr	r7, [pc, #232]	; (6ffc <usb_setup+0x358>)
		reg = &USB0_ENDPT1;
    6f14:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 7014 <usb_setup+0x370>
    6f18:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 7018 <usb_setup+0x374>
		usb_rx_memory_needed = 0;
    6f1c:	2200      	movs	r2, #0
    6f1e:	701a      	strb	r2, [r3, #0]
    6f20:	469b      	mov	fp, r3
			epconf = *cfg++;
    6f22:	f817 3f01 	ldrb.w	r3, [r7, #1]!
			*reg = epconf;
    6f26:	f80a 3b04 	strb.w	r3, [sl], #4
			if ( epconf & USB_ENDPT_EPRXEN )
    6f2a:	071a      	lsls	r2, r3, #28
    6f2c:	eb0a 0809 	add.w	r8, sl, r9
    6f30:	d51e      	bpl.n	6f70 <usb_setup+0x2cc>
				p = usb_malloc();
    6f32:	f000 feed 	bl	7d10 <usb_malloc>
    6f36:	ea4f 03ca 	mov.w	r3, sl, lsl #3
				if ( p )
    6f3a:	b340      	cbz	r0, 6f8e <usb_setup+0x2ea>
    6f3c:	4423      	add	r3, r4
					table[ index( i, RX, EVEN ) ].addr = p->buf;
    6f3e:	f5a3 1364 	sub.w	r3, r3, #3735552	; 0x390000
    6f42:	f2a3 6c1c 	subw	ip, r3, #1564	; 0x61c
    6f46:	3008      	adds	r0, #8
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    6f48:	f5a3 63c4 	sub.w	r3, r3, #1568	; 0x620
					table[ index( i, RX, EVEN ) ].addr = p->buf;
    6f4c:	f8cc 0000 	str.w	r0, [ip]
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    6f50:	482b      	ldr	r0, [pc, #172]	; (7000 <usb_setup+0x35c>)
    6f52:	6018      	str	r0, [r3, #0]
				p = usb_malloc();
    6f54:	f000 fedc 	bl	7d10 <usb_malloc>
    6f58:	f048 0301 	orr.w	r3, r8, #1
				if ( p )
    6f5c:	2800      	cmp	r0, #0
    6f5e:	d05d      	beq.n	701c <usb_setup+0x378>
					table[ index( i, RX, ODD ) ].addr = p->buf;
    6f60:	eb04 0cc3 	add.w	ip, r4, r3, lsl #3
					table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    6f64:	4a27      	ldr	r2, [pc, #156]	; (7004 <usb_setup+0x360>)
    6f66:	f844 2033 	str.w	r2, [r4, r3, lsl #3]
					table[ index( i, RX, ODD ) ].addr = p->buf;
    6f6a:	3008      	adds	r0, #8
    6f6c:	f8cc 0004 	str.w	r0, [ip, #4]
			table[ index( i, TX, EVEN ) ].desc = 0;
    6f70:	f048 0002 	orr.w	r0, r8, #2
			table[ index( i, TX, ODD ) ].desc = 0;
    6f74:	f048 0103 	orr.w	r1, r8, #3
			table[ index( i, TX, EVEN ) ].desc = 0;
    6f78:	2300      	movs	r3, #0
    6f7a:	f844 3030 	str.w	r3, [r4, r0, lsl #3]
			table[ index( i, TX, ODD ) ].desc = 0;
    6f7e:	f844 3031 	str.w	r3, [r4, r1, lsl #3]
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    6f82:	4b21      	ldr	r3, [pc, #132]	; (7008 <usb_setup+0x364>)
    6f84:	459a      	cmp	sl, r3
    6f86:	d1cc      	bne.n	6f22 <usb_setup+0x27e>
    6f88:	e793      	b.n	6eb2 <usb_setup+0x20e>
				tx_state[ i ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    6f8a:	2301      	movs	r3, #1
    6f8c:	e7b9      	b.n	6f02 <usb_setup+0x25e>
					table[ index( i, RX, EVEN ) ].desc = 0;
    6f8e:	f5a3 1364 	sub.w	r3, r3, #3735552	; 0x390000
    6f92:	f5a3 63c4 	sub.w	r3, r3, #1568	; 0x620
    6f96:	50e0      	str	r0, [r4, r3]
					usb_rx_memory_needed++;
    6f98:	f89b 3000 	ldrb.w	r3, [fp]
    6f9c:	3301      	adds	r3, #1
    6f9e:	f88b 3000 	strb.w	r3, [fp]
    6fa2:	e7d7      	b.n	6f54 <usb_setup+0x2b0>
    6fa4:	1fffe9d0 	.word	0x1fffe9d0
    6fa8:	1ffff048 	.word	0x1ffff048
    6fac:	20000744 	.word	0x20000744
    6fb0:	2000074e 	.word	0x2000074e
    6fb4:	1ffff4f0 	.word	0x1ffff4f0
    6fb8:	1ffff550 	.word	0x1ffff550
    6fbc:	400720c0 	.word	0x400720c0
    6fc0:	0000cb99 	.word	0x0000cb99
    6fc4:	0000cbd0 	.word	0x0000cbd0
    6fc8:	0000d303 	.word	0x0000d303
    6fcc:	1ffff463 	.word	0x1ffff463
    6fd0:	1fffeba9 	.word	0x1fffeba9
    6fd4:	0000c990 	.word	0x0000c990
    6fd8:	1fffedf4 	.word	0x1fffedf4
    6fdc:	1ffff500 	.word	0x1ffff500
    6fe0:	1ffff558 	.word	0x1ffff558
    6fe4:	1ffff580 	.word	0x1ffff580
    6fe8:	1ffff5a8 	.word	0x1ffff5a8
    6fec:	200007a8 	.word	0x200007a8
    6ff0:	200007a0 	.word	0x200007a0
    6ff4:	20000772 	.word	0x20000772
    6ff8:	1ffff5b6 	.word	0x1ffff5b6
    6ffc:	0000cad3 	.word	0x0000cad3
    7000:	00400088 	.word	0x00400088
    7004:	004000c8 	.word	0x004000c8
    7008:	400720ec 	.word	0x400720ec
    700c:	1fffe000 	.word	0x1fffe000
    7010:	1ffff528 	.word	0x1ffff528
    7014:	400720c4 	.word	0x400720c4
    7018:	bff8df3c 	.word	0xbff8df3c
					table[ index( i, RX, ODD ) ].desc = 0;
    701c:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
					usb_rx_memory_needed++;
    7020:	f89b 3000 	ldrb.w	r3, [fp]
    7024:	3301      	adds	r3, #1
    7026:	f88b 3000 	strb.w	r3, [fp]
    702a:	e7a1      	b.n	6f70 <usb_setup+0x2cc>
		reply_buffer[0] = usb_configuration;
    702c:	4b70      	ldr	r3, [pc, #448]	; (71f0 <usb_setup+0x54c>)
		reply_buffer[0] = USBKeys_Idle_Config;
    702e:	781b      	ldrb	r3, [r3, #0]
    7030:	4c70      	ldr	r4, [pc, #448]	; (71f4 <usb_setup+0x550>)
    7032:	e06a      	b.n	710a <usb_setup+0x466>
		reply_buffer[0] = (usb_remote_wakeup ? 1 : 0) << 1; // D1 is the remote wakeup bit
    7034:	4b70      	ldr	r3, [pc, #448]	; (71f8 <usb_setup+0x554>)
    7036:	4c6f      	ldr	r4, [pc, #444]	; (71f4 <usb_setup+0x550>)
    7038:	781b      	ldrb	r3, [r3, #0]
    703a:	2b00      	cmp	r3, #0
    703c:	bf18      	it	ne
    703e:	2302      	movne	r3, #2
    7040:	7023      	strb	r3, [r4, #0]
		reply_buffer[1] = 0;
    7042:	2300      	movs	r3, #0
		reply_buffer[1] = 0;
    7044:	7063      	strb	r3, [r4, #1]
		datalen = 2;
    7046:	2302      	movs	r3, #2
    7048:	e061      	b.n	710e <usb_setup+0x46a>
		reply_buffer[0] = 0;
    704a:	4c6a      	ldr	r4, [pc, #424]	; (71f4 <usb_setup+0x550>)
    704c:	2300      	movs	r3, #0
    704e:	7023      	strb	r3, [r4, #0]
    7050:	e7f8      	b.n	7044 <usb_setup+0x3a0>
		uint8_t endpoint = setup.wIndex & 0x0F; // D0..D3 Endpoint Number
    7052:	7923      	ldrb	r3, [r4, #4]
    7054:	4a69      	ldr	r2, [pc, #420]	; (71fc <usb_setup+0x558>)
    7056:	f003 030f 	and.w	r3, r3, #15
		if ( endpoint > NUM_ENDPOINTS )
    705a:	2b0a      	cmp	r3, #10
    705c:	d902      	bls.n	7064 <usb_setup+0x3c0>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    705e:	230f      	movs	r3, #15
    7060:	7013      	strb	r3, [r2, #0]
    7062:	e64d      	b.n	6d00 <usb_setup+0x5c>
		reply_buffer[0] = 0;
    7064:	4c63      	ldr	r4, [pc, #396]	; (71f4 <usb_setup+0x550>)
    7066:	2100      	movs	r1, #0
    7068:	7021      	strb	r1, [r4, #0]
		reply_buffer[1] = 0;
    706a:	7061      	strb	r1, [r4, #1]
		if ( *(uint8_t *)(&USB0_ENDPT0 + endpoint * 4) & USB_ENDPT_EPSTALL )
    706c:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
    7070:	079b      	lsls	r3, r3, #30
    7072:	d5e8      	bpl.n	7046 <usb_setup+0x3a2>
			reply_buffer[0] = 1;
    7074:	2301      	movs	r3, #1
    7076:	7023      	strb	r3, [r4, #0]
    7078:	e7e5      	b.n	7046 <usb_setup+0x3a2>
		switch ( setup.wValue )
    707a:	8863      	ldrh	r3, [r4, #2]
    707c:	2b01      	cmp	r3, #1
    707e:	d127      	bne.n	70d0 <usb_setup+0x42c>
			usb_remote_wakeup = 0;
    7080:	4a5d      	ldr	r2, [pc, #372]	; (71f8 <usb_setup+0x554>)
    7082:	2300      	movs	r3, #0
			USBKeys_Idle_Config = USBIdle_define;
    7084:	7013      	strb	r3, [r2, #0]
    7086:	e011      	b.n	70ac <usb_setup+0x408>
		uint8_t endpoint = setup.wIndex & 0x0F; // D0..D3 Endpoint Number
    7088:	7922      	ldrb	r2, [r4, #4]
    708a:	495c      	ldr	r1, [pc, #368]	; (71fc <usb_setup+0x558>)
    708c:	f002 020f 	and.w	r2, r2, #15
		if ( endpoint > NUM_ENDPOINTS || setup.wValue != 0 )
    7090:	2a0a      	cmp	r2, #10
    7092:	d801      	bhi.n	7098 <usb_setup+0x3f4>
    7094:	8863      	ldrh	r3, [r4, #2]
    7096:	b113      	cbz	r3, 709e <usb_setup+0x3fa>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    7098:	230f      	movs	r3, #15
    709a:	700b      	strb	r3, [r1, #0]
    709c:	e630      	b.n	6d00 <usb_setup+0x5c>
		(*(uint8_t *)(&USB0_ENDPT0 + endpoint * 4)) &= ~USB_ENDPT_EPSTALL;
    709e:	b212      	sxth	r2, r2
    70a0:	f811 0022 	ldrb.w	r0, [r1, r2, lsl #2]
    70a4:	f020 0002 	bic.w	r0, r0, #2
		(*(uint8_t *)(&USB0_ENDPT0 + endpoint * 4)) |= USB_ENDPT_EPSTALL;
    70a8:	f801 0022 	strb.w	r0, [r1, r2, lsl #2]
	const uint8_t *data = NULL;
    70ac:	461c      	mov	r4, r3
    70ae:	e02e      	b.n	710e <usb_setup+0x46a>
		warn_msg("(SET_FEATURE, SETUP)  - ");
    70b0:	4853      	ldr	r0, [pc, #332]	; (7200 <usb_setup+0x55c>)
    70b2:	f002 f9e9 	bl	9488 <_print>
		printHex32( setup.wValue );
    70b6:	2101      	movs	r1, #1
    70b8:	8860      	ldrh	r0, [r4, #2]
    70ba:	f002 fb5d 	bl	9778 <printHex32_op>
		print(NL);
    70be:	4851      	ldr	r0, [pc, #324]	; (7204 <usb_setup+0x560>)
    70c0:	f002 f9e2 	bl	9488 <_print>
		switch ( setup.wValue )
    70c4:	8863      	ldrh	r3, [r4, #2]
    70c6:	2b01      	cmp	r3, #1
    70c8:	d102      	bne.n	70d0 <usb_setup+0x42c>
			usb_remote_wakeup = 1;
    70ca:	4a4b      	ldr	r2, [pc, #300]	; (71f8 <usb_setup+0x554>)
    70cc:	7013      	strb	r3, [r2, #0]
    70ce:	e6f0      	b.n	6eb2 <usb_setup+0x20e>
		warn_msg("SET_FEATURE - Device wValue(");
    70d0:	484d      	ldr	r0, [pc, #308]	; (7208 <usb_setup+0x564>)
    70d2:	f002 f9d9 	bl	9488 <_print>
		printHex( setup.wValue );
    70d6:	2101      	movs	r1, #1
    70d8:	8860      	ldrh	r0, [r4, #2]
    70da:	e62c      	b.n	6d36 <usb_setup+0x92>
		warn_msg("SET_FEATURE - Interface wValue(");
    70dc:	484b      	ldr	r0, [pc, #300]	; (720c <usb_setup+0x568>)
    70de:	e61f      	b.n	6d20 <usb_setup+0x7c>
		uint8_t endpoint = setup.wIndex & 0x0F; // D0..D3 Endpoint Number
    70e0:	7922      	ldrb	r2, [r4, #4]
    70e2:	4946      	ldr	r1, [pc, #280]	; (71fc <usb_setup+0x558>)
    70e4:	f002 020f 	and.w	r2, r2, #15
		if ( endpoint > NUM_ENDPOINTS || setup.wValue != 0 )
    70e8:	2a0a      	cmp	r2, #10
    70ea:	d8d5      	bhi.n	7098 <usb_setup+0x3f4>
    70ec:	8863      	ldrh	r3, [r4, #2]
    70ee:	2b00      	cmp	r3, #0
    70f0:	d1d2      	bne.n	7098 <usb_setup+0x3f4>
		(*(uint8_t *)(&USB0_ENDPT0 + endpoint * 4)) |= USB_ENDPT_EPSTALL;
    70f2:	b212      	sxth	r2, r2
    70f4:	f811 0022 	ldrb.w	r0, [r1, r2, lsl #2]
    70f8:	f040 0002 	orr.w	r0, r0, #2
    70fc:	e7d4      	b.n	70a8 <usb_setup+0x404>
		if ( setup.wIndex > NUM_INTERFACES )
    70fe:	88a3      	ldrh	r3, [r4, #4]
    7100:	2b08      	cmp	r3, #8
    7102:	f63f adfa 	bhi.w	6cfa <usb_setup+0x56>
		reply_buffer[0] = 0;
    7106:	4c3b      	ldr	r4, [pc, #236]	; (71f4 <usb_setup+0x550>)
    7108:	2300      	movs	r3, #0
    710a:	7023      	strb	r3, [r4, #0]
		datalen = 1;
    710c:	2301      	movs	r3, #1
	if ( datalen > setup.wLength )
    710e:	88ef      	ldrh	r7, [r5, #6]
    7110:	429f      	cmp	r7, r3
    7112:	bf28      	it	cs
    7114:	461f      	movcs	r7, r3
    7116:	2f40      	cmp	r7, #64	; 0x40
    7118:	463d      	mov	r5, r7
    711a:	bf28      	it	cs
    711c:	2540      	movcs	r5, #64	; 0x40
	endpoint0_transmit( data, size );
    711e:	4629      	mov	r1, r5
    7120:	4620      	mov	r0, r4
    7122:	f7ff fd4b 	bl	6bbc <endpoint0_transmit>
	data += size;
    7126:	442c      	add	r4, r5
	if ( datalen == 0 && size < EP0_SIZE )
    7128:	1b7d      	subs	r5, r7, r5
    712a:	d14b      	bne.n	71c4 <usb_setup+0x520>
    712c:	2f3f      	cmp	r7, #63	; 0x3f
    712e:	f67f ade7 	bls.w	6d00 <usb_setup+0x5c>
    7132:	462f      	mov	r7, r5
    7134:	e04a      	b.n	71cc <usb_setup+0x528>
		if ( setup.wIndex > NUM_INTERFACES || setup.wValue != 0 )
    7136:	88a3      	ldrh	r3, [r4, #4]
    7138:	2b08      	cmp	r3, #8
    713a:	f63f adde 	bhi.w	6cfa <usb_setup+0x56>
    713e:	8863      	ldrh	r3, [r4, #2]
    7140:	2b00      	cmp	r3, #0
    7142:	f43f aeb6 	beq.w	6eb2 <usb_setup+0x20e>
    7146:	e5d8      	b.n	6cfa <usb_setup+0x56>
		uint8_t endpoint = setup.wIndex & 0x0F; // D0..D3 Endpoint Number
    7148:	7923      	ldrb	r3, [r4, #4]
    714a:	4a2c      	ldr	r2, [pc, #176]	; (71fc <usb_setup+0x558>)
    714c:	f003 030f 	and.w	r3, r3, #15
		if ( endpoint <= NUM_ENDPOINTS )
    7150:	2b0a      	cmp	r3, #10
    7152:	d884      	bhi.n	705e <usb_setup+0x3ba>
			if ( ( (*(uint8_t *)(&USB0_ENDPT0 + endpoint * 4)) & USB_ENDPT_EPHSHK ) == 0 )
    7154:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
    7158:	f013 0301 	ands.w	r3, r3, #1
    715c:	f47f af7f 	bne.w	705e <usb_setup+0x3ba>
				reply_buffer[0] = 0;
    7160:	4c24      	ldr	r4, [pc, #144]	; (71f4 <usb_setup+0x550>)
    7162:	e774      	b.n	704e <usb_setup+0x3aa>
				if ( setup.wValue == 0x0200 && setup.wIndex == 0x0 )
    7164:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
					datalen = list->length;
    7168:	891b      	ldrh	r3, [r3, #8]
				if ( setup.wValue == 0x0200 && setup.wIndex == 0x0 )
    716a:	d1d0      	bne.n	710e <usb_setup+0x46a>
    716c:	2800      	cmp	r0, #0
    716e:	d1ce      	bne.n	710e <usb_setup+0x46a>
					power_neg_delay = 1;
    7170:	2101      	movs	r1, #1
    7172:	7011      	strb	r1, [r2, #0]
					power_neg_time = systick_millis_count;
    7174:	4a26      	ldr	r2, [pc, #152]	; (7210 <usb_setup+0x56c>)
    7176:	6839      	ldr	r1, [r7, #0]
    7178:	6011      	str	r1, [r2, #0]
    717a:	e7c8      	b.n	710e <usb_setup+0x46a>
		for ( list = usb_descriptor_list; 1; list++ )
    717c:	330c      	adds	r3, #12
			if ( list->addr == NULL )
    717e:	e60f      	b.n	6da0 <usb_setup+0xfc>
		usb_cdc_line_rtsdtr = setup.wValue;
    7180:	78a2      	ldrb	r2, [r4, #2]
    7182:	4b24      	ldr	r3, [pc, #144]	; (7214 <usb_setup+0x570>)
    7184:	e6aa      	b.n	6edc <usb_setup+0x238>
    7186:	7922      	ldrb	r2, [r4, #4]
    7188:	2a05      	cmp	r2, #5
    718a:	d805      	bhi.n	7198 <usb_setup+0x4f4>
    718c:	2301      	movs	r3, #1
    718e:	4093      	lsls	r3, r2
    7190:	f013 0f23 	tst.w	r3, #35	; 0x23
    7194:	f47f ae8d 	bne.w	6eb2 <usb_setup+0x20e>
			warn_msg("(SET_REPORT, SETUP) Unknown interface - ");
    7198:	481f      	ldr	r0, [pc, #124]	; (7218 <usb_setup+0x574>)
    719a:	f002 f975 	bl	9488 <_print>
			printHex( setup.wIndex );
    719e:	88a8      	ldrh	r0, [r5, #4]
    71a0:	2101      	movs	r1, #1
    71a2:	f002 fa97 	bl	96d4 <printHex_op>
			print( NL );
    71a6:	4817      	ldr	r0, [pc, #92]	; (7204 <usb_setup+0x560>)
    71a8:	e5c8      	b.n	6d3c <usb_setup+0x98>
		for ( list = usb_descriptor_list; 1; list++ )
    71aa:	330c      	adds	r3, #12
			if ( list->addr == NULL )
    71ac:	e685      	b.n	6eba <usb_setup+0x216>
		USBKeys_Idle_Config = (setup.wValue >> 8);
    71ae:	8863      	ldrh	r3, [r4, #2]
    71b0:	4a1a      	ldr	r2, [pc, #104]	; (721c <usb_setup+0x578>)
		USBKeys_Idle_Expiry = 0;
    71b2:	491b      	ldr	r1, [pc, #108]	; (7220 <usb_setup+0x57c>)
		USBKeys_Idle_Config = (setup.wValue >> 8);
    71b4:	0a1b      	lsrs	r3, r3, #8
    71b6:	7013      	strb	r3, [r2, #0]
		USBKeys_Idle_Expiry = 0;
    71b8:	2300      	movs	r3, #0
    71ba:	600b      	str	r3, [r1, #0]
    71bc:	e762      	b.n	7084 <usb_setup+0x3e0>
		datalen = sizeof( usb_cdc_line_coding );
    71be:	2308      	movs	r3, #8
		data = (uint8_t*)&usb_cdc_line_coding;
    71c0:	4c18      	ldr	r4, [pc, #96]	; (7224 <usb_setup+0x580>)
    71c2:	e7a4      	b.n	710e <usb_setup+0x46a>
    71c4:	2d40      	cmp	r5, #64	; 0x40
    71c6:	462f      	mov	r7, r5
    71c8:	bf28      	it	cs
    71ca:	2740      	movcs	r7, #64	; 0x40
	endpoint0_transmit( data, size );
    71cc:	4620      	mov	r0, r4
    71ce:	4639      	mov	r1, r7
    71d0:	f7ff fcf4 	bl	6bbc <endpoint0_transmit>
	if ( datalen == 0 && size < EP0_SIZE )
    71d4:	1bed      	subs	r5, r5, r7
	data += size;
    71d6:	443c      	add	r4, r7
	if ( datalen == 0 && size < EP0_SIZE )
    71d8:	d102      	bne.n	71e0 <usb_setup+0x53c>
    71da:	2f40      	cmp	r7, #64	; 0x40
    71dc:	f47f ad90 	bne.w	6d00 <usb_setup+0x5c>
	ep0_tx_ptr = data;
    71e0:	4b11      	ldr	r3, [pc, #68]	; (7228 <usb_setup+0x584>)
    71e2:	601c      	str	r4, [r3, #0]
	ep0_tx_len = datalen;
    71e4:	4b11      	ldr	r3, [pc, #68]	; (722c <usb_setup+0x588>)
    71e6:	801d      	strh	r5, [r3, #0]
    71e8:	e58a      	b.n	6d00 <usb_setup+0x5c>
}
    71ea:	b005      	add	sp, #20
    71ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    71f0:	1ffff5b2 	.word	0x1ffff5b2
    71f4:	1ffff4f8 	.word	0x1ffff4f8
    71f8:	1ffff5b5 	.word	0x1ffff5b5
    71fc:	400720c0 	.word	0x400720c0
    7200:	0000cbda 	.word	0x0000cbda
    7204:	0000d348 	.word	0x0000d348
    7208:	0000cb67 	.word	0x0000cb67
    720c:	0000cc08 	.word	0x0000cc08
    7210:	1ffff4f4 	.word	0x1ffff4f4
    7214:	1ffff5c8 	.word	0x1ffff5c8
    7218:	0000cc3d 	.word	0x0000cc3d
    721c:	1ffff463 	.word	0x1ffff463
    7220:	2000079c 	.word	0x2000079c
    7224:	1fffefdc 	.word	0x1fffefdc
    7228:	1ffff4ec 	.word	0x1ffff4ec
    722c:	1ffff4ea 	.word	0x1ffff4ea

00007230 <keyboard_control>:


void keyboard_control(uint8_t *buf) {
    7230:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7232:	4d17      	ldr	r5, [pc, #92]	; (7290 <keyboard_control+0x60>)
#endif

	// Keyboard HID SET_REPORT - PID=OUT
	#if enableKeyboard_define == 1
	// XXX - Getting lots of NAKs in Linux
	if ( setup.wRequestAndType == 0x0921 && setup.wValue & 0x200 )
    7234:	4c17      	ldr	r4, [pc, #92]	; (7294 <keyboard_control+0x64>)
void keyboard_control(uint8_t *buf) {
    7236:	682b      	ldr	r3, [r5, #0]
	if ( setup.wRequestAndType == 0x0921 && setup.wValue & 0x200 )
    7238:	8822      	ldrh	r2, [r4, #0]
void keyboard_control(uint8_t *buf) {
    723a:	9301      	str	r3, [sp, #4]
	if ( setup.wRequestAndType == 0x0921 && setup.wValue & 0x200 )
    723c:	f640 1321 	movw	r3, #2337	; 0x921
    7240:	429a      	cmp	r2, r3
    7242:	4629      	mov	r1, r5
    7244:	d116      	bne.n	7274 <keyboard_control+0x44>
    7246:	8863      	ldrh	r3, [r4, #2]
    7248:	059b      	lsls	r3, r3, #22
    724a:	d513      	bpl.n	7274 <keyboard_control+0x44>
		print("]");
		print( NL );
		#endif

		// Interface
		switch ( setup.wIndex & 0xFF )
    724c:	7923      	ldrb	r3, [r4, #4]
    724e:	b173      	cbz	r3, 726e <keyboard_control+0x3e>
    7250:	2b01      	cmp	r3, #1
    7252:	d015      	beq.n	7280 <keyboard_control+0x50>
			// Already set with the control sequence
			// Only use 2nd byte, first byte is the report id
			USBKeys_LEDs = buf[1];
			break;
		default:
			warn_msg("(SET_REPORT, BULK) Unknown interface - ");
    7254:	4810      	ldr	r0, [pc, #64]	; (7298 <keyboard_control+0x68>)
    7256:	f002 f917 	bl	9488 <_print>
			printHex( setup.wIndex );
    725a:	2101      	movs	r1, #1
    725c:	88a0      	ldrh	r0, [r4, #4]
    725e:	f002 fa39 	bl	96d4 <printHex_op>
			print( NL );
    7262:	9a01      	ldr	r2, [sp, #4]
    7264:	682b      	ldr	r3, [r5, #0]
    7266:	429a      	cmp	r2, r3
    7268:	d00c      	beq.n	7284 <keyboard_control+0x54>

		// XXX ZLP causes timeout/delay, why? -HaaTa
		//endpoint0_transmit( NULL, 0 );
	}
	#endif
}
    726a:	f7fa f95b 	bl	1524 <__stack_chk_fail>
			USBKeys_LEDs = buf[0];
    726e:	7802      	ldrb	r2, [r0, #0]
			USBKeys_LEDs = buf[1];
    7270:	4b0a      	ldr	r3, [pc, #40]	; (729c <keyboard_control+0x6c>)
    7272:	701a      	strb	r2, [r3, #0]
}
    7274:	9a01      	ldr	r2, [sp, #4]
    7276:	680b      	ldr	r3, [r1, #0]
    7278:	429a      	cmp	r2, r3
    727a:	d1f6      	bne.n	726a <keyboard_control+0x3a>
    727c:	b003      	add	sp, #12
    727e:	bd30      	pop	{r4, r5, pc}
			USBKeys_LEDs = buf[1];
    7280:	7842      	ldrb	r2, [r0, #1]
    7282:	e7f5      	b.n	7270 <keyboard_control+0x40>
			print( NL );
    7284:	4806      	ldr	r0, [pc, #24]	; (72a0 <keyboard_control+0x70>)
}
    7286:	b003      	add	sp, #12
    7288:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			print( NL );
    728c:	f002 b8fc 	b.w	9488 <_print>
    7290:	1fffe9d0 	.word	0x1fffe9d0
    7294:	1ffff550 	.word	0x1ffff550
    7298:	0000cade 	.word	0x0000cade
    729c:	2000079b 	.word	0x2000079b
    72a0:	0000d348 	.word	0x0000d348

000072a4 <usb_rx>:
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
}
#endif

usb_packet_t *usb_rx( uint32_t endpoint )
{
    72a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    72a6:	4a10      	ldr	r2, [pc, #64]	; (72e8 <usb_rx+0x44>)
    72a8:	6813      	ldr	r3, [r2, #0]
    72aa:	9301      	str	r3, [sp, #4]
	//print("USB RX");

#if defined(_kinetis_)
	usb_packet_t *ret;
	endpoint--;
    72ac:	1e43      	subs	r3, r0, #1

	// Make sure this is a valid endpoint
	if ( endpoint >= NUM_ENDPOINTS )
    72ae:	2b09      	cmp	r3, #9
    72b0:	d815      	bhi.n	72de <usb_rx+0x3a>
	{
		return NULL;
	}

	__disable_irq();
    72b2:	b672      	cpsid	i

	// Receive packet, check pointer
	ret = rx_first[endpoint];
    72b4:	490d      	ldr	r1, [pc, #52]	; (72ec <usb_rx+0x48>)
    72b6:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if ( ret )
    72ba:	b148      	cbz	r0, 72d0 <usb_rx+0x2c>
	{
		rx_first[ endpoint ] = ret->next;
    72bc:	6844      	ldr	r4, [r0, #4]
    72be:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
		usb_rx_byte_count_data[ endpoint ] -= ret->len;
    72c2:	4c0b      	ldr	r4, [pc, #44]	; (72f0 <usb_rx+0x4c>)
    72c4:	8805      	ldrh	r5, [r0, #0]
    72c6:	f834 1013 	ldrh.w	r1, [r4, r3, lsl #1]
    72ca:	1b49      	subs	r1, r1, r5
    72cc:	f824 1013 	strh.w	r1, [r4, r3, lsl #1]
	}

	__enable_irq();
    72d0:	b662      	cpsie	i
	udd_ep_run(endpoint | USB_EP_DIR_OUT, false, ret->buf, ret->len, NULL);

	return ret;
#endif

}
    72d2:	9901      	ldr	r1, [sp, #4]
    72d4:	6813      	ldr	r3, [r2, #0]
    72d6:	4299      	cmp	r1, r3
    72d8:	d003      	beq.n	72e2 <usb_rx+0x3e>
    72da:	f7fa f923 	bl	1524 <__stack_chk_fail>
		return NULL;
    72de:	2000      	movs	r0, #0
    72e0:	e7f7      	b.n	72d2 <usb_rx+0x2e>
}
    72e2:	b003      	add	sp, #12
    72e4:	bd30      	pop	{r4, r5, pc}
    72e6:	bf00      	nop
    72e8:	1fffe9d0 	.word	0x1fffe9d0
    72ec:	1ffff500 	.word	0x1ffff500
    72f0:	200007a8 	.word	0x200007a8

000072f4 <usb_tx_packet_count>:
	return usb_queue_byte_count( tx_first[ endpoint ] );
}
#endif

uint32_t usb_tx_packet_count( uint32_t endpoint )
{
    72f4:	b507      	push	{r0, r1, r2, lr}
    72f6:	4b0d      	ldr	r3, [pc, #52]	; (732c <usb_tx_packet_count+0x38>)
	uint32_t count=0;

#if defined(_kinetis_)
	const usb_packet_t *p;

	endpoint--;
    72f8:	3801      	subs	r0, #1
{
    72fa:	681a      	ldr	r2, [r3, #0]
    72fc:	9201      	str	r2, [sp, #4]
	if ( endpoint >= NUM_ENDPOINTS )
    72fe:	2809      	cmp	r0, #9
    7300:	d80f      	bhi.n	7322 <usb_tx_packet_count+0x2e>
		return 0;
	__disable_irq();
    7302:	b672      	cpsid	i
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    7304:	4a0a      	ldr	r2, [pc, #40]	; (7330 <usb_tx_packet_count+0x3c>)
    7306:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
	uint32_t count=0;
    730a:	2000      	movs	r0, #0
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    730c:	b932      	cbnz	r2, 731c <usb_tx_packet_count+0x28>
		count++;
	__enable_irq();
    730e:	b662      	cpsie	i
#endif

	return count;
}
    7310:	9a01      	ldr	r2, [sp, #4]
    7312:	681b      	ldr	r3, [r3, #0]
    7314:	429a      	cmp	r2, r3
    7316:	d006      	beq.n	7326 <usb_tx_packet_count+0x32>
    7318:	f7fa f904 	bl	1524 <__stack_chk_fail>
		count++;
    731c:	3001      	adds	r0, #1
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    731e:	6852      	ldr	r2, [r2, #4]
    7320:	e7f4      	b.n	730c <usb_tx_packet_count+0x18>
		return 0;
    7322:	2000      	movs	r0, #0
    7324:	e7f4      	b.n	7310 <usb_tx_packet_count+0x1c>
}
    7326:	b003      	add	sp, #12
    7328:	f85d fb04 	ldr.w	pc, [sp], #4
    732c:	1fffe9d0 	.word	0x1fffe9d0
    7330:	1ffff558 	.word	0x1ffff558

00007334 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory( usb_packet_t *packet )
{
    7334:	b573      	push	{r0, r1, r4, r5, r6, lr}
    7336:	491f      	ldr	r1, [pc, #124]	; (73b4 <usb_rx_memory+0x80>)
    7338:	680b      	ldr	r3, [r1, #0]
    733a:	9301      	str	r3, [sp, #4]
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    733c:	b672      	cpsid	i
    733e:	4d1e      	ldr	r5, [pc, #120]	; (73b8 <usb_rx_memory+0x84>)
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
	{
		if ( *cfg++ & USB_ENDPT_EPRXEN )
		{
			if ( table[ index( i, RX, EVEN ) ].desc == 0 )
    7340:	4a1e      	ldr	r2, [pc, #120]	; (73bc <usb_rx_memory+0x88>)
	__disable_irq();
    7342:	2304      	movs	r3, #4
		if ( *cfg++ & USB_ENDPT_EPRXEN )
    7344:	f815 4f01 	ldrb.w	r4, [r5, #1]!
    7348:	0724      	lsls	r4, r4, #28
    734a:	d521      	bpl.n	7390 <usb_rx_memory+0x5c>
			if ( table[ index( i, RX, EVEN ) ].desc == 0 )
    734c:	f852 6033 	ldr.w	r6, [r2, r3, lsl #3]
    7350:	00dc      	lsls	r4, r3, #3
    7352:	b986      	cbnz	r6, 7376 <usb_rx_memory+0x42>
			{
				table[ index( i, RX, EVEN ) ].addr = packet->buf;
    7354:	4414      	add	r4, r2
    7356:	3008      	adds	r0, #8
    7358:	6060      	str	r0, [r4, #4]
				table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    735a:	4819      	ldr	r0, [pc, #100]	; (73c0 <usb_rx_memory+0x8c>)
    735c:	f842 0033 	str.w	r0, [r2, r3, lsl #3]
			}
			if ( table[ index( i, RX, ODD ) ].desc == 0 )
			{
				table[ index( i, RX, ODD ) ].addr = packet->buf;
				table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
				usb_rx_memory_needed--;
    7360:	4a18      	ldr	r2, [pc, #96]	; (73c4 <usb_rx_memory+0x90>)
    7362:	7813      	ldrb	r3, [r2, #0]
    7364:	3b01      	subs	r3, #1
    7366:	7013      	strb	r3, [r2, #0]
				__enable_irq();
    7368:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free( packet );
	return;
}
    736a:	9a01      	ldr	r2, [sp, #4]
    736c:	680b      	ldr	r3, [r1, #0]
    736e:	429a      	cmp	r2, r3
    7370:	d01e      	beq.n	73b0 <usb_rx_memory+0x7c>
    7372:	f7fa f8d7 	bl	1524 <__stack_chk_fail>
			if ( table[ index( i, RX, ODD ) ].desc == 0 )
    7376:	f043 0401 	orr.w	r4, r3, #1
    737a:	f852 6034 	ldr.w	r6, [r2, r4, lsl #3]
    737e:	b93e      	cbnz	r6, 7390 <usb_rx_memory+0x5c>
				table[ index( i, RX, ODD ) ].addr = packet->buf;
    7380:	eb02 03c4 	add.w	r3, r2, r4, lsl #3
    7384:	3008      	adds	r0, #8
    7386:	6058      	str	r0, [r3, #4]
				table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    7388:	4b0f      	ldr	r3, [pc, #60]	; (73c8 <usb_rx_memory+0x94>)
    738a:	f842 3034 	str.w	r3, [r2, r4, lsl #3]
    738e:	e7e7      	b.n	7360 <usb_rx_memory+0x2c>
    7390:	3304      	adds	r3, #4
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    7392:	2b2c      	cmp	r3, #44	; 0x2c
    7394:	d1d6      	bne.n	7344 <usb_rx_memory+0x10>
	__enable_irq();
    7396:	b662      	cpsie	i
	usb_rx_memory_needed = 0;
    7398:	4b0a      	ldr	r3, [pc, #40]	; (73c4 <usb_rx_memory+0x90>)
    739a:	2200      	movs	r2, #0
    739c:	701a      	strb	r2, [r3, #0]
	usb_free( packet );
    739e:	9a01      	ldr	r2, [sp, #4]
    73a0:	680b      	ldr	r3, [r1, #0]
    73a2:	429a      	cmp	r2, r3
    73a4:	d1e5      	bne.n	7372 <usb_rx_memory+0x3e>
}
    73a6:	b002      	add	sp, #8
    73a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	usb_free( packet );
    73ac:	f000 bcda 	b.w	7d64 <usb_free>
}
    73b0:	b002      	add	sp, #8
    73b2:	bd70      	pop	{r4, r5, r6, pc}
    73b4:	1fffe9d0 	.word	0x1fffe9d0
    73b8:	0000cad3 	.word	0x0000cad3
    73bc:	1fffe000 	.word	0x1fffe000
    73c0:	00400088 	.word	0x00400088
    73c4:	1ffff5b6 	.word	0x1ffff5b6
    73c8:	004000c8 	.word	0x004000c8

000073cc <usb_tx>:

	return 0;
}

void usb_tx( uint32_t endpoint, usb_packet_t *packet )
{
    73cc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    73ce:	4e27      	ldr	r6, [pc, #156]	; (746c <usb_tx+0xa0>)
    73d0:	6833      	ldr	r3, [r6, #0]
    73d2:	9301      	str	r3, [sp, #4]
	// Update expiry counter
	USBKeys_Idle_Expiry = systick_millis_count;
    73d4:	4b26      	ldr	r3, [pc, #152]	; (7470 <usb_tx+0xa4>)
    73d6:	681a      	ldr	r2, [r3, #0]
    73d8:	4b26      	ldr	r3, [pc, #152]	; (7474 <usb_tx+0xa8>)
    73da:	601a      	str	r2, [r3, #0]

	// Since we are transmitting data, USB will be brought out of sleep/suspend
	// if it's in that state
	// Use the currently set descriptor value
	Output_update_usb_current( *usb_bMaxPower * 2 );
    73dc:	4b26      	ldr	r3, [pc, #152]	; (7478 <usb_tx+0xac>)
    73de:	681b      	ldr	r3, [r3, #0]
{
    73e0:	4604      	mov	r4, r0
	Output_update_usb_current( *usb_bMaxPower * 2 );
    73e2:	7818      	ldrb	r0, [r3, #0]
    73e4:	0040      	lsls	r0, r0, #1
{
    73e6:	460d      	mov	r5, r1
	Output_update_usb_current( *usb_bMaxPower * 2 );
    73e8:	f7fe fbcc 	bl	5b84 <Output_update_usb_current>

#if defined(_kinetis_)
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
	uint8_t next;

	endpoint--;
    73ec:	1e63      	subs	r3, r4, #1
	if ( endpoint >= NUM_ENDPOINTS )
    73ee:	2b09      	cmp	r3, #9
    73f0:	4632      	mov	r2, r6
    73f2:	d82c      	bhi.n	744e <usb_tx+0x82>
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
    73f4:	0164      	lsls	r4, r4, #5
    73f6:	4821      	ldr	r0, [pc, #132]	; (747c <usb_tx+0xb0>)
    73f8:	f044 0410 	orr.w	r4, r4, #16
    73fc:	4420      	add	r0, r4
		return;
	__disable_irq();
    73fe:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[ endpoint ]);
	//serial_print("\n");
	switch ( tx_state[ endpoint ] )
    7400:	491f      	ldr	r1, [pc, #124]	; (7480 <usb_tx+0xb4>)
    7402:	5ccc      	ldrb	r4, [r1, r3]
    7404:	2c03      	cmp	r4, #3
    7406:	d818      	bhi.n	743a <usb_tx+0x6e>
    7408:	e8df f004 	tbb	[pc, r4]
    740c:	1402112b 	.word	0x1402112b
	case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    7410:	2405      	movs	r4, #5
		tx_last[ endpoint ] = packet;
		__enable_irq();
		return;
	}

	tx_state[ endpoint ] = next;
    7412:	54cc      	strb	r4, [r1, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    7414:	f010 0f08 	tst.w	r0, #8
	b->addr = packet->buf;
    7418:	f105 0308 	add.w	r3, r5, #8
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    741c:	8829      	ldrh	r1, [r5, #0]
	b->addr = packet->buf;
    741e:	6043      	str	r3, [r0, #4]
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    7420:	bf14      	ite	ne
    7422:	23c8      	movne	r3, #200	; 0xc8
    7424:	2388      	moveq	r3, #136	; 0x88
    7426:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    742a:	6003      	str	r3, [r0, #0]
    742c:	e00e      	b.n	744c <usb_tx+0x80>
		b++;
    742e:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    7430:	2402      	movs	r4, #2
		break;
    7432:	e7ee      	b.n	7412 <usb_tx+0x46>
		b++;
    7434:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    7436:	2404      	movs	r4, #4
		break;
    7438:	e7eb      	b.n	7412 <usb_tx+0x46>
		if (tx_first[ endpoint ] == NULL)
    743a:	4812      	ldr	r0, [pc, #72]	; (7484 <usb_tx+0xb8>)
    743c:	4912      	ldr	r1, [pc, #72]	; (7488 <usb_tx+0xbc>)
    743e:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    7442:	b954      	cbnz	r4, 745a <usb_tx+0x8e>
			tx_first[ endpoint ] = packet;
    7444:	f840 5023 	str.w	r5, [r0, r3, lsl #2]
		tx_last[ endpoint ] = packet;
    7448:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
	__enable_irq();
    744c:	b662      	cpsie	i

#elif defined(_sam_)
	udd_ep_run(endpoint | USB_EP_DIR_IN, false, packet->buf, packet->len, NULL);
#endif
}
    744e:	9901      	ldr	r1, [sp, #4]
    7450:	6813      	ldr	r3, [r2, #0]
    7452:	4299      	cmp	r1, r3
    7454:	d007      	beq.n	7466 <usb_tx+0x9a>
    7456:	f7fa f865 	bl	1524 <__stack_chk_fail>
			tx_last[ endpoint ]->next = packet;
    745a:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
    745e:	6045      	str	r5, [r0, #4]
    7460:	e7f2      	b.n	7448 <usb_tx+0x7c>
		next = TX_STATE_ODD_FREE;
    7462:	2403      	movs	r4, #3
    7464:	e7d5      	b.n	7412 <usb_tx+0x46>
}
    7466:	b002      	add	sp, #8
    7468:	bd70      	pop	{r4, r5, r6, pc}
    746a:	bf00      	nop
    746c:	1fffe9d0 	.word	0x1fffe9d0
    7470:	1ffff048 	.word	0x1ffff048
    7474:	2000079c 	.word	0x2000079c
    7478:	1fffedf4 	.word	0x1fffedf4
    747c:	1fffe000 	.word	0x1fffe000
    7480:	1ffff5a8 	.word	0x1ffff5a8
    7484:	1ffff558 	.word	0x1ffff558
    7488:	1ffff580 	.word	0x1ffff580

0000748c <usb_resume>:
{
    748c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return usb_dev_sleep;
    748e:	4e15      	ldr	r6, [pc, #84]	; (74e4 <usb_resume+0x58>)
{
    7490:	4d15      	ldr	r5, [pc, #84]	; (74e8 <usb_resume+0x5c>)
	return usb_dev_sleep;
    7492:	7830      	ldrb	r0, [r6, #0]
{
    7494:	682a      	ldr	r2, [r5, #0]
    7496:	9201      	str	r2, [sp, #4]
	if ( usb_suspended() && usb_configured() && usb_remote_wakeup )
    7498:	b1e0      	cbz	r0, 74d4 <usb_resume+0x48>

// return 0 if the USB is not configured, or the configuration
// number selected by the HOST
uint8_t usb_configured()
{
	return usb_configuration;
    749a:	4b14      	ldr	r3, [pc, #80]	; (74ec <usb_resume+0x60>)
    749c:	781b      	ldrb	r3, [r3, #0]
	if ( usb_suspended() && usb_configured() && usb_remote_wakeup )
    749e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    74a2:	b1bb      	cbz	r3, 74d4 <usb_resume+0x48>
    74a4:	4b12      	ldr	r3, [pc, #72]	; (74f0 <usb_resume+0x64>)
    74a6:	7818      	ldrb	r0, [r3, #0]
    74a8:	b1a0      	cbz	r0, 74d4 <usb_resume+0x48>
		USB0_CTL |= USB_CTL_RESUME;
    74aa:	4c12      	ldr	r4, [pc, #72]	; (74f4 <usb_resume+0x68>)
    74ac:	7823      	ldrb	r3, [r4, #0]
    74ae:	f043 0304 	orr.w	r3, r3, #4
    74b2:	7023      	strb	r3, [r4, #0]
		usb_packet_t *tx_packet = usb_malloc();
    74b4:	f000 fc2c 	bl	7d10 <usb_malloc>
		usb_tx( KEYBOARD_ENDPOINT, tx_packet );
    74b8:	4601      	mov	r1, r0
    74ba:	2001      	movs	r0, #1
    74bc:	f7ff ff86 	bl	73cc <usb_tx>
		delay_ms(10);
    74c0:	200a      	movs	r0, #10
    74c2:	f7fa f8d1 	bl	1668 <delay_ms>
		USB0_CTL &= ~(USB_CTL_RESUME);
    74c6:	7823      	ldrb	r3, [r4, #0]
    74c8:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    74cc:	7023      	strb	r3, [r4, #0]
		usb_dev_sleep = 0; // Make sure we don't call this again, may crash system
    74ce:	2300      	movs	r3, #0
    74d0:	7033      	strb	r3, [r6, #0]
		return 1;
    74d2:	2001      	movs	r0, #1
}
    74d4:	9a01      	ldr	r2, [sp, #4]
    74d6:	682b      	ldr	r3, [r5, #0]
    74d8:	429a      	cmp	r2, r3
    74da:	d001      	beq.n	74e0 <usb_resume+0x54>
    74dc:	f7fa f822 	bl	1524 <__stack_chk_fail>
    74e0:	b002      	add	sp, #8
    74e2:	bd70      	pop	{r4, r5, r6, pc}
    74e4:	1ffff5b3 	.word	0x1ffff5b3
    74e8:	1fffe9d0 	.word	0x1fffe9d0
    74ec:	1ffff5b2 	.word	0x1ffff5b2
    74f0:	1ffff5b5 	.word	0x1ffff5b5
    74f4:	40072094 	.word	0x40072094

000074f8 <usb_device_reload>:
{
    74f8:	b513      	push	{r0, r1, r4, lr}
    74fa:	4b0d      	ldr	r3, [pc, #52]	; (7530 <usb_device_reload+0x38>)
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
    74fc:	4c0d      	ldr	r4, [pc, #52]	; (7534 <usb_device_reload+0x3c>)
{
    74fe:	681a      	ldr	r2, [r3, #0]
    7500:	9201      	str	r2, [sp, #4]
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
    7502:	480d      	ldr	r0, [pc, #52]	; (7538 <usb_device_reload+0x40>)
{
    7504:	4a0d      	ldr	r2, [pc, #52]	; (753c <usb_device_reload+0x44>)
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
    7506:	f102 4140 	add.w	r1, r2, #3221225472	; 0xc0000000
    750a:	f5a1 3178 	sub.w	r1, r1, #253952	; 0x3e000
    750e:	5d09      	ldrb	r1, [r1, r4]
    7510:	f802 1b01 	strb.w	r1, [r2], #1
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
    7514:	4282      	cmp	r2, r0
    7516:	d1f6      	bne.n	7506 <usb_device_reload+0xe>
	SOFTWARE_RESET();
    7518:	4a09      	ldr	r2, [pc, #36]	; (7540 <usb_device_reload+0x48>)
    751a:	490a      	ldr	r1, [pc, #40]	; (7544 <usb_device_reload+0x4c>)
    751c:	6011      	str	r1, [r2, #0]
}
    751e:	9a01      	ldr	r2, [sp, #4]
    7520:	681b      	ldr	r3, [r3, #0]
    7522:	429a      	cmp	r2, r3
    7524:	d001      	beq.n	752a <usb_device_reload+0x32>
    7526:	f7f9 fffd 	bl	1524 <__stack_chk_fail>
    752a:	b002      	add	sp, #8
    752c:	bd10      	pop	{r4, pc}
    752e:	bf00      	nop
    7530:	1fffe9d0 	.word	0x1fffe9d0
    7534:	00009946 	.word	0x00009946
    7538:	4003e016 	.word	0x4003e016
    753c:	4003e000 	.word	0x4003e000
    7540:	e000ed0c 	.word	0xe000ed0c
    7544:	05fa0004 	.word	0x05fa0004

00007548 <usb_isr>:
{
    7548:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    754c:	4b93      	ldr	r3, [pc, #588]	; (779c <usb_isr+0x254>)
	status = USB0_ISTAT;
    754e:	f8df 92a0 	ldr.w	r9, [pc, #672]	; 77f0 <usb_isr+0x2a8>
{
    7552:	681a      	ldr	r2, [r3, #0]
		stat = USB0_STAT;
    7554:	f8df a29c 	ldr.w	sl, [pc, #668]	; 77f4 <usb_isr+0x2ac>
{
    7558:	b085      	sub	sp, #20
    755a:	4698      	mov	r8, r3
    755c:	9203      	str	r2, [sp, #12]
    755e:	464f      	mov	r7, r9
	status = USB0_ISTAT;
    7560:	f899 4000 	ldrb.w	r4, [r9]
    7564:	b2e4      	uxtb	r4, r4
	if ( (status & USB_INTEN_SOFTOKEN /* 04 */ ) )
    7566:	0766      	lsls	r6, r4, #29
    7568:	d525      	bpl.n	75b6 <usb_isr+0x6e>
		if ( usb_configuration )
    756a:	4b8d      	ldr	r3, [pc, #564]	; (77a0 <usb_isr+0x258>)
    756c:	781b      	ldrb	r3, [r3, #0]
    756e:	b1ab      	cbz	r3, 759c <usb_isr+0x54>
			t = usb_reboot_timer;
    7570:	4a8c      	ldr	r2, [pc, #560]	; (77a4 <usb_isr+0x25c>)
    7572:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    7574:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    7578:	b129      	cbz	r1, 7586 <usb_isr+0x3e>
				usb_reboot_timer = --t;
    757a:	3b01      	subs	r3, #1
    757c:	b2db      	uxtb	r3, r3
    757e:	7013      	strb	r3, [r2, #0]
				if ( !t )
    7580:	b90b      	cbnz	r3, 7586 <usb_isr+0x3e>
					usb_device_reload();
    7582:	f7ff ffb9 	bl	74f8 <usb_device_reload>
			t = usb_cdc_transmit_flush_timer;
    7586:	4a88      	ldr	r2, [pc, #544]	; (77a8 <usb_isr+0x260>)
    7588:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    758a:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    758e:	b129      	cbz	r1, 759c <usb_isr+0x54>
				usb_cdc_transmit_flush_timer = --t;
    7590:	3b01      	subs	r3, #1
    7592:	b2db      	uxtb	r3, r3
    7594:	7013      	strb	r3, [r2, #0]
				if ( t == 0 )
    7596:	b90b      	cbnz	r3, 759c <usb_isr+0x54>
					usb_serial_flush_callback();
    7598:	f000 fe18 	bl	81cc <usb_serial_flush_callback>
		if ( usb_dev_sleep )
    759c:	4d83      	ldr	r5, [pc, #524]	; (77ac <usb_isr+0x264>)
    759e:	782b      	ldrb	r3, [r5, #0]
    75a0:	b13b      	cbz	r3, 75b2 <usb_isr+0x6a>
			Output_update_usb_current( *usb_bMaxPower * 2 );
    75a2:	4b83      	ldr	r3, [pc, #524]	; (77b0 <usb_isr+0x268>)
    75a4:	681b      	ldr	r3, [r3, #0]
    75a6:	7818      	ldrb	r0, [r3, #0]
    75a8:	0040      	lsls	r0, r0, #1
    75aa:	f7fe faeb 	bl	5b84 <Output_update_usb_current>
			usb_dev_sleep = 0;
    75ae:	2300      	movs	r3, #0
    75b0:	702b      	strb	r3, [r5, #0]
		USB0_ISTAT = USB_INTEN_SOFTOKEN;
    75b2:	2304      	movs	r3, #4
    75b4:	703b      	strb	r3, [r7, #0]
	if ( (status & USB_ISTAT_TOKDNE /* 08 */ ) )
    75b6:	f014 0208 	ands.w	r2, r4, #8
    75ba:	f000 811f 	beq.w	77fc <usb_isr+0x2b4>
		stat = USB0_STAT;
    75be:	f89a 3000 	ldrb.w	r3, [sl]
    75c2:	4d7c      	ldr	r5, [pc, #496]	; (77b4 <usb_isr+0x26c>)
    75c4:	b2db      	uxtb	r3, r3
		if ( endpoint == 0 )
    75c6:	091c      	lsrs	r4, r3, #4
    75c8:	ea4f 0b93 	mov.w	fp, r3, lsr #2
    75cc:	d165      	bne.n	769a <usb_isr+0x152>
	b = stat2bufferdescriptor( stat );
    75ce:	eb05 03cb 	add.w	r3, r5, fp, lsl #3
    75d2:	4e79      	ldr	r6, [pc, #484]	; (77b8 <usb_isr+0x270>)
	buf = b->addr;
    75d4:	685c      	ldr	r4, [r3, #4]
	pid = BDT_PID( b->desc );
    75d6:	f855 303b 	ldr.w	r3, [r5, fp, lsl #3]
    75da:	f3c3 0383 	ubfx	r3, r3, #2, #4
	switch ( pid )
    75de:	3b01      	subs	r3, #1
    75e0:	2b0c      	cmp	r3, #12
    75e2:	d81b      	bhi.n	761c <usb_isr+0xd4>
    75e4:	e8df f003 	tbb	[pc, r3]
    75e8:	1a1a1f1f 	.word	0x1a1a1f1f
    75ec:	1a1a1a1a 	.word	0x1a1a1a1a
    75f0:	1a1a1a31 	.word	0x1a1a1a31
    75f4:	07          	.byte	0x07
    75f5:	00          	.byte	0x00
		setup.word1 = *(uint32_t *)(buf);
    75f6:	4b71      	ldr	r3, [pc, #452]	; (77bc <usb_isr+0x274>)
    75f8:	6822      	ldr	r2, [r4, #0]
    75fa:	601a      	str	r2, [r3, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    75fc:	6862      	ldr	r2, [r4, #4]
    75fe:	605a      	str	r2, [r3, #4]
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    7600:	4b6f      	ldr	r3, [pc, #444]	; (77c0 <usb_isr+0x278>)
		ep0_tx_ptr = NULL;
    7602:	4a70      	ldr	r2, [pc, #448]	; (77c4 <usb_isr+0x27c>)
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    7604:	f845 303b 	str.w	r3, [r5, fp, lsl #3]
		ep0_tx_ptr = NULL;
    7608:	2300      	movs	r3, #0
    760a:	6013      	str	r3, [r2, #0]
		table[index(0, TX, EVEN)].desc = 0;
    760c:	612b      	str	r3, [r5, #16]
		table[index(0, TX, ODD)].desc = 0;
    760e:	61ab      	str	r3, [r5, #24]
		ep0_tx_data_toggle = 1;
    7610:	4b6d      	ldr	r3, [pc, #436]	; (77c8 <usb_isr+0x280>)
    7612:	2401      	movs	r4, #1
    7614:	701c      	strb	r4, [r3, #0]
		usb_setup();
    7616:	f7ff fb45 	bl	6ca4 <usb_setup>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    761a:	7034      	strb	r4, [r6, #0]
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    761c:	2301      	movs	r3, #1
    761e:	7033      	strb	r3, [r6, #0]
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    7620:	2308      	movs	r3, #8
    7622:	703b      	strb	r3, [r7, #0]
		goto restart;
    7624:	e79c      	b.n	7560 <usb_isr+0x18>
		if ( setup.wRequestAndType == 0x2021 )
    7626:	4b65      	ldr	r3, [pc, #404]	; (77bc <usb_isr+0x274>)
    7628:	881a      	ldrh	r2, [r3, #0]
    762a:	f242 0321 	movw	r3, #8225	; 0x2021
    762e:	429a      	cmp	r2, r3
    7630:	d104      	bne.n	763c <usb_isr+0xf4>
			memcpy( (void*)&usb_cdc_line_coding, buf, 7 );
    7632:	2207      	movs	r2, #7
    7634:	4621      	mov	r1, r4
    7636:	4865      	ldr	r0, [pc, #404]	; (77cc <usb_isr+0x284>)
    7638:	f7f9 ff98 	bl	156c <memcpy>
		keyboard_control(buf);
    763c:	4620      	mov	r0, r4
    763e:	f7ff fdf7 	bl	7230 <keyboard_control>
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    7642:	4b5f      	ldr	r3, [pc, #380]	; (77c0 <usb_isr+0x278>)
    7644:	f845 303b 	str.w	r3, [r5, fp, lsl #3]
    7648:	e7e8      	b.n	761c <usb_isr+0xd4>
		data = ep0_tx_ptr;
    764a:	f8df b178 	ldr.w	fp, [pc, #376]	; 77c4 <usb_isr+0x27c>
    764e:	f8db 2000 	ldr.w	r2, [fp]
		if ( data )
    7652:	b1ba      	cbz	r2, 7684 <usb_isr+0x13c>
			size = ep0_tx_len;
    7654:	4b5e      	ldr	r3, [pc, #376]	; (77d0 <usb_isr+0x288>)
    7656:	9301      	str	r3, [sp, #4]
    7658:	881d      	ldrh	r5, [r3, #0]
			endpoint0_transmit( data, size );
    765a:	9200      	str	r2, [sp, #0]
    765c:	2d40      	cmp	r5, #64	; 0x40
    765e:	462c      	mov	r4, r5
    7660:	bf28      	it	cs
    7662:	2440      	movcs	r4, #64	; 0x40
    7664:	4621      	mov	r1, r4
    7666:	4610      	mov	r0, r2
    7668:	f7ff faa8 	bl	6bbc <endpoint0_transmit>
			data += size;
    766c:	9a00      	ldr	r2, [sp, #0]
			ep0_tx_len -= size;
    766e:	9b01      	ldr	r3, [sp, #4]
			data += size;
    7670:	4422      	add	r2, r4
			ep0_tx_len -= size;
    7672:	1b2c      	subs	r4, r5, r4
    7674:	b2a4      	uxth	r4, r4
    7676:	801c      	strh	r4, [r3, #0]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    7678:	b914      	cbnz	r4, 7680 <usb_isr+0x138>
    767a:	2d3f      	cmp	r5, #63	; 0x3f
    767c:	bf98      	it	ls
    767e:	2200      	movls	r2, #0
    7680:	f8cb 2000 	str.w	r2, [fp]
		if ( setup.bRequest == 5 && setup.bmRequestType == 0 )
    7684:	4b4d      	ldr	r3, [pc, #308]	; (77bc <usb_isr+0x274>)
    7686:	881a      	ldrh	r2, [r3, #0]
    7688:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    768c:	d1c6      	bne.n	761c <usb_isr+0xd4>
			setup.bRequest = 0;
    768e:	2200      	movs	r2, #0
    7690:	705a      	strb	r2, [r3, #1]
			USB0_ADDR = setup.wValue;
    7692:	789a      	ldrb	r2, [r3, #2]
    7694:	4b4f      	ldr	r3, [pc, #316]	; (77d4 <usb_isr+0x28c>)
    7696:	701a      	strb	r2, [r3, #0]
    7698:	e7c0      	b.n	761c <usb_isr+0xd4>
			bdt_t *b = stat2bufferdescriptor(stat);
    769a:	465e      	mov	r6, fp
    769c:	eb05 0bcb 	add.w	fp, r5, fp, lsl #3
			endpoint--;     // endpoint is index to zero-based arrays
    76a0:	3c01      	subs	r4, #1
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    76a2:	f8db c004 	ldr.w	ip, [fp, #4]
			if ( stat & 0x08 )
    76a6:	f013 0308 	ands.w	r3, r3, #8
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    76aa:	f1ac 0008 	sub.w	r0, ip, #8
			endpoint--;     // endpoint is index to zero-based arrays
    76ae:	b2e4      	uxtb	r4, r4
			if ( stat & 0x08 )
    76b0:	d041      	beq.n	7736 <usb_isr+0x1ee>
				usb_free( packet );
    76b2:	f000 fb57 	bl	7d64 <usb_free>
				packet = tx_first[ endpoint ];
    76b6:	4848      	ldr	r0, [pc, #288]	; (77d8 <usb_isr+0x290>)
    76b8:	4a48      	ldr	r2, [pc, #288]	; (77dc <usb_isr+0x294>)
    76ba:	f850 1024 	ldr.w	r1, [r0, r4, lsl #2]
				if ( packet )
    76be:	b301      	cbz	r1, 7702 <usb_isr+0x1ba>
					tx_first[endpoint] = packet->next;
    76c0:	684b      	ldr	r3, [r1, #4]
    76c2:	f840 3024 	str.w	r3, [r0, r4, lsl #2]
					b->addr = packet->buf;
    76c6:	f101 0308 	add.w	r3, r1, #8
    76ca:	f8cb 3004 	str.w	r3, [fp, #4]
					switch ( tx_state[ endpoint ] )
    76ce:	5d13      	ldrb	r3, [r2, r4]
    76d0:	2b03      	cmp	r3, #3
    76d2:	d805      	bhi.n	76e0 <usb_isr+0x198>
    76d4:	e8df f003 	tbb	[pc, r3]
    76d8:	13110f02 	.word	0x13110f02
						tx_state[ endpoint ] = TX_STATE_ODD_FREE;
    76dc:	2303      	movs	r3, #3
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_EVEN_FIRST;
    76de:	5513      	strb	r3, [r2, r4]
					b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    76e0:	f01b 0f08 	tst.w	fp, #8
    76e4:	880a      	ldrh	r2, [r1, #0]
    76e6:	bf14      	ite	ne
    76e8:	23c8      	movne	r3, #200	; 0xc8
    76ea:	2388      	moveq	r3, #136	; 0x88
    76ec:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
					b->desc = BDT_DESC( 64, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    76f0:	f845 3036 	str.w	r3, [r5, r6, lsl #3]
    76f4:	e794      	b.n	7620 <usb_isr+0xd8>
						tx_state[ endpoint ] = TX_STATE_EVEN_FREE;
    76f6:	2302      	movs	r3, #2
    76f8:	e7f1      	b.n	76de <usb_isr+0x196>
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_ODD_FIRST;
    76fa:	2305      	movs	r3, #5
    76fc:	e7ef      	b.n	76de <usb_isr+0x196>
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_EVEN_FIRST;
    76fe:	2304      	movs	r3, #4
    7700:	e7ed      	b.n	76de <usb_isr+0x196>
					switch ( tx_state[ endpoint ] )
    7702:	5d13      	ldrb	r3, [r2, r4]
    7704:	2b03      	cmp	r3, #3
    7706:	d810      	bhi.n	772a <usb_isr+0x1e2>
    7708:	a101      	add	r1, pc, #4	; (adr r1, 7710 <usb_isr+0x1c8>)
    770a:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    770e:	bf00      	nop
    7710:	00007621 	.word	0x00007621
    7714:	00007621 	.word	0x00007621
    7718:	00007721 	.word	0x00007721
    771c:	00007727 	.word	0x00007727
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    7720:	2300      	movs	r3, #0
						tx_state[ endpoint ] = ((uint32_t)b & 8)
    7722:	5513      	strb	r3, [r2, r4]
						break;
    7724:	e77c      	b.n	7620 <usb_isr+0xd8>
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    7726:	2301      	movs	r3, #1
    7728:	e7fb      	b.n	7722 <usb_isr+0x1da>
						tx_state[ endpoint ] = ((uint32_t)b & 8)
    772a:	f01b 0f08 	tst.w	fp, #8
    772e:	bf14      	ite	ne
    7730:	2303      	movne	r3, #3
    7732:	2302      	moveq	r3, #2
    7734:	e7f5      	b.n	7722 <usb_isr+0x1da>
				packet->len = b->desc >> 16;
    7736:	f855 2036 	ldr.w	r2, [r5, r6, lsl #3]
    773a:	0c12      	lsrs	r2, r2, #16
    773c:	b291      	uxth	r1, r2
    773e:	f82c 1c08 	strh.w	r1, [ip, #-8]
				if ( packet->len > 0 )
    7742:	b1ca      	cbz	r2, 7778 <usb_isr+0x230>
					packet->index = 0;
    7744:	f82c 3c06 	strh.w	r3, [ip, #-6]
					packet->next = NULL;
    7748:	f84c 3c04 	str.w	r3, [ip, #-4]
					if ( rx_first[ endpoint ] == NULL )
    774c:	4b24      	ldr	r3, [pc, #144]	; (77e0 <usb_isr+0x298>)
    774e:	f8df c0a8 	ldr.w	ip, [pc, #168]	; 77f8 <usb_isr+0x2b0>
    7752:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
    7756:	b9b2      	cbnz	r2, 7786 <usb_isr+0x23e>
						rx_first[ endpoint ] = packet;
    7758:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    775c:	4b21      	ldr	r3, [pc, #132]	; (77e4 <usb_isr+0x29c>)
					rx_last[ endpoint ] = packet;
    775e:	f84c 0024 	str.w	r0, [ip, r4, lsl #2]
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    7762:	f833 2014 	ldrh.w	r2, [r3, r4, lsl #1]
    7766:	4411      	add	r1, r2
    7768:	f823 1014 	strh.w	r1, [r3, r4, lsl #1]
					packet = usb_malloc();
    776c:	f000 fad0 	bl	7d10 <usb_malloc>
					if ( packet )
    7770:	b168      	cbz	r0, 778e <usb_isr+0x246>
						b->addr = packet->buf;
    7772:	3008      	adds	r0, #8
    7774:	f8cb 0004 	str.w	r0, [fp, #4]
					b->desc = BDT_DESC( 64, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    7778:	4a1b      	ldr	r2, [pc, #108]	; (77e8 <usb_isr+0x2a0>)
    777a:	4b11      	ldr	r3, [pc, #68]	; (77c0 <usb_isr+0x278>)
    777c:	f01b 0f08 	tst.w	fp, #8
    7780:	bf08      	it	eq
    7782:	4613      	moveq	r3, r2
    7784:	e7b4      	b.n	76f0 <usb_isr+0x1a8>
						rx_last[ endpoint ]->next = packet;
    7786:	f85c 3024 	ldr.w	r3, [ip, r4, lsl #2]
    778a:	6058      	str	r0, [r3, #4]
    778c:	e7e6      	b.n	775c <usb_isr+0x214>
						usb_rx_memory_needed++;
    778e:	4a17      	ldr	r2, [pc, #92]	; (77ec <usb_isr+0x2a4>)
						b->desc = 0;
    7790:	f845 0036 	str.w	r0, [r5, r6, lsl #3]
						usb_rx_memory_needed++;
    7794:	7813      	ldrb	r3, [r2, #0]
    7796:	3301      	adds	r3, #1
    7798:	7013      	strb	r3, [r2, #0]
    779a:	e741      	b.n	7620 <usb_isr+0xd8>
    779c:	1fffe9d0 	.word	0x1fffe9d0
    77a0:	1ffff5b2 	.word	0x1ffff5b2
    77a4:	1ffff5b4 	.word	0x1ffff5b4
    77a8:	1ffff5c9 	.word	0x1ffff5c9
    77ac:	1ffff5b3 	.word	0x1ffff5b3
    77b0:	1fffedf4 	.word	0x1fffedf4
    77b4:	1fffe000 	.word	0x1fffe000
    77b8:	40072094 	.word	0x40072094
    77bc:	1ffff550 	.word	0x1ffff550
    77c0:	004000c8 	.word	0x004000c8
    77c4:	1ffff4ec 	.word	0x1ffff4ec
    77c8:	1ffff4e9 	.word	0x1ffff4e9
    77cc:	1fffefdc 	.word	0x1fffefdc
    77d0:	1ffff4ea 	.word	0x1ffff4ea
    77d4:	40072098 	.word	0x40072098
    77d8:	1ffff558 	.word	0x1ffff558
    77dc:	1ffff5a8 	.word	0x1ffff5a8
    77e0:	1ffff500 	.word	0x1ffff500
    77e4:	200007a8 	.word	0x200007a8
    77e8:	00400088 	.word	0x00400088
    77ec:	1ffff5b6 	.word	0x1ffff5b6
    77f0:	40072080 	.word	0x40072080
    77f4:	40072090 	.word	0x40072090
    77f8:	1ffff528 	.word	0x1ffff528
	if ( status & USB_ISTAT_USBRST /* 01 */ )
    77fc:	07e5      	lsls	r5, r4, #31
    77fe:	d524      	bpl.n	784a <usb_isr+0x302>
		USB0_CTL = USB_CTL_ODDRST;
    7800:	4933      	ldr	r1, [pc, #204]	; (78d0 <usb_isr+0x388>)
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    7802:	4834      	ldr	r0, [pc, #208]	; (78d4 <usb_isr+0x38c>)
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
    7804:	4c34      	ldr	r4, [pc, #208]	; (78d8 <usb_isr+0x390>)
		USB0_CTL = USB_CTL_ODDRST;
    7806:	2302      	movs	r3, #2
    7808:	700b      	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    780a:	4b34      	ldr	r3, [pc, #208]	; (78dc <usb_isr+0x394>)
    780c:	701a      	strb	r2, [r3, #0]
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    780e:	4b34      	ldr	r3, [pc, #208]	; (78e0 <usb_isr+0x398>)
    7810:	6018      	str	r0, [r3, #0]
		table[index( 0, RX, ODD ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    7812:	e9c3 4001 	strd	r4, r0, [r3, #4]
		table[index( 0, RX, ODD ) ].addr = ep0_rx1_buf;
    7816:	4833      	ldr	r0, [pc, #204]	; (78e4 <usb_isr+0x39c>)
		table[index( 0, TX, ODD ) ].desc = 0;
    7818:	619a      	str	r2, [r3, #24]
		table[index( 0, TX, EVEN ) ].desc = 0;
    781a:	e9c3 0203 	strd	r0, r2, [r3, #12]
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    781e:	4b32      	ldr	r3, [pc, #200]	; (78e8 <usb_isr+0x3a0>)
    7820:	200d      	movs	r0, #13
    7822:	7018      	strb	r0, [r3, #0]
		USB0_ERRSTAT = 0xFF;
    7824:	4831      	ldr	r0, [pc, #196]	; (78ec <usb_isr+0x3a4>)
    7826:	23ff      	movs	r3, #255	; 0xff
    7828:	7003      	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    782a:	703b      	strb	r3, [r7, #0]
		USB0_ADDR = 0;
    782c:	7402      	strb	r2, [r0, #16]
		USB0_ERREN = 0xFF;
    782e:	4a30      	ldr	r2, [pc, #192]	; (78f0 <usb_isr+0x3a8>)
    7830:	7013      	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    7832:	4b30      	ldr	r3, [pc, #192]	; (78f4 <usb_isr+0x3ac>)
    7834:	229f      	movs	r2, #159	; 0x9f
    7836:	701a      	strb	r2, [r3, #0]
		USB0_CTL = USB_CTL_USBENSOFEN;
    7838:	2301      	movs	r3, #1
    783a:	700b      	strb	r3, [r1, #0]
}
    783c:	9a03      	ldr	r2, [sp, #12]
    783e:	f8d8 3000 	ldr.w	r3, [r8]
    7842:	429a      	cmp	r2, r3
    7844:	d040      	beq.n	78c8 <usb_isr+0x380>
    7846:	f7f9 fe6d 	bl	1524 <__stack_chk_fail>
	if ( (status & USB_ISTAT_STALL /* 80 */ ) )
    784a:	0620      	lsls	r0, r4, #24
    784c:	d504      	bpl.n	7858 <usb_isr+0x310>
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    784e:	4b26      	ldr	r3, [pc, #152]	; (78e8 <usb_isr+0x3a0>)
    7850:	220d      	movs	r2, #13
    7852:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    7854:	2380      	movs	r3, #128	; 0x80
    7856:	703b      	strb	r3, [r7, #0]
	if ( (status & USB_ISTAT_ERROR /* 02 */ ) )
    7858:	07a1      	lsls	r1, r4, #30
    785a:	d505      	bpl.n	7868 <usb_isr+0x320>
		uint8_t err = USB0_ERRSTAT;
    785c:	4a23      	ldr	r2, [pc, #140]	; (78ec <usb_isr+0x3a4>)
    785e:	7813      	ldrb	r3, [r2, #0]
    7860:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    7862:	7013      	strb	r3, [r2, #0]
		USB0_ISTAT = USB_ISTAT_ERROR;
    7864:	2302      	movs	r3, #2
    7866:	703b      	strb	r3, [r7, #0]
	if ( (status & USB_ISTAT_SLEEP /* 10 */ ) )
    7868:	06e2      	lsls	r2, r4, #27
    786a:	d514      	bpl.n	7896 <usb_isr+0x34e>
		if ( !usb_dev_sleep )
    786c:	4d22      	ldr	r5, [pc, #136]	; (78f8 <usb_isr+0x3b0>)
    786e:	782b      	ldrb	r3, [r5, #0]
    7870:	b923      	cbnz	r3, 787c <usb_isr+0x334>
			Output_update_usb_current( 100 ); // Set to 100 mA
    7872:	2064      	movs	r0, #100	; 0x64
    7874:	f7fe f986 	bl	5b84 <Output_update_usb_current>
			usb_dev_sleep = 1;
    7878:	2301      	movs	r3, #1
    787a:	702b      	strb	r3, [r5, #0]
		USB0_INTEN |= USB_INTEN_RESUMEEN;
    787c:	4b1d      	ldr	r3, [pc, #116]	; (78f4 <usb_isr+0x3ac>)
    787e:	781a      	ldrb	r2, [r3, #0]
    7880:	f042 0220 	orr.w	r2, r2, #32
    7884:	701a      	strb	r2, [r3, #0]
		USB0_INTEN &= ~(USB_INTEN_SLEEPEN);
    7886:	781a      	ldrb	r2, [r3, #0]
    7888:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    788c:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT |= USB_ISTAT_SLEEP;
    788e:	783b      	ldrb	r3, [r7, #0]
    7890:	f043 0310 	orr.w	r3, r3, #16
    7894:	703b      	strb	r3, [r7, #0]
	if ( (status & USB_ISTAT_RESUME /* 20 */ ) )
    7896:	06a3      	lsls	r3, r4, #26
    7898:	d5d0      	bpl.n	783c <usb_isr+0x2f4>
		Output_update_usb_current( *usb_bMaxPower * 2 );
    789a:	4b18      	ldr	r3, [pc, #96]	; (78fc <usb_isr+0x3b4>)
    789c:	681b      	ldr	r3, [r3, #0]
    789e:	7818      	ldrb	r0, [r3, #0]
    78a0:	0040      	lsls	r0, r0, #1
    78a2:	f7fe f96f 	bl	5b84 <Output_update_usb_current>
		usb_dev_sleep = 0;
    78a6:	4b14      	ldr	r3, [pc, #80]	; (78f8 <usb_isr+0x3b0>)
    78a8:	2200      	movs	r2, #0
    78aa:	701a      	strb	r2, [r3, #0]
		USB0_INTEN &= ~(USB_INTEN_RESUMEEN);
    78ac:	4b11      	ldr	r3, [pc, #68]	; (78f4 <usb_isr+0x3ac>)
    78ae:	781a      	ldrb	r2, [r3, #0]
    78b0:	f002 02df 	and.w	r2, r2, #223	; 0xdf
    78b4:	701a      	strb	r2, [r3, #0]
		USB0_INTEN |= USB_INTEN_SLEEPEN;
    78b6:	781a      	ldrb	r2, [r3, #0]
    78b8:	f042 0210 	orr.w	r2, r2, #16
    78bc:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT |= USB_ISTAT_RESUME;
    78be:	783b      	ldrb	r3, [r7, #0]
    78c0:	f043 0320 	orr.w	r3, r3, #32
    78c4:	703b      	strb	r3, [r7, #0]
    78c6:	e7b9      	b.n	783c <usb_isr+0x2f4>
}
    78c8:	b005      	add	sp, #20
    78ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    78ce:	bf00      	nop
    78d0:	40072094 	.word	0x40072094
    78d4:	00400088 	.word	0x00400088
    78d8:	1ffff468 	.word	0x1ffff468
    78dc:	1ffff4e8 	.word	0x1ffff4e8
    78e0:	1fffe000 	.word	0x1fffe000
    78e4:	1ffff4a8 	.word	0x1ffff4a8
    78e8:	400720c0 	.word	0x400720c0
    78ec:	40072088 	.word	0x40072088
    78f0:	4007208c 	.word	0x4007208c
    78f4:	40072084 	.word	0x40072084
    78f8:	1ffff5b3 	.word	0x1ffff5b3
    78fc:	1fffedf4 	.word	0x1fffedf4

00007900 <usb_init>:
{
    7900:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7902:	4d37      	ldr	r5, [pc, #220]	; (79e0 <usb_init+0xe0>)
    7904:	682b      	ldr	r3, [r5, #0]
    7906:	9301      	str	r3, [sp, #4]
	USBInit_TimeStart = systick_millis_count;
    7908:	4b36      	ldr	r3, [pc, #216]	; (79e4 <usb_init+0xe4>)
    790a:	681a      	ldr	r2, [r3, #0]
    790c:	4b36      	ldr	r3, [pc, #216]	; (79e8 <usb_init+0xe8>)
    790e:	601a      	str	r2, [r3, #0]
	USBInit_Ticks = 0;
    7910:	4b36      	ldr	r3, [pc, #216]	; (79ec <usb_init+0xec>)
    7912:	2400      	movs	r4, #0
    7914:	801c      	strh	r4, [r3, #0]
	usb_set_config_descriptor_size();
    7916:	f7ff f93b 	bl	6b90 <usb_set_config_descriptor_size>
	hex32ToStr16( SIM_UIDH,  &(usb_string_serial_number_default.wString[0]), 8 );
    791a:	4b35      	ldr	r3, [pc, #212]	; (79f0 <usb_init+0xf0>)
    791c:	4935      	ldr	r1, [pc, #212]	; (79f4 <usb_init+0xf4>)
    791e:	6818      	ldr	r0, [r3, #0]
    7920:	2208      	movs	r2, #8
    7922:	f001 ff3f 	bl	97a4 <hex32ToStr16>
	hex32ToStr16( SIM_UIDMH, &(usb_string_serial_number_default.wString[8]), 8 );
    7926:	4b34      	ldr	r3, [pc, #208]	; (79f8 <usb_init+0xf8>)
    7928:	4934      	ldr	r1, [pc, #208]	; (79fc <usb_init+0xfc>)
    792a:	6818      	ldr	r0, [r3, #0]
    792c:	2208      	movs	r2, #8
    792e:	f001 ff39 	bl	97a4 <hex32ToStr16>
	hex32ToStr16( SIM_UIDML, &(usb_string_serial_number_default.wString[16]), 8 );
    7932:	4b33      	ldr	r3, [pc, #204]	; (7a00 <usb_init+0x100>)
    7934:	4933      	ldr	r1, [pc, #204]	; (7a04 <usb_init+0x104>)
    7936:	6818      	ldr	r0, [r3, #0]
    7938:	2208      	movs	r2, #8
    793a:	f001 ff33 	bl	97a4 <hex32ToStr16>
	hex32ToStr16( SIM_UIDL,  &(usb_string_serial_number_default.wString[24]), 8 );
    793e:	4b32      	ldr	r3, [pc, #200]	; (7a08 <usb_init+0x108>)
    7940:	4932      	ldr	r1, [pc, #200]	; (7a0c <usb_init+0x10c>)
    7942:	6818      	ldr	r0, [r3, #0]
    7944:	2208      	movs	r2, #8
    7946:	f001 ff2d 	bl	97a4 <hex32ToStr16>
		table[i].desc = 0;
    794a:	4931      	ldr	r1, [pc, #196]	; (7a10 <usb_init+0x110>)
	hex32ToStr16( SIM_UIDL,  &(usb_string_serial_number_default.wString[24]), 8 );
    794c:	4623      	mov	r3, r4
		table[i].desc = 0;
    794e:	4618      	mov	r0, r3
    7950:	462c      	mov	r4, r5
    7952:	460a      	mov	r2, r1
    7954:	5058      	str	r0, [r3, r1]
		table[i].addr = 0;
    7956:	18cd      	adds	r5, r1, r3
    7958:	3308      	adds	r3, #8
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    795a:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
		table[i].addr = 0;
    795e:	6068      	str	r0, [r5, #4]
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    7960:	d1f8      	bne.n	7954 <usb_init+0x54>
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    7962:	492c      	ldr	r1, [pc, #176]	; (7a14 <usb_init+0x114>)
    7964:	680b      	ldr	r3, [r1, #0]
    7966:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    796a:	600b      	str	r3, [r1, #0]
	USB0_USBTRC0 = USB_USBTRC_USBRESET;
    796c:	4b2a      	ldr	r3, [pc, #168]	; (7a18 <usb_init+0x118>)
    796e:	2180      	movs	r1, #128	; 0x80
    7970:	7019      	strb	r1, [r3, #0]
	while ( (USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0 ); // wait for reset to end
    7972:	7819      	ldrb	r1, [r3, #0]
    7974:	0609      	lsls	r1, r1, #24
    7976:	d4fc      	bmi.n	7972 <usb_init+0x72>
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    7978:	4928      	ldr	r1, [pc, #160]	; (7a1c <usb_init+0x11c>)
    797a:	f3c2 2007 	ubfx	r0, r2, #8, #8
    797e:	7008      	strb	r0, [r1, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    7980:	f3c2 4007 	ubfx	r0, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    7984:	0e12      	lsrs	r2, r2, #24
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    7986:	7508      	strb	r0, [r1, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    7988:	760a      	strb	r2, [r1, #24]
	USB0_ISTAT = 0xFF;
    798a:	22ff      	movs	r2, #255	; 0xff
    798c:	f801 2c1c 	strb.w	r2, [r1, #-28]
	USB0_ERRSTAT = 0xFF;
    7990:	f801 2c14 	strb.w	r2, [r1, #-20]
	USB0_OTGISTAT = 0xFF;
    7994:	f801 2c8c 	strb.w	r2, [r1, #-140]
	USB0_USBTRC0 |= 0x40; // undocumented bit
    7998:	781a      	ldrb	r2, [r3, #0]
    799a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    799e:	701a      	strb	r2, [r3, #0]
	USB0_CTL = USB_CTL_USBENSOFEN;
    79a0:	4b1f      	ldr	r3, [pc, #124]	; (7a20 <usb_init+0x120>)
	USB0_USBCTRL = 0;
    79a2:	4a20      	ldr	r2, [pc, #128]	; (7a24 <usb_init+0x124>)
	USB0_CTL = USB_CTL_USBENSOFEN;
    79a4:	2001      	movs	r0, #1
    79a6:	7018      	strb	r0, [r3, #0]
	USB0_USBCTRL = 0;
    79a8:	2300      	movs	r3, #0
    79aa:	7013      	strb	r3, [r2, #0]
	USB0_INTEN = USB_INTEN_USBRSTEN;
    79ac:	f802 0c7c 	strb.w	r0, [r2, #-124]
	NVIC_SET_PRIORITY( IRQ_USBOTG, 112 );
    79b0:	4a1d      	ldr	r2, [pc, #116]	; (7a28 <usb_init+0x128>)
    79b2:	2170      	movs	r1, #112	; 0x70
    79b4:	7011      	strb	r1, [r2, #0]
	NVIC_ENABLE_IRQ( IRQ_USBOTG );
    79b6:	f2a2 321f 	subw	r2, r2, #799	; 0x31f
    79ba:	2108      	movs	r1, #8
    79bc:	6011      	str	r1, [r2, #0]
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    79be:	4a1b      	ldr	r2, [pc, #108]	; (7a2c <usb_init+0x12c>)
    79c0:	2110      	movs	r1, #16
    79c2:	7011      	strb	r1, [r2, #0]
	usb_dev_sleep = 0;
    79c4:	4a1a      	ldr	r2, [pc, #104]	; (7a30 <usb_init+0x130>)
    79c6:	7013      	strb	r3, [r2, #0]
	power_neg_delay = 0;
    79c8:	4a1a      	ldr	r2, [pc, #104]	; (7a34 <usb_init+0x134>)
    79ca:	7013      	strb	r3, [r2, #0]
	usb_remote_wakeup = 1;
    79cc:	4b1a      	ldr	r3, [pc, #104]	; (7a38 <usb_init+0x138>)
}
    79ce:	9a01      	ldr	r2, [sp, #4]
	usb_remote_wakeup = 1;
    79d0:	7018      	strb	r0, [r3, #0]
}
    79d2:	6823      	ldr	r3, [r4, #0]
    79d4:	429a      	cmp	r2, r3
    79d6:	d001      	beq.n	79dc <usb_init+0xdc>
    79d8:	f7f9 fda4 	bl	1524 <__stack_chk_fail>
    79dc:	b003      	add	sp, #12
    79de:	bd30      	pop	{r4, r5, pc}
    79e0:	1fffe9d0 	.word	0x1fffe9d0
    79e4:	1ffff048 	.word	0x1ffff048
    79e8:	200007a4 	.word	0x200007a4
    79ec:	2000074e 	.word	0x2000074e
    79f0:	40048054 	.word	0x40048054
    79f4:	1fffef66 	.word	0x1fffef66
    79f8:	40048058 	.word	0x40048058
    79fc:	1fffef76 	.word	0x1fffef76
    7a00:	4004805c 	.word	0x4004805c
    7a04:	1fffef86 	.word	0x1fffef86
    7a08:	40048060 	.word	0x40048060
    7a0c:	1fffef96 	.word	0x1fffef96
    7a10:	1fffe000 	.word	0x1fffe000
    7a14:	40048034 	.word	0x40048034
    7a18:	4007210c 	.word	0x4007210c
    7a1c:	4007209c 	.word	0x4007209c
    7a20:	40072094 	.word	0x40072094
    7a24:	40072100 	.word	0x40072100
    7a28:	e000e423 	.word	0xe000e423
    7a2c:	40072108 	.word	0x40072108
    7a30:	1ffff5b3 	.word	0x1ffff5b3
    7a34:	1ffff4f0 	.word	0x1ffff4f0
    7a38:	1ffff5b5 	.word	0x1ffff5b5

00007a3c <usb_configured>:
{
    7a3c:	b507      	push	{r0, r1, r2, lr}
    7a3e:	4b07      	ldr	r3, [pc, #28]	; (7a5c <usb_configured+0x20>)
    7a40:	681a      	ldr	r2, [r3, #0]
    7a42:	9201      	str	r2, [sp, #4]
	return usb_configuration;
    7a44:	4a06      	ldr	r2, [pc, #24]	; (7a60 <usb_configured+0x24>)
    7a46:	7810      	ldrb	r0, [r2, #0]
}
    7a48:	9a01      	ldr	r2, [sp, #4]
    7a4a:	681b      	ldr	r3, [r3, #0]
    7a4c:	429a      	cmp	r2, r3
    7a4e:	d001      	beq.n	7a54 <usb_configured+0x18>
    7a50:	f7f9 fd68 	bl	1524 <__stack_chk_fail>
    7a54:	b003      	add	sp, #12
    7a56:	f85d fb04 	ldr.w	pc, [sp], #4
    7a5a:	bf00      	nop
    7a5c:	1fffe9d0 	.word	0x1fffe9d0
    7a60:	1ffff5b2 	.word	0x1ffff5b2

00007a64 <usb_keyboard_send>:
}


// Send the contents of keyboard_keys and keyboard_modifier_keys
void usb_keyboard_send( USBKeys *buffer, uint8_t protocol )
{
    7a64:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    7a68:	4e79      	ldr	r6, [pc, #484]	; (7c50 <usb_keyboard_send+0x1ec>)
	usb_packet_t *tx_packet;

	// Wait till ready
	while ( 1 )
	{
		if ( !usb_configuration )
    7a6a:	f8df a200 	ldr.w	sl, [pc, #512]	; 7c6c <usb_keyboard_send+0x208>
{
    7a6e:	6833      	ldr	r3, [r6, #0]
    7a70:	9303      	str	r3, [sp, #12]
	Time start = Time_now();
    7a72:	f10d 0904 	add.w	r9, sp, #4
{
    7a76:	4605      	mov	r5, r0
	Time start = Time_now();
    7a78:	4648      	mov	r0, r9
{
    7a7a:	460f      	mov	r7, r1
	Time start = Time_now();
    7a7c:	f7fa f840 	bl	1b00 <Time_now>
    7a80:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 7c70 <usb_keyboard_send+0x20c>
		if ( !usb_configuration )
    7a84:	f89a 3000 	ldrb.w	r3, [sl]
    7a88:	b95b      	cbnz	r3, 7aa2 <usb_keyboard_send+0x3e>
		{
			erro_print("USB not configured...");
    7a8a:	9a03      	ldr	r2, [sp, #12]
    7a8c:	6833      	ldr	r3, [r6, #0]
    7a8e:	429a      	cmp	r2, r3
    7a90:	d001      	beq.n	7a96 <usb_keyboard_send+0x32>

		break;
	}

	return;
}
    7a92:	f7f9 fd47 	bl	1524 <__stack_chk_fail>
			erro_print("USB not configured...");
    7a96:	486f      	ldr	r0, [pc, #444]	; (7c54 <usb_keyboard_send+0x1f0>)
}
    7a98:	b004      	add	sp, #16
    7a9a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			warn_print("USB Transmit Timeout...auto-restart disabled");
    7a9e:	f001 bcf3 	b.w	9488 <_print>
		if ( usb_resume() )
    7aa2:	f7ff fcf3 	bl	748c <usb_resume>
    7aa6:	b108      	cbz	r0, 7aac <usb_keyboard_send+0x48>
			buffer->changed = USBKeyChangeState_None; // Mark sent
    7aa8:	2300      	movs	r3, #0
    7aaa:	e044      	b.n	7b36 <usb_keyboard_send+0xd2>
		if ( protocol == 0 ) // Boot Mode
    7aac:	b9b7      	cbnz	r7, 7adc <usb_keyboard_send+0x78>
			if ( usb_tx_packet_count( KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    7aae:	2001      	movs	r0, #1
    7ab0:	f7ff fc20 	bl	72f4 <usb_tx_packet_count>
    7ab4:	2803      	cmp	r0, #3
    7ab6:	d91c      	bls.n	7af2 <usb_keyboard_send+0x8e>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    7ab8:	e899 0003 	ldmia.w	r9, {r0, r1}
    7abc:	f7fa f944 	bl	1d48 <Time_duration_ms>
    7ac0:	2832      	cmp	r0, #50	; 0x32
    7ac2:	d93b      	bls.n	7b3c <usb_keyboard_send+0xd8>
			transmit_previous_timeout = 1;
    7ac4:	2301      	movs	r3, #1
    7ac6:	f888 3000 	strb.w	r3, [r8]
			buffer->changed = USBKeyChangeState_None; // Indicate packet lost
    7aca:	2300      	movs	r3, #0
			warn_print("USB Transmit Timeout...auto-restart disabled");
    7acc:	9a03      	ldr	r2, [sp, #12]
			buffer->changed = USBKeyChangeState_None; // Indicate packet lost
    7ace:	f885 3020 	strb.w	r3, [r5, #32]
			warn_print("USB Transmit Timeout...auto-restart disabled");
    7ad2:	6833      	ldr	r3, [r6, #0]
    7ad4:	429a      	cmp	r2, r3
    7ad6:	d1dc      	bne.n	7a92 <usb_keyboard_send+0x2e>
    7ad8:	485f      	ldr	r0, [pc, #380]	; (7c58 <usb_keyboard_send+0x1f4>)
    7ada:	e7dd      	b.n	7a98 <usb_keyboard_send+0x34>
		else if ( protocol == 1 ) // NKRO Mode
    7adc:	2f01      	cmp	r7, #1
    7ade:	d101      	bne.n	7ae4 <usb_keyboard_send+0x80>
			if ( usb_tx_packet_count( NKRO_KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    7ae0:	2002      	movs	r0, #2
    7ae2:	e7e5      	b.n	7ab0 <usb_keyboard_send+0x4c>
		else if ( buffer->changed &
    7ae4:	f895 3020 	ldrb.w	r3, [r5, #32]
    7ae8:	f013 0f0c 	tst.w	r3, #12
    7aec:	d0e4      	beq.n	7ab8 <usb_keyboard_send+0x54>
			if ( usb_tx_packet_count( SYS_CTRL_ENDPOINT ) < TX_PACKET_LIMIT )
    7aee:	2003      	movs	r0, #3
    7af0:	e7de      	b.n	7ab0 <usb_keyboard_send+0x4c>
				tx_packet = usb_malloc();
    7af2:	f000 f90d 	bl	7d10 <usb_malloc>
				if ( tx_packet )
    7af6:	4604      	mov	r4, r0
    7af8:	2800      	cmp	r0, #0
    7afa:	d0dd      	beq.n	7ab8 <usb_keyboard_send+0x54>
	transmit_previous_timeout = 0;
    7afc:	2300      	movs	r3, #0
    7afe:	f888 3000 	strb.w	r3, [r8]
	if ( buffer->changed & USBKeyChangeState_System )
    7b02:	f895 3020 	ldrb.w	r3, [r5, #32]
    7b06:	075a      	lsls	r2, r3, #29
    7b08:	d51f      	bpl.n	7b4a <usb_keyboard_send+0xe6>
		if ( Output_DebugMode )
    7b0a:	4b54      	ldr	r3, [pc, #336]	; (7c5c <usb_keyboard_send+0x1f8>)
    7b0c:	781b      	ldrb	r3, [r3, #0]
    7b0e:	b113      	cbz	r3, 7b16 <usb_keyboard_send+0xb2>
			USB_SysCtrlDebug( buffer );
    7b10:	4628      	mov	r0, r5
    7b12:	f7fe fee9 	bl	68e8 <USB_SysCtrlDebug>
		USBKeys_idle.sys_ctrl = buffer->sys_ctrl;
    7b16:	4b52      	ldr	r3, [pc, #328]	; (7c60 <usb_keyboard_send+0x1fc>)
    7b18:	7f6a      	ldrb	r2, [r5, #29]
    7b1a:	775a      	strb	r2, [r3, #29]
		*tx_buf++ = 0x02; // ID
    7b1c:	2302      	movs	r3, #2
    7b1e:	7223      	strb	r3, [r4, #8]
		*tx_buf   = buffer->sys_ctrl;
    7b20:	7f6a      	ldrb	r2, [r5, #29]
    7b22:	7262      	strb	r2, [r4, #9]
		tx_packet->len = 2;
    7b24:	8023      	strh	r3, [r4, #0]
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    7b26:	4621      	mov	r1, r4
    7b28:	2003      	movs	r0, #3
    7b2a:	f7ff fc4f 	bl	73cc <usb_tx>
		buffer->changed &= ~USBKeyChangeState_System; // Mark sent
    7b2e:	f895 3020 	ldrb.w	r3, [r5, #32]
    7b32:	f023 0304 	bic.w	r3, r3, #4
			buffer->changed = USBKeyChangeState_None; // Mark sent
    7b36:	f885 3020 	strb.w	r3, [r5, #32]
    7b3a:	e024      	b.n	7b86 <usb_keyboard_send+0x122>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    7b3c:	f898 3000 	ldrb.w	r3, [r8]
    7b40:	2b00      	cmp	r3, #0
    7b42:	d1bf      	bne.n	7ac4 <usb_keyboard_send+0x60>
		yield();
    7b44:	f7f9 fd66 	bl	1614 <yield>
		if ( !usb_configuration )
    7b48:	e79c      	b.n	7a84 <usb_keyboard_send+0x20>
	if ( buffer->changed & USBKeyChangeState_Consumer )
    7b4a:	071b      	lsls	r3, r3, #28
    7b4c:	d518      	bpl.n	7b80 <usb_keyboard_send+0x11c>
		if ( Output_DebugMode )
    7b4e:	4b43      	ldr	r3, [pc, #268]	; (7c5c <usb_keyboard_send+0x1f8>)
    7b50:	781b      	ldrb	r3, [r3, #0]
    7b52:	b113      	cbz	r3, 7b5a <usb_keyboard_send+0xf6>
			USB_ConsCtrlDebug( buffer );
    7b54:	4628      	mov	r0, r5
    7b56:	f7fe fee5 	bl	6924 <USB_ConsCtrlDebug>
		USBKeys_idle.cons_ctrl = buffer->cons_ctrl;
    7b5a:	4b41      	ldr	r3, [pc, #260]	; (7c60 <usb_keyboard_send+0x1fc>)
    7b5c:	8bea      	ldrh	r2, [r5, #30]
    7b5e:	83da      	strh	r2, [r3, #30]
		*tx_buf++ = 0x03; // ID
    7b60:	2003      	movs	r0, #3
    7b62:	7220      	strb	r0, [r4, #8]
		*tx_buf++ = (uint8_t)(buffer->cons_ctrl & 0x00FF);
    7b64:	8beb      	ldrh	r3, [r5, #30]
    7b66:	7263      	strb	r3, [r4, #9]
		*tx_buf   = (uint8_t)(buffer->cons_ctrl >> 8);
    7b68:	8beb      	ldrh	r3, [r5, #30]
		tx_packet->len = 3;
    7b6a:	8020      	strh	r0, [r4, #0]
		*tx_buf   = (uint8_t)(buffer->cons_ctrl >> 8);
    7b6c:	0a1b      	lsrs	r3, r3, #8
    7b6e:	72a3      	strb	r3, [r4, #10]
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    7b70:	4621      	mov	r1, r4
    7b72:	f7ff fc2b 	bl	73cc <usb_tx>
		buffer->changed &= ~USBKeyChangeState_Consumer; // Mark sent
    7b76:	f895 3020 	ldrb.w	r3, [r5, #32]
    7b7a:	f023 0308 	bic.w	r3, r3, #8
    7b7e:	e7da      	b.n	7b36 <usb_keyboard_send+0xd2>
	switch ( protocol )
    7b80:	b147      	cbz	r7, 7b94 <usb_keyboard_send+0x130>
    7b82:	2f01      	cmp	r7, #1
    7b84:	d02a      	beq.n	7bdc <usb_keyboard_send+0x178>
}
    7b86:	9a03      	ldr	r2, [sp, #12]
    7b88:	6833      	ldr	r3, [r6, #0]
    7b8a:	429a      	cmp	r2, r3
    7b8c:	d181      	bne.n	7a92 <usb_keyboard_send+0x2e>
    7b8e:	b004      	add	sp, #16
    7b90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if ( Output_DebugMode )
    7b94:	4b31      	ldr	r3, [pc, #196]	; (7c5c <usb_keyboard_send+0x1f8>)
    7b96:	781b      	ldrb	r3, [r3, #0]
    7b98:	b113      	cbz	r3, 7ba0 <usb_keyboard_send+0x13c>
			USB_6KRODebug( buffer );
    7b9a:	4628      	mov	r0, r5
    7b9c:	f7fe fee0 	bl	6960 <USB_6KRODebug>
		memcpy( (void*)&USBKeys_idle.keys, buffer->keys, USB_BOOT_MAX_KEYS );
    7ba0:	4f30      	ldr	r7, [pc, #192]	; (7c64 <usb_keyboard_send+0x200>)
    7ba2:	f105 0801 	add.w	r8, r5, #1
    7ba6:	2206      	movs	r2, #6
    7ba8:	4641      	mov	r1, r8
    7baa:	4638      	mov	r0, r7
    7bac:	f7f9 fcde 	bl	156c <memcpy>
		USBKeys_idle.modifiers = buffer->modifiers;
    7bb0:	782b      	ldrb	r3, [r5, #0]
    7bb2:	f807 3c01 	strb.w	r3, [r7, #-1]
		*tx_buf++ = buffer->modifiers;
    7bb6:	782b      	ldrb	r3, [r5, #0]
    7bb8:	7223      	strb	r3, [r4, #8]
		*tx_buf++ = 0;
    7bba:	2700      	movs	r7, #0
		memcpy( tx_buf, buffer->keys, USB_BOOT_MAX_KEYS );
    7bbc:	2206      	movs	r2, #6
    7bbe:	4641      	mov	r1, r8
		*tx_buf++ = 0;
    7bc0:	7267      	strb	r7, [r4, #9]
		memcpy( tx_buf, buffer->keys, USB_BOOT_MAX_KEYS );
    7bc2:	f104 000a 	add.w	r0, r4, #10
    7bc6:	f7f9 fcd1 	bl	156c <memcpy>
		tx_packet->len = 8;
    7bca:	2308      	movs	r3, #8
    7bcc:	8023      	strh	r3, [r4, #0]
		usb_tx( KEYBOARD_ENDPOINT, tx_packet );
    7bce:	4621      	mov	r1, r4
    7bd0:	2001      	movs	r0, #1
    7bd2:	f7ff fbfb 	bl	73cc <usb_tx>
		buffer->changed = USBKeyChangeState_None;
    7bd6:	f885 7020 	strb.w	r7, [r5, #32]
		break;
    7bda:	e7d4      	b.n	7b86 <usb_keyboard_send+0x122>
		if ( Output_DebugMode )
    7bdc:	4f1f      	ldr	r7, [pc, #124]	; (7c5c <usb_keyboard_send+0x1f8>)
    7bde:	783a      	ldrb	r2, [r7, #0]
    7be0:	b112      	cbz	r2, 7be8 <usb_keyboard_send+0x184>
			dbug_msg("NKRO USB: ");
    7be2:	4821      	ldr	r0, [pc, #132]	; (7c68 <usb_keyboard_send+0x204>)
    7be4:	f001 fc50 	bl	9488 <_print>
		if ( buffer->changed )
    7be8:	f895 3020 	ldrb.w	r3, [r5, #32]
    7bec:	2b00      	cmp	r3, #0
    7bee:	d0ca      	beq.n	7b86 <usb_keyboard_send+0x122>
			if ( Output_DebugMode )
    7bf0:	783b      	ldrb	r3, [r7, #0]
    7bf2:	b113      	cbz	r3, 7bfa <usb_keyboard_send+0x196>
				USB_NKRODebug( buffer );
    7bf4:	4628      	mov	r0, r5
    7bf6:	f7fe fef5 	bl	69e4 <USB_NKRODebug>
			memcpy( (void*)&USBKeys_idle.keys, buffer->keys, USB_NKRO_BITFIELD_SIZE_KEYS );
    7bfa:	4f1a      	ldr	r7, [pc, #104]	; (7c64 <usb_keyboard_send+0x200>)
    7bfc:	f105 0901 	add.w	r9, r5, #1
    7c00:	4649      	mov	r1, r9
    7c02:	221c      	movs	r2, #28
    7c04:	4638      	mov	r0, r7
    7c06:	f7f9 fcb1 	bl	156c <memcpy>
			USBKeys_idle.modifiers = buffer->modifiers;
    7c0a:	782b      	ldrb	r3, [r5, #0]
    7c0c:	f807 3c01 	strb.w	r3, [r7, #-1]
			*tx_buf++ = buffer->modifiers;
    7c10:	462f      	mov	r7, r5
			*tx_buf++ = 0x01; // ID
    7c12:	2301      	movs	r3, #1
    7c14:	7223      	strb	r3, [r4, #8]
			tx_packet->len += 2;
    7c16:	4620      	mov	r0, r4
			*tx_buf++ = buffer->modifiers;
    7c18:	f817 3b17 	ldrb.w	r3, [r7], #23
    7c1c:	7263      	strb	r3, [r4, #9]
			tx_packet->len += 2;
    7c1e:	f04f 0802 	mov.w	r8, #2
			memcpy( tx_buf, buffer->keys, 21 );
    7c22:	4649      	mov	r1, r9
			tx_packet->len += 2;
    7c24:	f820 8b0a 	strh.w	r8, [r0], #10
			memcpy( tx_buf, buffer->keys, 21 );
    7c28:	2215      	movs	r2, #21
    7c2a:	f7f9 fc9f 	bl	156c <memcpy>
			tx_packet->len += 21;
    7c2e:	8823      	ldrh	r3, [r4, #0]
    7c30:	4620      	mov	r0, r4
    7c32:	3315      	adds	r3, #21
			memcpy( tx_buf, buffer->keys + 22, 6 );
    7c34:	4639      	mov	r1, r7
			tx_packet->len += 21;
    7c36:	f820 3b1f 	strh.w	r3, [r0], #31
			memcpy( tx_buf, buffer->keys + 22, 6 );
    7c3a:	2206      	movs	r2, #6
    7c3c:	f7f9 fc96 	bl	156c <memcpy>
			tx_packet->len += 6;
    7c40:	8823      	ldrh	r3, [r4, #0]
    7c42:	3306      	adds	r3, #6
    7c44:	8023      	strh	r3, [r4, #0]
			usb_tx( NKRO_KEYBOARD_ENDPOINT, tx_packet );
    7c46:	4621      	mov	r1, r4
    7c48:	4640      	mov	r0, r8
    7c4a:	f7ff fbbf 	bl	73cc <usb_tx>
    7c4e:	e72b      	b.n	7aa8 <usb_keyboard_send+0x44>
    7c50:	1fffe9d0 	.word	0x1fffe9d0
    7c54:	0000cc7b 	.word	0x0000cc7b
    7c58:	0000cca8 	.word	0x0000cca8
    7c5c:	20000736 	.word	0x20000736
    7c60:	20000750 	.word	0x20000750
    7c64:	20000751 	.word	0x20000751
    7c68:	0000ccec 	.word	0x0000ccec
    7c6c:	1ffff5b2 	.word	0x1ffff5b2
    7c70:	1ffff5b7 	.word	0x1ffff5b7

00007c74 <usb_keyboard_idle_update>:
{
    7c74:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7c76:	4d12      	ldr	r5, [pc, #72]	; (7cc0 <usb_keyboard_idle_update+0x4c>)
    7c78:	682b      	ldr	r3, [r5, #0]
    7c7a:	9301      	str	r3, [sp, #4]
	if ( USBKeys_Idle_Config != 0 )
    7c7c:	4b11      	ldr	r3, [pc, #68]	; (7cc4 <usb_keyboard_idle_update+0x50>)
    7c7e:	7819      	ldrb	r1, [r3, #0]
    7c80:	b189      	cbz	r1, 7ca6 <usb_keyboard_idle_update+0x32>
		if ( USBKeys_Idle_Expiry + USBKeys_Idle_Config * 4 >= systick_millis_count )
    7c82:	7819      	ldrb	r1, [r3, #0]
    7c84:	4b10      	ldr	r3, [pc, #64]	; (7cc8 <usb_keyboard_idle_update+0x54>)
    7c86:	4a11      	ldr	r2, [pc, #68]	; (7ccc <usb_keyboard_idle_update+0x58>)
    7c88:	681b      	ldr	r3, [r3, #0]
    7c8a:	6812      	ldr	r2, [r2, #0]
    7c8c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    7c90:	4293      	cmp	r3, r2
    7c92:	d308      	bcc.n	7ca6 <usb_keyboard_idle_update+0x32>
			USBKeys_idle.changed = USBKeyChangeState_All;
    7c94:	4c0e      	ldr	r4, [pc, #56]	; (7cd0 <usb_keyboard_idle_update+0x5c>)
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    7c96:	4e0f      	ldr	r6, [pc, #60]	; (7cd4 <usb_keyboard_idle_update+0x60>)
			USBKeys_idle.changed = USBKeyChangeState_All;
    7c98:	230f      	movs	r3, #15
    7c9a:	f884 3020 	strb.w	r3, [r4, #32]
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    7c9e:	4627      	mov	r7, r4
			while ( USBKeys_idle.changed )
    7ca0:	f894 3020 	ldrb.w	r3, [r4, #32]
    7ca4:	b92b      	cbnz	r3, 7cb2 <usb_keyboard_idle_update+0x3e>
}
    7ca6:	9a01      	ldr	r2, [sp, #4]
    7ca8:	682b      	ldr	r3, [r5, #0]
    7caa:	429a      	cmp	r2, r3
    7cac:	d006      	beq.n	7cbc <usb_keyboard_idle_update+0x48>
    7cae:	f7f9 fc39 	bl	1524 <__stack_chk_fail>
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    7cb2:	7831      	ldrb	r1, [r6, #0]
    7cb4:	4638      	mov	r0, r7
    7cb6:	f7ff fed5 	bl	7a64 <usb_keyboard_send>
    7cba:	e7f1      	b.n	7ca0 <usb_keyboard_idle_update+0x2c>
}
    7cbc:	b003      	add	sp, #12
    7cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7cc0:	1fffe9d0 	.word	0x1fffe9d0
    7cc4:	1ffff463 	.word	0x1ffff463
    7cc8:	2000079c 	.word	0x2000079c
    7ccc:	1ffff048 	.word	0x1ffff048
    7cd0:	20000750 	.word	0x20000750
    7cd4:	1fffeba8 	.word	0x1fffeba8

00007cd8 <usb_keyboard_clear>:
{
    7cd8:	b530      	push	{r4, r5, lr}
    7cda:	4c0c      	ldr	r4, [pc, #48]	; (7d0c <usb_keyboard_clear+0x34>)
    7cdc:	b08b      	sub	sp, #44	; 0x2c
    7cde:	6823      	ldr	r3, [r4, #0]
    7ce0:	9309      	str	r3, [sp, #36]	; 0x24
	USBKeys buffer = {
    7ce2:	2222      	movs	r2, #34	; 0x22
{
    7ce4:	4605      	mov	r5, r0
	USBKeys buffer = {
    7ce6:	2100      	movs	r1, #0
    7ce8:	4668      	mov	r0, sp
    7cea:	f7f9 fc29 	bl	1540 <memset>
    7cee:	230f      	movs	r3, #15
	usb_keyboard_send( &buffer, protocol );
    7cf0:	4629      	mov	r1, r5
    7cf2:	4668      	mov	r0, sp
	USBKeys buffer = {
    7cf4:	f88d 3020 	strb.w	r3, [sp, #32]
	usb_keyboard_send( &buffer, protocol );
    7cf8:	f7ff feb4 	bl	7a64 <usb_keyboard_send>
}
    7cfc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    7cfe:	6823      	ldr	r3, [r4, #0]
    7d00:	429a      	cmp	r2, r3
    7d02:	d001      	beq.n	7d08 <usb_keyboard_clear+0x30>
    7d04:	f7f9 fc0e 	bl	1524 <__stack_chk_fail>
    7d08:	b00b      	add	sp, #44	; 0x2c
    7d0a:	bd30      	pop	{r4, r5, pc}
    7d0c:	1fffe9d0 	.word	0x1fffe9d0

00007d10 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t *usb_malloc()
{
    7d10:	b513      	push	{r0, r1, r4, lr}
    7d12:	4b11      	ldr	r3, [pc, #68]	; (7d58 <usb_malloc+0x48>)
    7d14:	681a      	ldr	r2, [r3, #0]
    7d16:	9201      	str	r2, [sp, #4]
#if defined(_kinetis_)
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    7d18:	b672      	cpsid	i
	avail = usb_buffer_available;
    7d1a:	4c10      	ldr	r4, [pc, #64]	; (7d5c <usb_malloc+0x4c>)
    7d1c:	6821      	ldr	r1, [r4, #0]
	n = __builtin_clz( avail ); // clz = count leading zeros
    7d1e:	fab1 f081 	clz	r0, r1
	if ( n >= NUM_USB_BUFFERS )
    7d22:	281d      	cmp	r0, #29
    7d24:	dd07      	ble.n	7d36 <usb_malloc+0x26>
	{
		__enable_irq();
    7d26:	b662      	cpsie	i
		return NULL;
    7d28:	2000      	movs	r0, #0
	return (usb_packet_t *)p;

#elif defined(_sam_)
	return &usb_packet;
#endif
}
    7d2a:	9a01      	ldr	r2, [sp, #4]
    7d2c:	681b      	ldr	r3, [r3, #0]
    7d2e:	429a      	cmp	r2, r3
    7d30:	d010      	beq.n	7d54 <usb_malloc+0x44>
    7d32:	f7f9 fbf7 	bl	1524 <__stack_chk_fail>
	usb_buffer_available = avail & ~(0x80000000 >> n);
    7d36:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    7d3a:	40c2      	lsrs	r2, r0
    7d3c:	ea21 0102 	bic.w	r1, r1, r2
    7d40:	6021      	str	r1, [r4, #0]
	__enable_irq();
    7d42:	b662      	cpsie	i
	p = usb_buffer_memory + ( n * sizeof(usb_packet_t) );
    7d44:	4c06      	ldr	r4, [pc, #24]	; (7d60 <usb_malloc+0x50>)
    7d46:	2248      	movs	r2, #72	; 0x48
    7d48:	4342      	muls	r2, r0
    7d4a:	18a0      	adds	r0, r4, r2
	*(uint32_t *)p = 0;
    7d4c:	2100      	movs	r1, #0
    7d4e:	50a1      	str	r1, [r4, r2]
	*(uint32_t *)(p + 4) = 0;
    7d50:	6041      	str	r1, [r0, #4]
	return (usb_packet_t *)p;
    7d52:	e7ea      	b.n	7d2a <usb_malloc+0x1a>
}
    7d54:	b002      	add	sp, #8
    7d56:	bd10      	pop	{r4, pc}
    7d58:	1fffe9d0 	.word	0x1fffe9d0
    7d5c:	1fffefd8 	.word	0x1fffefd8
    7d60:	1fffe160 	.word	0x1fffe160

00007d64 <usb_free>:


void usb_free( usb_packet_t *p )
{
    7d64:	b513      	push	{r0, r1, r4, lr}
    7d66:	4a16      	ldr	r2, [pc, #88]	; (7dc0 <usb_free+0x5c>)
    7d68:	6813      	ldr	r3, [r2, #0]
    7d6a:	9301      	str	r3, [sp, #4]
#if defined(_kinetis_)
	unsigned int n, mask;

	n = ( (uint8_t *)p - usb_buffer_memory ) / sizeof(usb_packet_t);
    7d6c:	4b15      	ldr	r3, [pc, #84]	; (7dc4 <usb_free+0x60>)
    7d6e:	2148      	movs	r1, #72	; 0x48
    7d70:	1ac3      	subs	r3, r0, r3
    7d72:	fbb3 f3f1 	udiv	r3, r3, r1
	if ( n >= NUM_USB_BUFFERS )
    7d76:	2b1d      	cmp	r3, #29
    7d78:	4614      	mov	r4, r2
    7d7a:	d81a      	bhi.n	7db2 <usb_free+0x4e>
		return;

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if ( usb_rx_memory_needed && usb_configuration )
    7d7c:	4912      	ldr	r1, [pc, #72]	; (7dc8 <usb_free+0x64>)
    7d7e:	7809      	ldrb	r1, [r1, #0]
    7d80:	b169      	cbz	r1, 7d9e <usb_free+0x3a>
    7d82:	4912      	ldr	r1, [pc, #72]	; (7dcc <usb_free+0x68>)
    7d84:	7809      	ldrb	r1, [r1, #0]
    7d86:	b151      	cbz	r1, 7d9e <usb_free+0x3a>
	{
		usb_rx_memory( p );
    7d88:	9901      	ldr	r1, [sp, #4]
    7d8a:	6813      	ldr	r3, [r2, #0]
    7d8c:	4299      	cmp	r1, r3
    7d8e:	d001      	beq.n	7d94 <usb_free+0x30>
	mask = (0x80000000 >> n);
	__disable_irq();
	usb_buffer_available |= mask;
	__enable_irq();
#endif
}
    7d90:	f7f9 fbc8 	bl	1524 <__stack_chk_fail>
    7d94:	b002      	add	sp, #8
    7d96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usb_rx_memory( p );
    7d9a:	f7ff bacb 	b.w	7334 <usb_rx_memory>
	__disable_irq();
    7d9e:	b672      	cpsid	i
	usb_buffer_available |= mask;
    7da0:	490b      	ldr	r1, [pc, #44]	; (7dd0 <usb_free+0x6c>)
	mask = (0x80000000 >> n);
    7da2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    7da6:	fa22 f303 	lsr.w	r3, r2, r3
	usb_buffer_available |= mask;
    7daa:	680a      	ldr	r2, [r1, #0]
    7dac:	431a      	orrs	r2, r3
    7dae:	600a      	str	r2, [r1, #0]
	__enable_irq();
    7db0:	b662      	cpsie	i
}
    7db2:	9a01      	ldr	r2, [sp, #4]
    7db4:	6823      	ldr	r3, [r4, #0]
    7db6:	429a      	cmp	r2, r3
    7db8:	d1ea      	bne.n	7d90 <usb_free+0x2c>
    7dba:	b002      	add	sp, #8
    7dbc:	bd10      	pop	{r4, pc}
    7dbe:	bf00      	nop
    7dc0:	1fffe9d0 	.word	0x1fffe9d0
    7dc4:	1fffe160 	.word	0x1fffe160
    7dc8:	1ffff5b6 	.word	0x1ffff5b6
    7dcc:	1ffff5b2 	.word	0x1ffff5b2
    7dd0:	1fffefd8 	.word	0x1fffefd8

00007dd4 <usb_mouse_send>:

// Process pending mouse commands
// XXX Proper support will require KLL generation of the USB descriptors
//     Similar support will be required for joystick control
void usb_mouse_send()
{
    7dd4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    7dd8:	4d37      	ldr	r5, [pc, #220]	; (7eb8 <usb_mouse_send+0xe4>)
	usb_packet_t *tx_packet;

	// Wait till ready
	while ( 1 )
	{
		if ( !usb_configuration )
    7dda:	4f38      	ldr	r7, [pc, #224]	; (7ebc <usb_mouse_send+0xe8>)
{
    7ddc:	682b      	ldr	r3, [r5, #0]
    7dde:	9303      	str	r3, [sp, #12]
	Time start = Time_now();
    7de0:	ac01      	add	r4, sp, #4
    7de2:	4620      	mov	r0, r4
    7de4:	f7f9 fe8c 	bl	1b00 <Time_now>
    7de8:	4e35      	ldr	r6, [pc, #212]	; (7ec0 <usb_mouse_send+0xec>)
		if ( !usb_configuration )
    7dea:	783b      	ldrb	r3, [r7, #0]
    7dec:	b95b      	cbnz	r3, 7e06 <usb_mouse_send+0x32>
		{
			erro_print("USB not configured...");
    7dee:	9a03      	ldr	r2, [sp, #12]
    7df0:	682b      	ldr	r3, [r5, #0]
    7df2:	429a      	cmp	r2, r3
    7df4:	d001      	beq.n	7dfa <usb_mouse_send+0x26>
	USBMouse_Relative_x = 0;
	USBMouse_Relative_y = 0;
	USBMouse_VertWheel = 0;
	USBMouse_HoriWheel = 0;
	USBMouse_Changed = 0;
}
    7df6:	f7f9 fb95 	bl	1524 <__stack_chk_fail>
			erro_print("USB not configured...");
    7dfa:	4832      	ldr	r0, [pc, #200]	; (7ec4 <usb_mouse_send+0xf0>)
}
    7dfc:	b004      	add	sp, #16
    7dfe:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			erro_print("USB not configured...");
    7e02:	f001 bb41 	b.w	9488 <_print>
		if ( usb_tx_packet_count( MOUSE_ENDPOINT ) < TX_PACKET_LIMIT )
    7e06:	2007      	movs	r0, #7
    7e08:	f7ff fa74 	bl	72f4 <usb_tx_packet_count>
    7e0c:	2802      	cmp	r0, #2
    7e0e:	d91e      	bls.n	7e4e <usb_mouse_send+0x7a>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    7e10:	e894 0003 	ldmia.w	r4, {r0, r1}
    7e14:	f7f9 ff98 	bl	1d48 <Time_duration_ms>
    7e18:	281e      	cmp	r0, #30
    7e1a:	d947      	bls.n	7eac <usb_mouse_send+0xd8>
			transmit_previous_timeout = 1;
    7e1c:	2301      	movs	r3, #1
			warn_print("USB Transmit Timeout...");
    7e1e:	482a      	ldr	r0, [pc, #168]	; (7ec8 <usb_mouse_send+0xf4>)
			transmit_previous_timeout = 1;
    7e20:	7033      	strb	r3, [r6, #0]
			warn_print("USB Transmit Timeout...");
    7e22:	f001 fb31 	bl	9488 <_print>
			USBMouse_Buttons = 0;
    7e26:	4a29      	ldr	r2, [pc, #164]	; (7ecc <usb_mouse_send+0xf8>)
    7e28:	2300      	movs	r3, #0
    7e2a:	8013      	strh	r3, [r2, #0]
			USBMouse_Relative_x = 0;
    7e2c:	4a28      	ldr	r2, [pc, #160]	; (7ed0 <usb_mouse_send+0xfc>)
    7e2e:	8013      	strh	r3, [r2, #0]
			USBMouse_Relative_y = 0;
    7e30:	4a28      	ldr	r2, [pc, #160]	; (7ed4 <usb_mouse_send+0x100>)
    7e32:	8013      	strh	r3, [r2, #0]
			USBMouse_VertWheel = 0;
    7e34:	4a28      	ldr	r2, [pc, #160]	; (7ed8 <usb_mouse_send+0x104>)
    7e36:	7013      	strb	r3, [r2, #0]
			USBMouse_HoriWheel = 0;
    7e38:	4a28      	ldr	r2, [pc, #160]	; (7edc <usb_mouse_send+0x108>)
    7e3a:	7013      	strb	r3, [r2, #0]
			USBMouse_Changed = 0;
    7e3c:	4a28      	ldr	r2, [pc, #160]	; (7ee0 <usb_mouse_send+0x10c>)
    7e3e:	7013      	strb	r3, [r2, #0]
}
    7e40:	9a03      	ldr	r2, [sp, #12]
    7e42:	682b      	ldr	r3, [r5, #0]
    7e44:	429a      	cmp	r2, r3
    7e46:	d1d6      	bne.n	7df6 <usb_mouse_send+0x22>
    7e48:	b004      	add	sp, #16
    7e4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			tx_packet = usb_malloc();
    7e4e:	f7ff ff5f 	bl	7d10 <usb_malloc>
			if ( tx_packet )
    7e52:	4601      	mov	r1, r0
    7e54:	2800      	cmp	r0, #0
    7e56:	d0db      	beq.n	7e10 <usb_mouse_send+0x3c>
	packet_data[0] = USBMouse_Buttons;
    7e58:	f8df 9070 	ldr.w	r9, [pc, #112]	; 7ecc <usb_mouse_send+0xf8>
	packet_data[1] = (uint16_t)USBMouse_Relative_x;
    7e5c:	f8df 8070 	ldr.w	r8, [pc, #112]	; 7ed0 <usb_mouse_send+0xfc>
	packet_data[0] = USBMouse_Buttons;
    7e60:	f8b9 3000 	ldrh.w	r3, [r9]
	packet_data[2] = (uint16_t)USBMouse_Relative_y;
    7e64:	4f1b      	ldr	r7, [pc, #108]	; (7ed4 <usb_mouse_send+0x100>)
	packet_data[0] = USBMouse_Buttons;
    7e66:	8103      	strh	r3, [r0, #8]
	transmit_previous_timeout = 0;
    7e68:	2400      	movs	r4, #0
	packet_data[1] = (uint16_t)USBMouse_Relative_x;
    7e6a:	f8b8 3000 	ldrh.w	r3, [r8]
	transmit_previous_timeout = 0;
    7e6e:	7034      	strb	r4, [r6, #0]
	packet_data[3] = (uint16_t)(USBMouse_VertWheel | (USBMouse_HoriWheel << 8));
    7e70:	f8df a068 	ldr.w	sl, [pc, #104]	; 7edc <usb_mouse_send+0x108>
    7e74:	4e18      	ldr	r6, [pc, #96]	; (7ed8 <usb_mouse_send+0x104>)
	packet_data[1] = (uint16_t)USBMouse_Relative_x;
    7e76:	8143      	strh	r3, [r0, #10]
	packet_data[2] = (uint16_t)USBMouse_Relative_y;
    7e78:	883b      	ldrh	r3, [r7, #0]
    7e7a:	8183      	strh	r3, [r0, #12]
	packet_data[3] = (uint16_t)(USBMouse_VertWheel | (USBMouse_HoriWheel << 8));
    7e7c:	7833      	ldrb	r3, [r6, #0]
    7e7e:	f89a 2000 	ldrb.w	r2, [sl]
    7e82:	b25b      	sxtb	r3, r3
    7e84:	b252      	sxtb	r2, r2
    7e86:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    7e8a:	81c3      	strh	r3, [r0, #14]
	tx_packet->len = 8;
    7e8c:	2308      	movs	r3, #8
    7e8e:	8003      	strh	r3, [r0, #0]
	usb_tx( MOUSE_ENDPOINT, tx_packet );
    7e90:	2007      	movs	r0, #7
    7e92:	f7ff fa9b 	bl	73cc <usb_tx>
	USBMouse_Changed = 0;
    7e96:	4b12      	ldr	r3, [pc, #72]	; (7ee0 <usb_mouse_send+0x10c>)
	USBMouse_Buttons = 0;
    7e98:	f8a9 4000 	strh.w	r4, [r9]
	USBMouse_Changed = 0;
    7e9c:	701c      	strb	r4, [r3, #0]
	USBMouse_Relative_x = 0;
    7e9e:	f8a8 4000 	strh.w	r4, [r8]
	USBMouse_Relative_y = 0;
    7ea2:	803c      	strh	r4, [r7, #0]
	USBMouse_VertWheel = 0;
    7ea4:	7034      	strb	r4, [r6, #0]
	USBMouse_HoriWheel = 0;
    7ea6:	f88a 4000 	strb.w	r4, [sl]
    7eaa:	e7c9      	b.n	7e40 <usb_mouse_send+0x6c>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    7eac:	7833      	ldrb	r3, [r6, #0]
    7eae:	2b00      	cmp	r3, #0
    7eb0:	d1b4      	bne.n	7e1c <usb_mouse_send+0x48>
		yield();
    7eb2:	f7f9 fbaf 	bl	1614 <yield>
		if ( !usb_configuration )
    7eb6:	e798      	b.n	7dea <usb_mouse_send+0x16>
    7eb8:	1fffe9d0 	.word	0x1fffe9d0
    7ebc:	1ffff5b2 	.word	0x1ffff5b2
    7ec0:	1ffff5b8 	.word	0x1ffff5b8
    7ec4:	0000cc7b 	.word	0x0000cc7b
    7ec8:	0000cd0a 	.word	0x0000cd0a
    7ecc:	20000748 	.word	0x20000748
    7ed0:	20000798 	.word	0x20000798
    7ed4:	2000074c 	.word	0x2000074c
    7ed8:	2000074a 	.word	0x2000074a
    7edc:	2000079a 	.word	0x2000079a
    7ee0:	20000741 	.word	0x20000741

00007ee4 <usb_rawio_available>:

// ----- Functions -----

// Check for packets available from host
uint32_t usb_rawio_available()
{
    7ee4:	b507      	push	{r0, r1, r2, lr}
    7ee6:	4b09      	ldr	r3, [pc, #36]	; (7f0c <usb_rawio_available+0x28>)
    7ee8:	681a      	ldr	r2, [r3, #0]
    7eea:	9201      	str	r2, [sp, #4]
	// Error if USB isn't configured
	if ( !usb_configuration )
    7eec:	4a08      	ldr	r2, [pc, #32]	; (7f10 <usb_rawio_available+0x2c>)
    7eee:	7812      	ldrb	r2, [r2, #0]
    7ef0:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    7ef4:	b10a      	cbz	r2, 7efa <usb_rawio_available+0x16>
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
	{
		return 0;
	}
	return usb_rx_byte_count_data[ endpoint ];
    7ef6:	4a07      	ldr	r2, [pc, #28]	; (7f14 <usb_rawio_available+0x30>)
    7ef8:	8a10      	ldrh	r0, [r2, #16]
		return 0;

	// Query number of bytes available from the endpoint
	return usb_rx_byte_count( RAWIO_RX_ENDPOINT );
}
    7efa:	9a01      	ldr	r2, [sp, #4]
    7efc:	681b      	ldr	r3, [r3, #0]
    7efe:	429a      	cmp	r2, r3
    7f00:	d001      	beq.n	7f06 <usb_rawio_available+0x22>
    7f02:	f7f9 fb0f 	bl	1524 <__stack_chk_fail>
    7f06:	b003      	add	sp, #12
    7f08:	f85d fb04 	ldr.w	pc, [sp], #4
    7f0c:	1fffe9d0 	.word	0x1fffe9d0
    7f10:	1ffff5b2 	.word	0x1ffff5b2
    7f14:	200007a8 	.word	0x200007a8

00007f18 <usb_rawio_rx>:

// Retrieve packets from host
// Always returns RAWIO_RX_SIZE
int32_t usb_rawio_rx( void *buf, uint32_t timeout )
{
    7f18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7f1c:	4f1c      	ldr	r7, [pc, #112]	; (7f90 <usb_rawio_rx+0x78>)

	// Read
	while ( 1 )
	{
		// Error if USB isn't configured
		if ( !usb_configuration )
    7f1e:	f8df 9078 	ldr.w	r9, [pc, #120]	; 7f98 <usb_rawio_rx+0x80>
{
    7f22:	683b      	ldr	r3, [r7, #0]
    7f24:	b085      	sub	sp, #20
	Time start = Time_now();
    7f26:	ad01      	add	r5, sp, #4
{
    7f28:	4680      	mov	r8, r0
	Time start = Time_now();
    7f2a:	4628      	mov	r0, r5
{
    7f2c:	460e      	mov	r6, r1
    7f2e:	9303      	str	r3, [sp, #12]
	Time start = Time_now();
    7f30:	f7f9 fde6 	bl	1b00 <Time_now>
		if ( !usb_configuration )
    7f34:	f899 3000 	ldrb.w	r3, [r9]
    7f38:	b31b      	cbz	r3, 7f82 <usb_rawio_rx+0x6a>
			return -1;

		// Retrieve packet
		rx_packet = usb_rx( RAWIO_RX_ENDPOINT );
    7f3a:	2009      	movs	r0, #9
    7f3c:	f7ff f9b2 	bl	72a4 <usb_rx>
		if ( rx_packet )
    7f40:	4604      	mov	r4, r0
    7f42:	b998      	cbnz	r0, 7f6c <usb_rawio_rx+0x54>
			break;

		// Check for timeout
		if ( Time_duration_ms( start ) > timeout || !timeout )
    7f44:	e895 0003 	ldmia.w	r5, {r0, r1}
    7f48:	f7f9 fefe 	bl	1d48 <Time_duration_ms>
    7f4c:	42b0      	cmp	r0, r6
    7f4e:	d800      	bhi.n	7f52 <usb_rawio_rx+0x3a>
    7f50:	b94e      	cbnz	r6, 7f66 <usb_rawio_rx+0x4e>
		{
			warn_msg("RAWIO Rx - Timeout, dropping packet.");
    7f52:	4810      	ldr	r0, [pc, #64]	; (7f94 <usb_rawio_rx+0x7c>)
    7f54:	f001 fa98 	bl	9488 <_print>
			return 0;
    7f58:	2000      	movs	r0, #0
	memcpy( buf, rx_packet->buf, RAWIO_RX_SIZE );
	usb_free( rx_packet );

	// Data sent in full packet chunks
	return RAWIO_RX_SIZE;
}
    7f5a:	9a03      	ldr	r2, [sp, #12]
    7f5c:	683b      	ldr	r3, [r7, #0]
    7f5e:	429a      	cmp	r2, r3
    7f60:	d012      	beq.n	7f88 <usb_rawio_rx+0x70>
    7f62:	f7f9 fadf 	bl	1524 <__stack_chk_fail>
		yield();
    7f66:	f7f9 fb55 	bl	1614 <yield>
		if ( !usb_configuration )
    7f6a:	e7e3      	b.n	7f34 <usb_rawio_rx+0x1c>
	memcpy( buf, rx_packet->buf, RAWIO_RX_SIZE );
    7f6c:	f100 0108 	add.w	r1, r0, #8
    7f70:	2240      	movs	r2, #64	; 0x40
    7f72:	4640      	mov	r0, r8
    7f74:	f7f9 fafa 	bl	156c <memcpy>
	usb_free( rx_packet );
    7f78:	4620      	mov	r0, r4
    7f7a:	f7ff fef3 	bl	7d64 <usb_free>
	return RAWIO_RX_SIZE;
    7f7e:	2040      	movs	r0, #64	; 0x40
    7f80:	e7eb      	b.n	7f5a <usb_rawio_rx+0x42>
			return -1;
    7f82:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    7f86:	e7e8      	b.n	7f5a <usb_rawio_rx+0x42>
}
    7f88:	b005      	add	sp, #20
    7f8a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    7f8e:	bf00      	nop
    7f90:	1fffe9d0 	.word	0x1fffe9d0
    7f94:	0000cd39 	.word	0x0000cd39
    7f98:	1ffff5b2 	.word	0x1ffff5b2

00007f9c <usb_rawio_tx>:

// Send packet to host
// XXX Only transfers RAWIO_TX_SIZE on each call (likely 64 bytes)
// Always returns RAWIO_TX_SIZE
int32_t usb_rawio_tx( const void *buf, uint32_t timeout )
{
    7f9c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    7fa0:	4f20      	ldr	r7, [pc, #128]	; (8024 <usb_rawio_tx+0x88>)
	Time start = Time_now();

	while ( 1 )
	{
		// Error if USB isn't configured
		if ( !usb_configuration )
    7fa2:	f8df 9088 	ldr.w	r9, [pc, #136]	; 802c <usb_rawio_tx+0x90>
{
    7fa6:	683b      	ldr	r3, [r7, #0]
    7fa8:	b085      	sub	sp, #20
	Time start = Time_now();
    7faa:	ac01      	add	r4, sp, #4
{
    7fac:	4680      	mov	r8, r0
	Time start = Time_now();
    7fae:	4620      	mov	r0, r4
{
    7fb0:	460e      	mov	r6, r1
    7fb2:	9303      	str	r3, [sp, #12]
	Time start = Time_now();
    7fb4:	f7f9 fda4 	bl	1b00 <Time_now>
		if ( !usb_configuration )
    7fb8:	f899 3000 	ldrb.w	r3, [r9]
    7fbc:	b35b      	cbz	r3, 8016 <usb_rawio_tx+0x7a>
			return -1;

		// Make sure we haven't exceeded the outgoing packet limit
		if ( usb_tx_packet_count( RAWIO_TX_ENDPOINT ) < TX_PACKET_LIMIT )
    7fbe:	2008      	movs	r0, #8
    7fc0:	f7ff f998 	bl	72f4 <usb_tx_packet_count>
    7fc4:	2804      	cmp	r0, #4
    7fc6:	d90f      	bls.n	7fe8 <usb_rawio_tx+0x4c>
			if ( tx_packet )
				break;
		}

		// Check for timeout
		if ( Time_duration_ms( start ) > timeout || !timeout )
    7fc8:	e894 0003 	ldmia.w	r4, {r0, r1}
    7fcc:	f7f9 febc 	bl	1d48 <Time_duration_ms>
    7fd0:	42b0      	cmp	r0, r6
    7fd2:	d91b      	bls.n	800c <usb_rawio_tx+0x70>
		{
			warn_msg("RAWIO Tx - Timeout, dropping packet.");
    7fd4:	4814      	ldr	r0, [pc, #80]	; (8028 <usb_rawio_tx+0x8c>)
    7fd6:	f001 fa57 	bl	9488 <_print>
			return 0;
    7fda:	2000      	movs	r0, #0

	// Send USB packet
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );

	return RAWIO_TX_SIZE;
}
    7fdc:	9a03      	ldr	r2, [sp, #12]
    7fde:	683b      	ldr	r3, [r7, #0]
    7fe0:	429a      	cmp	r2, r3
    7fe2:	d01b      	beq.n	801c <usb_rawio_tx+0x80>
    7fe4:	f7f9 fa9e 	bl	1524 <__stack_chk_fail>
			tx_packet = usb_malloc();
    7fe8:	f7ff fe92 	bl	7d10 <usb_malloc>
			if ( tx_packet )
    7fec:	4605      	mov	r5, r0
    7fee:	2800      	cmp	r0, #0
    7ff0:	d0ea      	beq.n	7fc8 <usb_rawio_tx+0x2c>
	memcpy( tx_packet->buf, buf, RAWIO_TX_SIZE );
    7ff2:	2240      	movs	r2, #64	; 0x40
    7ff4:	4641      	mov	r1, r8
	tx_packet->len = RAWIO_TX_SIZE;
    7ff6:	2440      	movs	r4, #64	; 0x40
	memcpy( tx_packet->buf, buf, RAWIO_TX_SIZE );
    7ff8:	3008      	adds	r0, #8
    7ffa:	f7f9 fab7 	bl	156c <memcpy>
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );
    7ffe:	2008      	movs	r0, #8
	tx_packet->len = RAWIO_TX_SIZE;
    8000:	802c      	strh	r4, [r5, #0]
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );
    8002:	4629      	mov	r1, r5
    8004:	f7ff f9e2 	bl	73cc <usb_tx>
	return RAWIO_TX_SIZE;
    8008:	4620      	mov	r0, r4
    800a:	e7e7      	b.n	7fdc <usb_rawio_tx+0x40>
		if ( Time_duration_ms( start ) > timeout || !timeout )
    800c:	2e00      	cmp	r6, #0
    800e:	d0e1      	beq.n	7fd4 <usb_rawio_tx+0x38>
		yield();
    8010:	f7f9 fb00 	bl	1614 <yield>
		if ( !usb_configuration )
    8014:	e7d0      	b.n	7fb8 <usb_rawio_tx+0x1c>
			return -1;
    8016:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    801a:	e7df      	b.n	7fdc <usb_rawio_tx+0x40>
}
    801c:	b005      	add	sp, #20
    801e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    8022:	bf00      	nop
    8024:	1fffe9d0 	.word	0x1fffe9d0
    8028:	0000cd73 	.word	0x0000cd73
    802c:	1ffff5b2 	.word	0x1ffff5b2

00008030 <usb_serial_getchar>:

// ----- Functions -----

// get the next character, or -1 if nothing received
int usb_serial_getchar()
{
    8030:	b573      	push	{r0, r1, r4, r5, r6, lr}
    8032:	4e15      	ldr	r6, [pc, #84]	; (8088 <usb_serial_getchar+0x58>)
	unsigned int i;
	int c;

	if ( !rx_packet )
    8034:	4c15      	ldr	r4, [pc, #84]	; (808c <usb_serial_getchar+0x5c>)
{
    8036:	6832      	ldr	r2, [r6, #0]
    8038:	9201      	str	r2, [sp, #4]
	if ( !rx_packet )
    803a:	6822      	ldr	r2, [r4, #0]
    803c:	b162      	cbz	r2, 8058 <usb_serial_getchar+0x28>
			return -1;
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
		if ( !rx_packet )
			return -1;
	}
	i = rx_packet->index;
    803e:	6820      	ldr	r0, [r4, #0]
    8040:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    8042:	18c2      	adds	r2, r0, r3
    8044:	3301      	adds	r3, #1
    8046:	7a15      	ldrb	r5, [r2, #8]
	if ( i >= rx_packet->len )
    8048:	8802      	ldrh	r2, [r0, #0]
    804a:	429a      	cmp	r2, r3
    804c:	d817      	bhi.n	807e <usb_serial_getchar+0x4e>
	{
		usb_free( rx_packet );
    804e:	f7ff fe89 	bl	7d64 <usb_free>
		rx_packet = NULL;
    8052:	2300      	movs	r3, #0
    8054:	6023      	str	r3, [r4, #0]
    8056:	e004      	b.n	8062 <usb_serial_getchar+0x32>
		if ( !usb_configuration )
    8058:	4b0d      	ldr	r3, [pc, #52]	; (8090 <usb_serial_getchar+0x60>)
    805a:	781b      	ldrb	r3, [r3, #0]
    805c:	b943      	cbnz	r3, 8070 <usb_serial_getchar+0x40>
			return -1;
    805e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	else
	{
		rx_packet->index = i;
	}
	return c;
}
    8062:	9a01      	ldr	r2, [sp, #4]
    8064:	6833      	ldr	r3, [r6, #0]
    8066:	429a      	cmp	r2, r3
    8068:	4628      	mov	r0, r5
    806a:	d00a      	beq.n	8082 <usb_serial_getchar+0x52>
    806c:	f7f9 fa5a 	bl	1524 <__stack_chk_fail>
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
    8070:	2005      	movs	r0, #5
    8072:	f7ff f917 	bl	72a4 <usb_rx>
    8076:	6020      	str	r0, [r4, #0]
		if ( !rx_packet )
    8078:	2800      	cmp	r0, #0
    807a:	d1e0      	bne.n	803e <usb_serial_getchar+0xe>
    807c:	e7ef      	b.n	805e <usb_serial_getchar+0x2e>
		rx_packet->index = i;
    807e:	8043      	strh	r3, [r0, #2]
    8080:	e7ef      	b.n	8062 <usb_serial_getchar+0x32>
}
    8082:	b002      	add	sp, #8
    8084:	bd70      	pop	{r4, r5, r6, pc}
    8086:	bf00      	nop
    8088:	1fffe9d0 	.word	0x1fffe9d0
    808c:	1ffff5bc 	.word	0x1ffff5bc
    8090:	1ffff5b2 	.word	0x1ffff5b2

00008094 <usb_serial_available>:
	return rx_packet->buf[ rx_packet->index ];
}

// number of bytes available in the receive buffer
int usb_serial_available()
{
    8094:	b507      	push	{r0, r1, r2, lr}
    8096:	4b0a      	ldr	r3, [pc, #40]	; (80c0 <usb_serial_available+0x2c>)
    8098:	681a      	ldr	r2, [r3, #0]
    809a:	9201      	str	r2, [sp, #4]
    809c:	4a09      	ldr	r2, [pc, #36]	; (80c4 <usb_serial_available+0x30>)
	int count = usb_rx_byte_count( CDC_RX_ENDPOINT );
    809e:	8910      	ldrh	r0, [r2, #8]
	if ( rx_packet )
    80a0:	4a09      	ldr	r2, [pc, #36]	; (80c8 <usb_serial_available+0x34>)
    80a2:	6811      	ldr	r1, [r2, #0]
    80a4:	b119      	cbz	r1, 80ae <usb_serial_available+0x1a>
		count += rx_packet->len - rx_packet->index;
    80a6:	880a      	ldrh	r2, [r1, #0]
    80a8:	8849      	ldrh	r1, [r1, #2]
    80aa:	1a52      	subs	r2, r2, r1
    80ac:	4410      	add	r0, r2
	return count;
}
    80ae:	9a01      	ldr	r2, [sp, #4]
    80b0:	681b      	ldr	r3, [r3, #0]
    80b2:	429a      	cmp	r2, r3
    80b4:	d001      	beq.n	80ba <usb_serial_available+0x26>
    80b6:	f7f9 fa35 	bl	1524 <__stack_chk_fail>
    80ba:	b003      	add	sp, #12
    80bc:	f85d fb04 	ldr.w	pc, [sp], #4
    80c0:	1fffe9d0 	.word	0x1fffe9d0
    80c4:	200007a8 	.word	0x200007a8
    80c8:	1ffff5bc 	.word	0x1ffff5bc

000080cc <usb_serial_write>:
{
	return usb_serial_write( &c, 1 );
}

int usb_serial_write( const void *buffer, uint32_t size )
{
    80cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    80d0:	4f38      	ldr	r7, [pc, #224]	; (81b4 <usb_serial_write+0xe8>)
	uint32_t len;
	Time start;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    80d2:	4d39      	ldr	r5, [pc, #228]	; (81b8 <usb_serial_write+0xec>)
{
    80d4:	683b      	ldr	r3, [r7, #0]
	while ( size > 0 )
	{
		if ( !tx_packet )
    80d6:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 81c4 <usb_serial_write+0xf8>
		{
			start = Time_now();
			while ( 1 )
			{
				if ( !usb_configuration )
    80da:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 81c8 <usb_serial_write+0xfc>
{
    80de:	b085      	sub	sp, #20
    80e0:	4606      	mov	r6, r0
    80e2:	9303      	str	r3, [sp, #12]
	tx_noautoflush = 1;
    80e4:	2301      	movs	r3, #1
{
    80e6:	460c      	mov	r4, r1
	tx_noautoflush = 1;
    80e8:	702b      	strb	r3, [r5, #0]
	while ( size > 0 )
    80ea:	b914      	cbnz	r4, 80f2 <usb_serial_write+0x26>
			usb_tx( CDC_TX_ENDPOINT, tx_packet );
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    80ec:	702c      	strb	r4, [r5, #0]
	return 0;
    80ee:	4620      	mov	r0, r4
    80f0:	e011      	b.n	8116 <usb_serial_write+0x4a>
		if ( !tx_packet )
    80f2:	f8d8 3000 	ldr.w	r3, [r8]
    80f6:	bb8b      	cbnz	r3, 815c <usb_serial_write+0x90>
			start = Time_now();
    80f8:	f10d 0a04 	add.w	sl, sp, #4
    80fc:	4650      	mov	r0, sl
    80fe:	f7f9 fcff 	bl	1b00 <Time_now>
    8102:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 81bc <usb_serial_write+0xf0>
				if ( !usb_configuration )
    8106:	f899 3000 	ldrb.w	r3, [r9]
    810a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    810e:	b943      	cbnz	r3, 8122 <usb_serial_write+0x56>
					tx_noautoflush = 0;
    8110:	702a      	strb	r2, [r5, #0]
					return -1;
    8112:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    8116:	9a03      	ldr	r2, [sp, #12]
    8118:	683b      	ldr	r3, [r7, #0]
    811a:	429a      	cmp	r2, r3
    811c:	d047      	beq.n	81ae <usb_serial_write+0xe2>
    811e:	f7f9 fa01 	bl	1524 <__stack_chk_fail>
				if ( usb_tx_packet_count( CDC_TX_ENDPOINT ) < TX_PACKET_LIMIT )
    8122:	2006      	movs	r0, #6
    8124:	f7ff f8e6 	bl	72f4 <usb_tx_packet_count>
    8128:	2807      	cmp	r0, #7
    812a:	d807      	bhi.n	813c <usb_serial_write+0x70>
					tx_noautoflush = 1;
    812c:	2301      	movs	r3, #1
    812e:	702b      	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    8130:	f7ff fdee 	bl	7d10 <usb_malloc>
    8134:	f8c8 0000 	str.w	r0, [r8]
					if ( tx_packet )
    8138:	b980      	cbnz	r0, 815c <usb_serial_write+0x90>
					tx_noautoflush = 0;
    813a:	7028      	strb	r0, [r5, #0]
				if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    813c:	e89a 0003 	ldmia.w	sl, {r0, r1}
    8140:	f7f9 fe02 	bl	1d48 <Time_duration_ms>
    8144:	2846      	cmp	r0, #70	; 0x46
    8146:	d802      	bhi.n	814e <usb_serial_write+0x82>
    8148:	f89b 3000 	ldrb.w	r3, [fp]
    814c:	b11b      	cbz	r3, 8156 <usb_serial_write+0x8a>
					transmit_previous_timeout = 1;
    814e:	2301      	movs	r3, #1
    8150:	f88b 3000 	strb.w	r3, [fp]
    8154:	e7dd      	b.n	8112 <usb_serial_write+0x46>
				yield();
    8156:	f7f9 fa5d 	bl	1614 <yield>
				if ( !usb_configuration )
    815a:	e7d4      	b.n	8106 <usb_serial_write+0x3a>
		len = CDC_TX_SIZE - tx_packet->index;
    815c:	f8d8 1000 	ldr.w	r1, [r8]
		transmit_previous_timeout = 0;
    8160:	4b16      	ldr	r3, [pc, #88]	; (81bc <usb_serial_write+0xf0>)
    8162:	2200      	movs	r2, #0
    8164:	701a      	strb	r2, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    8166:	884b      	ldrh	r3, [r1, #2]
    8168:	f1c3 0240 	rsb	r2, r3, #64	; 0x40
    816c:	42a2      	cmp	r2, r4
    816e:	bf28      	it	cs
    8170:	4622      	movcs	r2, r4
		tx_packet->index += len;
    8172:	1898      	adds	r0, r3, r2
    8174:	440b      	add	r3, r1
    8176:	8048      	strh	r0, [r1, #2]
		size -= len;
    8178:	1aa4      	subs	r4, r4, r2
    817a:	3307      	adds	r3, #7
    817c:	eb06 0a02 	add.w	sl, r6, r2
		while ( len-- > 0 )
    8180:	4556      	cmp	r6, sl
    8182:	d10f      	bne.n	81a4 <usb_serial_write+0xd8>
		if ( tx_packet->index >= CDC_TX_SIZE )
    8184:	884b      	ldrh	r3, [r1, #2]
    8186:	2b3f      	cmp	r3, #63	; 0x3f
    8188:	d907      	bls.n	819a <usb_serial_write+0xce>
			tx_packet->len = CDC_TX_SIZE;
    818a:	2340      	movs	r3, #64	; 0x40
    818c:	800b      	strh	r3, [r1, #0]
			usb_tx( CDC_TX_ENDPOINT, tx_packet );
    818e:	2006      	movs	r0, #6
    8190:	f7ff f91c 	bl	73cc <usb_tx>
			tx_packet = NULL;
    8194:	2300      	movs	r3, #0
    8196:	f8c8 3000 	str.w	r3, [r8]
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    819a:	4b09      	ldr	r3, [pc, #36]	; (81c0 <usb_serial_write+0xf4>)
    819c:	2205      	movs	r2, #5
    819e:	701a      	strb	r2, [r3, #0]
    81a0:	4656      	mov	r6, sl
    81a2:	e7a2      	b.n	80ea <usb_serial_write+0x1e>
			*dest++ = *src++;
    81a4:	f816 2b01 	ldrb.w	r2, [r6], #1
    81a8:	f803 2f01 	strb.w	r2, [r3, #1]!
    81ac:	e7e8      	b.n	8180 <usb_serial_write+0xb4>
}
    81ae:	b005      	add	sp, #20
    81b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    81b4:	1fffe9d0 	.word	0x1fffe9d0
    81b8:	1ffff5c1 	.word	0x1ffff5c1
    81bc:	1ffff5c0 	.word	0x1ffff5c0
    81c0:	1ffff5c9 	.word	0x1ffff5c9
    81c4:	1ffff5c4 	.word	0x1ffff5c4
    81c8:	1ffff5b2 	.word	0x1ffff5b2

000081cc <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback()
{
    81cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    81ce:	4c16      	ldr	r4, [pc, #88]	; (8228 <usb_serial_flush_callback+0x5c>)
    81d0:	6823      	ldr	r3, [r4, #0]
    81d2:	9301      	str	r3, [sp, #4]
	if ( tx_noautoflush )
    81d4:	4b15      	ldr	r3, [pc, #84]	; (822c <usb_serial_flush_callback+0x60>)
    81d6:	781b      	ldrb	r3, [r3, #0]
    81d8:	4626      	mov	r6, r4
    81da:	f003 07ff 	and.w	r7, r3, #255	; 0xff
    81de:	b943      	cbnz	r3, 81f2 <usb_serial_flush_callback+0x26>
		return;
	if ( tx_packet )
    81e0:	4d13      	ldr	r5, [pc, #76]	; (8230 <usb_serial_flush_callback+0x64>)
    81e2:	6829      	ldr	r1, [r5, #0]
    81e4:	b159      	cbz	r1, 81fe <usb_serial_flush_callback+0x32>
	{
		tx_packet->len = tx_packet->index;
    81e6:	884b      	ldrh	r3, [r1, #2]
    81e8:	800b      	strh	r3, [r1, #0]
		usb_tx( CDC_TX_ENDPOINT, tx_packet );
    81ea:	2006      	movs	r0, #6
    81ec:	f7ff f8ee 	bl	73cc <usb_tx>
		tx_packet = NULL;
    81f0:	602f      	str	r7, [r5, #0]
		else
		{
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    81f2:	9a01      	ldr	r2, [sp, #4]
    81f4:	6833      	ldr	r3, [r6, #0]
    81f6:	429a      	cmp	r2, r3
    81f8:	d109      	bne.n	820e <usb_serial_flush_callback+0x42>
    81fa:	b003      	add	sp, #12
    81fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		usb_packet_t *tx = usb_malloc();
    81fe:	f7ff fd87 	bl	7d10 <usb_malloc>
		if ( tx )
    8202:	4601      	mov	r1, r0
    8204:	b158      	cbz	r0, 821e <usb_serial_flush_callback+0x52>
			usb_tx( CDC_TX_ENDPOINT, tx );
    8206:	9a01      	ldr	r2, [sp, #4]
    8208:	6823      	ldr	r3, [r4, #0]
    820a:	429a      	cmp	r2, r3
    820c:	d001      	beq.n	8212 <usb_serial_flush_callback+0x46>
}
    820e:	f7f9 f989 	bl	1524 <__stack_chk_fail>
			usb_tx( CDC_TX_ENDPOINT, tx );
    8212:	2006      	movs	r0, #6
}
    8214:	b003      	add	sp, #12
    8216:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			usb_tx( CDC_TX_ENDPOINT, tx );
    821a:	f7ff b8d7 	b.w	73cc <usb_tx>
			usb_cdc_transmit_flush_timer = 1;
    821e:	4b05      	ldr	r3, [pc, #20]	; (8234 <usb_serial_flush_callback+0x68>)
    8220:	2201      	movs	r2, #1
    8222:	701a      	strb	r2, [r3, #0]
    8224:	e7e5      	b.n	81f2 <usb_serial_flush_callback+0x26>
    8226:	bf00      	nop
    8228:	1fffe9d0 	.word	0x1fffe9d0
    822c:	1ffff5c1 	.word	0x1ffff5c1
    8230:	1ffff5c4 	.word	0x1ffff5c4
    8234:	1ffff5c9 	.word	0x1ffff5c9

00008238 <cliFunc_clear>:


// ----- CLI Command Functions -----

void cliFunc_clear( char* args)
{
    8238:	b507      	push	{r0, r1, r2, lr}
    823a:	4b07      	ldr	r3, [pc, #28]	; (8258 <cliFunc_clear+0x20>)
    823c:	681a      	ldr	r2, [r3, #0]
    823e:	9201      	str	r2, [sp, #4]
	print("\033[2J\033[H\r"); // Erases the whole screen
    8240:	9a01      	ldr	r2, [sp, #4]
    8242:	681b      	ldr	r3, [r3, #0]
    8244:	429a      	cmp	r2, r3
    8246:	d001      	beq.n	824c <cliFunc_clear+0x14>
    8248:	f7f9 f96c 	bl	1524 <__stack_chk_fail>
    824c:	4803      	ldr	r0, [pc, #12]	; (825c <cliFunc_clear+0x24>)
}
    824e:	b003      	add	sp, #12
    8250:	f85d eb04 	ldr.w	lr, [sp], #4
	print("\033[2J\033[H\r"); // Erases the whole screen
    8254:	f001 b918 	b.w	9488 <_print>
    8258:	1fffe9d0 	.word	0x1fffe9d0
    825c:	0000d0dd 	.word	0x0000d0dd

00008260 <cliFunc_colorTest>:
		CLIHexDebugMode = 1;
	}
}

void cliFunc_colorTest( char* args )
{
    8260:	b513      	push	{r0, r1, r4, lr}
    8262:	4c09      	ldr	r4, [pc, #36]	; (8288 <cliFunc_colorTest+0x28>)
	print( NL );
    8264:	4809      	ldr	r0, [pc, #36]	; (828c <cliFunc_colorTest+0x2c>)
{
    8266:	6823      	ldr	r3, [r4, #0]
    8268:	9301      	str	r3, [sp, #4]
	print( NL );
    826a:	f001 f90d 	bl	9488 <_print>
	print("\x1b[38;2;255;100;0mTRUECOLOR\x1b[0m");
    826e:	9a01      	ldr	r2, [sp, #4]
    8270:	6823      	ldr	r3, [r4, #0]
    8272:	429a      	cmp	r2, r3
    8274:	d001      	beq.n	827a <cliFunc_colorTest+0x1a>
    8276:	f7f9 f955 	bl	1524 <__stack_chk_fail>
    827a:	4805      	ldr	r0, [pc, #20]	; (8290 <cliFunc_colorTest+0x30>)
}
    827c:	b002      	add	sp, #8
    827e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print("\x1b[38;2;255;100;0mTRUECOLOR\x1b[0m");
    8282:	f001 b901 	b.w	9488 <_print>
    8286:	bf00      	nop
    8288:	1fffe9d0 	.word	0x1fffe9d0
    828c:	0000d348 	.word	0x0000d348
    8290:	0000d143 	.word	0x0000d143

00008294 <cliFunc_reload>:
	info_msg("Rand: ");
	printHex32( rand_value32() );
}

void cliFunc_reload( char* args )
{
    8294:	b513      	push	{r0, r1, r4, lr}
    8296:	4c0a      	ldr	r4, [pc, #40]	; (82c0 <cliFunc_reload+0x2c>)
	if ( flashModeEnabled_define == 0 )
	{
		print( NL );
    8298:	480a      	ldr	r0, [pc, #40]	; (82c4 <cliFunc_reload+0x30>)
{
    829a:	6823      	ldr	r3, [r4, #0]
    829c:	9301      	str	r3, [sp, #4]
		print( NL );
    829e:	f001 f8f3 	bl	9488 <_print>
		warn_print("flashModeEnabled not set, cancelling firmware reload...");
    82a2:	4809      	ldr	r0, [pc, #36]	; (82c8 <cliFunc_reload+0x34>)
    82a4:	f001 f8f0 	bl	9488 <_print>
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    82a8:	9a01      	ldr	r2, [sp, #4]
    82aa:	6823      	ldr	r3, [r4, #0]
    82ac:	429a      	cmp	r2, r3
    82ae:	d001      	beq.n	82b4 <cliFunc_reload+0x20>
    82b0:	f7f9 f938 	bl	1524 <__stack_chk_fail>
    82b4:	4805      	ldr	r0, [pc, #20]	; (82cc <cliFunc_reload+0x38>)
		return;
	}

	// Request to output module to be set into firmware reload mode
	Output_firmwareReload();
}
    82b6:	b002      	add	sp, #8
    82b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    82bc:	f001 b8e4 	b.w	9488 <_print>
    82c0:	1fffe9d0 	.word	0x1fffe9d0
    82c4:	0000d348 	.word	0x0000d348
    82c8:	0000a7f6 	.word	0x0000a7f6
    82cc:	0000a845 	.word	0x0000a845

000082d0 <cliFunc_reset>:

void cliFunc_reset( char* args )
{
    82d0:	b507      	push	{r0, r1, r2, lr}
    82d2:	4b07      	ldr	r3, [pc, #28]	; (82f0 <cliFunc_reset+0x20>)
    82d4:	681a      	ldr	r2, [r3, #0]
    82d6:	9201      	str	r2, [sp, #4]
	print("\033c"); // Resets the terminal
    82d8:	9a01      	ldr	r2, [sp, #4]
    82da:	681b      	ldr	r3, [r3, #0]
    82dc:	429a      	cmp	r2, r3
    82de:	d001      	beq.n	82e4 <cliFunc_reset+0x14>
    82e0:	f7f9 f920 	bl	1524 <__stack_chk_fail>
    82e4:	4803      	ldr	r0, [pc, #12]	; (82f4 <cliFunc_reset+0x24>)
}
    82e6:	b003      	add	sp, #12
    82e8:	f85d eb04 	ldr.w	lr, [sp], #4
	print("\033c"); // Resets the terminal
    82ec:	f001 b8cc 	b.w	9488 <_print>
    82f0:	1fffe9d0 	.word	0x1fffe9d0
    82f4:	0000d220 	.word	0x0000d220

000082f8 <cliFunc_help>:
{
    82f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    82fc:	4e2a      	ldr	r6, [pc, #168]	; (83a8 <cliFunc_help+0xb0>)
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    82fe:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 83cc <cliFunc_help+0xd4>
{
    8302:	6833      	ldr	r3, [r6, #0]
    8304:	b085      	sub	sp, #20
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    8306:	2700      	movs	r7, #0
{
    8308:	9303      	str	r3, [sp, #12]
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    830a:	4b28      	ldr	r3, [pc, #160]	; (83ac <cliFunc_help+0xb4>)
    830c:	781b      	ldrb	r3, [r3, #0]
    830e:	b2fc      	uxtb	r4, r7
    8310:	42a3      	cmp	r3, r4
    8312:	d805      	bhi.n	8320 <cliFunc_help+0x28>
}
    8314:	9a03      	ldr	r2, [sp, #12]
    8316:	6833      	ldr	r3, [r6, #0]
    8318:	429a      	cmp	r2, r3
    831a:	d042      	beq.n	83a2 <cliFunc_help+0xaa>
    831c:	f7f9 f902 	bl	1524 <__stack_chk_fail>
		print( NL "\033[1;32m" );
    8320:	4823      	ldr	r0, [pc, #140]	; (83b0 <cliFunc_help+0xb8>)
			dPrintStrs(" \033[35m", CLIDict[dict][cmd].name, "\033[0m");
    8322:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 83d0 <cliFunc_help+0xd8>
		print( NL "\033[1;32m" );
    8326:	f001 f8af 	bl	9488 <_print>
		_print( CLIDictNames[dict] ); // This print is requride by AVR (flash)
    832a:	4b22      	ldr	r3, [pc, #136]	; (83b4 <cliFunc_help+0xbc>)
    832c:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    8330:	f001 f8aa 	bl	9488 <_print>
		print( "\033[0m" NL );
    8334:	4820      	ldr	r0, [pc, #128]	; (83b8 <cliFunc_help+0xc0>)
    8336:	f001 f8a7 	bl	9488 <_print>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    833a:	f04f 0900 	mov.w	r9, #0
    833e:	fa5f f389 	uxtb.w	r3, r9
    8342:	250c      	movs	r5, #12
    8344:	435d      	muls	r5, r3
    8346:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
    834a:	5959      	ldr	r1, [r3, r5]
    834c:	b909      	cbnz	r1, 8352 <cliFunc_help+0x5a>
    834e:	3701      	adds	r7, #1
    8350:	e7db      	b.n	830a <cliFunc_help+0x12>
			dPrintStrs(" \033[35m", CLIDict[dict][cmd].name, "\033[0m");
    8352:	4a1a      	ldr	r2, [pc, #104]	; (83bc <cliFunc_help+0xc4>)
    8354:	481a      	ldr	r0, [pc, #104]	; (83c0 <cliFunc_help+0xc8>)
    8356:	465b      	mov	r3, fp
    8358:	f001 f872 	bl	9440 <printstrs>
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
    835c:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
    8360:	5958      	ldr	r0, [r3, r5]
    8362:	f001 f8a3 	bl	94ac <lenStr>
				print(" ");
    8366:	4a17      	ldr	r2, [pc, #92]	; (83c4 <cliFunc_help+0xcc>)
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
    8368:	f1c0 000d 	rsb	r0, r0, #13
    836c:	fa5f fa80 	uxtb.w	sl, r0
			while ( padLength-- > 0 )
    8370:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
    8374:	fa5f fa83 	uxtb.w	sl, r3
    8378:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
    837c:	d10b      	bne.n	8396 <cliFunc_help+0x9e>
			_print( CLIDict[dict][cmd].description ); // This print is required by AVR (flash)
    837e:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
    8382:	441d      	add	r5, r3
    8384:	f109 0901 	add.w	r9, r9, #1
    8388:	6868      	ldr	r0, [r5, #4]
    838a:	f001 f87d 	bl	9488 <_print>
			print( NL );
    838e:	480e      	ldr	r0, [pc, #56]	; (83c8 <cliFunc_help+0xd0>)
    8390:	f001 f87a 	bl	9488 <_print>
    8394:	e7d3      	b.n	833e <cliFunc_help+0x46>
				print(" ");
    8396:	4610      	mov	r0, r2
    8398:	9201      	str	r2, [sp, #4]
    839a:	f001 f875 	bl	9488 <_print>
    839e:	9a01      	ldr	r2, [sp, #4]
    83a0:	e7e6      	b.n	8370 <cliFunc_help+0x78>
}
    83a2:	b005      	add	sp, #20
    83a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    83a8:	1fffe9d0 	.word	0x1fffe9d0
    83ac:	1ffff73b 	.word	0x1ffff73b
    83b0:	0000d162 	.word	0x0000d162
    83b4:	1ffffbb8 	.word	0x1ffffbb8
    83b8:	0000d16c 	.word	0x0000d16c
    83bc:	0000ac37 	.word	0x0000ac37
    83c0:	0000d173 	.word	0x0000d173
    83c4:	0000d6a4 	.word	0x0000d6a4
    83c8:	0000d348 	.word	0x0000d348
    83cc:	1ffffb8c 	.word	0x1ffffb8c
    83d0:	0000cdad 	.word	0x0000cdad

000083d4 <cliFunc_led>:
{
    83d4:	b507      	push	{r0, r1, r2, lr}
    83d6:	4b09      	ldr	r3, [pc, #36]	; (83fc <cliFunc_led+0x28>)
    83d8:	681a      	ldr	r2, [r3, #0]
    83da:	9201      	str	r2, [sp, #4]
	CLILEDState ^= 1 << 1; // Toggle between 0 and 1
    83dc:	4a08      	ldr	r2, [pc, #32]	; (8400 <cliFunc_led+0x2c>)
    83de:	7810      	ldrb	r0, [r2, #0]
    83e0:	f080 0002 	eor.w	r0, r0, #2
    83e4:	7010      	strb	r0, [r2, #0]
	errorLED( CLILEDState ); // Enable/Disable error LED
    83e6:	9a01      	ldr	r2, [sp, #4]
    83e8:	681b      	ldr	r3, [r3, #0]
    83ea:	429a      	cmp	r2, r3
    83ec:	d001      	beq.n	83f2 <cliFunc_led+0x1e>
    83ee:	f7f9 f899 	bl	1524 <__stack_chk_fail>
}
    83f2:	b003      	add	sp, #12
    83f4:	f85d eb04 	ldr.w	lr, [sp], #4
	errorLED( CLILEDState ); // Enable/Disable error LED
    83f8:	f000 bffe 	b.w	93f8 <errorLED>
    83fc:	1fffe9d0 	.word	0x1fffe9d0
    8400:	1ffff73a 	.word	0x1ffff73a

00008404 <cliFunc_restart>:

void cliFunc_restart( char* args )
{
    8404:	b507      	push	{r0, r1, r2, lr}
    8406:	4b07      	ldr	r3, [pc, #28]	; (8424 <cliFunc_restart+0x20>)
    8408:	681a      	ldr	r2, [r3, #0]
    840a:	9201      	str	r2, [sp, #4]
	// Trigger an overall software reset
	Output_softReset();
    840c:	9a01      	ldr	r2, [sp, #4]
    840e:	681b      	ldr	r3, [r3, #0]
    8410:	429a      	cmp	r2, r3
    8412:	d001      	beq.n	8418 <cliFunc_restart+0x14>
    8414:	f7f9 f886 	bl	1524 <__stack_chk_fail>
}
    8418:	b003      	add	sp, #12
    841a:	f85d eb04 	ldr.w	lr, [sp], #4
	Output_softReset();
    841e:	f7fd bc79 	b.w	5d14 <Output_softReset>
    8422:	bf00      	nop
    8424:	1fffe9d0 	.word	0x1fffe9d0

00008428 <cliFunc_tick>:

void cliFunc_tick( char* args )
{
    8428:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    842a:	4c15      	ldr	r4, [pc, #84]	; (8480 <cliFunc_tick+0x58>)
	print( NL );
    842c:	4815      	ldr	r0, [pc, #84]	; (8484 <cliFunc_tick+0x5c>)
{
    842e:	6823      	ldr	r3, [r4, #0]
    8430:	9303      	str	r3, [sp, #12]
	print( NL );
    8432:	f001 f829 	bl	9488 <_print>

	// Get current time
	Time now = Time_now();
    8436:	a801      	add	r0, sp, #4
    8438:	f7f9 fb62 	bl	1b00 <Time_now>

	// Display <systick>:<cycleticks since systick>
	info_msg("ns per cycletick: ");
    843c:	4812      	ldr	r0, [pc, #72]	; (8488 <cliFunc_tick+0x60>)
    843e:	f001 f823 	bl	9488 <_print>
	print( Time_ticksPer_ns_str );
    8442:	4b12      	ldr	r3, [pc, #72]	; (848c <cliFunc_tick+0x64>)
    8444:	6818      	ldr	r0, [r3, #0]
    8446:	f001 f81f 	bl	9488 <_print>
	print( NL );
    844a:	480e      	ldr	r0, [pc, #56]	; (8484 <cliFunc_tick+0x5c>)
    844c:	f001 f81c 	bl	9488 <_print>
	info_print("<systick ms>:<cycleticks since systick>");
    8450:	480f      	ldr	r0, [pc, #60]	; (8490 <cliFunc_tick+0x68>)
    8452:	f001 f819 	bl	9488 <_print>
	printInt32( now.ms );
    8456:	9801      	ldr	r0, [sp, #4]
    8458:	f001 f8ec 	bl	9634 <printInt32>
	print(":");
    845c:	480d      	ldr	r0, [pc, #52]	; (8494 <cliFunc_tick+0x6c>)
    845e:	f001 f813 	bl	9488 <_print>
	printInt32( now.ticks );
    8462:	9802      	ldr	r0, [sp, #8]
    8464:	f001 f8e6 	bl	9634 <printInt32>
	print( NL );
    8468:	9a03      	ldr	r2, [sp, #12]
    846a:	6823      	ldr	r3, [r4, #0]
    846c:	429a      	cmp	r2, r3
    846e:	d001      	beq.n	8474 <cliFunc_tick+0x4c>
    8470:	f7f9 f858 	bl	1524 <__stack_chk_fail>
    8474:	4803      	ldr	r0, [pc, #12]	; (8484 <cliFunc_tick+0x5c>)
}
    8476:	b004      	add	sp, #16
    8478:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    847c:	f001 b804 	b.w	9488 <_print>
    8480:	1fffe9d0 	.word	0x1fffe9d0
    8484:	0000d348 	.word	0x0000d348
    8488:	0000d223 	.word	0x0000d223
    848c:	1fffe9d4 	.word	0x1fffe9d4
    8490:	0000d248 	.word	0x0000d248
    8494:	0000d681 	.word	0x0000d681

00008498 <cliFunc_cliDebug>:
{
    8498:	b537      	push	{r0, r1, r2, r4, r5, lr}
    849a:	4c0e      	ldr	r4, [pc, #56]	; (84d4 <cliFunc_cliDebug+0x3c>)
	if ( CLIHexDebugMode )
    849c:	4d0e      	ldr	r5, [pc, #56]	; (84d8 <cliFunc_cliDebug+0x40>)
{
    849e:	6822      	ldr	r2, [r4, #0]
    84a0:	9201      	str	r2, [sp, #4]
	if ( CLIHexDebugMode )
    84a2:	782a      	ldrb	r2, [r5, #0]
		print( NL );
    84a4:	480d      	ldr	r0, [pc, #52]	; (84dc <cliFunc_cliDebug+0x44>)
	if ( CLIHexDebugMode )
    84a6:	b162      	cbz	r2, 84c2 <cliFunc_cliDebug+0x2a>
		print( NL );
    84a8:	f000 ffee 	bl	9488 <_print>
		info_print("Hex debug mode disabled...");
    84ac:	480c      	ldr	r0, [pc, #48]	; (84e0 <cliFunc_cliDebug+0x48>)
    84ae:	f000 ffeb 	bl	9488 <_print>
		CLIHexDebugMode = 0;
    84b2:	2300      	movs	r3, #0
}
    84b4:	9a01      	ldr	r2, [sp, #4]
		CLIHexDebugMode = 1;
    84b6:	702b      	strb	r3, [r5, #0]
}
    84b8:	6823      	ldr	r3, [r4, #0]
    84ba:	429a      	cmp	r2, r3
    84bc:	d008      	beq.n	84d0 <cliFunc_cliDebug+0x38>
    84be:	f7f9 f831 	bl	1524 <__stack_chk_fail>
		print( NL );
    84c2:	f000 ffe1 	bl	9488 <_print>
		info_print("Hex debug mode enabled...");
    84c6:	4807      	ldr	r0, [pc, #28]	; (84e4 <cliFunc_cliDebug+0x4c>)
    84c8:	f000 ffde 	bl	9488 <_print>
		CLIHexDebugMode = 1;
    84cc:	2301      	movs	r3, #1
    84ce:	e7f1      	b.n	84b4 <cliFunc_cliDebug+0x1c>
}
    84d0:	b003      	add	sp, #12
    84d2:	bd30      	pop	{r4, r5, pc}
    84d4:	1fffe9d0 	.word	0x1fffe9d0
    84d8:	1ffff738 	.word	0x1ffff738
    84dc:	0000d348 	.word	0x0000d348
    84e0:	0000d0e6 	.word	0x0000d0e6
    84e4:	0000d115 	.word	0x0000d115

000084e8 <cliFunc_rand>:
{
    84e8:	b513      	push	{r0, r1, r4, lr}
    84ea:	4c12      	ldr	r4, [pc, #72]	; (8534 <cliFunc_rand+0x4c>)
	print( NL );
    84ec:	4812      	ldr	r0, [pc, #72]	; (8538 <cliFunc_rand+0x50>)
{
    84ee:	6823      	ldr	r3, [r4, #0]
    84f0:	9301      	str	r3, [sp, #4]
	print( NL );
    84f2:	f000 ffc9 	bl	9488 <_print>
	if ( !rand_available() )
    84f6:	f7f9 f949 	bl	178c <rand_available>
    84fa:	b958      	cbnz	r0, 8514 <cliFunc_rand+0x2c>
		warn_print("No entropy available!");
    84fc:	9a01      	ldr	r2, [sp, #4]
    84fe:	6823      	ldr	r3, [r4, #0]
    8500:	429a      	cmp	r2, r3
    8502:	d001      	beq.n	8508 <cliFunc_rand+0x20>
	printHex32( rand_value32() );
    8504:	f7f9 f80e 	bl	1524 <__stack_chk_fail>
		warn_print("No entropy available!");
    8508:	480c      	ldr	r0, [pc, #48]	; (853c <cliFunc_rand+0x54>)
}
    850a:	b002      	add	sp, #8
    850c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		warn_print("No entropy available!");
    8510:	f000 bfba 	b.w	9488 <_print>
	info_msg("Rand: ");
    8514:	480a      	ldr	r0, [pc, #40]	; (8540 <cliFunc_rand+0x58>)
    8516:	f000 ffb7 	bl	9488 <_print>
	printHex32( rand_value32() );
    851a:	f7f9 f8f9 	bl	1710 <rand_value32>
    851e:	9a01      	ldr	r2, [sp, #4]
    8520:	6823      	ldr	r3, [r4, #0]
    8522:	429a      	cmp	r2, r3
    8524:	d1ee      	bne.n	8504 <cliFunc_rand+0x1c>
    8526:	2101      	movs	r1, #1
}
    8528:	b002      	add	sp, #8
    852a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printHex32( rand_value32() );
    852e:	f001 b923 	b.w	9778 <printHex32_op>
    8532:	bf00      	nop
    8534:	1fffe9d0 	.word	0x1fffe9d0
    8538:	0000d348 	.word	0x0000d348
    853c:	0000d1da 	.word	0x0000d1da
    8540:	0000d207 	.word	0x0000d207

00008544 <ChipVersion_cpuid_partno>:
// ----- Function Declarations -----

// ----- Functions -----
//
const char *ChipVersion_cpuid_partno()
{
    8544:	b507      	push	{r0, r1, r2, lr}
    8546:	4a14      	ldr	r2, [pc, #80]	; (8598 <ChipVersion_cpuid_partno+0x54>)
    8548:	6813      	ldr	r3, [r2, #0]
    854a:	9301      	str	r3, [sp, #4]
	switch ( SCB_CPUID_PARTNO )
    854c:	4b13      	ldr	r3, [pc, #76]	; (859c <ChipVersion_cpuid_partno+0x58>)
    854e:	681b      	ldr	r3, [r3, #0]
    8550:	f640 4123 	movw	r1, #3107	; 0xc23
    8554:	f3c3 130b 	ubfx	r3, r3, #4, #12
    8558:	428b      	cmp	r3, r1
    855a:	d00e      	beq.n	857a <ChipVersion_cpuid_partno+0x36>
    855c:	d804      	bhi.n	8568 <ChipVersion_cpuid_partno+0x24>
    855e:	f5b3 6f42 	cmp.w	r3, #3104	; 0xc20
    8562:	d013      	beq.n	858c <ChipVersion_cpuid_partno+0x48>
	case 0xC60:
		return "Cortex-M0+";
	case 0xC24:
		return "Cortex-M4";
	default:
		return "--";
    8564:	480e      	ldr	r0, [pc, #56]	; (85a0 <ChipVersion_cpuid_partno+0x5c>)
    8566:	e009      	b.n	857c <ChipVersion_cpuid_partno+0x38>
	switch ( SCB_CPUID_PARTNO )
    8568:	f640 4124 	movw	r1, #3108	; 0xc24
    856c:	428b      	cmp	r3, r1
    856e:	d00b      	beq.n	8588 <ChipVersion_cpuid_partno+0x44>
    8570:	f5b3 6f46 	cmp.w	r3, #3168	; 0xc60
    8574:	d1f6      	bne.n	8564 <ChipVersion_cpuid_partno+0x20>
		return "Cortex-M0+";
    8576:	480b      	ldr	r0, [pc, #44]	; (85a4 <ChipVersion_cpuid_partno+0x60>)
    8578:	e000      	b.n	857c <ChipVersion_cpuid_partno+0x38>
		return "Cortex-M3";
    857a:	480b      	ldr	r0, [pc, #44]	; (85a8 <ChipVersion_cpuid_partno+0x64>)
	}
}
    857c:	9901      	ldr	r1, [sp, #4]
    857e:	6813      	ldr	r3, [r2, #0]
    8580:	4299      	cmp	r1, r3
    8582:	d005      	beq.n	8590 <ChipVersion_cpuid_partno+0x4c>
    8584:	f7f8 ffce 	bl	1524 <__stack_chk_fail>
		return "Cortex-M4";
    8588:	4808      	ldr	r0, [pc, #32]	; (85ac <ChipVersion_cpuid_partno+0x68>)
    858a:	e7f7      	b.n	857c <ChipVersion_cpuid_partno+0x38>
		return "Cortex-M0";
    858c:	4808      	ldr	r0, [pc, #32]	; (85b0 <ChipVersion_cpuid_partno+0x6c>)
    858e:	e7f5      	b.n	857c <ChipVersion_cpuid_partno+0x38>
}
    8590:	b003      	add	sp, #12
    8592:	f85d fb04 	ldr.w	pc, [sp], #4
    8596:	bf00      	nop
    8598:	1fffe9d0 	.word	0x1fffe9d0
    859c:	e000ed00 	.word	0xe000ed00
    85a0:	0000ced5 	.word	0x0000ced5
    85a4:	0000cec0 	.word	0x0000cec0
    85a8:	0000ceb6 	.word	0x0000ceb6
    85ac:	0000cecb 	.word	0x0000cecb
    85b0:	0000ceac 	.word	0x0000ceac

000085b4 <ChipVersion_cpuid_implementor>:

const char *ChipVersion_cpuid_implementor()
{
    85b4:	b507      	push	{r0, r1, r2, lr}
    85b6:	4b0a      	ldr	r3, [pc, #40]	; (85e0 <ChipVersion_cpuid_implementor+0x2c>)
	case 0x41:
		return "ARM";
	default:
		return "--";
	}
}
    85b8:	490a      	ldr	r1, [pc, #40]	; (85e4 <ChipVersion_cpuid_implementor+0x30>)
{
    85ba:	681a      	ldr	r2, [r3, #0]
    85bc:	9201      	str	r2, [sp, #4]
	switch ( SCB_CPUID_IMPLEMENTOR )
    85be:	4a0a      	ldr	r2, [pc, #40]	; (85e8 <ChipVersion_cpuid_implementor+0x34>)
    85c0:	78d0      	ldrb	r0, [r2, #3]
}
    85c2:	4a0a      	ldr	r2, [pc, #40]	; (85ec <ChipVersion_cpuid_implementor+0x38>)
    85c4:	2841      	cmp	r0, #65	; 0x41
    85c6:	bf0c      	ite	eq
    85c8:	4608      	moveq	r0, r1
    85ca:	4610      	movne	r0, r2
    85cc:	9a01      	ldr	r2, [sp, #4]
    85ce:	681b      	ldr	r3, [r3, #0]
    85d0:	429a      	cmp	r2, r3
    85d2:	d001      	beq.n	85d8 <ChipVersion_cpuid_implementor+0x24>
    85d4:	f7f8 ffa6 	bl	1524 <__stack_chk_fail>
    85d8:	b003      	add	sp, #12
    85da:	f85d fb04 	ldr.w	pc, [sp], #4
    85de:	bf00      	nop
    85e0:	1fffe9d0 	.word	0x1fffe9d0
    85e4:	0000cea8 	.word	0x0000cea8
    85e8:	e000ed00 	.word	0xe000ed00
    85ec:	0000ced5 	.word	0x0000ced5

000085f0 <ChipVersion_lookup>:

// Attempts to detect the chip part number using registers only
// Not perfect, but is quite useful
// Returns -- if unknown
const char *ChipVersion_lookup()
{
    85f0:	b507      	push	{r0, r1, r2, lr}
    85f2:	4a21      	ldr	r2, [pc, #132]	; (8678 <ChipVersion_lookup+0x88>)
	// The first m stands for production, the other option is p (unqualified sample)

	//uint8_t family = SIM_SDID_FAMID; // e.g. k20
	// TODO e.g. d (Cortex-M4)
	//uint8_t flex = SIM_FCFG1_NVMSIZE ? 1 : 0; // e.g. x (Flex memory)
	uint16_t pflash = ChipVersion_pflashsize[ SIM_FCFG1_PFSIZE ]; // e.g. 256 (256 kB)
    85f4:	4921      	ldr	r1, [pc, #132]	; (867c <ChipVersion_lookup+0x8c>)
{
    85f6:	6813      	ldr	r3, [r2, #0]
    85f8:	9301      	str	r3, [sp, #4]
	uint16_t pflash = ChipVersion_pflashsize[ SIM_FCFG1_PFSIZE ]; // e.g. 256 (256 kB)
    85fa:	4b21      	ldr	r3, [pc, #132]	; (8680 <ChipVersion_lookup+0x90>)
    85fc:	78db      	ldrb	r3, [r3, #3]
    85fe:	f003 030f 	and.w	r3, r3, #15
    8602:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
	//uint8_t pincount = SIM_SDID_PINID; // e.g. LH (64 LQFP)
	// TODO e.g. 7 (70 MHz)

	// Using openocd method of using the SDID mask
	// Not perfect, but generally ok, also using the pincount
	if ( SIM_SDID & 0x00000095 )
    8606:	491f      	ldr	r1, [pc, #124]	; (8684 <ChipVersion_lookup+0x94>)
    8608:	6808      	ldr	r0, [r1, #0]
    860a:	f010 0f95 	tst.w	r0, #149	; 0x95
    860e:	d01f      	beq.n	8650 <ChipVersion_lookup+0x60>
	{
		switch ( pflash )
    8610:	2b80      	cmp	r3, #128	; 0x80
    8612:	d004      	beq.n	861e <ChipVersion_lookup+0x2e>
    8614:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    8618:	d010      	beq.n	863c <ChipVersion_lookup+0x4c>
				return "mk20dx256vmc7";
			default:
				return "mk20dx256XXXX";
			}
		default:
			return "mk20dxXXXvlh7";
    861a:	481b      	ldr	r0, [pc, #108]	; (8688 <ChipVersion_lookup+0x98>)
    861c:	e008      	b.n	8630 <ChipVersion_lookup+0x40>
			switch ( SIM_SDID_PINID )
    861e:	f000 030f 	and.w	r3, r0, #15
    8622:	2b04      	cmp	r3, #4
    8624:	d01f      	beq.n	8666 <ChipVersion_lookup+0x76>
				return "mk20dx128XXXX";
    8626:	4819      	ldr	r0, [pc, #100]	; (868c <ChipVersion_lookup+0x9c>)
    8628:	4919      	ldr	r1, [pc, #100]	; (8690 <ChipVersion_lookup+0xa0>)
    862a:	2b05      	cmp	r3, #5
    862c:	bf18      	it	ne
    862e:	4608      	movne	r0, r1
			return "mk22fxXXXavlh12";
		}
	}

	return "--";
}
    8630:	9901      	ldr	r1, [sp, #4]
    8632:	6813      	ldr	r3, [r2, #0]
    8634:	4299      	cmp	r1, r3
    8636:	d01c      	beq.n	8672 <ChipVersion_lookup+0x82>
    8638:	f7f8 ff74 	bl	1524 <__stack_chk_fail>
			switch ( SIM_SDID_PINID )
    863c:	f000 030f 	and.w	r3, r0, #15
    8640:	2b05      	cmp	r3, #5
    8642:	d012      	beq.n	866a <ChipVersion_lookup+0x7a>
				return "mk20dx256XXXX";
    8644:	4813      	ldr	r0, [pc, #76]	; (8694 <ChipVersion_lookup+0xa4>)
    8646:	4914      	ldr	r1, [pc, #80]	; (8698 <ChipVersion_lookup+0xa8>)
    8648:	2b09      	cmp	r3, #9
    864a:	bf18      	it	ne
    864c:	4608      	movne	r0, r1
    864e:	e7ef      	b.n	8630 <ChipVersion_lookup+0x40>
	else if ( SIM_SDID & 0x00000315 )
    8650:	f240 3115 	movw	r1, #789	; 0x315
    8654:	4208      	tst	r0, r1
    8656:	d00a      	beq.n	866e <ChipVersion_lookup+0x7e>
			return "mk22fxXXXavlh12";
    8658:	4810      	ldr	r0, [pc, #64]	; (869c <ChipVersion_lookup+0xac>)
    865a:	4911      	ldr	r1, [pc, #68]	; (86a0 <ChipVersion_lookup+0xb0>)
    865c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    8660:	bf18      	it	ne
    8662:	4608      	movne	r0, r1
    8664:	e7e4      	b.n	8630 <ChipVersion_lookup+0x40>
				return "mk20dx128vlf5";
    8666:	480f      	ldr	r0, [pc, #60]	; (86a4 <ChipVersion_lookup+0xb4>)
    8668:	e7e2      	b.n	8630 <ChipVersion_lookup+0x40>
				return "mk20dx256vlh7";
    866a:	480f      	ldr	r0, [pc, #60]	; (86a8 <ChipVersion_lookup+0xb8>)
    866c:	e7e0      	b.n	8630 <ChipVersion_lookup+0x40>
	return "--";
    866e:	480f      	ldr	r0, [pc, #60]	; (86ac <ChipVersion_lookup+0xbc>)
    8670:	e7de      	b.n	8630 <ChipVersion_lookup+0x40>
}
    8672:	b003      	add	sp, #12
    8674:	f85d fb04 	ldr.w	pc, [sp], #4
    8678:	1fffe9d0 	.word	0x1fffe9d0
    867c:	0000cf98 	.word	0x0000cf98
    8680:	4004804c 	.word	0x4004804c
    8684:	40048024 	.word	0x40048024
    8688:	0000cf4c 	.word	0x0000cf4c
    868c:	0000cf06 	.word	0x0000cf06
    8690:	0000cf14 	.word	0x0000cf14
    8694:	0000cf30 	.word	0x0000cf30
    8698:	0000cf3e 	.word	0x0000cf3e
    869c:	0000cf5a 	.word	0x0000cf5a
    86a0:	0000cf6a 	.word	0x0000cf6a
    86a4:	0000cef8 	.word	0x0000cef8
    86a8:	0000cf22 	.word	0x0000cf22
    86ac:	0000ced5 	.word	0x0000ced5

000086b0 <cliFunc_version>:

void cliFunc_version( char* args )
{
    86b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    86b2:	4d9b      	ldr	r5, [pc, #620]	; (8920 <cliFunc_version+0x270>)
	print( NL );
    86b4:	489b      	ldr	r0, [pc, #620]	; (8924 <cliFunc_version+0x274>)
{
    86b6:	682b      	ldr	r3, [r5, #0]
    86b8:	9301      	str	r3, [sp, #4]
	print( NL );
    86ba:	f000 fee5 	bl	9488 <_print>
	print( " \033[1mRevision:\033[0m      " CLI_Revision          NL );
    86be:	489a      	ldr	r0, [pc, #616]	; (8928 <cliFunc_version+0x278>)
	print( " \033[1mCPU Detected:\033[0m  " );
	print( ChipVersion_lookup() );
	print( NL);

	print( " \033[1mCPU Id:\033[0m        " );
	printHex32( SCB_CPUID );
    86c0:	4c9a      	ldr	r4, [pc, #616]	; (892c <cliFunc_version+0x27c>)
	print( " \033[1mRevision:\033[0m      " CLI_Revision          NL );
    86c2:	f000 fee1 	bl	9488 <_print>
	print( " \033[1mRevision #:\033[0m    " CLI_RevisionNumberStr NL );
    86c6:	489a      	ldr	r0, [pc, #616]	; (8930 <cliFunc_version+0x280>)
    86c8:	f000 fede 	bl	9488 <_print>
	print( " \033[1mVersion:\033[0m       " CLI_Version " (+" );
    86cc:	4899      	ldr	r0, [pc, #612]	; (8934 <cliFunc_version+0x284>)
    86ce:	f000 fedb 	bl	9488 <_print>
	printInt16( CLI_RevisionNumber - CLI_VersionRevNumber );
    86d2:	2000      	movs	r0, #0
    86d4:	f000 ff78 	bl	95c8 <printInt16>
	print( ":" CLI_VersionRevNumberStr ")" NL );
    86d8:	4897      	ldr	r0, [pc, #604]	; (8938 <cliFunc_version+0x288>)
    86da:	f000 fed5 	bl	9488 <_print>
	print( " \033[1mBranch:\033[0m        " CLI_Branch            NL );
    86de:	4897      	ldr	r0, [pc, #604]	; (893c <cliFunc_version+0x28c>)
    86e0:	f000 fed2 	bl	9488 <_print>
	print( " \033[1mTree Status:\033[0m   " CLI_ModifiedStatus CLI_ModifiedFiles NL );
    86e4:	4896      	ldr	r0, [pc, #600]	; (8940 <cliFunc_version+0x290>)
    86e6:	f000 fecf 	bl	9488 <_print>
	print( " \033[1mRepo Origin:\033[0m   " CLI_RepoOrigin        NL );
    86ea:	4896      	ldr	r0, [pc, #600]	; (8944 <cliFunc_version+0x294>)
    86ec:	f000 fecc 	bl	9488 <_print>
	print( " \033[1mCommit Date:\033[0m   " CLI_CommitDate        NL );
    86f0:	4895      	ldr	r0, [pc, #596]	; (8948 <cliFunc_version+0x298>)
    86f2:	f000 fec9 	bl	9488 <_print>
	print( " \033[1mCommit Author:\033[0m " CLI_CommitAuthor      NL );
    86f6:	4895      	ldr	r0, [pc, #596]	; (894c <cliFunc_version+0x29c>)
    86f8:	f000 fec6 	bl	9488 <_print>
	print( " \033[1mBuild Date:\033[0m    " CLI_BuildDate         NL );
    86fc:	4894      	ldr	r0, [pc, #592]	; (8950 <cliFunc_version+0x2a0>)
    86fe:	f000 fec3 	bl	9488 <_print>
	print( " \033[1mBuild OS:\033[0m      " CLI_BuildOS           NL );
    8702:	4894      	ldr	r0, [pc, #592]	; (8954 <cliFunc_version+0x2a4>)
    8704:	f000 fec0 	bl	9488 <_print>
	print( " \033[1mCompiler:\033[0m      " CLI_BuildCompiler     NL );
    8708:	4893      	ldr	r0, [pc, #588]	; (8958 <cliFunc_version+0x2a8>)
    870a:	f000 febd 	bl	9488 <_print>
	print( " \033[1mArchitecture:\033[0m  " CLI_Arch              NL );
    870e:	4893      	ldr	r0, [pc, #588]	; (895c <cliFunc_version+0x2ac>)
    8710:	f000 feba 	bl	9488 <_print>
	print( " \033[1mChip Compiled:\033[0m " CLI_ChipShort " (" CLI_Chip ")" NL );
    8714:	4892      	ldr	r0, [pc, #584]	; (8960 <cliFunc_version+0x2b0>)
    8716:	f000 feb7 	bl	9488 <_print>
	print( " \033[1mCPU:\033[0m           " CLI_CPU               NL );
    871a:	4892      	ldr	r0, [pc, #584]	; (8964 <cliFunc_version+0x2b4>)
    871c:	f000 feb4 	bl	9488 <_print>
	print( " \033[1mDevice:\033[0m        " CLI_Device            NL );
    8720:	4891      	ldr	r0, [pc, #580]	; (8968 <cliFunc_version+0x2b8>)
    8722:	f000 feb1 	bl	9488 <_print>
	print( " \033[1mModules:\033[0m       " CLI_Modules           NL );
    8726:	4891      	ldr	r0, [pc, #580]	; (896c <cliFunc_version+0x2bc>)
    8728:	f000 feae 	bl	9488 <_print>
	print( NL );
    872c:	487d      	ldr	r0, [pc, #500]	; (8924 <cliFunc_version+0x274>)
    872e:	f000 feab 	bl	9488 <_print>
	print( " \033[1mCPU Detected:\033[0m  " );
    8732:	488f      	ldr	r0, [pc, #572]	; (8970 <cliFunc_version+0x2c0>)
    8734:	f000 fea8 	bl	9488 <_print>
	print( ChipVersion_lookup() );
    8738:	f7ff ff5a 	bl	85f0 <ChipVersion_lookup>
    873c:	f000 fea4 	bl	9488 <_print>
	print( NL);
    8740:	4878      	ldr	r0, [pc, #480]	; (8924 <cliFunc_version+0x274>)
    8742:	f000 fea1 	bl	9488 <_print>
	print( " \033[1mCPU Id:\033[0m        " );
    8746:	488b      	ldr	r0, [pc, #556]	; (8974 <cliFunc_version+0x2c4>)
    8748:	f000 fe9e 	bl	9488 <_print>
	printHex32( SCB_CPUID );
    874c:	2101      	movs	r1, #1
    874e:	6820      	ldr	r0, [r4, #0]
    8750:	f001 f812 	bl	9778 <printHex32_op>
	print( NL "  (Implementor:");
    8754:	4888      	ldr	r0, [pc, #544]	; (8978 <cliFunc_version+0x2c8>)
    8756:	f000 fe97 	bl	9488 <_print>
	print( ChipVersion_cpuid_implementor() );
    875a:	f7ff ff2b 	bl	85b4 <ChipVersion_cpuid_implementor>
    875e:	f000 fe93 	bl	9488 <_print>
	print( ":" );
    8762:	4886      	ldr	r0, [pc, #536]	; (897c <cliFunc_version+0x2cc>)
    8764:	f000 fe90 	bl	9488 <_print>
	printHex32( SCB_CPUID_IMPLEMENTOR );
    8768:	2101      	movs	r1, #1
    876a:	78e0      	ldrb	r0, [r4, #3]
    876c:	f001 f804 	bl	9778 <printHex32_op>
	print( ")(Variant:" );
    8770:	4883      	ldr	r0, [pc, #524]	; (8980 <cliFunc_version+0x2d0>)
    8772:	f000 fe89 	bl	9488 <_print>
	printHex32( SCB_CPUID_VARIANT );
    8776:	6820      	ldr	r0, [r4, #0]
    8778:	2101      	movs	r1, #1
    877a:	f3c0 5003 	ubfx	r0, r0, #20, #4
    877e:	f000 fffb 	bl	9778 <printHex32_op>
	print( ")(Arch:" );
    8782:	4880      	ldr	r0, [pc, #512]	; (8984 <cliFunc_version+0x2d4>)
    8784:	f000 fe80 	bl	9488 <_print>
	printHex32( SCB_CPUID_ARCH );
    8788:	8860      	ldrh	r0, [r4, #2]
    878a:	2101      	movs	r1, #1
    878c:	f000 000f 	and.w	r0, r0, #15
    8790:	f000 fff2 	bl	9778 <printHex32_op>
	print( ")(PartNo:" );
    8794:	487c      	ldr	r0, [pc, #496]	; (8988 <cliFunc_version+0x2d8>)
    8796:	f000 fe77 	bl	9488 <_print>
	print( ChipVersion_cpuid_partno() );
    879a:	f7ff fed3 	bl	8544 <ChipVersion_cpuid_partno>
    879e:	f000 fe73 	bl	9488 <_print>
	print( ":" );
    87a2:	4876      	ldr	r0, [pc, #472]	; (897c <cliFunc_version+0x2cc>)
    87a4:	f000 fe70 	bl	9488 <_print>
	printHex32( SCB_CPUID_PARTNO );
    87a8:	6820      	ldr	r0, [r4, #0]
    87aa:	2101      	movs	r1, #1
    87ac:	f3c0 100b 	ubfx	r0, r0, #4, #12
    87b0:	f000 ffe2 	bl	9778 <printHex32_op>
	print( ")(Revision:" );
    87b4:	4875      	ldr	r0, [pc, #468]	; (898c <cliFunc_version+0x2dc>)
    87b6:	f000 fe67 	bl	9488 <_print>
	printHex32( SCB_CPUID_REVISION );
    87ba:	6820      	ldr	r0, [r4, #0]
	print( ")" NL );

	print( " \033[1mDevice Id:\033[0m     " );
	printHex32( SIM_SDID );
    87bc:	4c74      	ldr	r4, [pc, #464]	; (8990 <cliFunc_version+0x2e0>)
	printHex32( SCB_CPUID_REVISION );
    87be:	2101      	movs	r1, #1
    87c0:	f000 000f 	and.w	r0, r0, #15
    87c4:	f000 ffd8 	bl	9778 <printHex32_op>
	print( ")" NL );
    87c8:	4872      	ldr	r0, [pc, #456]	; (8994 <cliFunc_version+0x2e4>)
    87ca:	f000 fe5d 	bl	9488 <_print>
	print( " \033[1mDevice Id:\033[0m     " );
    87ce:	4872      	ldr	r0, [pc, #456]	; (8998 <cliFunc_version+0x2e8>)
    87d0:	f000 fe5a 	bl	9488 <_print>
	printHex32( SIM_SDID );
    87d4:	2101      	movs	r1, #1
    87d6:	6820      	ldr	r0, [r4, #0]
    87d8:	f000 ffce 	bl	9778 <printHex32_op>
	print( NL "  (Pincount:");
    87dc:	486f      	ldr	r0, [pc, #444]	; (899c <cliFunc_version+0x2ec>)
    87de:	f000 fe53 	bl	9488 <_print>
	print( ChipVersion_pincount[ SIM_SDID_PINID ] );
    87e2:	6823      	ldr	r3, [r4, #0]
    87e4:	4a6e      	ldr	r2, [pc, #440]	; (89a0 <cliFunc_version+0x2f0>)
    87e6:	f003 030f 	and.w	r3, r3, #15
    87ea:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    87ee:	f000 fe4b 	bl	9488 <_print>
	print( ":" );
    87f2:	4862      	ldr	r0, [pc, #392]	; (897c <cliFunc_version+0x2cc>)
    87f4:	f000 fe48 	bl	9488 <_print>
	printHex32( SIM_SDID_PINID );
    87f8:	6820      	ldr	r0, [r4, #0]
    87fa:	2101      	movs	r1, #1
    87fc:	f000 000f 	and.w	r0, r0, #15
    8800:	f000 ffba 	bl	9778 <printHex32_op>
	print( ")(Family:" );
    8804:	4867      	ldr	r0, [pc, #412]	; (89a4 <cliFunc_version+0x2f4>)
    8806:	f000 fe3f 	bl	9488 <_print>
	print( ChipVersion_familyid[ SIM_SDID_FAMID ] );
    880a:	6823      	ldr	r3, [r4, #0]
    880c:	4a66      	ldr	r2, [pc, #408]	; (89a8 <cliFunc_version+0x2f8>)
    880e:	f3c3 1302 	ubfx	r3, r3, #4, #3
    8812:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    8816:	f000 fe37 	bl	9488 <_print>
	print( ":" );
    881a:	4858      	ldr	r0, [pc, #352]	; (897c <cliFunc_version+0x2cc>)
    881c:	f000 fe34 	bl	9488 <_print>
	printHex32( SIM_SDID_FAMID );
    8820:	6820      	ldr	r0, [r4, #0]
    8822:	2101      	movs	r1, #1
    8824:	f3c0 1002 	ubfx	r0, r0, #4, #3
    8828:	f000 ffa6 	bl	9778 <printHex32_op>
	print( ")(Die:" );
    882c:	485f      	ldr	r0, [pc, #380]	; (89ac <cliFunc_version+0x2fc>)
    882e:	f000 fe2b 	bl	9488 <_print>
	printHex32( SIM_SDID_DIEID );
    8832:	6820      	ldr	r0, [r4, #0]
    8834:	2101      	movs	r1, #1
    8836:	f3c0 10c4 	ubfx	r0, r0, #7, #5
    883a:	f000 ff9d 	bl	9778 <printHex32_op>
	print( ")(Rev:" );
    883e:	485c      	ldr	r0, [pc, #368]	; (89b0 <cliFunc_version+0x300>)
    8840:	f000 fe22 	bl	9488 <_print>
	printHex32( SIM_SDID_REVID );
    8844:	6820      	ldr	r0, [r4, #0]
    8846:	2101      	movs	r1, #1
    8848:	f3c0 3003 	ubfx	r0, r0, #12, #4
    884c:	f000 ff94 	bl	9778 <printHex32_op>
	print( ")" NL );
    8850:	4850      	ldr	r0, [pc, #320]	; (8994 <cliFunc_version+0x2e4>)
    8852:	f000 fe19 	bl	9488 <_print>

	print( " \033[1mFlash Cfg:\033[0m     " );
    8856:	4857      	ldr	r0, [pc, #348]	; (89b4 <cliFunc_version+0x304>)
    8858:	f000 fe16 	bl	9488 <_print>
	printHex32( SIM_FCFG1 & 0xFFFFFFF0 );
    885c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    885e:	2101      	movs	r1, #1
    8860:	f020 000f 	bic.w	r0, r0, #15
    8864:	f000 ff88 	bl	9778 <printHex32_op>
	print( NL "  (FlexNVM:" );
    8868:	4853      	ldr	r0, [pc, #332]	; (89b8 <cliFunc_version+0x308>)
    886a:	f000 fe0d 	bl	9488 <_print>
	printInt16( ChipVersion_nvmsize[ SIM_FCFG1_NVMSIZE ] );
    886e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    8870:	4a52      	ldr	r2, [pc, #328]	; (89bc <cliFunc_version+0x30c>)
    8872:	0f1b      	lsrs	r3, r3, #28
    8874:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    8878:	f000 fea6 	bl	95c8 <printInt16>
	print( "kB)(PFlash:" );
    887c:	4850      	ldr	r0, [pc, #320]	; (89c0 <cliFunc_version+0x310>)
    887e:	f000 fe03 	bl	9488 <_print>
	printInt16( ChipVersion_pflashsize[ SIM_FCFG1_PFSIZE ] );
    8882:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
    8886:	4a4f      	ldr	r2, [pc, #316]	; (89c4 <cliFunc_version+0x314>)
    8888:	f003 030f 	and.w	r3, r3, #15
    888c:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    8890:	f000 fe9a 	bl	95c8 <printInt16>
	print( "kB)(EEPROM:" );
    8894:	484c      	ldr	r0, [pc, #304]	; (89c8 <cliFunc_version+0x318>)
    8896:	f000 fdf7 	bl	9488 <_print>
	printInt16( ChipVersion_eepromsize[ SIM_FCFG1_EESIZE ] );
    889a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    889c:	4a4b      	ldr	r2, [pc, #300]	; (89cc <cliFunc_version+0x31c>)
    889e:	f003 030f 	and.w	r3, r3, #15
    88a2:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    88a6:	f000 fe8f 	bl	95c8 <printInt16>
	print( ")(DEPART:" );
    88aa:	4849      	ldr	r0, [pc, #292]	; (89d0 <cliFunc_version+0x320>)
    88ac:	f000 fdec 	bl	9488 <_print>
	printHex32( SIM_FCFG1_DEPART );
    88b0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    88b2:	2101      	movs	r1, #1
    88b4:	f3c0 2003 	ubfx	r0, r0, #8, #4
    88b8:	f000 ff5e 	bl	9778 <printHex32_op>
	print( ")" NL );
    88bc:	4835      	ldr	r0, [pc, #212]	; (8994 <cliFunc_version+0x2e4>)
    88be:	f000 fde3 	bl	9488 <_print>

	print( " \033[1mRAM:\033[0m           ");
    88c2:	4844      	ldr	r0, [pc, #272]	; (89d4 <cliFunc_version+0x324>)
    88c4:	f000 fde0 	bl	9488 <_print>
	printInt16( ChipVersion_ramsize[ SIM_SOPT1_RAMSIZE ] );
    88c8:	4b43      	ldr	r3, [pc, #268]	; (89d8 <cliFunc_version+0x328>)
    88ca:	4a44      	ldr	r2, [pc, #272]	; (89dc <cliFunc_version+0x32c>)
    88cc:	681b      	ldr	r3, [r3, #0]
    88ce:	f3c3 3303 	ubfx	r3, r3, #12, #4
    88d2:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    88d6:	f000 fe77 	bl	95c8 <printInt16>
	print( " kB" NL );
    88da:	4841      	ldr	r0, [pc, #260]	; (89e0 <cliFunc_version+0x330>)
    88dc:	f000 fdd4 	bl	9488 <_print>

	print( " \033[1mUnique Id:\033[0m     " );
    88e0:	4840      	ldr	r0, [pc, #256]	; (89e4 <cliFunc_version+0x334>)
    88e2:	f000 fdd1 	bl	9488 <_print>
	printHex32_op( SIM_UIDH, 8 );
    88e6:	4b40      	ldr	r3, [pc, #256]	; (89e8 <cliFunc_version+0x338>)
    88e8:	2108      	movs	r1, #8
    88ea:	6818      	ldr	r0, [r3, #0]
    88ec:	f000 ff44 	bl	9778 <printHex32_op>
	printHex32_op( SIM_UIDMH, 8 );
    88f0:	4b3e      	ldr	r3, [pc, #248]	; (89ec <cliFunc_version+0x33c>)
    88f2:	2108      	movs	r1, #8
    88f4:	6818      	ldr	r0, [r3, #0]
    88f6:	f000 ff3f 	bl	9778 <printHex32_op>
	printHex32_op( SIM_UIDML, 8 );
    88fa:	4b3d      	ldr	r3, [pc, #244]	; (89f0 <cliFunc_version+0x340>)
    88fc:	2108      	movs	r1, #8
    88fe:	6818      	ldr	r0, [r3, #0]
    8900:	f000 ff3a 	bl	9778 <printHex32_op>
	printHex32_op( SIM_UIDL, 8 );
    8904:	9a01      	ldr	r2, [sp, #4]
    8906:	682b      	ldr	r3, [r5, #0]
    8908:	429a      	cmp	r2, r3
    890a:	d001      	beq.n	8910 <cliFunc_version+0x260>
    890c:	f7f8 fe0a 	bl	1524 <__stack_chk_fail>
    8910:	4b38      	ldr	r3, [pc, #224]	; (89f4 <cliFunc_version+0x344>)
    8912:	6818      	ldr	r0, [r3, #0]
    8914:	2108      	movs	r1, #8
#elif defined(_avr_at_)
#elif defined(_host_)
#else
#warning "No unique id defined."
#endif
}
    8916:	b003      	add	sp, #12
    8918:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printHex32_op( SIM_UIDL, 8 );
    891c:	f000 bf2c 	b.w	9778 <printHex32_op>
    8920:	1fffe9d0 	.word	0x1fffe9d0
    8924:	0000d348 	.word	0x0000d348
    8928:	0000d284 	.word	0x0000d284
    892c:	e000ed00 	.word	0xe000ed00
    8930:	0000d2c7 	.word	0x0000d2c7
    8934:	0000d2e4 	.word	0x0000d2e4
    8938:	0000d300 	.word	0x0000d300
    893c:	0000d307 	.word	0x0000d307
    8940:	0000d328 	.word	0x0000d328
    8944:	0000d34b 	.word	0x0000d34b
    8948:	0000d397 	.word	0x0000d397
    894c:	0000d3cb 	.word	0x0000d3cb
    8950:	0000d408 	.word	0x0000d408
    8954:	0000d43c 	.word	0x0000d43c
    8958:	0000d45e 	.word	0x0000d45e
    895c:	0000d49f 	.word	0x0000d49f
    8960:	0000d4bd 	.word	0x0000d4bd
    8964:	0000d4f1 	.word	0x0000d4f1
    8968:	0000d515 	.word	0x0000d515
    896c:	0000d538 	.word	0x0000d538
    8970:	0000d597 	.word	0x0000d597
    8974:	0000d5b0 	.word	0x0000d5b0
    8978:	0000d5c9 	.word	0x0000d5c9
    897c:	0000d681 	.word	0x0000d681
    8980:	0000d5db 	.word	0x0000d5db
    8984:	0000d5e6 	.word	0x0000d5e6
    8988:	0000d5ee 	.word	0x0000d5ee
    898c:	0000d5f8 	.word	0x0000d5f8
    8990:	40048024 	.word	0x40048024
    8994:	0000d303 	.word	0x0000d303
    8998:	0000d604 	.word	0x0000d604
    899c:	0000d61d 	.word	0x0000d61d
    89a0:	1ffff004 	.word	0x1ffff004
    89a4:	0000d62c 	.word	0x0000d62c
    89a8:	1fffefe4 	.word	0x1fffefe4
    89ac:	0000d636 	.word	0x0000d636
    89b0:	0000d63d 	.word	0x0000d63d
    89b4:	0000d644 	.word	0x0000d644
    89b8:	0000d65d 	.word	0x0000d65d
    89bc:	0000cf7a 	.word	0x0000cf7a
    89c0:	0000d66b 	.word	0x0000d66b
    89c4:	0000cf98 	.word	0x0000cf98
    89c8:	0000d677 	.word	0x0000d677
    89cc:	0000ced8 	.word	0x0000ced8
    89d0:	0000d683 	.word	0x0000d683
    89d4:	0000d68d 	.word	0x0000d68d
    89d8:	40047000 	.word	0x40047000
    89dc:	0000cfb8 	.word	0x0000cfb8
    89e0:	0000d6a6 	.word	0x0000d6a6
    89e4:	0000d6ac 	.word	0x0000d6ac
    89e8:	40048054 	.word	0x40048054
    89ec:	40048058 	.word	0x40048058
    89f0:	4004805c 	.word	0x4004805c
    89f4:	40048060 	.word	0x40048060

000089f8 <prompt>:
{
    89f8:	b513      	push	{r0, r1, r4, lr}
    89fa:	4c09      	ldr	r4, [pc, #36]	; (8a20 <prompt+0x28>)
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    89fc:	4809      	ldr	r0, [pc, #36]	; (8a24 <prompt+0x2c>)
{
    89fe:	6823      	ldr	r3, [r4, #0]
    8a00:	9301      	str	r3, [sp, #4]
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    8a02:	f000 fd41 	bl	9488 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    8a06:	9a01      	ldr	r2, [sp, #4]
    8a08:	6823      	ldr	r3, [r4, #0]
    8a0a:	429a      	cmp	r2, r3
    8a0c:	d001      	beq.n	8a12 <prompt+0x1a>
    8a0e:	f7f8 fd89 	bl	1524 <__stack_chk_fail>
    8a12:	4805      	ldr	r0, [pc, #20]	; (8a28 <prompt+0x30>)
}
    8a14:	b002      	add	sp, #8
    8a16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    8a1a:	f000 bd35 	b.w	9488 <_print>
    8a1e:	bf00      	nop
    8a20:	1fffe9d0 	.word	0x1fffe9d0
    8a24:	0000d85b 	.word	0x0000d85b
    8a28:	0000d861 	.word	0x0000d861

00008a2c <CLI_argumentIsolation>:
{
    8a2c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    8a2e:	4b0f      	ldr	r3, [pc, #60]	; (8a6c <CLI_argumentIsolation+0x40>)
    8a30:	681c      	ldr	r4, [r3, #0]
    8a32:	9401      	str	r4, [sp, #4]
	char* cmdPtr = string - 1;
    8a34:	3801      	subs	r0, #1
	while ( *++cmdPtr == ' ' ); // Skips leading spaces, and points to first character of cmd
    8a36:	7844      	ldrb	r4, [r0, #1]
    8a38:	2c20      	cmp	r4, #32
    8a3a:	f100 0601 	add.w	r6, r0, #1
    8a3e:	d00f      	beq.n	8a60 <CLI_argumentIsolation+0x34>
	char* argPtr = cmdPtr + 1;
    8a40:	3002      	adds	r0, #2
	while ( *argPtr != ' ' && *argPtr != '\0' )
    8a42:	7804      	ldrb	r4, [r0, #0]
    8a44:	f014 04df 	ands.w	r4, r4, #223	; 0xdf
    8a48:	f100 0501 	add.w	r5, r0, #1
    8a4c:	d10a      	bne.n	8a64 <CLI_argumentIsolation+0x38>
	(++argPtr)[-1] = '\0';
    8a4e:	7004      	strb	r4, [r0, #0]
	*first = cmdPtr;
    8a50:	600e      	str	r6, [r1, #0]
	*second = argPtr;
    8a52:	6015      	str	r5, [r2, #0]
}
    8a54:	9a01      	ldr	r2, [sp, #4]
    8a56:	681b      	ldr	r3, [r3, #0]
    8a58:	429a      	cmp	r2, r3
    8a5a:	d005      	beq.n	8a68 <CLI_argumentIsolation+0x3c>
    8a5c:	f7f8 fd62 	bl	1524 <__stack_chk_fail>
    8a60:	4630      	mov	r0, r6
    8a62:	e7e8      	b.n	8a36 <CLI_argumentIsolation+0xa>
    8a64:	4628      	mov	r0, r5
    8a66:	e7ec      	b.n	8a42 <CLI_argumentIsolation+0x16>
    8a68:	b002      	add	sp, #8
    8a6a:	bd70      	pop	{r4, r5, r6, pc}
    8a6c:	1fffe9d0 	.word	0x1fffe9d0

00008a70 <cliFunc_periodic>:
{
    8a70:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    8a72:	4c10      	ldr	r4, [pc, #64]	; (8ab4 <cliFunc_periodic+0x44>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    8a74:	aa02      	add	r2, sp, #8
{
    8a76:	6823      	ldr	r3, [r4, #0]
    8a78:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    8a7a:	a901      	add	r1, sp, #4
    8a7c:	f7ff ffd6 	bl	8a2c <CLI_argumentIsolation>
	print( NL );
    8a80:	480d      	ldr	r0, [pc, #52]	; (8ab8 <cliFunc_periodic+0x48>)
    8a82:	f000 fd01 	bl	9488 <_print>
	if ( arg1Ptr[0] != '\0' )
    8a86:	9801      	ldr	r0, [sp, #4]
    8a88:	7803      	ldrb	r3, [r0, #0]
    8a8a:	b11b      	cbz	r3, 8a94 <cliFunc_periodic+0x24>
		uint32_t cycles = (uint32_t)numToInt( arg1Ptr );
    8a8c:	f000 fecc 	bl	9828 <numToInt>
		Periodic_init( cycles );
    8a90:	f7f8 ff9c 	bl	19cc <Periodic_init>
	info_msg("Period Clock Cycles: ");
    8a94:	4809      	ldr	r0, [pc, #36]	; (8abc <cliFunc_periodic+0x4c>)
    8a96:	f000 fcf7 	bl	9488 <_print>
	printInt32( Periodic_cycles() );
    8a9a:	f7f9 f805 	bl	1aa8 <Periodic_cycles>
    8a9e:	f000 fdc9 	bl	9634 <printInt32>
}
    8aa2:	9a03      	ldr	r2, [sp, #12]
    8aa4:	6823      	ldr	r3, [r4, #0]
    8aa6:	429a      	cmp	r2, r3
    8aa8:	d001      	beq.n	8aae <cliFunc_periodic+0x3e>
    8aaa:	f7f8 fd3b 	bl	1524 <__stack_chk_fail>
    8aae:	b004      	add	sp, #16
    8ab0:	bd10      	pop	{r4, pc}
    8ab2:	bf00      	nop
    8ab4:	1fffe9d0 	.word	0x1fffe9d0
    8ab8:	0000d348 	.word	0x0000d348
    8abc:	0000d1b2 	.word	0x0000d1b2

00008ac0 <CLI_commandLookup>:
{
    8ac0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8ac4:	4a2a      	ldr	r2, [pc, #168]	; (8b70 <CLI_commandLookup+0xb0>)
    8ac6:	b08d      	sub	sp, #52	; 0x34
    8ac8:	6813      	ldr	r3, [r2, #0]
    8aca:	930b      	str	r3, [sp, #44]	; 0x2c
	if ( CLILineBufferCurrent == 0 )
    8acc:	4b29      	ldr	r3, [pc, #164]	; (8b74 <CLI_commandLookup+0xb4>)
    8ace:	781b      	ldrb	r3, [r3, #0]
    8ad0:	4690      	mov	r8, r2
    8ad2:	2b00      	cmp	r3, #0
    8ad4:	d036      	beq.n	8b44 <CLI_commandLookup+0x84>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    8ad6:	4d28      	ldr	r5, [pc, #160]	; (8b78 <CLI_commandLookup+0xb8>)
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    8ad8:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 8ba0 <CLI_commandLookup+0xe0>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    8adc:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 8ba4 <CLI_commandLookup+0xe4>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    8ae0:	2400      	movs	r4, #0
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    8ae2:	aa0a      	add	r2, sp, #40	; 0x28
    8ae4:	a909      	add	r1, sp, #36	; 0x24
    8ae6:	4628      	mov	r0, r5
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    8ae8:	54ec      	strb	r4, [r5, r3]
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    8aea:	f04f 090c 	mov.w	r9, #12
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    8aee:	f7ff ff9d 	bl	8a2c <CLI_argumentIsolation>
    8af2:	9507      	str	r5, [sp, #28]
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    8af4:	f89b 2000 	ldrb.w	r2, [fp]
    8af8:	b2e6      	uxtb	r6, r4
    8afa:	42b2      	cmp	r2, r6
    8afc:	d829      	bhi.n	8b52 <CLI_commandLookup+0x92>
	print( NL );
    8afe:	4c1f      	ldr	r4, [pc, #124]	; (8b7c <CLI_commandLookup+0xbc>)
    8b00:	4620      	mov	r0, r4
    8b02:	f000 fcc1 	bl	9488 <_print>
	erro_dPrint("\"", CLILineBuffer, "\" is not a valid command...type \033[35mhelp\033[0m");
    8b06:	4b1e      	ldr	r3, [pc, #120]	; (8b80 <CLI_commandLookup+0xc0>)
    8b08:	4a1e      	ldr	r2, [pc, #120]	; (8b84 <CLI_commandLookup+0xc4>)
    8b0a:	491f      	ldr	r1, [pc, #124]	; (8b88 <CLI_commandLookup+0xc8>)
    8b0c:	481f      	ldr	r0, [pc, #124]	; (8b8c <CLI_commandLookup+0xcc>)
    8b0e:	e9cd 4304 	strd	r4, r3, [sp, #16]
    8b12:	4b1f      	ldr	r3, [pc, #124]	; (8b90 <CLI_commandLookup+0xd0>)
    8b14:	9303      	str	r3, [sp, #12]
    8b16:	9b07      	ldr	r3, [sp, #28]
    8b18:	9302      	str	r3, [sp, #8]
    8b1a:	4b1e      	ldr	r3, [pc, #120]	; (8b94 <CLI_commandLookup+0xd4>)
    8b1c:	9301      	str	r3, [sp, #4]
    8b1e:	4b1e      	ldr	r3, [pc, #120]	; (8b98 <CLI_commandLookup+0xd8>)
    8b20:	9300      	str	r3, [sp, #0]
    8b22:	4b1e      	ldr	r3, [pc, #120]	; (8b9c <CLI_commandLookup+0xdc>)
    8b24:	f000 fc8c 	bl	9440 <printstrs>
    8b28:	e00c      	b.n	8b44 <CLI_commandLookup+0x84>
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == -1 )
    8b2a:	9809      	ldr	r0, [sp, #36]	; 0x24
    8b2c:	f000 fe5a 	bl	97e4 <eqStr>
    8b30:	3001      	adds	r0, #1
    8b32:	f107 0701 	add.w	r7, r7, #1
    8b36:	d10d      	bne.n	8b54 <CLI_commandLookup+0x94>
				(*(void (*)(char*))CLIDict[dict][cmd].function)( argPtr );
    8b38:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
    8b3c:	980a      	ldr	r0, [sp, #40]	; 0x28
    8b3e:	441d      	add	r5, r3
    8b40:	68ab      	ldr	r3, [r5, #8]
    8b42:	4798      	blx	r3
}
    8b44:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    8b46:	f8d8 3000 	ldr.w	r3, [r8]
    8b4a:	429a      	cmp	r2, r3
    8b4c:	d00c      	beq.n	8b68 <CLI_commandLookup+0xa8>
    8b4e:	f7f8 fce9 	bl	1524 <__stack_chk_fail>
    8b52:	2700      	movs	r7, #0
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    8b54:	b2fd      	uxtb	r5, r7
    8b56:	fb09 f505 	mul.w	r5, r9, r5
    8b5a:	f85a 2026 	ldr.w	r2, [sl, r6, lsl #2]
    8b5e:	5951      	ldr	r1, [r2, r5]
    8b60:	2900      	cmp	r1, #0
    8b62:	d1e2      	bne.n	8b2a <CLI_commandLookup+0x6a>
    8b64:	3401      	adds	r4, #1
    8b66:	e7c5      	b.n	8af4 <CLI_commandLookup+0x34>
}
    8b68:	b00d      	add	sp, #52	; 0x34
    8b6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8b6e:	bf00      	nop
    8b70:	1fffe9d0 	.word	0x1fffe9d0
    8b74:	1ffffbe0 	.word	0x1ffffbe0
    8b78:	1ffffb24 	.word	0x1ffffb24
    8b7c:	0000d348 	.word	0x0000d348
    8b80:	0000cdad 	.word	0x0000cdad
    8b84:	0000ac3a 	.word	0x0000ac3a
    8b88:	0000cdb7 	.word	0x0000cdb7
    8b8c:	0000cdbe 	.word	0x0000cdbe
    8b90:	0000cdc1 	.word	0x0000cdc1
    8b94:	0000cdef 	.word	0x0000cdef
    8b98:	0000cdf1 	.word	0x0000cdf1
    8b9c:	0000cdb1 	.word	0x0000cdb1
    8ba0:	1ffff73b 	.word	0x1ffff73b
    8ba4:	1ffffb8c 	.word	0x1ffffb8c

00008ba8 <CLI_registerDictionary>:
{
    8ba8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    8baa:	4a10      	ldr	r2, [pc, #64]	; (8bec <CLI_registerDictionary+0x44>)
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
    8bac:	4c10      	ldr	r4, [pc, #64]	; (8bf0 <CLI_registerDictionary+0x48>)
{
    8bae:	6813      	ldr	r3, [r2, #0]
    8bb0:	9301      	str	r3, [sp, #4]
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
    8bb2:	7823      	ldrb	r3, [r4, #0]
    8bb4:	2b09      	cmp	r3, #9
    8bb6:	d90b      	bls.n	8bd0 <CLI_registerDictionary+0x28>
		erro_print("Max number of dictionaries defined already...");
    8bb8:	9901      	ldr	r1, [sp, #4]
    8bba:	6813      	ldr	r3, [r2, #0]
    8bbc:	4299      	cmp	r1, r3
    8bbe:	d001      	beq.n	8bc4 <CLI_registerDictionary+0x1c>
}
    8bc0:	f7f8 fcb0 	bl	1524 <__stack_chk_fail>
		erro_print("Max number of dictionaries defined already...");
    8bc4:	480b      	ldr	r0, [pc, #44]	; (8bf4 <CLI_registerDictionary+0x4c>)
}
    8bc6:	b003      	add	sp, #12
    8bc8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		erro_print("Max number of dictionaries defined already...");
    8bcc:	f000 bc5c 	b.w	9488 <_print>
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
    8bd0:	4d09      	ldr	r5, [pc, #36]	; (8bf8 <CLI_registerDictionary+0x50>)
    8bd2:	f845 1023 	str.w	r1, [r5, r3, lsl #2]
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
    8bd6:	1c59      	adds	r1, r3, #1
    8bd8:	7021      	strb	r1, [r4, #0]
    8bda:	4908      	ldr	r1, [pc, #32]	; (8bfc <CLI_registerDictionary+0x54>)
    8bdc:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
}
    8be0:	9901      	ldr	r1, [sp, #4]
    8be2:	6813      	ldr	r3, [r2, #0]
    8be4:	4299      	cmp	r1, r3
    8be6:	d1eb      	bne.n	8bc0 <CLI_registerDictionary+0x18>
    8be8:	b003      	add	sp, #12
    8bea:	bd30      	pop	{r4, r5, pc}
    8bec:	1fffe9d0 	.word	0x1fffe9d0
    8bf0:	1ffff73b 	.word	0x1ffff73b
    8bf4:	0000ce63 	.word	0x0000ce63
    8bf8:	1ffffbb8 	.word	0x1ffffbb8
    8bfc:	1ffffb8c 	.word	0x1ffffb8c

00008c00 <CLI_init>:
{
    8c00:	b537      	push	{r0, r1, r2, r4, r5, lr}
    8c02:	4d11      	ldr	r5, [pc, #68]	; (8c48 <CLI_init+0x48>)
    8c04:	682b      	ldr	r3, [r5, #0]
    8c06:	9301      	str	r3, [sp, #4]
	CLILineBufferCurrent = 0;
    8c08:	4b10      	ldr	r3, [pc, #64]	; (8c4c <CLI_init+0x4c>)
    8c0a:	2400      	movs	r4, #0
    8c0c:	701c      	strb	r4, [r3, #0]
	CLIHistoryHead = 0;
    8c0e:	4b10      	ldr	r3, [pc, #64]	; (8c50 <CLI_init+0x50>)
    8c10:	701c      	strb	r4, [r3, #0]
	CLIHistoryCurrent = 0;
    8c12:	4b10      	ldr	r3, [pc, #64]	; (8c54 <CLI_init+0x54>)
    8c14:	701c      	strb	r4, [r3, #0]
	CLIHistoryTail = 0;
    8c16:	4b10      	ldr	r3, [pc, #64]	; (8c58 <CLI_init+0x58>)
    8c18:	701c      	strb	r4, [r3, #0]
	prompt();
    8c1a:	f7ff feed 	bl	89f8 <prompt>
	CLIDictionariesUsed = 0;
    8c1e:	4b0f      	ldr	r3, [pc, #60]	; (8c5c <CLI_init+0x5c>)
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    8c20:	490f      	ldr	r1, [pc, #60]	; (8c60 <CLI_init+0x60>)
    8c22:	4810      	ldr	r0, [pc, #64]	; (8c64 <CLI_init+0x64>)
	CLIDictionariesUsed = 0;
    8c24:	701c      	strb	r4, [r3, #0]
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    8c26:	f7ff ffbf 	bl	8ba8 <CLI_registerDictionary>
	init_errorLED();
    8c2a:	f000 fbcb 	bl	93c4 <init_errorLED>
	CLILEDState = 0;
    8c2e:	4b0e      	ldr	r3, [pc, #56]	; (8c68 <CLI_init+0x68>)
}
    8c30:	9a01      	ldr	r2, [sp, #4]
	CLILEDState = 0;
    8c32:	701c      	strb	r4, [r3, #0]
	CLIHexDebugMode = 0;
    8c34:	4b0d      	ldr	r3, [pc, #52]	; (8c6c <CLI_init+0x6c>)
    8c36:	701c      	strb	r4, [r3, #0]
}
    8c38:	682b      	ldr	r3, [r5, #0]
    8c3a:	429a      	cmp	r2, r3
    8c3c:	d001      	beq.n	8c42 <CLI_init+0x42>
    8c3e:	f7f8 fc71 	bl	1524 <__stack_chk_fail>
    8c42:	b003      	add	sp, #12
    8c44:	bd30      	pop	{r4, r5, pc}
    8c46:	bf00      	nop
    8c48:	1fffe9d0 	.word	0x1fffe9d0
    8c4c:	1ffffbe0 	.word	0x1ffffbe0
    8c50:	1ffffb89 	.word	0x1ffffb89
    8c54:	1ffff739 	.word	0x1ffff739
    8c58:	1ffffbb4 	.word	0x1ffffbb4
    8c5c:	1ffff73b 	.word	0x1ffff73b
    8c60:	0000d080 	.word	0x0000d080
    8c64:	0000cfd8 	.word	0x0000cfd8
    8c68:	1ffff73a 	.word	0x1ffff73a
    8c6c:	1ffff738 	.word	0x1ffff738

00008c70 <CLI_tabCompletion>:
{
    8c70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8c74:	4a2d      	ldr	r2, [pc, #180]	; (8d2c <CLI_tabCompletion+0xbc>)
	if ( CLILineBufferCurrent == 0 )
    8c76:	4e2e      	ldr	r6, [pc, #184]	; (8d30 <CLI_tabCompletion+0xc0>)
{
    8c78:	6813      	ldr	r3, [r2, #0]
    8c7a:	b089      	sub	sp, #36	; 0x24
    8c7c:	9307      	str	r3, [sp, #28]
	if ( CLILineBufferCurrent == 0 )
    8c7e:	7833      	ldrb	r3, [r6, #0]
    8c80:	9200      	str	r2, [sp, #0]
    8c82:	b31b      	cbz	r3, 8ccc <CLI_tabCompletion+0x5c>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    8c84:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 8d38 <CLI_tabCompletion+0xc8>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    8c88:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 8d3c <CLI_tabCompletion+0xcc>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    8c8c:	2400      	movs	r4, #0
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    8c8e:	aa06      	add	r2, sp, #24
    8c90:	a905      	add	r1, sp, #20
    8c92:	4640      	mov	r0, r8
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    8c94:	f808 4003 	strb.w	r4, [r8, r3]
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    8c98:	f7ff fec8 	bl	8a2c <CLI_argumentIsolation>
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    8c9c:	4b25      	ldr	r3, [pc, #148]	; (8d34 <CLI_tabCompletion+0xc4>)
    8c9e:	f8cd 8004 	str.w	r8, [sp, #4]
	uint8_t matches = 0;
    8ca2:	4627      	mov	r7, r4
	char* tabMatch = 0;
    8ca4:	4625      	mov	r5, r4
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    8ca6:	220c      	movs	r2, #12
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    8ca8:	7819      	ldrb	r1, [r3, #0]
    8caa:	fa5f f984 	uxtb.w	r9, r4
    8cae:	4549      	cmp	r1, r9
    8cb0:	d82f      	bhi.n	8d12 <CLI_tabCompletion+0xa2>
	if ( matches == 1 )
    8cb2:	2f01      	cmp	r7, #1
    8cb4:	d10a      	bne.n	8ccc <CLI_tabCompletion+0x5c>
		CLILineBufferCurrent = 0;
    8cb6:	2300      	movs	r3, #0
    8cb8:	7033      	strb	r3, [r6, #0]
		prompt();
    8cba:	f7ff fe9d 	bl	89f8 <prompt>
		dPrint( tabMatch );
    8cbe:	4628      	mov	r0, r5
    8cc0:	f7fd f85e 	bl	5d80 <Output_putstr>
    8cc4:	3d01      	subs	r5, #1
		while ( *tabMatch != '\0' )
    8cc6:	f815 3f01 	ldrb.w	r3, [r5, #1]!
    8cca:	bb2b      	cbnz	r3, 8d18 <CLI_tabCompletion+0xa8>
}
    8ccc:	9b00      	ldr	r3, [sp, #0]
    8cce:	9a07      	ldr	r2, [sp, #28]
    8cd0:	681b      	ldr	r3, [r3, #0]
    8cd2:	429a      	cmp	r2, r3
    8cd4:	d027      	beq.n	8d26 <CLI_tabCompletion+0xb6>
    8cd6:	f7f8 fc25 	bl	1524 <__stack_chk_fail>
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
    8cda:	9805      	ldr	r0, [sp, #20]
    8cdc:	e9cd 3202 	strd	r3, r2, [sp, #8]
    8ce0:	f000 fd80 	bl	97e4 <eqStr>
    8ce4:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    8ce8:	b928      	cbnz	r0, 8cf6 <CLI_tabCompletion+0x86>
				tabMatch = (char*)CLIDict[dict][cmd].name;
    8cea:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
				matches++;
    8cee:	3701      	adds	r7, #1
				tabMatch = (char*)CLIDict[dict][cmd].name;
    8cf0:	f851 5008 	ldr.w	r5, [r1, r8]
				matches++;
    8cf4:	b2ff      	uxtb	r7, r7
    8cf6:	f10a 0a01 	add.w	sl, sl, #1
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    8cfa:	fa5f f88a 	uxtb.w	r8, sl
    8cfe:	fb02 f808 	mul.w	r8, r2, r8
    8d02:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
    8d06:	f851 1008 	ldr.w	r1, [r1, r8]
    8d0a:	2900      	cmp	r1, #0
    8d0c:	d1e5      	bne.n	8cda <CLI_tabCompletion+0x6a>
    8d0e:	3401      	adds	r4, #1
    8d10:	e7ca      	b.n	8ca8 <CLI_tabCompletion+0x38>
    8d12:	f04f 0a00 	mov.w	sl, #0
    8d16:	e7f0      	b.n	8cfa <CLI_tabCompletion+0x8a>
			CLILineBuffer[CLILineBufferCurrent++] = *tabMatch++;
    8d18:	7833      	ldrb	r3, [r6, #0]
    8d1a:	9901      	ldr	r1, [sp, #4]
    8d1c:	1c5a      	adds	r2, r3, #1
    8d1e:	7032      	strb	r2, [r6, #0]
    8d20:	782a      	ldrb	r2, [r5, #0]
    8d22:	54ca      	strb	r2, [r1, r3]
    8d24:	e7cf      	b.n	8cc6 <CLI_tabCompletion+0x56>
}
    8d26:	b009      	add	sp, #36	; 0x24
    8d28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8d2c:	1fffe9d0 	.word	0x1fffe9d0
    8d30:	1ffffbe0 	.word	0x1ffffbe0
    8d34:	1ffff73b 	.word	0x1ffff73b
    8d38:	1ffffb24 	.word	0x1ffffb24
    8d3c:	1ffffb8c 	.word	0x1ffffb8c

00008d40 <CLI_wrap>:
{
    8d40:	b513      	push	{r0, r1, r4, lr}
    8d42:	4b0f      	ldr	r3, [pc, #60]	; (8d80 <CLI_wrap+0x40>)
	if ( kX < kLowerBound )
    8d44:	4281      	cmp	r1, r0
{
    8d46:	681c      	ldr	r4, [r3, #0]
    8d48:	9401      	str	r4, [sp, #4]
	int range_size = kUpperBound - kLowerBound + 1;
    8d4a:	eba2 0201 	sub.w	r2, r2, r1
    8d4e:	f102 0201 	add.w	r2, r2, #1
    8d52:	461c      	mov	r4, r3
		kX += range_size * ((kLowerBound - kX) / range_size + 1);
    8d54:	bfc1      	itttt	gt
    8d56:	1a0b      	subgt	r3, r1, r0
    8d58:	fb93 f3f2 	sdivgt	r3, r3, r2
    8d5c:	fb03 2302 	mlagt	r3, r3, r2, r2
    8d60:	18c0      	addgt	r0, r0, r3
	return kLowerBound + (kX - kLowerBound) % range_size;
    8d62:	1a40      	subs	r0, r0, r1
    8d64:	fb90 f3f2 	sdiv	r3, r0, r2
    8d68:	fb02 0013 	mls	r0, r2, r3, r0
}
    8d6c:	9a01      	ldr	r2, [sp, #4]
    8d6e:	6823      	ldr	r3, [r4, #0]
    8d70:	429a      	cmp	r2, r3
    8d72:	4408      	add	r0, r1
    8d74:	d001      	beq.n	8d7a <CLI_wrap+0x3a>
    8d76:	f7f8 fbd5 	bl	1524 <__stack_chk_fail>
    8d7a:	b002      	add	sp, #8
    8d7c:	bd10      	pop	{r4, pc}
    8d7e:	bf00      	nop
    8d80:	1fffe9d0 	.word	0x1fffe9d0

00008d84 <CLI_saveHistory>:
{
    8d84:	b537      	push	{r0, r1, r2, r4, r5, lr}
    8d86:	4914      	ldr	r1, [pc, #80]	; (8dd8 <CLI_saveHistory+0x54>)
    8d88:	680a      	ldr	r2, [r1, #0]
    8d8a:	9201      	str	r2, [sp, #4]
	if ( buff == NULL )
    8d8c:	b1a8      	cbz	r0, 8dba <CLI_saveHistory+0x36>
    8d8e:	3801      	subs	r0, #1
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
    8d90:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    8d94:	2b20      	cmp	r3, #32
    8d96:	d0fb      	beq.n	8d90 <CLI_saveHistory+0xc>
        if (*cursor == '\0') { return ; }
    8d98:	b1ab      	cbz	r3, 8dc6 <CLI_saveHistory+0x42>
	for (i = 0; i < CLILineBufferCurrent; i++)
    8d9a:	4b10      	ldr	r3, [pc, #64]	; (8ddc <CLI_saveHistory+0x58>)
    8d9c:	7818      	ldrb	r0, [r3, #0]
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    8d9e:	4b10      	ldr	r3, [pc, #64]	; (8de0 <CLI_saveHistory+0x5c>)
    8da0:	781c      	ldrb	r4, [r3, #0]
    8da2:	4b10      	ldr	r3, [pc, #64]	; (8de4 <CLI_saveHistory+0x60>)
    8da4:	2264      	movs	r2, #100	; 0x64
    8da6:	fb04 3202 	mla	r2, r4, r2, r3
    8daa:	4c0f      	ldr	r4, [pc, #60]	; (8de8 <CLI_saveHistory+0x64>)
	for (i = 0; i < CLILineBufferCurrent; i++)
    8dac:	2300      	movs	r3, #0
    8dae:	4283      	cmp	r3, r0
    8db0:	da09      	bge.n	8dc6 <CLI_saveHistory+0x42>
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    8db2:	5d1d      	ldrb	r5, [r3, r4]
    8db4:	54d5      	strb	r5, [r2, r3]
	for (i = 0; i < CLILineBufferCurrent; i++)
    8db6:	3301      	adds	r3, #1
    8db8:	e7f9      	b.n	8dae <CLI_saveHistory+0x2a>
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    8dba:	4b09      	ldr	r3, [pc, #36]	; (8de0 <CLI_saveHistory+0x5c>)
    8dbc:	781a      	ldrb	r2, [r3, #0]
    8dbe:	2364      	movs	r3, #100	; 0x64
    8dc0:	4353      	muls	r3, r2
    8dc2:	4a08      	ldr	r2, [pc, #32]	; (8de4 <CLI_saveHistory+0x60>)
    8dc4:	54d0      	strb	r0, [r2, r3]
}
    8dc6:	9a01      	ldr	r2, [sp, #4]
    8dc8:	680b      	ldr	r3, [r1, #0]
    8dca:	429a      	cmp	r2, r3
    8dcc:	d001      	beq.n	8dd2 <CLI_saveHistory+0x4e>
    8dce:	f7f8 fba9 	bl	1524 <__stack_chk_fail>
    8dd2:	b003      	add	sp, #12
    8dd4:	bd30      	pop	{r4, r5, pc}
    8dd6:	bf00      	nop
    8dd8:	1fffe9d0 	.word	0x1fffe9d0
    8ddc:	1ffffbe0 	.word	0x1ffffbe0
    8de0:	1ffffbb4 	.word	0x1ffffbb4
    8de4:	1ffff73c 	.word	0x1ffff73c
    8de8:	1ffffb24 	.word	0x1ffffb24

00008dec <CLI_retreiveHistory>:
{
    8dec:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8dee:	4f12      	ldr	r7, [pc, #72]	; (8e38 <CLI_retreiveHistory+0x4c>)
	CLILineBufferCurrent = 0;
    8df0:	4d12      	ldr	r5, [pc, #72]	; (8e3c <CLI_retreiveHistory+0x50>)
{
    8df2:	683b      	ldr	r3, [r7, #0]
    8df4:	9301      	str	r3, [sp, #4]
	char *histMatch = CLIHistoryBuffer[ index ];
    8df6:	4b12      	ldr	r3, [pc, #72]	; (8e40 <CLI_retreiveHistory+0x54>)
    8df8:	2664      	movs	r6, #100	; 0x64
    8dfa:	fb06 3600 	mla	r6, r6, r0, r3
	CLILineBufferCurrent = 0;
    8dfe:	2400      	movs	r4, #0
    8e00:	702c      	strb	r4, [r5, #0]
	prompt();
    8e02:	f7ff fdf9 	bl	89f8 <prompt>
	dPrint( histMatch );
    8e06:	4630      	mov	r0, r6
    8e08:	f7fc ffba 	bl	5d80 <Output_putstr>
		CLILineBuffer[ CLILineBufferCurrent++ ] = *histMatch++;
    8e0c:	480d      	ldr	r0, [pc, #52]	; (8e44 <CLI_retreiveHistory+0x58>)
	CLILineBufferCurrent = 0;
    8e0e:	702c      	strb	r4, [r5, #0]
	while ( *histMatch != '\0' )
    8e10:	4632      	mov	r2, r6
    8e12:	1b93      	subs	r3, r2, r6
    8e14:	f812 1b01 	ldrb.w	r1, [r2], #1
    8e18:	b2db      	uxtb	r3, r3
    8e1a:	b939      	cbnz	r1, 8e2c <CLI_retreiveHistory+0x40>
    8e1c:	b104      	cbz	r4, 8e20 <CLI_retreiveHistory+0x34>
    8e1e:	702b      	strb	r3, [r5, #0]
}
    8e20:	9a01      	ldr	r2, [sp, #4]
    8e22:	683b      	ldr	r3, [r7, #0]
    8e24:	429a      	cmp	r2, r3
    8e26:	d004      	beq.n	8e32 <CLI_retreiveHistory+0x46>
    8e28:	f7f8 fb7c 	bl	1524 <__stack_chk_fail>
		CLILineBuffer[ CLILineBufferCurrent++ ] = *histMatch++;
    8e2c:	54c1      	strb	r1, [r0, r3]
    8e2e:	2401      	movs	r4, #1
    8e30:	e7ef      	b.n	8e12 <CLI_retreiveHistory+0x26>
}
    8e32:	b003      	add	sp, #12
    8e34:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8e36:	bf00      	nop
    8e38:	1fffe9d0 	.word	0x1fffe9d0
    8e3c:	1ffffbe0 	.word	0x1ffffbe0
    8e40:	1ffff73c 	.word	0x1ffff73c
    8e44:	1ffffb24 	.word	0x1ffffb24

00008e48 <CLI_process>:
{
    8e48:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    8e4c:	4f7b      	ldr	r7, [pc, #492]	; (903c <CLI_process+0x1f4>)
	uint8_t prev_buf_pos = CLILineBufferCurrent;
    8e4e:	4c7c      	ldr	r4, [pc, #496]	; (9040 <CLI_process+0x1f8>)
{
    8e50:	683b      	ldr	r3, [r7, #0]
	uint8_t prev_buf_pos = CLILineBufferCurrent;
    8e52:	7825      	ldrb	r5, [r4, #0]
		CLILineBuffer[CLILineBufferCurrent++] = cur_char;
    8e54:	4e7b      	ldr	r6, [pc, #492]	; (9044 <CLI_process+0x1fc>)
{
    8e56:	9301      	str	r3, [sp, #4]
		if ( Output_availablechar() == 0 )
    8e58:	f7fc ff6e 	bl	5d38 <Output_availablechar>
    8e5c:	b1e0      	cbz	r0, 8e98 <CLI_process+0x50>
		char cur_char = (char)Output_getchar();
    8e5e:	f7fc ff7d 	bl	5d5c <Output_getchar>
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    8e62:	7823      	ldrb	r3, [r4, #0]
    8e64:	2b63      	cmp	r3, #99	; 0x63
		char cur_char = (char)Output_getchar();
    8e66:	b2c0      	uxtb	r0, r0
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    8e68:	d912      	bls.n	8e90 <CLI_process+0x48>
			print( NL );
    8e6a:	4877      	ldr	r0, [pc, #476]	; (9048 <CLI_process+0x200>)
    8e6c:	f000 fb0c 	bl	9488 <_print>
			erro_print("Serial line buffer is full, dropping character and resetting...");
    8e70:	4876      	ldr	r0, [pc, #472]	; (904c <CLI_process+0x204>)
    8e72:	f000 fb09 	bl	9488 <_print>
			CLILineBufferCurrent = 0;
    8e76:	2300      	movs	r3, #0
    8e78:	7023      	strb	r3, [r4, #0]
			prompt();
    8e7a:	f7ff fdbd 	bl	89f8 <prompt>
}
    8e7e:	9a01      	ldr	r2, [sp, #4]
    8e80:	683b      	ldr	r3, [r7, #0]
    8e82:	429a      	cmp	r2, r3
    8e84:	f04f 0000 	mov.w	r0, #0
    8e88:	f000 80d5 	beq.w	9036 <CLI_process+0x1ee>
    8e8c:	f7f8 fb4a 	bl	1524 <__stack_chk_fail>
		CLILineBuffer[CLILineBufferCurrent++] = cur_char;
    8e90:	1c5a      	adds	r2, r3, #1
    8e92:	7022      	strb	r2, [r4, #0]
    8e94:	54f0      	strb	r0, [r6, r3]
	{
    8e96:	e7df      	b.n	8e58 <CLI_process+0x10>
	if ( CLIHexDebugMode && CLILineBufferCurrent > prev_buf_pos )
    8e98:	4b6d      	ldr	r3, [pc, #436]	; (9050 <CLI_process+0x208>)
    8e9a:	781b      	ldrb	r3, [r3, #0]
    8e9c:	b19b      	cbz	r3, 8ec6 <CLI_process+0x7e>
    8e9e:	7823      	ldrb	r3, [r4, #0]
    8ea0:	42ab      	cmp	r3, r5
    8ea2:	d9ec      	bls.n	8e7e <CLI_process+0x36>
		print("\033[s\r\n"); // Save cursor position, and move to the next line
    8ea4:	486b      	ldr	r0, [pc, #428]	; (9054 <CLI_process+0x20c>)
			printHex( CLILineBuffer[pos++] );
    8ea6:	f8df 919c 	ldr.w	r9, [pc, #412]	; 9044 <CLI_process+0x1fc>
			print(" ");
    8eaa:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 9070 <CLI_process+0x228>
		print("\033[s\r\n"); // Save cursor position, and move to the next line
    8eae:	f000 faeb 	bl	9488 <_print>
		print("\033[2K");    // Erases the current line
    8eb2:	4869      	ldr	r0, [pc, #420]	; (9058 <CLI_process+0x210>)
    8eb4:	f000 fae8 	bl	9488 <_print>
		while ( CLILineBufferCurrent > pos )
    8eb8:	462b      	mov	r3, r5
    8eba:	7822      	ldrb	r2, [r4, #0]
    8ebc:	429a      	cmp	r2, r3
    8ebe:	d819      	bhi.n	8ef4 <CLI_process+0xac>
		print("\033[u"); // Restore cursor position
    8ec0:	4866      	ldr	r0, [pc, #408]	; (905c <CLI_process+0x214>)
    8ec2:	f000 fae1 	bl	9488 <_print>
		switch ( CLILineBuffer[prev_buf_pos] )
    8ec6:	4e5f      	ldr	r6, [pc, #380]	; (9044 <CLI_process+0x1fc>)
				print("\b \b");
    8ec8:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 9074 <CLI_process+0x22c>
	while ( CLILineBufferCurrent > prev_buf_pos )
    8ecc:	7823      	ldrb	r3, [r4, #0]
    8ece:	42ab      	cmp	r3, r5
    8ed0:	d9d5      	bls.n	8e7e <CLI_process+0x36>
		switch ( CLILineBuffer[prev_buf_pos] )
    8ed2:	5d72      	ldrb	r2, [r6, r5]
    8ed4:	2a0a      	cmp	r2, #10
    8ed6:	d020      	beq.n	8f1a <CLI_process+0xd2>
    8ed8:	d818      	bhi.n	8f0c <CLI_process+0xc4>
    8eda:	2a08      	cmp	r2, #8
    8edc:	f000 80a0 	beq.w	9020 <CLI_process+0x1d8>
    8ee0:	2a09      	cmp	r2, #9
    8ee2:	d04a      	beq.n	8f7a <CLI_process+0x132>
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    8ee4:	2200      	movs	r2, #0
			dPrint( &CLILineBuffer[prev_buf_pos] );
    8ee6:	1970      	adds	r0, r6, r5
			prev_buf_pos++;
    8ee8:	3501      	adds	r5, #1
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    8eea:	54f2      	strb	r2, [r6, r3]
			prev_buf_pos++;
    8eec:	b2ed      	uxtb	r5, r5
			dPrint( &CLILineBuffer[prev_buf_pos] );
    8eee:	f7fc ff47 	bl	5d80 <Output_putstr>
			break;
    8ef2:	e7eb      	b.n	8ecc <CLI_process+0x84>
			printHex( CLILineBuffer[pos++] );
    8ef4:	1c5e      	adds	r6, r3, #1
    8ef6:	f819 0003 	ldrb.w	r0, [r9, r3]
    8efa:	2101      	movs	r1, #1
    8efc:	f000 fbea 	bl	96d4 <printHex_op>
    8f00:	b2f6      	uxtb	r6, r6
			print(" ");
    8f02:	4640      	mov	r0, r8
    8f04:	f000 fac0 	bl	9488 <_print>
			printHex( CLILineBuffer[pos++] );
    8f08:	4633      	mov	r3, r6
    8f0a:	e7d6      	b.n	8eba <CLI_process+0x72>
		switch ( CLILineBuffer[prev_buf_pos] )
    8f0c:	2a1b      	cmp	r2, #27
    8f0e:	d03a      	beq.n	8f86 <CLI_process+0x13e>
    8f10:	2a7f      	cmp	r2, #127	; 0x7f
    8f12:	f000 8085 	beq.w	9020 <CLI_process+0x1d8>
    8f16:	2a0d      	cmp	r2, #13
    8f18:	d1e4      	bne.n	8ee4 <CLI_process+0x9c>
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    8f1a:	441e      	add	r6, r3
    8f1c:	2220      	movs	r2, #32
			if ( CLILineBufferCurrent == 1 )
    8f1e:	2b01      	cmp	r3, #1
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    8f20:	f806 2c01 	strb.w	r2, [r6, #-1]
			if ( CLILineBufferCurrent == 1 )
    8f24:	d023      	beq.n	8f6e <CLI_process+0x126>
				CLI_saveHistory( CLILineBuffer );
    8f26:	4847      	ldr	r0, [pc, #284]	; (9044 <CLI_process+0x1fc>)
    8f28:	f7ff ff2c 	bl	8d84 <CLI_saveHistory>
				CLI_commandLookup();
    8f2c:	f7ff fdc8 	bl	8ac0 <CLI_commandLookup>
				if ( CLIHistoryTail < CLIHistoryHead )
    8f30:	4a4b      	ldr	r2, [pc, #300]	; (9060 <CLI_process+0x218>)
    8f32:	494c      	ldr	r1, [pc, #304]	; (9064 <CLI_process+0x21c>)
    8f34:	7813      	ldrb	r3, [r2, #0]
    8f36:	7808      	ldrb	r0, [r1, #0]
    8f38:	4283      	cmp	r3, r0
    8f3a:	d206      	bcs.n	8f4a <CLI_process+0x102>
					CLIHistoryHead = ( CLIHistoryHead + 1 ) % CLIMaxHistorySize;
    8f3c:	3001      	adds	r0, #1
    8f3e:	260a      	movs	r6, #10
    8f40:	fb90 f5f6 	sdiv	r5, r0, r6
    8f44:	fb06 0015 	mls	r0, r6, r5, r0
    8f48:	7008      	strb	r0, [r1, #0]
				CLIHistoryTail++;
    8f4a:	3301      	adds	r3, #1
    8f4c:	b2db      	uxtb	r3, r3
				if ( CLIHistoryTail == CLIMaxHistorySize )
    8f4e:	2b0a      	cmp	r3, #10
					CLIHistoryTail = 0;
    8f50:	bf03      	ittte	eq
    8f52:	2300      	moveq	r3, #0
    8f54:	7013      	strbeq	r3, [r2, #0]
					CLIHistoryHead = 1;
    8f56:	2301      	moveq	r3, #1
				CLIHistoryTail++;
    8f58:	7013      	strbne	r3, [r2, #0]
					CLIHistoryHead = 1;
    8f5a:	bf08      	it	eq
    8f5c:	700b      	strbeq	r3, [r1, #0]
				CLIHistoryCurrent = CLIHistoryTail; // 'Up' starts at the last item
    8f5e:	4b42      	ldr	r3, [pc, #264]	; (9068 <CLI_process+0x220>)
    8f60:	7812      	ldrb	r2, [r2, #0]
    8f62:	701a      	strb	r2, [r3, #0]
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    8f64:	2364      	movs	r3, #100	; 0x64
    8f66:	4353      	muls	r3, r2
    8f68:	4a40      	ldr	r2, [pc, #256]	; (906c <CLI_process+0x224>)
    8f6a:	2100      	movs	r1, #0
    8f6c:	54d1      	strb	r1, [r2, r3]
			CLILineBufferCurrent = 0;
    8f6e:	2300      	movs	r3, #0
			print( NL );
    8f70:	4835      	ldr	r0, [pc, #212]	; (9048 <CLI_process+0x200>)
			CLILineBufferCurrent = 0;
    8f72:	7023      	strb	r3, [r4, #0]
			print( NL );
    8f74:	f000 fa88 	bl	9488 <_print>
    8f78:	e77f      	b.n	8e7a <CLI_process+0x32>
			CLI_tabCompletion();
    8f7a:	f7ff fe79 	bl	8c70 <CLI_tabCompletion>
			CLILineBufferCurrent--; // Remove the Tab
    8f7e:	7823      	ldrb	r3, [r4, #0]
    8f80:	3b01      	subs	r3, #1
    8f82:	7023      	strb	r3, [r4, #0]
			return 0;
    8f84:	e77b      	b.n	8e7e <CLI_process+0x36>
			if ( CLILineBufferCurrent >= prev_buf_pos + 3
    8f86:	f105 0802 	add.w	r8, r5, #2
    8f8a:	4598      	cmp	r8, r3
    8f8c:	f6bf af77 	bge.w	8e7e <CLI_process+0x36>
				&& CLILineBuffer[ prev_buf_pos + 1] == 0x5B )
    8f90:	1973      	adds	r3, r6, r5
    8f92:	785b      	ldrb	r3, [r3, #1]
    8f94:	2b5b      	cmp	r3, #91	; 0x5b
    8f96:	f47f af72 	bne.w	8e7e <CLI_process+0x36>
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x41 ) // Hist prev
    8f9a:	f816 3008 	ldrb.w	r3, [r6, r8]
    8f9e:	2b41      	cmp	r3, #65	; 0x41
    8fa0:	d121      	bne.n	8fe6 <CLI_process+0x19e>
					if ( CLIHistoryCurrent == CLIHistoryTail )
    8fa2:	4c31      	ldr	r4, [pc, #196]	; (9068 <CLI_process+0x220>)
    8fa4:	4b2e      	ldr	r3, [pc, #184]	; (9060 <CLI_process+0x218>)
    8fa6:	f994 2000 	ldrsb.w	r2, [r4]
    8faa:	781b      	ldrb	r3, [r3, #0]
    8fac:	429a      	cmp	r2, r3
    8fae:	d104      	bne.n	8fba <CLI_process+0x172>
						CLILineBuffer[ prev_buf_pos ] = '\0';
    8fb0:	2300      	movs	r3, #0
						CLI_saveHistory( CLILineBuffer );
    8fb2:	4824      	ldr	r0, [pc, #144]	; (9044 <CLI_process+0x1fc>)
						CLILineBuffer[ prev_buf_pos ] = '\0';
    8fb4:	5573      	strb	r3, [r6, r5]
						CLI_saveHistory( CLILineBuffer );
    8fb6:	f7ff fee5 	bl	8d84 <CLI_saveHistory>
					if ( RING_PREV( CLIHistoryCurrent ) != RING_PREV( CLIHistoryHead ) )
    8fba:	f994 0000 	ldrsb.w	r0, [r4]
    8fbe:	2209      	movs	r2, #9
    8fc0:	2100      	movs	r1, #0
    8fc2:	3801      	subs	r0, #1
    8fc4:	f7ff febc 	bl	8d40 <CLI_wrap>
    8fc8:	4b26      	ldr	r3, [pc, #152]	; (9064 <CLI_process+0x21c>)
    8fca:	4605      	mov	r5, r0
    8fcc:	7818      	ldrb	r0, [r3, #0]
    8fce:	2209      	movs	r2, #9
    8fd0:	2100      	movs	r1, #0
    8fd2:	3801      	subs	r0, #1
    8fd4:	f7ff feb4 	bl	8d40 <CLI_wrap>
    8fd8:	4285      	cmp	r5, r0
						CLIHistoryCurrent = RING_PREV( CLIHistoryCurrent );
    8fda:	bf18      	it	ne
    8fdc:	7025      	strbne	r5, [r4, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    8fde:	f994 0000 	ldrsb.w	r0, [r4]
    8fe2:	f7ff ff03 	bl	8dec <CLI_retreiveHistory>
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x42 ) // Hist next
    8fe6:	f816 3008 	ldrb.w	r3, [r6, r8]
    8fea:	2b42      	cmp	r3, #66	; 0x42
    8fec:	f47f af47 	bne.w	8e7e <CLI_process+0x36>
					if ( RING_NEXT( CLIHistoryCurrent ) != RING_NEXT( CLIHistoryTail ) )
    8ff0:	4c1d      	ldr	r4, [pc, #116]	; (9068 <CLI_process+0x220>)
    8ff2:	f994 0000 	ldrsb.w	r0, [r4]
    8ff6:	2209      	movs	r2, #9
    8ff8:	2100      	movs	r1, #0
    8ffa:	3001      	adds	r0, #1
    8ffc:	f7ff fea0 	bl	8d40 <CLI_wrap>
    9000:	4b17      	ldr	r3, [pc, #92]	; (9060 <CLI_process+0x218>)
    9002:	4605      	mov	r5, r0
    9004:	7818      	ldrb	r0, [r3, #0]
    9006:	2209      	movs	r2, #9
    9008:	2100      	movs	r1, #0
    900a:	3001      	adds	r0, #1
    900c:	f7ff fe98 	bl	8d40 <CLI_wrap>
    9010:	4285      	cmp	r5, r0
						CLIHistoryCurrent = RING_NEXT( CLIHistoryCurrent );
    9012:	bf18      	it	ne
    9014:	7025      	strbne	r5, [r4, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    9016:	f994 0000 	ldrsb.w	r0, [r4]
    901a:	f7ff fee7 	bl	8dec <CLI_retreiveHistory>
    901e:	e72e      	b.n	8e7e <CLI_process+0x36>
			if ( CLILineBufferCurrent > 0 )
    9020:	2b01      	cmp	r3, #1
    9022:	d102      	bne.n	902a <CLI_process+0x1e2>
			CLILineBufferCurrent--; // Remove the backspace
    9024:	2300      	movs	r3, #0
    9026:	7023      	strb	r3, [r4, #0]
    9028:	e750      	b.n	8ecc <CLI_process+0x84>
				CLILineBufferCurrent--;
    902a:	3b02      	subs	r3, #2
				print("\b \b");
    902c:	4640      	mov	r0, r8
				CLILineBufferCurrent--;
    902e:	7023      	strb	r3, [r4, #0]
				print("\b \b");
    9030:	f000 fa2a 	bl	9488 <_print>
    9034:	e74a      	b.n	8ecc <CLI_process+0x84>
}
    9036:	b003      	add	sp, #12
    9038:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    903c:	1fffe9d0 	.word	0x1fffe9d0
    9040:	1ffffbe0 	.word	0x1ffffbe0
    9044:	1ffffb24 	.word	0x1ffffb24
    9048:	0000d348 	.word	0x0000d348
    904c:	0000cdf9 	.word	0x0000cdf9
    9050:	1ffff738 	.word	0x1ffff738
    9054:	0000ce50 	.word	0x0000ce50
    9058:	0000ce56 	.word	0x0000ce56
    905c:	0000ce5b 	.word	0x0000ce5b
    9060:	1ffffbb4 	.word	0x1ffffbb4
    9064:	1ffffb89 	.word	0x1ffffb89
    9068:	1ffff739 	.word	0x1ffff739
    906c:	1ffff73c 	.word	0x1ffff73c
    9070:	0000d6a4 	.word	0x0000d6a4
    9074:	0000ce5f 	.word	0x0000ce5f

00009078 <printLatency>:
{
    9078:	b537      	push	{r0, r1, r2, r4, r5, lr}
    907a:	4d22      	ldr	r5, [pc, #136]	; (9104 <printLatency+0x8c>)
    907c:	682b      	ldr	r3, [r5, #0]
    907e:	9301      	str	r3, [sp, #4]
    9080:	4604      	mov	r4, r0
	printInt8( resource );
    9082:	f000 fa6b 	bl	955c <printInt8>
	print(":");
    9086:	4820      	ldr	r0, [pc, #128]	; (9108 <printLatency+0x90>)
    9088:	f000 f9fe 	bl	9488 <_print>
	print( Latency_query_name( resource ) );
    908c:	4620      	mov	r0, r4
    908e:	f000 f913 	bl	92b8 <Latency_query_name>
    9092:	f000 f9f9 	bl	9488 <_print>
	print("\t");
    9096:	481d      	ldr	r0, [pc, #116]	; (910c <printLatency+0x94>)
    9098:	f000 f9f6 	bl	9488 <_print>
	printInt32( Latency_query( LatencyQuery_Count, resource ) );
    909c:	4621      	mov	r1, r4
    909e:	2004      	movs	r0, #4
    90a0:	f000 f8d2 	bl	9248 <Latency_query>
    90a4:	f000 fac6 	bl	9634 <printInt32>
	print("\t");
    90a8:	4818      	ldr	r0, [pc, #96]	; (910c <printLatency+0x94>)
    90aa:	f000 f9ed 	bl	9488 <_print>
	printInt32( Latency_query( LatencyQuery_Min, resource ) );
    90ae:	4621      	mov	r1, r4
    90b0:	2000      	movs	r0, #0
    90b2:	f000 f8c9 	bl	9248 <Latency_query>
    90b6:	f000 fabd 	bl	9634 <printInt32>
	print("\t");
    90ba:	4814      	ldr	r0, [pc, #80]	; (910c <printLatency+0x94>)
    90bc:	f000 f9e4 	bl	9488 <_print>
	printInt32( Latency_query( LatencyQuery_Average, resource ) );
    90c0:	4621      	mov	r1, r4
    90c2:	2002      	movs	r0, #2
    90c4:	f000 f8c0 	bl	9248 <Latency_query>
    90c8:	f000 fab4 	bl	9634 <printInt32>
	print("\t");
    90cc:	480f      	ldr	r0, [pc, #60]	; (910c <printLatency+0x94>)
    90ce:	f000 f9db 	bl	9488 <_print>
	printInt32( Latency_query( LatencyQuery_Last, resource ) );
    90d2:	4621      	mov	r1, r4
    90d4:	2003      	movs	r0, #3
    90d6:	f000 f8b7 	bl	9248 <Latency_query>
    90da:	f000 faab 	bl	9634 <printInt32>
	print("\t");
    90de:	480b      	ldr	r0, [pc, #44]	; (910c <printLatency+0x94>)
    90e0:	f000 f9d2 	bl	9488 <_print>
	printInt32( Latency_query( LatencyQuery_Max, resource ) );
    90e4:	4621      	mov	r1, r4
    90e6:	2001      	movs	r0, #1
    90e8:	f000 f8ae 	bl	9248 <Latency_query>
    90ec:	9a01      	ldr	r2, [sp, #4]
    90ee:	682b      	ldr	r3, [r5, #0]
    90f0:	429a      	cmp	r2, r3
    90f2:	d001      	beq.n	90f8 <printLatency+0x80>
    90f4:	f7f8 fa16 	bl	1524 <__stack_chk_fail>
}
    90f8:	b003      	add	sp, #12
    90fa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt32( Latency_query( LatencyQuery_Max, resource ) );
    90fe:	f000 ba99 	b.w	9634 <printInt32>
    9102:	bf00      	nop
    9104:	1fffe9d0 	.word	0x1fffe9d0
    9108:	0000d681 	.word	0x0000d681
    910c:	0000a7e0 	.word	0x0000a7e0

00009110 <cliFunc_latency>:
{
    9110:	b5f0      	push	{r4, r5, r6, r7, lr}
    9112:	4e1c      	ldr	r6, [pc, #112]	; (9184 <cliFunc_latency+0x74>)
    9114:	b085      	sub	sp, #20
    9116:	6833      	ldr	r3, [r6, #0]
    9118:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    911a:	aa02      	add	r2, sp, #8
    911c:	a901      	add	r1, sp, #4
    911e:	f7ff fc85 	bl	8a2c <CLI_argumentIsolation>
	print( NL );
    9122:	4819      	ldr	r0, [pc, #100]	; (9188 <cliFunc_latency+0x78>)
    9124:	f000 f9b0 	bl	9488 <_print>
	print("Latency" NL );
    9128:	4818      	ldr	r0, [pc, #96]	; (918c <cliFunc_latency+0x7c>)
    912a:	f000 f9ad 	bl	9488 <_print>
	print("<i>:<module>\t<count>\t<min>\t<avg>\t<last>\t<max>");
    912e:	4818      	ldr	r0, [pc, #96]	; (9190 <cliFunc_latency+0x80>)
    9130:	f000 f9aa 	bl	9488 <_print>
	if ( arg1Ptr[0] == '\0' )
    9134:	9b01      	ldr	r3, [sp, #4]
    9136:	781c      	ldrb	r4, [r3, #0]
    9138:	b304      	cbz	r4, 917c <cliFunc_latency+0x6c>
		print( NL );
    913a:	4813      	ldr	r0, [pc, #76]	; (9188 <cliFunc_latency+0x78>)
    913c:	f000 f9a4 	bl	9488 <_print>
		if ( arg1Ptr[0] < Latency_resources() )
    9140:	9b01      	ldr	r3, [sp, #4]
    9142:	781c      	ldrb	r4, [r3, #0]
    9144:	f000 f842 	bl	91cc <Latency_resources>
    9148:	4284      	cmp	r4, r0
    914a:	d211      	bcs.n	9170 <cliFunc_latency+0x60>
			printLatency( arg1Ptr[0] );
    914c:	9b01      	ldr	r3, [sp, #4]
    914e:	7818      	ldrb	r0, [r3, #0]
    9150:	f7ff ff92 	bl	9078 <printLatency>
}
    9154:	e00c      	b.n	9170 <cliFunc_latency+0x60>
			print( NL );
    9156:	4638      	mov	r0, r7
    9158:	f000 f996 	bl	9488 <_print>
			printLatency( c );
    915c:	4628      	mov	r0, r5
    915e:	f7ff ff8b 	bl	9078 <printLatency>
		for ( uint8_t c = 0; c < Latency_resources(); c++ )
    9162:	f000 f833 	bl	91cc <Latency_resources>
    9166:	b2e5      	uxtb	r5, r4
    9168:	4285      	cmp	r5, r0
    916a:	f104 0401 	add.w	r4, r4, #1
    916e:	d3f2      	bcc.n	9156 <cliFunc_latency+0x46>
}
    9170:	9a03      	ldr	r2, [sp, #12]
    9172:	6833      	ldr	r3, [r6, #0]
    9174:	429a      	cmp	r2, r3
    9176:	d003      	beq.n	9180 <cliFunc_latency+0x70>
    9178:	f7f8 f9d4 	bl	1524 <__stack_chk_fail>
			print( NL );
    917c:	4f02      	ldr	r7, [pc, #8]	; (9188 <cliFunc_latency+0x78>)
    917e:	e7f0      	b.n	9162 <cliFunc_latency+0x52>
}
    9180:	b005      	add	sp, #20
    9182:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9184:	1fffe9d0 	.word	0x1fffe9d0
    9188:	0000d348 	.word	0x0000d348
    918c:	0000d17a 	.word	0x0000d17a
    9190:	0000d184 	.word	0x0000d184

00009194 <Latency_init>:
// ----- Functions -----

// Initialize latency module
// Call before adding resources
void Latency_init()
{
    9194:	b513      	push	{r0, r1, r4, lr}
    9196:	4c0a      	ldr	r4, [pc, #40]	; (91c0 <Latency_init+0x2c>)
	// Zero out all measurements
	memset( &latency_measurements, 0, sizeof(LatencyMeasurement) * LatencyMeasurementCount_define );
    9198:	480a      	ldr	r0, [pc, #40]	; (91c4 <Latency_init+0x30>)
{
    919a:	6823      	ldr	r3, [r4, #0]
    919c:	9301      	str	r3, [sp, #4]
	memset( &latency_measurements, 0, sizeof(LatencyMeasurement) * LatencyMeasurementCount_define );
    919e:	f44f 72b4 	mov.w	r2, #360	; 0x168
    91a2:	2100      	movs	r1, #0
    91a4:	f7f8 f9cc 	bl	1540 <memset>

	// Set used resources to 0
	latency_resources = 0;
    91a8:	4b07      	ldr	r3, [pc, #28]	; (91c8 <Latency_init+0x34>)
    91aa:	2200      	movs	r2, #0
    91ac:	701a      	strb	r2, [r3, #0]
}
    91ae:	9a01      	ldr	r2, [sp, #4]
    91b0:	6823      	ldr	r3, [r4, #0]
    91b2:	429a      	cmp	r2, r3
    91b4:	d001      	beq.n	91ba <Latency_init+0x26>
    91b6:	f7f8 f9b5 	bl	1524 <__stack_chk_fail>
    91ba:	b002      	add	sp, #8
    91bc:	bd10      	pop	{r4, pc}
    91be:	bf00      	nop
    91c0:	1fffe9d0 	.word	0x1fffe9d0
    91c4:	1ffff5cc 	.word	0x1ffff5cc
    91c8:	1ffff734 	.word	0x1ffff734

000091cc <Latency_resources>:

// Number of latency resources used
uint8_t Latency_resources()
{
    91cc:	b507      	push	{r0, r1, r2, lr}
    91ce:	4b07      	ldr	r3, [pc, #28]	; (91ec <Latency_resources+0x20>)
    91d0:	681a      	ldr	r2, [r3, #0]
    91d2:	9201      	str	r2, [sp, #4]
	return latency_resources;
}
    91d4:	4a06      	ldr	r2, [pc, #24]	; (91f0 <Latency_resources+0x24>)
    91d6:	7810      	ldrb	r0, [r2, #0]
    91d8:	9a01      	ldr	r2, [sp, #4]
    91da:	681b      	ldr	r3, [r3, #0]
    91dc:	429a      	cmp	r2, r3
    91de:	d001      	beq.n	91e4 <Latency_resources+0x18>
    91e0:	f7f8 f9a0 	bl	1524 <__stack_chk_fail>
    91e4:	b003      	add	sp, #12
    91e6:	f85d fb04 	ldr.w	pc, [sp], #4
    91ea:	bf00      	nop
    91ec:	1fffe9d0 	.word	0x1fffe9d0
    91f0:	1ffff734 	.word	0x1ffff734

000091f4 <Latency_add_resource>:

// Add latency tracking resource
//
// return: resource index
uint8_t Latency_add_resource( const char* name, LatencyOption option )
{
    91f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    91f6:	4a10      	ldr	r2, [pc, #64]	; (9238 <Latency_add_resource+0x44>)
	// Add identifier name
	uint8_t index = latency_resources++;
    91f8:	4c10      	ldr	r4, [pc, #64]	; (923c <Latency_add_resource+0x48>)
{
    91fa:	6813      	ldr	r3, [r2, #0]
    91fc:	9301      	str	r3, [sp, #4]
	uint8_t index = latency_resources++;
    91fe:	7823      	ldrb	r3, [r4, #0]
    9200:	1c5d      	adds	r5, r3, #1

	// Make sure there are resources left to allocate
	if ( index >= LatencyMeasurementCount_define )
    9202:	2b09      	cmp	r3, #9
	uint8_t index = latency_resources++;
    9204:	7025      	strb	r5, [r4, #0]
    9206:	4614      	mov	r4, r2
	if ( index >= LatencyMeasurementCount_define )
    9208:	d90a      	bls.n	9220 <Latency_add_resource+0x2c>
	{
		erro_print("No more latency resources available...");
    920a:	480d      	ldr	r0, [pc, #52]	; (9240 <Latency_add_resource+0x4c>)
    920c:	f000 f93c 	bl	9488 <_print>
		return 0;
    9210:	2300      	movs	r3, #0

	// Max out min latency
	latency_measurements[index].min_latency = 0xFFFFFFFF;

	return index;
}
    9212:	9a01      	ldr	r2, [sp, #4]
    9214:	4618      	mov	r0, r3
    9216:	6823      	ldr	r3, [r4, #0]
    9218:	429a      	cmp	r2, r3
    921a:	d00b      	beq.n	9234 <Latency_add_resource+0x40>
    921c:	f7f8 f982 	bl	1524 <__stack_chk_fail>
	latency_measurements[index].name = name;
    9220:	4e08      	ldr	r6, [pc, #32]	; (9244 <Latency_add_resource+0x50>)
    9222:	2224      	movs	r2, #36	; 0x24
    9224:	435a      	muls	r2, r3
    9226:	18b5      	adds	r5, r6, r2
    9228:	50b0      	str	r0, [r6, r2]
	latency_measurements[index].min_latency = 0xFFFFFFFF;
    922a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	latency_measurements[index].option = option;
    922e:	7329      	strb	r1, [r5, #12]
	latency_measurements[index].min_latency = 0xFFFFFFFF;
    9230:	612a      	str	r2, [r5, #16]
	return index;
    9232:	e7ee      	b.n	9212 <Latency_add_resource+0x1e>
}
    9234:	b002      	add	sp, #8
    9236:	bd70      	pop	{r4, r5, r6, pc}
    9238:	1fffe9d0 	.word	0x1fffe9d0
    923c:	1ffff734 	.word	0x1ffff734
    9240:	0000da7f 	.word	0x0000da7f
    9244:	1ffff5cc 	.word	0x1ffff5cc

00009248 <Latency_query>:
// type:     type of query
// resource: index of resource
//
// return: latency query result
uint32_t Latency_query( LatencyQuery type, uint8_t resource )
{
    9248:	b507      	push	{r0, r1, r2, lr}
    924a:	4b19      	ldr	r3, [pc, #100]	; (92b0 <Latency_query+0x68>)
    924c:	681a      	ldr	r2, [r3, #0]
    924e:	9201      	str	r2, [sp, #4]
    9250:	461a      	mov	r2, r3
	switch ( type )
    9252:	2804      	cmp	r0, #4
    9254:	d827      	bhi.n	92a6 <Latency_query+0x5e>
    9256:	e8df f000 	tbb	[pc, r0]
    925a:	0e03      	.short	0x0e03
    925c:	1a14      	.short	0x1a14
    925e:	20          	.byte	0x20
    925f:	00          	.byte	0x00
	{
	case LatencyQuery_Min:
		return latency_measurements[resource].min_latency;
    9260:	4814      	ldr	r0, [pc, #80]	; (92b4 <Latency_query+0x6c>)
    9262:	2324      	movs	r3, #36	; 0x24
    9264:	fb03 0101 	mla	r1, r3, r1, r0
    9268:	6908      	ldr	r0, [r1, #16]
		return latency_measurements[resource].count;

	default:
		return 0;
	}
}
    926a:	9901      	ldr	r1, [sp, #4]
    926c:	6813      	ldr	r3, [r2, #0]
    926e:	4299      	cmp	r1, r3
    9270:	d01b      	beq.n	92aa <Latency_query+0x62>
    9272:	f7f8 f957 	bl	1524 <__stack_chk_fail>
		return latency_measurements[resource].max_latency;
    9276:	480f      	ldr	r0, [pc, #60]	; (92b4 <Latency_query+0x6c>)
    9278:	2324      	movs	r3, #36	; 0x24
    927a:	fb03 0101 	mla	r1, r3, r1, r0
    927e:	6948      	ldr	r0, [r1, #20]
    9280:	e7f3      	b.n	926a <Latency_query+0x22>
		return latency_measurements[resource].average_latency;
    9282:	480c      	ldr	r0, [pc, #48]	; (92b4 <Latency_query+0x6c>)
    9284:	2324      	movs	r3, #36	; 0x24
    9286:	fb03 0101 	mla	r1, r3, r1, r0
    928a:	6988      	ldr	r0, [r1, #24]
    928c:	e7ed      	b.n	926a <Latency_query+0x22>
		return latency_measurements[resource].last_latency;
    928e:	4809      	ldr	r0, [pc, #36]	; (92b4 <Latency_query+0x6c>)
    9290:	2324      	movs	r3, #36	; 0x24
    9292:	fb03 0101 	mla	r1, r3, r1, r0
    9296:	69c8      	ldr	r0, [r1, #28]
    9298:	e7e7      	b.n	926a <Latency_query+0x22>
		return latency_measurements[resource].count;
    929a:	4b06      	ldr	r3, [pc, #24]	; (92b4 <Latency_query+0x6c>)
    929c:	2024      	movs	r0, #36	; 0x24
    929e:	fb00 3101 	mla	r1, r0, r1, r3
    92a2:	6a08      	ldr	r0, [r1, #32]
    92a4:	e7e1      	b.n	926a <Latency_query+0x22>
		return 0;
    92a6:	2000      	movs	r0, #0
    92a8:	e7df      	b.n	926a <Latency_query+0x22>
}
    92aa:	b003      	add	sp, #12
    92ac:	f85d fb04 	ldr.w	pc, [sp], #4
    92b0:	1fffe9d0 	.word	0x1fffe9d0
    92b4:	1ffff5cc 	.word	0x1ffff5cc

000092b8 <Latency_query_name>:
// Resource Lookup
// resource: index of resource
//
// return: Name of resource
const char* Latency_query_name( uint8_t resource )
{
    92b8:	b507      	push	{r0, r1, r2, lr}
    92ba:	4a08      	ldr	r2, [pc, #32]	; (92dc <Latency_query_name+0x24>)
    92bc:	6813      	ldr	r3, [r2, #0]
    92be:	9301      	str	r3, [sp, #4]
	return latency_measurements[resource].name;
    92c0:	2324      	movs	r3, #36	; 0x24
    92c2:	4358      	muls	r0, r3
}
    92c4:	4b06      	ldr	r3, [pc, #24]	; (92e0 <Latency_query_name+0x28>)
    92c6:	9901      	ldr	r1, [sp, #4]
    92c8:	5818      	ldr	r0, [r3, r0]
    92ca:	6813      	ldr	r3, [r2, #0]
    92cc:	4299      	cmp	r1, r3
    92ce:	d001      	beq.n	92d4 <Latency_query_name+0x1c>
    92d0:	f7f8 f928 	bl	1524 <__stack_chk_fail>
    92d4:	b003      	add	sp, #12
    92d6:	f85d fb04 	ldr.w	pc, [sp], #4
    92da:	bf00      	nop
    92dc:	1fffe9d0 	.word	0x1fffe9d0
    92e0:	1ffff5cc 	.word	0x1ffff5cc

000092e4 <Latency_start_time>:

// Resource start time
//
// resource: index of resource
void Latency_start_time( uint8_t resource )
{
    92e4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    92e6:	4e0c      	ldr	r6, [pc, #48]	; (9318 <Latency_start_time+0x34>)
	latency_measurements[resource].start_time = Time_now();
    92e8:	4c0c      	ldr	r4, [pc, #48]	; (931c <Latency_start_time+0x38>)
{
    92ea:	6833      	ldr	r3, [r6, #0]
    92ec:	9303      	str	r3, [sp, #12]
	latency_measurements[resource].start_time = Time_now();
    92ee:	466d      	mov	r5, sp
    92f0:	2324      	movs	r3, #36	; 0x24
    92f2:	fb03 4400 	mla	r4, r3, r0, r4
    92f6:	4628      	mov	r0, r5
    92f8:	f7f8 fc02 	bl	1b00 <Time_now>
    92fc:	e895 0003 	ldmia.w	r5, {r0, r1}
    9300:	1d23      	adds	r3, r4, #4
}
    9302:	9a03      	ldr	r2, [sp, #12]
	latency_measurements[resource].start_time = Time_now();
    9304:	e883 0003 	stmia.w	r3, {r0, r1}
}
    9308:	6833      	ldr	r3, [r6, #0]
    930a:	429a      	cmp	r2, r3
    930c:	d001      	beq.n	9312 <Latency_start_time+0x2e>
    930e:	f7f8 f909 	bl	1524 <__stack_chk_fail>
    9312:	b004      	add	sp, #16
    9314:	bd70      	pop	{r4, r5, r6, pc}
    9316:	bf00      	nop
    9318:	1fffe9d0 	.word	0x1fffe9d0
    931c:	1ffff5cc 	.word	0x1ffff5cc

00009320 <Latency_end_time>:

// Measure latency, and store
//
// resource: index of resource
void Latency_end_time( uint8_t resource )
{
    9320:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9322:	4d26      	ldr	r5, [pc, #152]	; (93bc <Latency_end_time+0x9c>)
	uint32_t measured;
	switch ( latency_measurements[resource].option )
    9324:	4e26      	ldr	r6, [pc, #152]	; (93c0 <Latency_end_time+0xa0>)
{
    9326:	682b      	ldr	r3, [r5, #0]
    9328:	9301      	str	r3, [sp, #4]
	switch ( latency_measurements[resource].option )
    932a:	2324      	movs	r3, #36	; 0x24
    932c:	fb03 6300 	mla	r3, r3, r0, r6
{
    9330:	4604      	mov	r4, r0
	switch ( latency_measurements[resource].option )
    9332:	7b1a      	ldrb	r2, [r3, #12]
    9334:	2a02      	cmp	r2, #2
    9336:	f103 0304 	add.w	r3, r3, #4
    933a:	d033      	beq.n	93a4 <Latency_end_time+0x84>
    933c:	2a03      	cmp	r2, #3
    933e:	d006      	beq.n	934e <Latency_end_time+0x2e>
    9340:	2a01      	cmp	r2, #1
    9342:	d134      	bne.n	93ae <Latency_end_time+0x8e>
	case LatencyOption_us:
		measured = Time_duration_us( latency_measurements[resource].start_time );
		break;

	case LatencyOption_ns:
		measured = Time_duration_ns( latency_measurements[resource].start_time );
    9344:	e893 0003 	ldmia.w	r3, {r0, r1}
    9348:	f7f8 fd34 	bl	1db4 <Time_duration_ns>
		break;
    934c:	e003      	b.n	9356 <Latency_end_time+0x36>
		measured = Time_duration_ms( latency_measurements[resource].start_time );
    934e:	e893 0003 	ldmia.w	r3, {r0, r1}
    9352:	f7f8 fcf9 	bl	1d48 <Time_duration_ms>
		measured = Time_duration_ticks( latency_measurements[resource].start_time );
		break;
	}

	// Check if min or max latencies need to change
	if ( measured < latency_measurements[resource].min_latency )
    9356:	2224      	movs	r2, #36	; 0x24
    9358:	fb02 6304 	mla	r3, r2, r4, r6
	{
		latency_measurements[resource].min_latency = measured;
	}
	if ( measured > latency_measurements[resource].max_latency )
    935c:	fb02 6204 	mla	r2, r2, r4, r6
	if ( measured < latency_measurements[resource].min_latency )
    9360:	6919      	ldr	r1, [r3, #16]
    9362:	4281      	cmp	r1, r0
		latency_measurements[resource].min_latency = measured;
    9364:	bf88      	it	hi
    9366:	6118      	strhi	r0, [r3, #16]
	if ( measured > latency_measurements[resource].max_latency )
    9368:	6953      	ldr	r3, [r2, #20]
    936a:	4283      	cmp	r3, r0
	{
		latency_measurements[resource].max_latency = measured;
	}

	// Calculate average, places emphasis on recent values
	uint32_t old_avg = latency_measurements[resource].average_latency;
    936c:	f04f 0324 	mov.w	r3, #36	; 0x24
    9370:	fb03 6304 	mla	r3, r3, r4, r6
		latency_measurements[resource].max_latency = measured;
    9374:	bf38      	it	cc
    9376:	6150      	strcc	r0, [r2, #20]
	uint32_t old_avg = latency_measurements[resource].average_latency;
    9378:	6999      	ldr	r1, [r3, #24]
	if ( old_avg == 0 )
	{
		// Use measured value if this is the first calculation
		old_avg = measured;
	}
	latency_measurements[resource].average_latency = ( old_avg / 2 ) + ( measured / 2 ) + ( old_avg & measured & 1 );
    937a:	f000 0201 	and.w	r2, r0, #1
	if ( old_avg == 0 )
    937e:	2900      	cmp	r1, #0
    9380:	bf08      	it	eq
    9382:	4601      	moveq	r1, r0
	latency_measurements[resource].average_latency = ( old_avg / 2 ) + ( measured / 2 ) + ( old_avg & measured & 1 );
    9384:	400a      	ands	r2, r1
    9386:	eb02 0251 	add.w	r2, r2, r1, lsr #1
    938a:	eb02 0250 	add.w	r2, r2, r0, lsr #1

	// Set last average
	latency_measurements[resource].last_latency = measured;
    938e:	e9c3 2006 	strd	r2, r0, [r3, #24]

	// Latency check count
	latency_measurements[resource].count++;
    9392:	6a1a      	ldr	r2, [r3, #32]
    9394:	3201      	adds	r2, #1
    9396:	621a      	str	r2, [r3, #32]
}
    9398:	9a01      	ldr	r2, [sp, #4]
    939a:	682b      	ldr	r3, [r5, #0]
    939c:	429a      	cmp	r2, r3
    939e:	d00b      	beq.n	93b8 <Latency_end_time+0x98>
    93a0:	f7f8 f8c0 	bl	1524 <__stack_chk_fail>
		measured = Time_duration_us( latency_measurements[resource].start_time );
    93a4:	e893 0003 	ldmia.w	r3, {r0, r1}
    93a8:	f7f8 fce6 	bl	1d78 <Time_duration_us>
		break;
    93ac:	e7d3      	b.n	9356 <Latency_end_time+0x36>
		measured = Time_duration_ticks( latency_measurements[resource].start_time );
    93ae:	e893 0003 	ldmia.w	r3, {r0, r1}
    93b2:	f7f8 fd1d 	bl	1df0 <Time_duration_ticks>
		break;
    93b6:	e7ce      	b.n	9356 <Latency_end_time+0x36>
}
    93b8:	b002      	add	sp, #8
    93ba:	bd70      	pop	{r4, r5, r6, pc}
    93bc:	1fffe9d0 	.word	0x1fffe9d0
    93c0:	1ffff5cc 	.word	0x1ffff5cc

000093c4 <init_errorLED>:

// ----- Functions -----

// Error LED Setup
inline void init_errorLED()
{
    93c4:	b507      	push	{r0, r1, r2, lr}
    93c6:	4b0a      	ldr	r3, [pc, #40]	; (93f0 <init_errorLED+0x2c>)
    93c8:	681a      	ldr	r2, [r3, #0]
    93ca:	9201      	str	r2, [sp, #4]
	// Enable output
	GPIO_Ctrl( led_pin, GPIO_Type_DriveSetup, GPIO_Config_None );
    93cc:	9a01      	ldr	r2, [sp, #4]
    93ce:	681b      	ldr	r3, [r3, #0]
    93d0:	429a      	cmp	r2, r3
    93d2:	d001      	beq.n	93d8 <init_errorLED+0x14>
    93d4:	f7f8 f8a6 	bl	1524 <__stack_chk_fail>
    93d8:	4b06      	ldr	r3, [pc, #24]	; (93f4 <init_errorLED+0x30>)
    93da:	7818      	ldrb	r0, [r3, #0]
    93dc:	785b      	ldrb	r3, [r3, #1]
    93de:	2200      	movs	r2, #0
    93e0:	2103      	movs	r1, #3
    93e2:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
}
    93e6:	b003      	add	sp, #12
    93e8:	f85d eb04 	ldr.w	lr, [sp], #4
	GPIO_Ctrl( led_pin, GPIO_Type_DriveSetup, GPIO_Config_None );
    93ec:	f7f8 ba82 	b.w	18f4 <GPIO_Ctrl>
    93f0:	1fffe9d0 	.word	0x1fffe9d0
    93f4:	0000dabd 	.word	0x0000dabd

000093f8 <errorLED>:

// Error LED Control
inline void errorLED( uint8_t on )
{
    93f8:	b507      	push	{r0, r1, r2, lr}
    93fa:	490f      	ldr	r1, [pc, #60]	; (9438 <errorLED+0x40>)
    93fc:	680b      	ldr	r3, [r1, #0]
    93fe:	9301      	str	r3, [sp, #4]
	// Error LED On
	if (on)
    9400:	4602      	mov	r2, r0
    9402:	4b0e      	ldr	r3, [pc, #56]	; (943c <errorLED+0x44>)
	{
		GPIO_Ctrl( led_pin, GPIO_Type_DriveHigh, GPIO_Config_None );
    9404:	9801      	ldr	r0, [sp, #4]
	if (on)
    9406:	b17a      	cbz	r2, 9428 <errorLED+0x30>
		GPIO_Ctrl( led_pin, GPIO_Type_DriveHigh, GPIO_Config_None );
    9408:	680a      	ldr	r2, [r1, #0]
    940a:	4290      	cmp	r0, r2
    940c:	d001      	beq.n	9412 <errorLED+0x1a>
	}
	// Error LED Off
	else
	{
		GPIO_Ctrl( led_pin, GPIO_Type_DriveLow, GPIO_Config_None );
    940e:	f7f8 f889 	bl	1524 <__stack_chk_fail>
		GPIO_Ctrl( led_pin, GPIO_Type_DriveHigh, GPIO_Config_None );
    9412:	7818      	ldrb	r0, [r3, #0]
    9414:	785b      	ldrb	r3, [r3, #1]
    9416:	2200      	movs	r2, #0
    9418:	4611      	mov	r1, r2
		GPIO_Ctrl( led_pin, GPIO_Type_DriveLow, GPIO_Config_None );
    941a:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
	}
}
    941e:	b003      	add	sp, #12
    9420:	f85d eb04 	ldr.w	lr, [sp], #4
		GPIO_Ctrl( led_pin, GPIO_Type_DriveLow, GPIO_Config_None );
    9424:	f7f8 ba66 	b.w	18f4 <GPIO_Ctrl>
    9428:	6809      	ldr	r1, [r1, #0]
    942a:	4288      	cmp	r0, r1
    942c:	d1ef      	bne.n	940e <errorLED+0x16>
    942e:	7818      	ldrb	r0, [r3, #0]
    9430:	785b      	ldrb	r3, [r3, #1]
    9432:	2101      	movs	r1, #1
    9434:	e7f1      	b.n	941a <errorLED+0x22>
    9436:	bf00      	nop
    9438:	1fffe9d0 	.word	0x1fffe9d0
    943c:	0000dabd 	.word	0x0000dabd

00009440 <printstrs>:

// ----- Functions -----

// Multiple string Output
void printstrs( char* first, ... )
{
    9440:	b40f      	push	{r0, r1, r2, r3}
    9442:	b513      	push	{r0, r1, r4, lr}
    9444:	4c0f      	ldr	r4, [pc, #60]	; (9484 <printstrs+0x44>)
    9446:	aa04      	add	r2, sp, #16
    9448:	6821      	ldr	r1, [r4, #0]
    944a:	f852 0b04 	ldr.w	r0, [r2], #4
    944e:	9101      	str	r1, [sp, #4]
	// Initialize the variadic function parameter list
	va_list ap;

	// Get the first parameter
	va_start( ap, first );
    9450:	9200      	str	r2, [sp, #0]
	char *cur = first;

	// Loop through the variadic list until "\0\0\0" is found
	while ( !( cur[0] == '\0' && cur[1] == '\0' && cur[2] == '\0' ) )
    9452:	7803      	ldrb	r3, [r0, #0]
    9454:	b94b      	cbnz	r3, 946a <printstrs+0x2a>
    9456:	7843      	ldrb	r3, [r0, #1]
    9458:	b93b      	cbnz	r3, 946a <printstrs+0x2a>
    945a:	7883      	ldrb	r3, [r0, #2]
    945c:	b92b      	cbnz	r3, 946a <printstrs+0x2a>
		// Get the next argument ready
		cur = va_arg( ap, char* );
	}

	va_end( ap ); // Not required, but good practice
}
    945e:	9a01      	ldr	r2, [sp, #4]
    9460:	6823      	ldr	r3, [r4, #0]
    9462:	429a      	cmp	r2, r3
    9464:	d008      	beq.n	9478 <printstrs+0x38>
    9466:	f7f8 f85d 	bl	1524 <__stack_chk_fail>
		Output_putstr( cur );
    946a:	f7fc fc89 	bl	5d80 <Output_putstr>
		cur = va_arg( ap, char* );
    946e:	9b00      	ldr	r3, [sp, #0]
    9470:	1d1a      	adds	r2, r3, #4
    9472:	9200      	str	r2, [sp, #0]
    9474:	6818      	ldr	r0, [r3, #0]
    9476:	e7ec      	b.n	9452 <printstrs+0x12>
}
    9478:	b002      	add	sp, #8
    947a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    947e:	b004      	add	sp, #16
    9480:	4770      	bx	lr
    9482:	bf00      	nop
    9484:	1fffe9d0 	.word	0x1fffe9d0

00009488 <_print>:

// Print a constant string
void _print( const char* s )
{
    9488:	b507      	push	{r0, r1, r2, lr}
    948a:	4b07      	ldr	r3, [pc, #28]	; (94a8 <_print+0x20>)
    948c:	681a      	ldr	r2, [r3, #0]
    948e:	9201      	str	r2, [sp, #4]
	while ( ( c = pgm_read_byte( s++ ) ) != '\0' )
	{
		Output_putchar( c );
	}
#elif defined(_kinetis_) || defined(_sam_) // ARM
	Output_putstr( (char*)s );
    9490:	9a01      	ldr	r2, [sp, #4]
    9492:	681b      	ldr	r3, [r3, #0]
    9494:	429a      	cmp	r2, r3
    9496:	d001      	beq.n	949c <_print+0x14>
    9498:	f7f8 f844 	bl	1524 <__stack_chk_fail>
#elif defined(_host_) // Host
	Output_putstr( (char*)s );
#endif
}
    949c:	b003      	add	sp, #12
    949e:	f85d eb04 	ldr.w	lr, [sp], #4
	Output_putstr( (char*)s );
    94a2:	f7fc bc6d 	b.w	5d80 <Output_putstr>
    94a6:	bf00      	nop
    94a8:	1fffe9d0 	.word	0x1fffe9d0

000094ac <lenStr>:
	}
}


uint16_t lenStr( char* in )
{
    94ac:	b513      	push	{r0, r1, r4, lr}
    94ae:	4a09      	ldr	r2, [pc, #36]	; (94d4 <lenStr+0x28>)
    94b0:	6813      	ldr	r3, [r2, #0]
    94b2:	9301      	str	r3, [sp, #4]
    94b4:	4603      	mov	r3, r0
	// Iterator
	char *pos;

	// Loop until null is found
	for ( pos = in; *pos; pos++ );
    94b6:	7819      	ldrb	r1, [r3, #0]
    94b8:	1c5c      	adds	r4, r3, #1
    94ba:	b939      	cbnz	r1, 94cc <lenStr+0x20>

	// Return the difference between the pointers of in and pos (which is the string length)
	return (pos - in);
    94bc:	1a18      	subs	r0, r3, r0
}
    94be:	9901      	ldr	r1, [sp, #4]
    94c0:	6813      	ldr	r3, [r2, #0]
    94c2:	4299      	cmp	r1, r3
    94c4:	b280      	uxth	r0, r0
    94c6:	d003      	beq.n	94d0 <lenStr+0x24>
    94c8:	f7f8 f82c 	bl	1524 <__stack_chk_fail>
    94cc:	4623      	mov	r3, r4
    94ce:	e7f2      	b.n	94b6 <lenStr+0xa>
    94d0:	b002      	add	sp, #8
    94d2:	bd10      	pop	{r4, pc}
    94d4:	1fffe9d0 	.word	0x1fffe9d0

000094d8 <revsStr>:
{
    94d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    94da:	4c0e      	ldr	r4, [pc, #56]	; (9514 <revsStr+0x3c>)
    94dc:	6823      	ldr	r3, [r4, #0]
    94de:	9301      	str	r3, [sp, #4]
    94e0:	4605      	mov	r5, r0
	for ( i = 0, j = lenStr( in ) - 1; i < j; i++, j-- )
    94e2:	f7ff ffe3 	bl	94ac <lenStr>
    94e6:	3801      	subs	r0, #1
    94e8:	4428      	add	r0, r5
    94ea:	462b      	mov	r3, r5
    94ec:	1b5a      	subs	r2, r3, r5
    94ee:	1b41      	subs	r1, r0, r5
    94f0:	428a      	cmp	r2, r1
    94f2:	db05      	blt.n	9500 <revsStr+0x28>
}
    94f4:	9a01      	ldr	r2, [sp, #4]
    94f6:	6823      	ldr	r3, [r4, #0]
    94f8:	429a      	cmp	r2, r3
    94fa:	d008      	beq.n	950e <revsStr+0x36>
    94fc:	f7f8 f812 	bl	1524 <__stack_chk_fail>
		c = in[i];
    9500:	781a      	ldrb	r2, [r3, #0]
		in[i] = in[j];
    9502:	7801      	ldrb	r1, [r0, #0]
    9504:	f803 1b01 	strb.w	r1, [r3], #1
		in[j] = c;
    9508:	f800 2901 	strb.w	r2, [r0], #-1
    950c:	e7ee      	b.n	94ec <revsStr+0x14>
}
    950e:	b003      	add	sp, #12
    9510:	bd30      	pop	{r4, r5, pc}
    9512:	bf00      	nop
    9514:	1fffe9d0 	.word	0x1fffe9d0

00009518 <int8ToStr>:
{
    9518:	b573      	push	{r0, r1, r4, r5, r6, lr}
    951a:	4a0f      	ldr	r2, [pc, #60]	; (9558 <int8ToStr+0x40>)
    951c:	4603      	mov	r3, r0
    951e:	6810      	ldr	r0, [r2, #0]
    9520:	9001      	str	r0, [sp, #4]
	pos = 0;
    9522:	2400      	movs	r4, #0
		out[pos++] = in % 10 + '0';
    9524:	250a      	movs	r5, #10
    9526:	fbb3 f0f5 	udiv	r0, r3, r5
    952a:	fb05 3310 	mls	r3, r5, r0, r3
    952e:	3330      	adds	r3, #48	; 0x30
    9530:	550b      	strb	r3, [r1, r4]
    9532:	1c66      	adds	r6, r4, #1
	while ( (in /= 10) > 0 );
    9534:	f010 03ff 	ands.w	r3, r0, #255	; 0xff
		out[pos++] = in % 10 + '0';
    9538:	b2f4      	uxtb	r4, r6
	while ( (in /= 10) > 0 );
    953a:	d1f4      	bne.n	9526 <int8ToStr+0xe>
	out[pos] = '\0';
    953c:	550b      	strb	r3, [r1, r4]
	revsStr(out);
    953e:	9801      	ldr	r0, [sp, #4]
    9540:	6813      	ldr	r3, [r2, #0]
    9542:	4298      	cmp	r0, r3
    9544:	d001      	beq.n	954a <int8ToStr+0x32>
    9546:	f7f7 ffed 	bl	1524 <__stack_chk_fail>
    954a:	4608      	mov	r0, r1
}
    954c:	b002      	add	sp, #8
    954e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	revsStr(out);
    9552:	f7ff bfc1 	b.w	94d8 <revsStr>
    9556:	bf00      	nop
    9558:	1fffe9d0 	.word	0x1fffe9d0

0000955c <printInt8>:
{
    955c:	b513      	push	{r0, r1, r4, lr}
    955e:	4c08      	ldr	r4, [pc, #32]	; (9580 <printInt8+0x24>)
	int8ToStr( in, tmpStr );
    9560:	4669      	mov	r1, sp
{
    9562:	6823      	ldr	r3, [r4, #0]
    9564:	9301      	str	r3, [sp, #4]
	int8ToStr( in, tmpStr );
    9566:	f7ff ffd7 	bl	9518 <int8ToStr>
	dPrintStr( tmpStr );
    956a:	4668      	mov	r0, sp
    956c:	f7fc fc08 	bl	5d80 <Output_putstr>
}
    9570:	9a01      	ldr	r2, [sp, #4]
    9572:	6823      	ldr	r3, [r4, #0]
    9574:	429a      	cmp	r2, r3
    9576:	d001      	beq.n	957c <printInt8+0x20>
    9578:	f7f7 ffd4 	bl	1524 <__stack_chk_fail>
    957c:	b002      	add	sp, #8
    957e:	bd10      	pop	{r4, pc}
    9580:	1fffe9d0 	.word	0x1fffe9d0

00009584 <int16ToStr>:
{
    9584:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9586:	4a0f      	ldr	r2, [pc, #60]	; (95c4 <int16ToStr+0x40>)
    9588:	4603      	mov	r3, r0
    958a:	6810      	ldr	r0, [r2, #0]
    958c:	9001      	str	r0, [sp, #4]
	pos = 0;
    958e:	2400      	movs	r4, #0
		out[pos++] = in % 10 + '0';
    9590:	250a      	movs	r5, #10
    9592:	fbb3 f0f5 	udiv	r0, r3, r5
    9596:	fb05 3310 	mls	r3, r5, r0, r3
    959a:	3330      	adds	r3, #48	; 0x30
    959c:	550b      	strb	r3, [r1, r4]
    959e:	1c66      	adds	r6, r4, #1
	while ( (in /= 10) > 0 );
    95a0:	b283      	uxth	r3, r0
		out[pos++] = in % 10 + '0';
    95a2:	b2b4      	uxth	r4, r6
	while ( (in /= 10) > 0 );
    95a4:	2b00      	cmp	r3, #0
    95a6:	d1f4      	bne.n	9592 <int16ToStr+0xe>
	out[pos] = '\0';
    95a8:	550b      	strb	r3, [r1, r4]
	revsStr(out);
    95aa:	9801      	ldr	r0, [sp, #4]
    95ac:	6813      	ldr	r3, [r2, #0]
    95ae:	4298      	cmp	r0, r3
    95b0:	d001      	beq.n	95b6 <int16ToStr+0x32>
    95b2:	f7f7 ffb7 	bl	1524 <__stack_chk_fail>
    95b6:	4608      	mov	r0, r1
}
    95b8:	b002      	add	sp, #8
    95ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	revsStr(out);
    95be:	f7ff bf8b 	b.w	94d8 <revsStr>
    95c2:	bf00      	nop
    95c4:	1fffe9d0 	.word	0x1fffe9d0

000095c8 <printInt16>:
{
    95c8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    95ca:	4c08      	ldr	r4, [pc, #32]	; (95ec <printInt16+0x24>)
	int16ToStr( in, tmpStr );
    95cc:	a901      	add	r1, sp, #4
{
    95ce:	6823      	ldr	r3, [r4, #0]
    95d0:	9303      	str	r3, [sp, #12]
	int16ToStr( in, tmpStr );
    95d2:	f7ff ffd7 	bl	9584 <int16ToStr>
	dPrintStr( tmpStr );
    95d6:	a801      	add	r0, sp, #4
    95d8:	f7fc fbd2 	bl	5d80 <Output_putstr>
}
    95dc:	9a03      	ldr	r2, [sp, #12]
    95de:	6823      	ldr	r3, [r4, #0]
    95e0:	429a      	cmp	r2, r3
    95e2:	d001      	beq.n	95e8 <printInt16+0x20>
    95e4:	f7f7 ff9e 	bl	1524 <__stack_chk_fail>
    95e8:	b004      	add	sp, #16
    95ea:	bd10      	pop	{r4, pc}
    95ec:	1fffe9d0 	.word	0x1fffe9d0

000095f0 <int32ToStr>:
{
    95f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    95f2:	4a0f      	ldr	r2, [pc, #60]	; (9630 <int32ToStr+0x40>)
    95f4:	4603      	mov	r3, r0
    95f6:	6810      	ldr	r0, [r2, #0]
    95f8:	9001      	str	r0, [sp, #4]
    95fa:	1e4d      	subs	r5, r1, #1
	pos = 0;
    95fc:	2000      	movs	r0, #0
		out[pos++] = in % 10 + '0';
    95fe:	260a      	movs	r6, #10
    9600:	fbb3 f4f6 	udiv	r4, r3, r6
    9604:	fb06 3314 	mls	r3, r6, r4, r3
    9608:	3330      	adds	r3, #48	; 0x30
    960a:	f805 3f01 	strb.w	r3, [r5, #1]!
    960e:	3001      	adds	r0, #1
	while ( (in /= 10) > 0 );
    9610:	4623      	mov	r3, r4
    9612:	2c00      	cmp	r4, #0
    9614:	d1f4      	bne.n	9600 <int32ToStr+0x10>
	out[pos] = '\0';
    9616:	540c      	strb	r4, [r1, r0]
	revsStr(out);
    9618:	9801      	ldr	r0, [sp, #4]
    961a:	6813      	ldr	r3, [r2, #0]
    961c:	4298      	cmp	r0, r3
    961e:	d001      	beq.n	9624 <int32ToStr+0x34>
    9620:	f7f7 ff80 	bl	1524 <__stack_chk_fail>
    9624:	4608      	mov	r0, r1
}
    9626:	b002      	add	sp, #8
    9628:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	revsStr(out);
    962c:	f7ff bf54 	b.w	94d8 <revsStr>
    9630:	1fffe9d0 	.word	0x1fffe9d0

00009634 <printInt32>:
{
    9634:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    9636:	4c08      	ldr	r4, [pc, #32]	; (9658 <printInt32+0x24>)
	int32ToStr( in, tmpStr );
    9638:	4669      	mov	r1, sp
{
    963a:	6823      	ldr	r3, [r4, #0]
    963c:	9303      	str	r3, [sp, #12]
	int32ToStr( in, tmpStr );
    963e:	f7ff ffd7 	bl	95f0 <int32ToStr>
	dPrintStr( tmpStr );
    9642:	4668      	mov	r0, sp
    9644:	f7fc fb9c 	bl	5d80 <Output_putstr>
}
    9648:	9a03      	ldr	r2, [sp, #12]
    964a:	6823      	ldr	r3, [r4, #0]
    964c:	429a      	cmp	r2, r3
    964e:	d001      	beq.n	9654 <printInt32+0x20>
    9650:	f7f7 ff68 	bl	1524 <__stack_chk_fail>
    9654:	b004      	add	sp, #16
    9656:	bd10      	pop	{r4, pc}
    9658:	1fffe9d0 	.word	0x1fffe9d0

0000965c <hexToStr_op>:
{
    965c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    965e:	4e1c      	ldr	r6, [pc, #112]	; (96d0 <hexToStr_op+0x74>)
    9660:	6834      	ldr	r4, [r6, #0]
    9662:	9401      	str	r4, [sp, #4]
	uint16_t pos = 0;
    9664:	2400      	movs	r4, #0
		uint16_t cur = in % 16;
    9666:	f000 050f 	and.w	r5, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    966a:	2d09      	cmp	r5, #9
    966c:	bf8c      	ite	hi
    966e:	2737      	movhi	r7, #55	; 0x37
    9670:	2730      	movls	r7, #48	; 0x30
    9672:	1c63      	adds	r3, r4, #1
    9674:	443d      	add	r5, r7
	while ( (in /= 16) > 0 );
    9676:	0900      	lsrs	r0, r0, #4
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    9678:	b29b      	uxth	r3, r3
    967a:	550d      	strb	r5, [r1, r4]
	while ( (in /= 16) > 0 );
    967c:	d115      	bne.n	96aa <hexToStr_op+0x4e>
	switch ( op )
    967e:	2a02      	cmp	r2, #2
    9680:	d015      	beq.n	96ae <hexToStr_op+0x52>
    9682:	2a04      	cmp	r2, #4
    9684:	d013      	beq.n	96ae <hexToStr_op+0x52>
    9686:	2a01      	cmp	r2, #1
    9688:	d107      	bne.n	969a <hexToStr_op+0x3e>
		out[pos++] = 'x';
    968a:	2278      	movs	r2, #120	; 0x78
    968c:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    968e:	1ce3      	adds	r3, r4, #3
		out[pos++] = 'x';
    9690:	3402      	adds	r4, #2
		out[pos++] = '0';
    9692:	b2a4      	uxth	r4, r4
    9694:	2230      	movs	r2, #48	; 0x30
    9696:	550a      	strb	r2, [r1, r4]
    9698:	b29b      	uxth	r3, r3
	out[pos] = '\0';
    969a:	2200      	movs	r2, #0
    969c:	54ca      	strb	r2, [r1, r3]
	revsStr(out);
    969e:	9a01      	ldr	r2, [sp, #4]
    96a0:	6833      	ldr	r3, [r6, #0]
    96a2:	429a      	cmp	r2, r3
    96a4:	d00e      	beq.n	96c4 <hexToStr_op+0x68>
    96a6:	f7f7 ff3d 	bl	1524 <__stack_chk_fail>
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    96aa:	461c      	mov	r4, r3
    96ac:	e7db      	b.n	9666 <hexToStr_op+0xa>
    96ae:	1e58      	subs	r0, r3, #1
    96b0:	4408      	add	r0, r1
		while ( pos < op )
    96b2:	b292      	uxth	r2, r2
			out[pos++] = '0';
    96b4:	2430      	movs	r4, #48	; 0x30
		while ( pos < op )
    96b6:	429a      	cmp	r2, r3
    96b8:	d9ef      	bls.n	969a <hexToStr_op+0x3e>
			out[pos++] = '0';
    96ba:	3301      	adds	r3, #1
    96bc:	b29b      	uxth	r3, r3
    96be:	f800 4f01 	strb.w	r4, [r0, #1]!
    96c2:	e7f8      	b.n	96b6 <hexToStr_op+0x5a>
	revsStr(out);
    96c4:	4608      	mov	r0, r1
}
    96c6:	b003      	add	sp, #12
    96c8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	revsStr(out);
    96cc:	f7ff bf04 	b.w	94d8 <revsStr>
    96d0:	1fffe9d0 	.word	0x1fffe9d0

000096d4 <printHex_op>:
{
    96d4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    96d6:	4c09      	ldr	r4, [pc, #36]	; (96fc <printHex_op+0x28>)
	hexToStr_op( in, tmpStr, op );
    96d8:	460a      	mov	r2, r1
{
    96da:	6823      	ldr	r3, [r4, #0]
    96dc:	9303      	str	r3, [sp, #12]
	hexToStr_op( in, tmpStr, op );
    96de:	a901      	add	r1, sp, #4
    96e0:	f7ff ffbc 	bl	965c <hexToStr_op>
	dPrintStr( tmpStr );
    96e4:	a801      	add	r0, sp, #4
    96e6:	f7fc fb4b 	bl	5d80 <Output_putstr>
}
    96ea:	9a03      	ldr	r2, [sp, #12]
    96ec:	6823      	ldr	r3, [r4, #0]
    96ee:	429a      	cmp	r2, r3
    96f0:	d001      	beq.n	96f6 <printHex_op+0x22>
    96f2:	f7f7 ff17 	bl	1524 <__stack_chk_fail>
    96f6:	b004      	add	sp, #16
    96f8:	bd10      	pop	{r4, pc}
    96fa:	bf00      	nop
    96fc:	1fffe9d0 	.word	0x1fffe9d0

00009700 <hex32ToStr_op>:
{
    9700:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9702:	4b1c      	ldr	r3, [pc, #112]	; (9774 <hex32ToStr_op+0x74>)
    9704:	681c      	ldr	r4, [r3, #0]
    9706:	9401      	str	r4, [sp, #4]
    9708:	1e4e      	subs	r6, r1, #1
	uint32_t pos = 0;
    970a:	2400      	movs	r4, #0
    970c:	469c      	mov	ip, r3
		uint32_t cur = in % 16;
    970e:	f000 070f 	and.w	r7, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    9712:	2f09      	cmp	r7, #9
    9714:	bf8c      	ite	hi
    9716:	2537      	movhi	r5, #55	; 0x37
    9718:	2530      	movls	r5, #48	; 0x30
    971a:	443d      	add	r5, r7
	while ( (in /= 16) > 0 );
    971c:	0900      	lsrs	r0, r0, #4
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    971e:	f104 0301 	add.w	r3, r4, #1
    9722:	f806 5f01 	strb.w	r5, [r6, #1]!
	while ( (in /= 16) > 0 );
    9726:	d108      	bne.n	973a <hex32ToStr_op+0x3a>
	switch ( op )
    9728:	1e50      	subs	r0, r2, #1
    972a:	2807      	cmp	r0, #7
    972c:	d813      	bhi.n	9756 <hex32ToStr_op+0x56>
    972e:	e8df f000 	tbb	[pc, r0]
    9732:	060c      	.short	0x060c
    9734:	12120612 	.word	0x12120612
    9738:	0612      	.short	0x0612
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    973a:	461c      	mov	r4, r3
    973c:	e7e7      	b.n	970e <hex32ToStr_op+0xe>
			out[pos++] = '0';
    973e:	2030      	movs	r0, #48	; 0x30
		while ( pos < op )
    9740:	4293      	cmp	r3, r2
    9742:	d208      	bcs.n	9756 <hex32ToStr_op+0x56>
			out[pos++] = '0';
    9744:	54c8      	strb	r0, [r1, r3]
    9746:	3301      	adds	r3, #1
    9748:	e7fa      	b.n	9740 <hex32ToStr_op+0x40>
		out[pos++] = 'x';
    974a:	2278      	movs	r2, #120	; 0x78
    974c:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    974e:	1ce3      	adds	r3, r4, #3
    9750:	440c      	add	r4, r1
    9752:	2230      	movs	r2, #48	; 0x30
    9754:	70a2      	strb	r2, [r4, #2]
	out[pos] = '\0';
    9756:	2200      	movs	r2, #0
    9758:	54ca      	strb	r2, [r1, r3]
	revsStr(out);
    975a:	9a01      	ldr	r2, [sp, #4]
    975c:	f8dc 3000 	ldr.w	r3, [ip]
    9760:	429a      	cmp	r2, r3
    9762:	d001      	beq.n	9768 <hex32ToStr_op+0x68>
    9764:	f7f7 fede 	bl	1524 <__stack_chk_fail>
    9768:	4608      	mov	r0, r1
}
    976a:	b003      	add	sp, #12
    976c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	revsStr(out);
    9770:	f7ff beb2 	b.w	94d8 <revsStr>
    9774:	1fffe9d0 	.word	0x1fffe9d0

00009778 <printHex32_op>:
{
    9778:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    977a:	4c09      	ldr	r4, [pc, #36]	; (97a0 <printHex32_op+0x28>)
	hex32ToStr_op( in, tmpStr, op );
    977c:	460a      	mov	r2, r1
{
    977e:	6823      	ldr	r3, [r4, #0]
    9780:	9303      	str	r3, [sp, #12]
	hex32ToStr_op( in, tmpStr, op );
    9782:	4669      	mov	r1, sp
    9784:	f7ff ffbc 	bl	9700 <hex32ToStr_op>
	dPrintStr( tmpStr );
    9788:	4668      	mov	r0, sp
    978a:	f7fc faf9 	bl	5d80 <Output_putstr>
}
    978e:	9a03      	ldr	r2, [sp, #12]
    9790:	6823      	ldr	r3, [r4, #0]
    9792:	429a      	cmp	r2, r3
    9794:	d001      	beq.n	979a <printHex32_op+0x22>
    9796:	f7f7 fec5 	bl	1524 <__stack_chk_fail>
    979a:	b004      	add	sp, #16
    979c:	bd10      	pop	{r4, pc}
    979e:	bf00      	nop
    97a0:	1fffe9d0 	.word	0x1fffe9d0

000097a4 <hex32ToStr16>:
{
    97a4:	b530      	push	{r4, r5, lr}
    97a6:	4c0e      	ldr	r4, [pc, #56]	; (97e0 <hex32ToStr16+0x3c>)
    97a8:	b085      	sub	sp, #20
    97aa:	6823      	ldr	r3, [r4, #0]
    97ac:	9303      	str	r3, [sp, #12]
    97ae:	460d      	mov	r5, r1
	hex32ToStr_op( in, tmpStr, op );
    97b0:	4669      	mov	r1, sp
    97b2:	f7ff ffa5 	bl	9700 <hex32ToStr_op>
    97b6:	2300      	movs	r3, #0
		if ( tmpStr[byte] == '\0' && out[byte] != 0x0000 )
    97b8:	f81d 2003 	ldrb.w	r2, [sp, r3]
    97bc:	b912      	cbnz	r2, 97c4 <hex32ToStr16+0x20>
    97be:	f835 1013 	ldrh.w	r1, [r5, r3, lsl #1]
    97c2:	b921      	cbnz	r1, 97ce <hex32ToStr16+0x2a>
		out[byte] = tmpStr[byte] | 0x0000;
    97c4:	f825 2013 	strh.w	r2, [r5, r3, lsl #1]
    97c8:	3301      	adds	r3, #1
	for ( uint8_t byte = 0; byte < sizeof( tmpStr ); byte++ )
    97ca:	2b0b      	cmp	r3, #11
    97cc:	d1f4      	bne.n	97b8 <hex32ToStr16+0x14>
}
    97ce:	9a03      	ldr	r2, [sp, #12]
    97d0:	6823      	ldr	r3, [r4, #0]
    97d2:	429a      	cmp	r2, r3
    97d4:	d001      	beq.n	97da <hex32ToStr16+0x36>
    97d6:	f7f7 fea5 	bl	1524 <__stack_chk_fail>
    97da:	b005      	add	sp, #20
    97dc:	bd30      	pop	{r4, r5, pc}
    97de:	bf00      	nop
    97e0:	1fffe9d0 	.word	0x1fffe9d0

000097e4 <eqStr>:


int16_t eqStr( char* str1, char* str2 )
{
    97e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    97e6:	4b0f      	ldr	r3, [pc, #60]	; (9824 <eqStr+0x40>)
    97e8:	681a      	ldr	r2, [r3, #0]
    97ea:	9201      	str	r2, [sp, #4]
    97ec:	4602      	mov	r2, r0
	// Scan each string for NULLs and whether they are the same
	while( *str1 != '\0' && *str1++ == *str2++ );
    97ee:	f810 4b01 	ldrb.w	r4, [r0], #1
    97f2:	b124      	cbz	r4, 97fe <eqStr+0x1a>
    97f4:	f811 5b01 	ldrb.w	r5, [r1], #1
    97f8:	42a5      	cmp	r5, r4
    97fa:	4602      	mov	r2, r0
    97fc:	d0f6      	beq.n	97ec <eqStr+0x8>

	// If the strings are still identical (i.e. both NULL), then return -1, otherwise current *str1
	// If *str1 is 0, then str1 ended (and str1 is "like" str2), otherwise strings are different
	return *--str1 == *--str2 ? -1 : *++str1;
    97fe:	f812 0c01 	ldrb.w	r0, [r2, #-1]
    9802:	f811 1c01 	ldrb.w	r1, [r1, #-1]
    9806:	4288      	cmp	r0, r1
    9808:	bf18      	it	ne
    980a:	7810      	ldrbne	r0, [r2, #0]
}
    980c:	9a01      	ldr	r2, [sp, #4]
    980e:	681b      	ldr	r3, [r3, #0]
	return *--str1 == *--str2 ? -1 : *++str1;
    9810:	bf08      	it	eq
    9812:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
}
    9816:	429a      	cmp	r2, r3
    9818:	d001      	beq.n	981e <eqStr+0x3a>
    981a:	f7f7 fe83 	bl	1524 <__stack_chk_fail>
    981e:	b003      	add	sp, #12
    9820:	bd30      	pop	{r4, r5, pc}
    9822:	bf00      	nop
    9824:	1fffe9d0 	.word	0x1fffe9d0

00009828 <numToInt>:

int numToInt( char* in )
{
    9828:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    982a:	4d25      	ldr	r5, [pc, #148]	; (98c0 <numToInt+0x98>)
    982c:	682b      	ldr	r3, [r5, #0]
    982e:	9301      	str	r3, [sp, #4]
    9830:	4604      	mov	r4, r0
	char* lsd = in;
	char* msd = in;

	int total = 0;
	int sign = 1; // Default to positive
	uint8_t base = 10; // Use base 10 by default TODO Add support for bases other than 10 and 16
    9832:	220a      	movs	r2, #10
	int sign = 1; // Default to positive
    9834:	2601      	movs	r6, #1
    9836:	4621      	mov	r1, r4

	// Scan the string once to determine the length
	while ( *lsd != '\0' )
    9838:	f814 3b01 	ldrb.w	r3, [r4], #1
    983c:	b95b      	cbnz	r3, 9856 <numToInt+0x2e>
			break;
		}
	}

	// Process string depending on which base
	switch ( base )
    983e:	2a0a      	cmp	r2, #10
    9840:	d024      	beq.n	988c <numToInt+0x64>
    9842:	2a10      	cmp	r2, #16
    9844:	d037      	beq.n	98b6 <numToInt+0x8e>
		break;
	}

	// Propagate sign and return
	return total * sign;
}
    9846:	9a01      	ldr	r2, [sp, #4]
    9848:	fb06 f003 	mul.w	r0, r6, r3
    984c:	682b      	ldr	r3, [r5, #0]
    984e:	429a      	cmp	r2, r3
    9850:	d033      	beq.n	98ba <numToInt+0x92>
    9852:	f7f7 fe67 	bl	1524 <__stack_chk_fail>
		switch ( *lsd++ )
    9856:	2b2b      	cmp	r3, #43	; 0x2b
    9858:	4621      	mov	r1, r4
    985a:	d00c      	beq.n	9876 <numToInt+0x4e>
    985c:	d803      	bhi.n	9866 <numToInt+0x3e>
    985e:	2b20      	cmp	r3, #32
    9860:	d009      	beq.n	9876 <numToInt+0x4e>
    9862:	4601      	mov	r1, r0
    9864:	e007      	b.n	9876 <numToInt+0x4e>
    9866:	2b2d      	cmp	r3, #45	; 0x2d
    9868:	d003      	beq.n	9872 <numToInt+0x4a>
    986a:	2b78      	cmp	r3, #120	; 0x78
    986c:	d1f9      	bne.n	9862 <numToInt+0x3a>
			base = 0x10;
    986e:	2210      	movs	r2, #16
			break;
    9870:	e001      	b.n	9876 <numToInt+0x4e>
		case '-': sign = -1;
    9872:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    9876:	4608      	mov	r0, r1
    9878:	e7dd      	b.n	9836 <numToInt+0xe>
			total += ( (*--lsd) - '0' ) * digit;
    987a:	f811 7d01 	ldrb.w	r7, [r1, #-1]!
    987e:	3f30      	subs	r7, #48	; 0x30
    9880:	fb04 3307 	mla	r3, r4, r7, r3
		for ( unsigned int digit = 1; lsd > msd ; digit *= 10 )
    9884:	4354      	muls	r4, r2
    9886:	4281      	cmp	r1, r0
    9888:	d8f7      	bhi.n	987a <numToInt+0x52>
    988a:	e7dc      	b.n	9846 <numToInt+0x1e>
    988c:	2401      	movs	r4, #1
    988e:	e7fa      	b.n	9886 <numToInt+0x5e>
			if    ( *--lsd <= '9' ) total += ( *lsd - '0' ) * digit;
    9890:	f811 2d01 	ldrb.w	r2, [r1, #-1]!
    9894:	2a39      	cmp	r2, #57	; 0x39
    9896:	d806      	bhi.n	98a6 <numToInt+0x7e>
    9898:	3a30      	subs	r2, #48	; 0x30
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    989a:	fb04 3302 	mla	r3, r4, r2, r3
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
    989e:	0124      	lsls	r4, r4, #4
    98a0:	4281      	cmp	r1, r0
    98a2:	d8f5      	bhi.n	9890 <numToInt+0x68>
    98a4:	e7cf      	b.n	9846 <numToInt+0x1e>
			else if ( *lsd <= 'F' ) total += ( *lsd - 'A' + 10 ) * digit;
    98a6:	2a46      	cmp	r2, #70	; 0x46
    98a8:	d801      	bhi.n	98ae <numToInt+0x86>
    98aa:	3a37      	subs	r2, #55	; 0x37
    98ac:	e7f5      	b.n	989a <numToInt+0x72>
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    98ae:	2a66      	cmp	r2, #102	; 0x66
    98b0:	d8f5      	bhi.n	989e <numToInt+0x76>
    98b2:	3a57      	subs	r2, #87	; 0x57
    98b4:	e7f1      	b.n	989a <numToInt+0x72>
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
    98b6:	2401      	movs	r4, #1
    98b8:	e7f2      	b.n	98a0 <numToInt+0x78>
}
    98ba:	b003      	add	sp, #12
    98bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    98be:	bf00      	nop
    98c0:	1fffe9d0 	.word	0x1fffe9d0
    98c4:	66676553 	.word	0x66676553
    98c8:	746c7561 	.word	0x746c7561
    98cc:	000a0d21 	.word	0x000a0d21
    98d0:	20737542 	.word	0x20737542
    98d4:	6c756146 	.word	0x6c756146
    98d8:	53202174 	.word	0x53202174
    98dc:	435f4243 	.word	0x435f4243
    98e0:	3a525346 	.word	0x3a525346
    98e4:	53200020 	.word	0x53200020
    98e8:	425f4243 	.word	0x425f4243
    98ec:	3a524146 	.word	0x3a524146
    98f0:	0020      	.short	0x0020
    98f2:	6146      	.short	0x6146
    98f4:	21746c75 	.word	0x21746c75
    98f8:	0a0d      	.short	0x0a0d
    98fa:	00          	.byte	0x00
    98fb:	48          	.byte	0x48
    98fc:	20647261 	.word	0x20647261
    9900:	6c756146 	.word	0x6c756146
    9904:	53202174 	.word	0x53202174
    9908:	485f4243 	.word	0x485f4243
    990c:	3a525346 	.word	0x3a525346
    9910:	0020      	.short	0x0020
    9912:	654d      	.short	0x654d
    9914:	79726f6d 	.word	0x79726f6d
    9918:	6e614d20 	.word	0x6e614d20
    991c:	72656761 	.word	0x72656761
    9920:	75614620 	.word	0x75614620
    9924:	2021746c 	.word	0x2021746c
    9928:	5f424353 	.word	0x5f424353
    992c:	52534643 	.word	0x52534643
    9930:	2000203a 	.word	0x2000203a
    9934:	5f424353 	.word	0x5f424353
    9938:	52414d4d 	.word	0x52414d4d
    993c:	203a      	.short	0x203a
    993e:	00          	.byte	0x00
    993f:	4e          	.byte	0x4e
    9940:	0d21494d 	.word	0x0d21494d
    9944:	000a      	.short	0x000a

00009946 <sys_reset_to_loader_magic>:
    9946:	00ff 527f 5345 5445 5420 204f 4f4c 4441     ...RESET TO LOAD
    9956:	5245 007f 00ff 7355 6761 2065 6146 6c75     ER....Usage Faul
    9966:	2174 5320 4243 435f 5346 3a52 0020 6157     t! SCB_CFSR: .Wa
    9976:	6374 6468 676f 7420 6d69 6f65 7475 2021     tchdog timeout! 
    9986:	5700 7461 6863 6f64 2067 6552 6573 2074     .Watchdog Reset 
    9996:	6f43 6e75 3a74 0020 3032 382e 3333 6e20     Count: .20.833 n
    99a6:	0073                                        s.

000099a8 <Matrix_cols>:
    99a8:	0001 0101 0201 0301 1001 1101 0402 0502     ................
    99b8:	0003 5b1b 6d31 1b4f 305b 006d 5b1b 3b31     ...[1mO.[0m..[1;
    99c8:	3333 506d 5b1b 6d30 1b00 315b 333b 6d32     33mP.[0m..[1;32m
    99d8:	1b48 305b 006d 5b1b 3b31 3533 526d 5b1b     H.[0m..[1;35mR.[
    99e8:	6d30 1b00 315b 333b 6d31 1b49 305b 006d     0m..[1;31mI.[0m.

000099f8 <Matrix_rows>:
    99f8:	0103 0203 0303 0403 0503 0603 0703 614d     ..............Ma
    9a08:	7274 7869 5241 504d 7265 0069 5b1b 3b31     trixARMPeri..[1;
    9a18:	3b35 3133 456d 5252 524f 5b1b 6d30 2d20     5;31mERROR.[0m -
    9a28:	4d20 7461 6972 2078 6373 6e61 6220 6775      Matrix scan bug
    9a38:	2121 5220 7065 726f 2074 656d 2021 202d     !! Report me! - 
    9a48:	2000 6f43 3a6c 0020 5220 776f 203a 2000     . Col: . Row: . 
    9a58:	654b 3a79 0020 5b1b 6d31 2000 7830 3c00     Key: ..[1m. 0x.<
    9a68:	656b 3e79 3c3a 7270 7665 6f69 7375 7320     key>:<previous s
    9a78:	6174 6574 3c3e 7563 7272 6e65 2074 7473     tate><current st
    9a88:	7461 3e65 3c20 6361 6974 6576 6320 756f     ate> <active cou
    9a98:	746e 203e 693c 616e 7463 7669 2065 6f63     nt> <inactive co
    9aa8:	6e75 3e74 1b00 315b 333b 6d32 4e49 4f46     unt>..[1;32mINFO
    9ab8:	5b1b 6d30 2d20 4420 6265 756f 636e 2065     .[0m - Debounce 
    9ac8:	6954 656d 3a72 0020 736d 1b00 315b 333b     Timer: .ms..[1;3
    9ad8:	6d32 4e49 4f46 5b1b 6d30 2d20 4d20 7461     2mINFO.[0m - Mat
    9ae8:	6972 2078 6544 7562 2067 6f4d 6564 203a     rix Debug Mode: 
    9af8:	1b00 315b 333b 6d32 4e49 4f46 5b1b 6d30     ..[1;32mINFO.[0m
    9b08:	2d20 4320 6c6f 6d75 736e 203a 0020 5b1b      - Columns:  ..[
    9b18:	3b31 3233 496d 464e 1b4f 305b 206d 202d     1;32mINFO.[0m - 
    9b28:	6f52 7377 203a 2020 2020 1b00 315b 333b     Rows:     ..[1;3
    9b38:	6d32 4e49 4f46 5b1b 6d30 2d20 4d20 7861     2mINFO.[0m - Max
    9b48:	4b20 7965 3a73 0020 5b1b 3b31 3233 496d      Keys: ..[1;32mI
    9b58:	464e 1b4f 305b 206d 202d 7453 6f72 6562     NFO.[0m - Strobe
    9b68:	4420 6c65 7961 203a 7500 0073                Delay: .us.

00009b74 <debounceCLIDict_DescEntry>:
    9b74:	6553 2074 6874 2065 6564 6f62 6e75 6563     Set the debounce
    9b84:	7420 6d69 7265 2820 736d 2e29 5520 6573      timer (ms). Use
    9b94:	7566 206c 6f66 2072 6f62 6e75 7963 7320     ful for bouncy s
    9ba4:	6977 6374 6568 2e73 0000 0000               witches.....

00009bb0 <matrixCLIDict>:
    9bb0:	9d57 0000 9b74 0000 1f71 0000 9d60 0000     W...t...q...`...
    9bc0:	9c0f 0000 2035 0000 9d6c 0000 9c95 0000     ....5 ..l.......
    9bd0:	1fd1 0000 9d77 0000 9cbd 0000 1f31 0000     ....w.......1...
    9be0:	9d83 0000 9d8f 0000 20c5 0000 0000 0000     ......... ......
    9bf0:	0000 0000 0000 0000                         ........

00009bf8 <matrixCLIDictName>:
    9bf8:	614d 7274 7869 4d20 646f 6c75 2065 6f43     Matrix Module Co
    9c08:	6d6d 6e61 7364                               mmands.

00009c0f <matrixDebugCLIDict_DescEntry>:
    9c0f:	6e45 6261 656c 2073 616d 7274 7869 6420     Enables matrix d
    9c1f:	6265 6775 6d20 646f 2c65 7020 6972 746e     ebug mode, print
    9c2f:	2073 756f 2074 6165 6863 7320 6163 206e     s out each scan 
    9c3f:	6f63 6564 0d2e 090a 4909 2066 7261 7567     code.....If argu
    9c4f:	656d 746e 1b20 335b 6d35 1b54 305b 206d     ment .[35mT.[0m 
    9c5f:	7369 6720 7669 6e65 202c 7270 6e69 7374     is given, prints
    9c6f:	6f20 7475 6520 6361 2068 6373 6e61 6320      out each scan c
    9c7f:	646f 2065 7473 7461 2065 7274 6e61 6973     ode state transi
    9c8f:	6974 6e6f 002e                              tion..

00009c95 <matrixInfoCLIDict_DescEntry>:
    9c95:	7250 6e69 2074 6e69 6f66 6120 6f62 7475     Print info about
    9ca5:	7420 6568 6320 6e6f 6966 7567 6572 2064      the configured 
    9cb5:	616d 7274 7869 002e                         matrix..

00009cbd <matrixStateCLIDict_DescEntry>:
    9cbd:	7250 6e69 7374 6f20 7475 7420 6568 6320     Prints out the c
    9ccd:	7275 6572 746e 7320 6163 206e 6174 6c62     urrent scan tabl
    9cdd:	2065 204e 6974 656d 2e73 0a0d 0909 1b20     e N times..... .
    9ced:	315b 4f6d 5b1b 6d30 2d20 4f20 6666 202c     [1mO.[0m - Off, 
    9cfd:	5b1b 3b31 3333 506d 5b1b 6d30 2d20 5020     .[1;33mP.[0m - P
    9d0d:	6572 7373 202c 5b1b 3b31 3233 486d 5b1b     ress, .[1;32mH.[
    9d1d:	6d30 2d20 4820 6c6f 2c64 1b20 315b 333b     0m - Hold, .[1;3
    9d2d:	6d35 1b52 305b 206d 202d 6552 656c 7361     5mR.[0m - Releas
    9d3d:	2c65 1b20 315b 333b 6d31 1b49 305b 206d     e, .[1;31mI.[0m 
    9d4d:	202d 6e49 6176 696c 0064 6564 6f62 6e75     - Invalid.deboun
    9d5d:	6563 6d00 7461 6972 4478 6265 6775 6d00     ce.matrixDebug.m
    9d6d:	7461 6972 4978 666e 006f 616d 7274 7869     atrixInfo.matrix
    9d7d:	7453 7461 0065 7473 6f72 6562 6544 616c     State.strobeDela
    9d8d:	0079                                        y.

00009d8f <strobeDelayCLIDict_DescEntry>:
    9d8f:	6553 2074 6874 2065 7473 6f72 6562 6420     Set the strobe d
    9d9f:	6c65 7961 2820 7375 2e29 5520 6573 7566     elay (us). Usefu
    9daf:	206c 6f66 2072 6162 2064 7570 6c6c 7075     l for bad pullup
    9dbf:	7220 7365 7369 6f74 7372 002e                resistors..

00009dcb <echoCLIDict_DescEntry>:
    9dcb:	7845 6d61 6c70 2065 6f63 6d6d 6e61 2c64     Example command,
    9ddb:	6520 6863 736f 7420 6568 6120 6772 6d75      echos the argum
    9deb:	6e65 7374 002e 0000                          ents.....

00009df4 <scanCLIDict>:
    9df4:	9e21 0000 9dcb 0000 27ad 0000 0000 0000     !........'......
    9e04:	0000 0000 0000 0000                         ........

00009e0c <scanCLIDictName>:
    9e0c:	6353 6e61 4d20 646f 6c75 2065 6f43 6d6d     Scan Module Comm
    9e1c:	6e61 7364 6500 6863 006f 614c 6579 5f72     ands.echo.Layer_
    9e2c:	616c 6579 4c72 7461 6863 6c28 7961 7265     layerLatch(layer
    9e3c:	6e49 6564 2978 4c00 7961 7265 6c5f 7961     Index).Layer_lay
    9e4c:	7265 6f4c 6b63 6c28 7961 7265 6e49 6564     erLock(layerInde
    9e5c:	2978 4c00 7961 7265 6c5f 7961 7265 6f52     x).Layer_layerRo
    9e6c:	6174 6574 7028 6572 6976 756f 2973 4c00     tate(previous).L
    9e7c:	7961 7265 6c5f 7961 7265 6853 6669 2874     ayer_layerShift(
    9e8c:	616c 6579 4972 646e 7865 0029 5b1b 3b31     layerIndex)..[1;
    9e9c:	3633 4c6d 5b1b 6d30 0020 3020 4c00 7961     36mL.[0m . 0.Lay
    9eac:	7265 6c5f 7961 7265 7453 7461 2865 616c     er_layerState(la
    9ebc:	6579 4972 646e 7865 6c2c 7961 7265 7453     yerIndex,layerSt
    9ecc:	7461 2965 2000 3e2d 0020 0000               ate). -> ...

00009ed8 <CapabilitiesList>:
    9ed8:	2b65 0000 0102 0000 2bd9 0000 0102 0000     e+.......+......
    9ee8:	2ced 0000 0101 0000 2c51 0000 0102 0000     .,......Q,......
    9ef8:	2aed 0000 0103 0000 2f39 0000 0000 0000     .*......9/......
    9f08:	3c79 0000 0002 0000 380d 0000 0100 0000     y<.......8......
    9f18:	3889 0000 0000 0000 6015 0000 0102 0000     .8.......`......
    9f28:	5abd 0000 0100 0000 6551 0000 0000 0000     .Z......Qe......
    9f38:	65b9 0000 0000 0000 60a9 0000 0100 0000     .e.......`......
    9f48:	60e5 0000 0101 0000 6621 0000 0000 0000     .`......!f......
    9f58:	6179 0000 0101 0000 647d 0000 0102 0000     ya......}d......
    9f68:	63bd 0000 0106 0000                         .c......

00009f70 <LayerIndex>:
    9f70:	e9d8 1fff a8ce 0000 3f00 0000 ead8 1fff     .........?......
    9f80:	ac68 0000 3502 0000 5b1b 3b31 3333 576d     h....5...[1;33mW
    9f90:	5241 494e 474e 5b1b 6d30 2d20 5320 6163     ARNING.[0m - Sca
    9fa0:	436e 646f 2065 7369 6f20 7475 6f20 2066     nCode is out of 
    9fb0:	6172 676e 2f65 6f6e 2074 6564 6966 656e     range/not define
    9fc0:	3a64 0020 5b1b 3b31 3333 576d 5241 494e     d: ..[1;33mWARNI
    9fd0:	474e 5b1b 6d30 2d20 4c20 7961 7265 6e49     NG.[0m - LayerIn
    9fe0:	6564 2078 7369 6f20 7475 6f20 2066 6172     dex is out of ra
    9ff0:	676e 2f65 6f6e 2074 6564 6966 656e 3a64     nge/not defined:
    a000:	0020 614d 7263 5f6f 6f6e 656e 2928 1b00      .Macro_none()..
    a010:	315b 353b 333b 6d31 5245 4f52 1b52 305b     [1;5;31mERROR.[0
    a020:	206d 202d 6e49 6574 6372 6e6f 656e 7463     m - Interconnect
    a030:	5420 6972 6767 7265 4520 6576 746e 5420      Trigger Event T
    a040:	7079 2065 202d 6f4e 2074 6d49 6c70 6d65     ype - Not Implem
    a050:	6e65 6574 2064 1b00 315b 353b 333b 6d31     ented ..[1;5;31m
    a060:	5245 4f52 1b52 305b 206d 202d 614d 7263     ERROR.[0m - Macr
    a070:	206f 7254 6769 6567 2072 7645 6e65 2074     o Trigger Event 
    a080:	764f 7265 6c66 776f 2021 6553 6972 756f     Overflow! Seriou
    a090:	2073 7542 2167 0020 5b1b 3b31 3533 446d     s Bug! ..[1;35mD
    a0a0:	4245 4755 5b1b 6d30 2d20 4d20 6361 6f72     EBUG.[0m - Macro
    a0b0:	5320 6574 0d70 000a 614d 7263 5f6f 6f72      Step...Macro_ro
    a0c0:	6174 6574 2928 5000 7261 6974 6c61 614d     tate().PartialMa
    a0d0:	0070 5055 5500 0052 6f44 656e 5200 7065     p.UP.UR.Done.Rep
    a0e0:	6165 0074 5b1b 3b31 3133 496d 564e 4c41     eat..[1;31mINVAL
    a0f0:	4449 5b1b 6d30 5300 0068 614c 4c00 006f     ID.[0m.Sh.La.Lo.
    a100:	7753 4c00 4445 4100 006e 614c 6579 0072     Sw.LED.An.Layer.
    a110:	6e41 6d69 7461 6f69 006e 6c53 6565 0070     Animation.Sleep.
    a120:	6552 7573 656d 4900 616e 7463 7669 0065     Resume.Inactive.
    a130:	6341 6974 6576 5200 746f 7461 6f69 006e     Active.Rotation.
    a140:	4e49 4156 494c 0044 614d 7263 5f6f 6574     INVALID.Macro_te
    a150:	7473 6854 6572 6461 6153 6566 2928 5400     stThreadSafe().T
    a160:	7268 6165 5364 6661 3a65 0020 614d 7263     hreadSafe: .Macr
    a170:	5f6f 6574 7473 6854 6572 6461 6e55 6173     o_testThreadUnsa
    a180:	6566 2928 5400 7268 6165 5564 736e 6661     fe().ThreadUnsaf
    a190:	3a65 0020 5b1b 3b31 3333 576d 5241 494e     e: ..[1;33mWARNI
    a1a0:	474e 5b1b 6d30 2d20 4920 766e 6c61 6469     NG.[0m - Invalid
    a1b0:	7420 6d69 2065 7473 7461 2065 7274 6769      time state trig
    a1c0:	6567 2072 7075 6164 6574 203a 1b00 315b     ger update: ..[1
    a1d0:	333b 6d33 4157 4e52 4e49 1b47 305b 206d     ;33mWARNING.[0m 
    a1e0:	202d 6e4f 796c 3220 3535 7420 6d69 2065     - Only 255 time 
    a1f0:	6e69 7473 6e61 6563 2073 7261 2065 6361     instances are ac
    a200:	6563 7470 6465 6620 726f 6120 7420 6d69     cepted for a tim
    a210:	2065 7473 7461 2065 7274 6769 6567 3a72     e state trigger:
    a220:	0020 0000                                    ...

0000a224 <ResultMacroList>:
    a224:	b9e2 0000 ba0f 0000 ba3c 0000 ba69 0000     ........<...i...
    a234:	ba96 0000 bac2 0000 baee 0000 bb1a 0000     ................
    a244:	bb46 0000 bb5b 0000 b9e7 0000 b9eb 0000     F...[...........
    a254:	b9ef 0000 b9f3 0000 b9f7 0000 b9fb 0000     ................
    a264:	b9ff 0000 ba03 0000 ba07 0000 ba0b 0000     ................
    a274:	ba14 0000 ba18 0000 ba1c 0000 ba20 0000     ............ ...
    a284:	ba24 0000 ba28 0000 ba2c 0000 ba30 0000     $...(...,...0...
    a294:	ba34 0000 ba38 0000 ba41 0000 ba45 0000     4...8...A...E...
    a2a4:	ba49 0000 ba4d 0000 ba51 0000 ba55 0000     I...M...Q...U...
    a2b4:	ba59 0000 ba5d 0000 ba61 0000 ba65 0000     Y...]...a...e...
    a2c4:	ba6e 0000 ba72 0000 ba76 0000 ba7a 0000     n...r...v...z...
    a2d4:	ba7e 0000 ba82 0000 ba86 0000 ba8a 0000     ~...............
    a2e4:	ba8e 0000 ba92 0000 ba9a 0000 ba9e 0000     ................
    a2f4:	baa2 0000 baa6 0000 baaa 0000 baae 0000     ................
    a304:	bab2 0000 bab6 0000 baba 0000 babe 0000     ................
    a314:	bac6 0000 baca 0000 bace 0000 bad2 0000     ................
    a324:	bad6 0000 bada 0000 bade 0000 bae2 0000     ................
    a334:	bae6 0000 baea 0000 baf2 0000 baf6 0000     ................
    a344:	bafa 0000 bafe 0000 bb02 0000 bb06 0000     ................
    a354:	bb0a 0000 bb0e 0000 bb12 0000 bb16 0000     ................
    a364:	bb1e 0000 bb22 0000 bb26 0000 bb2a 0000     ...."...&...*...
    a374:	bb2e 0000 bb32 0000 bb36 0000 bb3a 0000     ....2...6...:...
    a384:	bb3e 0000 bb42 0000 bb4a 0000 bb4e 0000     >...B...J...N...
    a394:	bb51 0000 bb56 0000                         Q...V...

0000a39c <TriggerMacroList>:
    a39c:	bbfb 0000 0029 0000 bc32 0000 001e 0000     ....)...2.......
    a3ac:	bc32 0000 0038 0000 bc69 0000 001f 0000     2...8...i.......
    a3bc:	bc69 0000 0039 0000 bca0 0000 0020 0000     i...9....... ...
    a3cc:	bca0 0000 003a 0000 bcd7 0000 0021 0000     ....:.......!...
    a3dc:	bcd7 0000 003b 0000 bd0e 0000 0022 0000     ....;......."...
    a3ec:	bd0e 0000 003c 0000 bd18 0000 0023 0000     ....<.......#...
    a3fc:	bd18 0000 003d 0000 bd1d 0000 0024 0000     ....=.......$...
    a40c:	bd1d 0000 003e 0000 bd22 0000 0025 0000     ....>..."...%...
    a41c:	bd22 0000 003f 0000 bd27 0000 0026 0000     "...?...'...&...
    a42c:	bd27 0000 0040 0000 bc00 0000 0027 0000     '...@.......'...
    a43c:	bc00 0000 0041 0000 bc05 0000 002d 0000     ....A.......-...
    a44c:	bc05 0000 0042 0000 bc0a 0000 002e 0000     ....B...........
    a45c:	bc0a 0000 0043 0000 bc0f 0000 002a 0000     ....C.......*...
    a46c:	bc14 0000 002b 0000 bc14 0000 0037 0000     ....+.......7...
    a47c:	bc19 0000 0014 0000 bc1e 0000 001a 0000     ................
    a48c:	bc1e 0000 005b 0000 bc23 0000 0008 0000     ....[...#.......
    a49c:	bc28 0000 0015 0000 bc2d 0000 0017 0000     (.......-.......
    a4ac:	bc37 0000 001c 0000 bc3c 0000 0018 0000     7.......<.......
    a4bc:	bc41 0000 000c 0000 bc41 0000 0044 0000     A.......A...D...
    a4cc:	bc46 0000 0012 0000 bc46 0000 0045 0000     F.......F...E...
    a4dc:	bc4b 0000 0013 0000 bc4b 0000 0046 0000     K.......K...F...
    a4ec:	bc50 0000 002f 0000 bc50 0000 004f 0000     P.../...P...O...
    a4fc:	bc55 0000 0030 0000 bc5a 0000 0031 0000     U...0...Z...1...
    a50c:	bc5a 0000 0047 0000 bc5f 0000 0037 0000     Z...G..._...7...
    a51c:	bc64 0000 0004 0000 bc64 0000 0003 0000     d.......d.......
    a52c:	bc6e 0000 0016 0000 bc6e 0000 0002 0000     n.......n.......
    a53c:	bc73 0000 0007 0000 bc73 0000 0001 0000     s.......s.......
    a54c:	bc78 0000 0009 0000 bc78 0000 0000 0000     x.......x.......
    a55c:	bc7d 0000 000a 0000 bc82 0000 000b 0000     }...............
    a56c:	bc82 0000 0051 0000 bc87 0000 000d 0000     ....Q...........
    a57c:	bc87 0000 0050 0000 bc8c 0000 000e 0000     ....P...........
    a58c:	bc8c 0000 0048 0000 bc91 0000 000f 0000     ....H...........
    a59c:	bc91 0000 0049 0000 bc96 0000 0032 0000     ....I.......2...
    a5ac:	bc96 0000 004d 0000 bc9b 0000 0033 0000     ....M.......3...
    a5bc:	bc9b 0000 004c 0000 bca5 0000 0028 0000     ....L.......(...
    a5cc:	bcaa 0000 0055 0000 bcaf 0000 001d 0000     ....U...........
    a5dc:	bcb4 0000 001b 0000 bcb9 0000 0006 0000     ................
    a5ec:	bcbe 0000 0019 0000 bcc3 0000 0005 0000     ................
    a5fc:	bcc8 0000 0011 0000 bcc8 0000 0053 0000     ............S...
    a60c:	bccd 0000 0010 0000 bccd 0000 0052 0000     ............R...
    a61c:	bcd2 0000 0034 0000 bcd2 0000 004a 0000     ....4.......J...
    a62c:	bcdc 0000 0035 0000 bcdc 0000 004b 0000     ....5.......K...
    a63c:	bce1 0000 0036 0000 bce1 0000 004e 0000     ....6.......N...
    a64c:	bce6 0000 0059 0000 bceb 0000 0054 0000     ....Y.......T...
    a65c:	bcf0 0000 0056 0000 bcf5 0000 0057 0000     ....V.......W...
    a66c:	bcfa 0000 002c 0000 bcff 0000 005a 0000     ....,.......Z...
    a67c:	bd04 0000 005c 0000 bd09 0000 005d 0000     ....\.......]...
    a68c:	bd13 0000 0058 0000                         ....X...

0000a694 <capDebugCLIDict_DescEntry>:
    a694:	7250 6e69 7374 6320 7061 6261 6c69 7469     Prints capabilit
    a6a4:	2079 6564 7562 2067 656d 7373 6761 2065     y debug message 
    a6b4:	6562 6f66 6572 6320 6c61 696c 676e 202c     before calling, 
    a6c4:	6977 6874 7420 6972 6767 7265 6320 6e6f     with trigger con
    a6d4:	6964 6974 6e6f 2e73                          ditions..

0000a6dd <capListCLIDict_DescEntry>:
    a6dd:	7250 6e69 7374 6120 206e 6e69 6564 6578     Prints an indexe
    a6ed:	2064 696c 7473 6f20 2066 6c61 206c 6f6e     d list of all no
    a6fd:	206e 5355 2042 656b 6379 646f 2065 6163     n USB keycode ca
    a70d:	6170 6962 696c 6974 7365 002e               pabilities..

0000a719 <capSelectCLIDict_DescEntry>:
    a719:	7254 6769 6567 7372 7420 6568 7320 6570     Triggers the spe
    a729:	6963 6966 6465 6320 7061 6261 6c69 7469     cified capabilit
    a739:	6569 2e73 4620 7269 7473 7420 6f77 6120     ies. First two a
    a749:	6772 2073 7261 2065 7473 7461 2065 6e61     rgs are state an
    a759:	2064 7473 7461 5465 7079 2e65 0a0d 0909     d stateType.....
    a769:	5b1b 3533 4b6d 3131 5b1b 6d30 4b20 7965     .[35mK11.[0m Key
    a779:	6f62 7261 2064 6143 6170 6962 696c 7974     board Capability
    a789:	3020 3078 0042 5b1b 3b31 3233 496d 464e      0x0B..[1;32mINF
    a799:	1b4f 305b 206d 202d 6143 6170 6962 696c     O.[0m - Capabili
    a7a9:	7974 4420 6265 6775 4d20 646f 3a65 0020     ty Debug Mode: .
    a7b9:	5b1b 3b31 3233 496d 464e 1b4f 305b 206d     .[1;32mINFO.[0m 
    a7c9:	202d 6143 6170 6962 696c 6974 7365 4c20     - Capabilities L
    a7d9:	7369 2074 0d00 090a 1b00 315b 333b 6d32     ist ......[1;32m
    a7e9:	4e49 4f46 5b1b 6d30 2d20 4b20 1b00 315b     INFO.[0m - K..[1
    a7f9:	333b 6d33 4157 4e52 4e49 1b47 305b 206d     ;33mWARNING.[0m 
    a809:	202d 6c66 7361 4d68 646f 4565 616e 6c62     - flashModeEnabl
    a819:	6465 6e20 746f 7320 7465 202c 6163 636e     ed not set, canc
    a829:	6c65 696c 676e 6620 7269 776d 7261 2065     elling firmware 
    a839:	6572 6f6c 6461 2e2e 0d2e 000a 5b1b 3b31     reload.......[1;
    a849:	3233 496d 464e 1b4f 305b 206d 202d 6553     32mINFO.[0m - Se
    a859:	2074 6c66 7361 4d68 646f 4565 616e 6c62     t flashModeEnabl
    a869:	6465 7420 206f 2031 6e69 7920 756f 2072     ed to 1 in your 
    a879:	6c6b 206c 6f63 666e 6769 7275 7461 6f69     kll configuratio
    a889:	2e6e 1b00 315b 333b 6d32 4e49 4f46 5b1b     n...[1;32mINFO.[
    a899:	6d30 2d20 4c20 7961 7265 4420 6265 6775     0m - Layer Debug
    a8a9:	4d20 646f 3a65 0020 5b1b 3b31 3233 496d      Mode: ..[1;32mI
    a8b9:	464e 1b4f 305b 206d 202d 614c 6579 2072     NFO.[0m - Layer 
    a8c9:	694c 7473 4400 203a 6564 5f76 656b 6279     List.D: dev_keyb
    a8d9:	616f 6472 755f 6974 696c 6974 7365 655f     oard_utilities_e
    a8e9:	6772 646f 786f 635f 6e6f 7274 6c6f 656c     rgodox_controlle
    a8f9:	5f72 6353 6e61 445f 7665 6369 7365 4d5f     r_Scan_Devices_M
    a909:	7461 6972 4178 4d52 6550 6972 646f 6369     atrixARMPeriodic
    a919:	5b40 6327 7061 6261 6c69 7469 6569 2773     @['capabilities'
    a929:	5f5d 7270 636f 7365 6573 2e64 6c6b 206c     ]_processed.kll 
    a939:	202b 6564 5f76 656b 6279 616f 6472 755f     + dev_keyboard_u
    a949:	6974 696c 6974 7365 655f 6772 646f 786f     tilities_ergodox
    a959:	635f 6e6f 7274 6c6f 656c 5f72 614d 7263     _controller_Macr
    a969:	5f6f 6150 7472 6169 4d6c 7061 5b40 6327     o_PartialMap@['c
    a979:	7061 6261 6c69 7469 6569 2773 5f5d 7270     apabilities']_pr
    a989:	636f 7365 6573 2e64 6c6b 206c 202b 6564     ocessed.kll + de
    a999:	5f76 656b 6279 616f 6472 755f 6974 696c     v_keyboard_utili
    a9a9:	6974 7365 655f 6772 646f 786f 635f 6e6f     ties_ergodox_con
    a9b9:	7274 6c6f 656c 5f72 754f 7074 7475 485f     troller_Output_H
    a9c9:	4449 492d 404f 275b 6163 6170 6962 696c     ID-IO@['capabili
    a9d9:	6974 7365 5d27 705f 6f72 6563 7373 6465     ties']_processed
    a9e9:	6b2e 6c6c 2b20 6420 7665 6b5f 7965 6f62     .kll + dev_keybo
    a9f9:	7261 5f64 7475 6c69 7469 6569 5f73 7265     ard_utilities_er
    aa09:	6f67 6f64 5f78 6f63 746e 6f72 6c6c 7265     godox_controller
    aa19:	4f5f 7475 7570 5f74 5355 4042 275b 6163     _Output_USB@['ca
    aa29:	6170 6962 696c 6974 7365 5d27 705f 6f72     pabilities']_pro
    aa39:	6563 7373 6465 6b2e 6c6c 2b20 6420 7665     cessed.kll + dev
    aa49:	6b5f 7965 6f62 7261 5f64 7475 6c69 7469     _keyboard_utilit
    aa59:	6569 5f73 7265 6f67 6f64 5f78 6f63 746e     ies_ergodox_cont
    aa69:	6f72 6c6c 7265 445f 6265 6775 6c5f 7461     roller_Debug_lat
    aa79:	6e65 7963 5b40 6327 7061 6261 6c69 7469     ency@['capabilit
    aa89:	6569 2773 5f5d 7270 636f 7365 6573 2e64     ies']_processed.
    aa99:	6c6b 206c 202b 6564 5f76 656b 6279 616f     kll + dev_keyboa
    aaa9:	6472 755f 6974 696c 6974 7365 655f 6772     rd_utilities_erg
    aab9:	646f 786f 635f 6e6f 7274 6c6f 656c 5f72     odox_controller_
    aac9:	6544 7562 5f67 656c 4064 275b 6163 6170     Debug_led@['capa
    aad9:	6962 696c 6974 7365 5d27 705f 6f72 6563     bilities']_proce
    aae9:	7373 6465 6b2e 6c6c 2b20 6420 7665 6b5f     ssed.kll + dev_k
    aaf9:	7965 6f62 7261 5f64 7475 6c69 7469 6569     eyboard_utilitie
    ab09:	5f73 7265 6f67 6f64 5f78 6f63 746e 6f72     s_ergodox_contro
    ab19:	6c6c 7265 535f 6163 5f6e 6e49 6966 696e     ller_Scan_Infini
    ab29:	7974 365f 4030 275b 6373 6e61 6f63 6564     ty_60@['scancode
    ab39:	6d5f 7061 5d27 705f 6f72 6563 7373 6465     _map']_processed
    ab49:	6b2e 6c6c 2b20 6420 7665 6b5f 7965 6f62     .kll + dev_keybo
    ab59:	7261 5f64 7475 6c69 7469 6569 5f73 7265     ard_utilities_er
    ab69:	6f67 6f64 5f78 6f63 746e 6f72 6c6c 7265     godox_controller
    ab79:	535f 6163 5f6e 6e49 6966 696e 7974 365f     _Scan_Infinity_6
    ab89:	4030 275b 6373 6e61 6f63 6564 6d5f 7061     0@['scancode_map
    ab99:	2c27 2720 6c61 6870 6261 7465 5d27 705f     ', 'alphabet']_p
    aba9:	6f72 6563 7373 6465 6b2e 6c6c 2b20 2e20     rocessed.kll + .
    abb9:	6f6c 6163 5f6c 6873 7261 5f65 6976 7472     local_share_virt
    abc9:	6175 656c 766e 5f73 654b 6279 616f 6472     ualenvs_Keyboard
    abd9:	2d73 6476 5378 3549 4164 6c5f 6269 705f     s-vdxSI5dA_lib_p
    abe9:	7479 6f68 336e 372e 735f 7469 2d65 6170     ython3.7_site-pa
    abf9:	6b63 6761 7365 6b5f 6c6c 6c5f 7961 756f     ckages_kll_layou
    ac09:	7374 5b40 7327 6474 7546 636e 614d 2770     ts@['stdFuncMap'
    ac19:	5f5d 7270 636f 7365 6573 2e64 6c6b 006c     ]_processed.kll.
    ac29:	1b20 315b 286d 6564 6166 6c75 2974 5b1b      .[1m(default).[
    ac39:	6d30 0d00 090a 2009 614c 6579 2072 7453     0m..... Layer St
    ac49:	7461 3a65 0020 4620 7269 7473 2d20 203e     ate: . First -> 
    ac59:	614c 7473 4920 646e 6369 7365 203a 3100     Last Indices: .1
    ac69:	203a 6564 5f76 656b 6279 616f 6472 755f     : dev_keyboard_u
    ac79:	6974 696c 6974 7365 655f 6772 646f 786f     tilities_ergodox
    ac89:	635f 6e6f 7274 6c6f 656c 5f72 6353 6e61     _controller_Scan
    ac99:	445f 7665 6369 7365 4d5f 7461 6972 4178     _Devices_MatrixA
    aca9:	4d52 6550 6972 646f 6369 5b40 6327 7061     RMPeriodic@['cap
    acb9:	6261 6c69 7469 6569 2773 5f5d 7270 636f     abilities']_proc
    acc9:	7365 6573 2e64 6c6b 206c 202b 6564 5f76     essed.kll + dev_
    acd9:	656b 6279 616f 6472 755f 6974 696c 6974     keyboard_utiliti
    ace9:	7365 655f 6772 646f 786f 635f 6e6f 7274     es_ergodox_contr
    acf9:	6c6f 656c 5f72 614d 7263 5f6f 6150 7472     oller_Macro_Part
    ad09:	6169 4d6c 7061 5b40 6327 7061 6261 6c69     ialMap@['capabil
    ad19:	7469 6569 2773 5f5d 7270 636f 7365 6573     ities']_processe
    ad29:	2e64 6c6b 206c 202b 6564 5f76 656b 6279     d.kll + dev_keyb
    ad39:	616f 6472 755f 6974 696c 6974 7365 655f     oard_utilities_e
    ad49:	6772 646f 786f 635f 6e6f 7274 6c6f 656c     rgodox_controlle
    ad59:	5f72 754f 7074 7475 485f 4449 492d 404f     r_Output_HID-IO@
    ad69:	275b 6163 6170 6962 696c 6974 7365 5d27     ['capabilities']
    ad79:	705f 6f72 6563 7373 6465 6b2e 6c6c 2b20     _processed.kll +
    ad89:	6420 7665 6b5f 7965 6f62 7261 5f64 7475      dev_keyboard_ut
    ad99:	6c69 7469 6569 5f73 7265 6f67 6f64 5f78     ilities_ergodox_
    ada9:	6f63 746e 6f72 6c6c 7265 4f5f 7475 7570     controller_Outpu
    adb9:	5f74 5355 4042 275b 6163 6170 6962 696c     t_USB@['capabili
    adc9:	6974 7365 5d27 705f 6f72 6563 7373 6465     ties']_processed
    add9:	6b2e 6c6c 2b20 6420 7665 6b5f 7965 6f62     .kll + dev_keybo
    ade9:	7261 5f64 7475 6c69 7469 6569 5f73 7265     ard_utilities_er
    adf9:	6f67 6f64 5f78 6f63 746e 6f72 6c6c 7265     godox_controller
    ae09:	445f 6265 6775 6c5f 7461 6e65 7963 5b40     _Debug_latency@[
    ae19:	6327 7061 6261 6c69 7469 6569 2773 5f5d     'capabilities']_
    ae29:	7270 636f 7365 6573 2e64 6c6b 206c 202b     processed.kll + 
    ae39:	6564 5f76 656b 6279 616f 6472 755f 6974     dev_keyboard_uti
    ae49:	696c 6974 7365 655f 6772 646f 786f 635f     lities_ergodox_c
    ae59:	6e6f 7274 6c6f 656c 5f72 6544 7562 5f67     ontroller_Debug_
    ae69:	656c 4064 275b 6163 6170 6962 696c 6974     led@['capabiliti
    ae79:	7365 5d27 705f 6f72 6563 7373 6465 6b2e     es']_processed.k
    ae89:	6c6c 2b20 6420 7665 6b5f 7965 6f62 7261     ll + dev_keyboar
    ae99:	5f64 7475 6c69 7469 6569 5f73 7265 6f67     d_utilities_ergo
    aea9:	6f64 5f78 6f63 746e 6f72 6c6c 7265 535f     dox_controller_S
    aeb9:	6163 5f6e 6e49 6966 696e 7974 365f 4030     can_Infinity_60@
    aec9:	275b 6373 6e61 6f63 6564 6d5f 7061 5d27     ['scancode_map']
    aed9:	705f 6f72 6563 7373 6465 6b2e 6c6c 2b20     _processed.kll +
    aee9:	6420 7665 6b5f 7965 6f62 7261 5f64 7475      dev_keyboard_ut
    aef9:	6c69 7469 6569 5f73 7265 6f67 6f64 5f78     ilities_ergodox_
    af09:	6f63 746e 6f72 6c6c 7265 535f 6163 5f6e     controller_Scan_
    af19:	6e49 6966 696e 7974 365f 4030 275b 6373     Infinity_60@['sc
    af29:	6e61 6f63 6564 6d5f 7061 2c27 2720 6c61     ancode_map', 'al
    af39:	6870 6261 7465 5d27 705f 6f72 6563 7373     phabet']_process
    af49:	6465 6b2e 6c6c 2b20 2e20 6f6c 6163 5f6c     ed.kll + .local_
    af59:	6873 7261 5f65 6976 7472 6175 656c 766e     share_virtualenv
    af69:	5f73 654b 6279 616f 6472 2d73 6476 5378     s_Keyboards-vdxS
    af79:	3549 4164 6c5f 6269 705f 7479 6f68 336e     I5dA_lib_python3
    af89:	372e 735f 7469 2d65 6170 6b63 6761 7365     .7_site-packages
    af99:	6b5f 6c6c 6c5f 7961 756f 7374 695f 3663     _kll_layouts_ic6
    afa9:	4030 275b 6868 626b 7270 326f 5d27 705f     0@['hhkbpro2']_p
    afb9:	6f72 6563 7373 6465 6b2e 6c6c 1b00 315b     rocessed.kll..[1
    afc9:	333b 6d32 4e49 4f46 5b1b 6d30 2d20 5320     ;32mINFO.[0m - S
    afd9:	7465 6974 676e 4c20 7961 7265 4c20 2000     etting Layer L. 
    afe9:	6f74 2d20 0020 5b1b 3b31 3233 496d 464e     to - ..[1;32mINF
    aff9:	1b4f 305b 206d 202d 614d 7263 206f 6544     O.[0m - Macro De
    b009:	7562 2067 6f4d 6564 203a 1b00 315b 333b     bug Mode: ..[1;3
    b019:	6d32 4e49 4f46 5b1b 6d30 2d20 5020 6e65     2mINFO.[0m - Pen
    b029:	6964 676e 4b20 7965 4520 6576 746e 3a73     ding Key Events:
    b039:	0020 3a20 0020 5b1b 3b31 3233 496d 464e      . : ..[1;32mINF
    b049:	1b4f 305b 206d 202d 6550 646e 6e69 2067     O.[0m - Pending 
    b059:	7254 6769 6567 2072 614d 7263 736f 203a     Trigger Macros: 
    b069:	1b00 315b 333b 6d32 4e49 4f46 5b1b 6d30     ..[1;32mINFO.[0m
    b079:	2d20 5020 6e65 6964 676e 5220 7365 6c75      - Pending Resul
    b089:	2074 614d 7263 736f 203a 1b00 315b 333b     t Macros: ..[1;3
    b099:	6d32 4e49 4f46 5b1b 6d30 2d20 5420 6972     2mINFO.[0m - Tri
    b0a9:	6767 7265 4d20 6361 6f72 2073 6152 676e     gger Macros Rang
    b0b9:	3a65 5420 2030 3e2d 5420 1b00 315b 333b     e: T0 -> T..[1;3
    b0c9:	6d32 4e49 4f46 5b1b 6d30 2d20 5220 7365     2mINFO.[0m - Res
    b0d9:	6c75 2074 4d20 6361 6f72 2073 6152 676e     ult  Macros Rang
    b0e9:	3a65 5220 2030 3e2d 5220 1b00 315b 333b     e: R0 -> R..[1;3
    b0f9:	6d32 4e49 4f46 5b1b 6d30 2d20 5420 6972     2mINFO.[0m - Tri
    b109:	6767 7265 3a20 5220 7365 6c75 2074 614d     gger : Result Ma
    b119:	7263 206f 6150 7269 0073 5409 2000 203a     cro Pairs..T. : 
    b129:	0052 5b1b 3b31 3233 496d 464e 1b4f 305b     R..[1;32mINFO.[0
    b139:	206d 202d 614d 7263 206f 7250 636f 7365     m - Macro Proces
    b149:	6973 676e 4d20 646f 3a65 0020 5b1b 3b31     sing Mode: ..[1;
    b159:	3233 496d 464e 1b4f 305b 206d 202d 6f56     32mINFO.[0m - Vo
    b169:	6574 4420 6265 6775 4d20 646f 3a65 0020     te Debug Mode: .
    b179:	0000                                         ...

0000b17c <default_tl_0x00>:
    b17c:	0000 0000                                   ....

0000b180 <default_tl_0x01>:
    b180:	0001 0000 0000 0000                         ........

0000b188 <default_tl_0x02>:
    b188:	0001 0000 0001 0000                         ........

0000b190 <default_tl_0x03>:
    b190:	0001 0000 0003 0000                         ........

0000b198 <default_tl_0x04>:
    b198:	0001 0000 0005 0000                         ........

0000b1a0 <default_tl_0x05>:
    b1a0:	0001 0000 0007 0000                         ........

0000b1a8 <default_tl_0x06>:
    b1a8:	0001 0000 0009 0000                         ........

0000b1b0 <default_tl_0x07>:
    b1b0:	0001 0000 000b 0000                         ........

0000b1b8 <default_tl_0x08>:
    b1b8:	0001 0000 000d 0000                         ........

0000b1c0 <default_tl_0x09>:
    b1c0:	0001 0000 000f 0000                         ........

0000b1c8 <default_tl_0x0A>:
    b1c8:	0001 0000 0011 0000                         ........

0000b1d0 <default_tl_0x0B>:
    b1d0:	0001 0000 0013 0000                         ........

0000b1d8 <default_tl_0x0C>:
    b1d8:	0001 0000 0015 0000                         ........

0000b1e0 <default_tl_0x0D>:
    b1e0:	0001 0000 0017 0000                         ........

0000b1e8 <default_tl_0x0E>:
    b1e8:	0001 0000 0019 0000                         ........

0000b1f0 <default_tl_0x0F>:
    b1f0:	0000 0000                                   ....

0000b1f4 <default_tl_0x10>:
    b1f4:	0001 0000 001a 0000                         ........

0000b1fc <default_tl_0x11>:
    b1fc:	0001 0000 001c 0000                         ........

0000b204 <default_tl_0x12>:
    b204:	0001 0000 001d 0000                         ........

0000b20c <default_tl_0x13>:
    b20c:	0001 0000 001f 0000                         ........

0000b214 <default_tl_0x14>:
    b214:	0001 0000 0020 0000                         .... ...

0000b21c <default_tl_0x15>:
    b21c:	0001 0000 0021 0000                         ....!...

0000b224 <default_tl_0x16>:
    b224:	0001 0000 0022 0000                         ...."...

0000b22c <default_tl_0x17>:
    b22c:	0001 0000 0023 0000                         ....#...

0000b234 <default_tl_0x18>:
    b234:	0001 0000 0024 0000                         ....$...

0000b23c <default_tl_0x19>:
    b23c:	0001 0000 0026 0000                         ....&...

0000b244 <default_tl_0x1A>:
    b244:	0001 0000 0028 0000                         ....(...

0000b24c <default_tl_0x1B>:
    b24c:	0001 0000 002a 0000                         ....*...

0000b254 <default_tl_0x1C>:
    b254:	0001 0000 002c 0000                         ....,...

0000b25c <default_tl_0x1D>:
    b25c:	0001 0000 002d 0000                         ....-...

0000b264 <default_tl_0x1E>:
    b264:	0001 0000 002f 0000                         ..../...

0000b26c <default_tl_0x1F>:
    b26c:	0001 0000 0030 0000                         ....0...

0000b274 <default_tl_0x20>:
    b274:	0001 0000 0032 0000                         ....2...

0000b27c <default_tl_0x21>:
    b27c:	0001 0000 0034 0000                         ....4...

0000b284 <default_tl_0x22>:
    b284:	0001 0000 0036 0000                         ....6...

0000b28c <default_tl_0x23>:
    b28c:	0001 0000 0038 0000                         ....8...

0000b294 <default_tl_0x24>:
    b294:	0001 0000 0039 0000                         ....9...

0000b29c <default_tl_0x25>:
    b29c:	0001 0000 003b 0000                         ....;...

0000b2a4 <default_tl_0x26>:
    b2a4:	0001 0000 003d 0000                         ....=...

0000b2ac <default_tl_0x27>:
    b2ac:	0001 0000 003f 0000                         ....?...

0000b2b4 <default_tl_0x28>:
    b2b4:	0001 0000 0041 0000                         ....A...

0000b2bc <default_tl_0x29>:
    b2bc:	0001 0000 0043 0000                         ....C...

0000b2c4 <default_tl_0x2A>:
    b2c4:	0001 0000 0045 0000                         ....E...

0000b2cc <default_tl_0x2B>:
    b2cc:	0001 0000 0046 0000                         ....F...

0000b2d4 <default_tl_0x2C>:
    b2d4:	0001 0000 0047 0000                         ....G...

0000b2dc <default_tl_0x2D>:
    b2dc:	0001 0000 0048 0000                         ....H...

0000b2e4 <default_tl_0x2E>:
    b2e4:	0001 0000 0049 0000                         ....I...

0000b2ec <default_tl_0x2F>:
    b2ec:	0001 0000 004a 0000                         ....J...

0000b2f4 <default_tl_0x30>:
    b2f4:	0001 0000 004b 0000                         ....K...

0000b2fc <default_tl_0x31>:
    b2fc:	0001 0000 004c 0000                         ....L...

0000b304 <default_tl_0x32>:
    b304:	0001 0000 004e 0000                         ....N...

0000b30c <default_tl_0x33>:
    b30c:	0001 0000 0050 0000                         ....P...

0000b314 <default_tl_0x34>:
    b314:	0001 0000 0052 0000                         ....R...

0000b31c <default_tl_0x35>:
    b31c:	0001 0000 0054 0000                         ....T...

0000b324 <default_tl_0x36>:
    b324:	0001 0000 0056 0000                         ....V...

0000b32c <default_tl_0x37>:
    b32c:	0000 0000                                   ....

0000b330 <default_tl_0x38>:
    b330:	0001 0000 0057 0000                         ....W...

0000b338 <default_tl_0x39>:
    b338:	0001 0000 0058 0000                         ....X...

0000b340 <default_tl_0x3A>:
    b340:	0001 0000 0059 0000                         ....Y...

0000b348 <default_tl_0x3B>:
    b348:	0001 0000 005a 0000                         ....Z...

0000b350 <default_tl_0x3C>:
    b350:	0001 0000 005b 0000                         ....[...

0000b358 <default_tl_0x3D>:
    b358:	0001 0000 005c 0000                         ....\...

0000b360 <default_tl_0x3E>:
    b360:	0001 0000 005d 0000                         ....]...

0000b368 <default_tl_0x3F>:
    b368:	0001 0000 005e 0000                         ....^...

0000b370 <keyHoldCLIDict_DescEntry>:
    b370:	6553 646e 6b20 7965 682d 6c6f 2064 7665     Send key-hold ev
    b380:	6e65 7374 7420 206f 6874 2065 616d 7263     ents to the macr
    b390:	206f 6f6d 7564 656c 202e 7544 6c70 6369     o module. Duplic
    b3a0:	7461 7365 6820 7661 2065 6e75 6564 6966     ates have undefi
    b3b0:	656e 2064 6562 6168 6976 756f 2e72 0a0d     ned behaviour...
    b3c0:	0909 5b1b 3533 536d 3031 5b1b 6d30 5320     ...[35mS10.[0m S
    b3d0:	6163 636e 646f 2065 7830 4130                cancode 0x0A.

0000b3dd <keyPressCLIDict_DescEntry>:
    b3dd:	6553 646e 6b20 7965 702d 6572 7373 6520     Send key-press e
    b3ed:	6576 746e 2073 6f74 7420 6568 6d20 6361     vents to the mac
    b3fd:	6f72 6d20 646f 6c75 2e65 4420 7075 696c     ro module. Dupli
    b40d:	6163 6574 2073 6168 6576 7520 646e 6665     cates have undef
    b41d:	6e69 6465 6220 6865 7661 6f69 7275 0d2e     ined behaviour..
    b42d:	090a 1b09 335b 6d35 3153 1b30 305b 206d     ....[35mS10.[0m 
    b43d:	6353 6e61 6f63 6564 3020 3078 0041          Scancode 0x0A.

0000b44b <keyReleaseCLIDict_DescEntry>:
    b44b:	6553 646e 6b20 7965 722d 6c65 6165 6573     Send key-release
    b45b:	6520 6576 746e 7420 206f 616d 7263 206f      event to macro 
    b46b:	6f6d 7564 656c 202e 7544 6c70 6369 7461     module. Duplicat
    b47b:	7365 6820 7661 2065 6e75 6564 6966 656e     es have undefine
    b48b:	2064 6562 6168 6976 756f 2e72 0a0d 0909     d behaviour.....
    b49b:	5b1b 3533 536d 3031 5b1b 6d30 5320 6163     .[35mS10.[0m Sca
    b4ab:	636e 646f 2065 7830 4130 0000                ncode 0x0A...

0000b4b8 <layer1_tl_0x00>:
    b4b8:	0001 0000 0002 0000                         ........

0000b4c0 <layer1_tl_0x01>:
    b4c0:	0001 0000 0004 0000                         ........

0000b4c8 <layer1_tl_0x02>:
    b4c8:	0001 0000 0006 0000                         ........

0000b4d0 <layer1_tl_0x03>:
    b4d0:	0001 0000 0008 0000                         ........

0000b4d8 <layer1_tl_0x04>:
    b4d8:	0001 0000 000a 0000                         ........

0000b4e0 <layer1_tl_0x05>:
    b4e0:	0001 0000 000c 0000                         ........

0000b4e8 <layer1_tl_0x06>:
    b4e8:	0001 0000 000e 0000                         ........

0000b4f0 <layer1_tl_0x07>:
    b4f0:	0001 0000 0010 0000                         ........

0000b4f8 <layer1_tl_0x08>:
    b4f8:	0001 0000 0012 0000                         ........

0000b500 <layer1_tl_0x09>:
    b500:	0001 0000 0014 0000                         ........

0000b508 <layer1_tl_0x0A>:
    b508:	0001 0000 0016 0000                         ........

0000b510 <layer1_tl_0x0B>:
    b510:	0001 0000 0018 0000                         ........

0000b518 <layer1_tl_0x0C>:
    b518:	0000 0000                                   ....

0000b51c <layer1_tl_0x0D>:
    b51c:	0000 0000                                   ....

0000b520 <layer1_tl_0x0E>:
    b520:	0001 0000 001b 0000                         ........

0000b528 <layer1_tl_0x0F>:
    b528:	0000 0000                                   ....

0000b52c <layer1_tl_0x10>:
    b52c:	0001 0000 001e 0000                         ........

0000b534 <layer1_tl_0x11>:
    b534:	0000 0000                                   ....

0000b538 <layer1_tl_0x12>:
    b538:	0000 0000                                   ....

0000b53c <layer1_tl_0x13>:
    b53c:	0000 0000                                   ....

0000b540 <layer1_tl_0x14>:
    b540:	0000 0000                                   ....

0000b544 <layer1_tl_0x15>:
    b544:	0000 0000                                   ....

0000b548 <layer1_tl_0x16>:
    b548:	0001 0000 0025 0000                         ....%...

0000b550 <layer1_tl_0x17>:
    b550:	0001 0000 0027 0000                         ....'...

0000b558 <layer1_tl_0x18>:
    b558:	0001 0000 0029 0000                         ....)...

0000b560 <layer1_tl_0x19>:
    b560:	0001 0000 002b 0000                         ....+...

0000b568 <layer1_tl_0x1A>:
    b568:	0000 0000                                   ....

0000b56c <layer1_tl_0x1B>:
    b56c:	0001 0000 002e 0000                         ........

0000b574 <layer1_tl_0x1C>:
    b574:	0000 0000                                   ....

0000b578 <layer1_tl_0x1D>:
    b578:	0001 0000 0031 0000                         ....1...

0000b580 <layer1_tl_0x1E>:
    b580:	0001 0000 0033 0000                         ....3...

0000b588 <layer1_tl_0x1F>:
    b588:	0001 0000 0035 0000                         ....5...

0000b590 <layer1_tl_0x20>:
    b590:	0001 0000 0037 0000                         ....7...

0000b598 <layer1_tl_0x21>:
    b598:	0000 0000                                   ....

0000b59c <layer1_tl_0x22>:
    b59c:	0001 0000 003a 0000                         ....:...

0000b5a4 <layer1_tl_0x23>:
    b5a4:	0001 0000 003c 0000                         ....<...

0000b5ac <layer1_tl_0x24>:
    b5ac:	0001 0000 003e 0000                         ....>...

0000b5b4 <layer1_tl_0x25>:
    b5b4:	0001 0000 0040 0000                         ....@...

0000b5bc <layer1_tl_0x26>:
    b5bc:	0001 0000 0042 0000                         ....B...

0000b5c4 <layer1_tl_0x27>:
    b5c4:	0001 0000 0044 0000                         ....D...

0000b5cc <layer1_tl_0x28>:
    b5cc:	0000 0000                                   ....

0000b5d0 <layer1_tl_0x29>:
    b5d0:	0000 0000                                   ....

0000b5d4 <layer1_tl_0x2A>:
    b5d4:	0000 0000                                   ....

0000b5d8 <layer1_tl_0x2B>:
    b5d8:	0000 0000                                   ....

0000b5dc <layer1_tl_0x2C>:
    b5dc:	0000 0000                                   ....

0000b5e0 <layer1_tl_0x2D>:
    b5e0:	0000 0000                                   ....

0000b5e4 <layer1_tl_0x2E>:
    b5e4:	0000 0000                                   ....

0000b5e8 <layer1_tl_0x2F>:
    b5e8:	0001 0000 004d 0000                         ....M...

0000b5f0 <layer1_tl_0x30>:
    b5f0:	0001 0000 004f 0000                         ....O...

0000b5f8 <layer1_tl_0x31>:
    b5f8:	0001 0000 0051 0000                         ....Q...

0000b600 <layer1_tl_0x32>:
    b600:	0001 0000 0053 0000                         ....S...

0000b608 <layer1_tl_0x33>:
    b608:	0001 0000 0055 0000                         ....U...

0000b610 <layerDebugCLIDict_DescEntry>:
    b610:	614c 6579 2072 6564 7562 2067 6f6d 6564     Layer debug mode
    b620:	202e 6853 776f 2073 616c 6579 2072 7473     . Shows layer st
    b630:	6361 206b 6e61 2064 6e61 2079 6863 6e61     ack and any chan
    b640:	6567 2e73                                    ges..

0000b645 <layerListCLIDict_DescEntry>:
    b645:	694c 7473 6120 6176 6c69 6261 656c 6c20     List available l
    b655:	7961 7265 2e73                               ayers..

0000b65c <layerStateCLIDict_DescEntry>:
    b65c:	6f4d 6964 7966 7320 6570 6963 6966 6465     Modify specified
    b66c:	6920 646e 7865 6465 6c20 7961 7265 7320      indexed layer s
    b67c:	6174 6574 3c20 616c 6579 3e72 3c20 7473     tate <layer> <st
    b68c:	7461 2065 7962 6574 2e3e 0a0d 0909 5b1b     ate byte>......[
    b69c:	3533 4c6d 1b32 305b 206d 6e49 6564 6578     35mL2.[0m Indexe
    b6ac:	2064 614c 6579 2072 7830 3230 0a0d 0909     d Layer 0x02....
    b6bc:	2030 664f 2c66 3120 5320 6968 7466 202c     0 Off, 1 Shift, 
    b6cc:	2032 614c 6374 2c68 3420 4c20 636f 206b     2 Latch, 4 Lock 
    b6dc:	7453 7461 7365 0000                         States..

0000b6e4 <macroCLIDict>:
    b6e4:	bb5f 0000 a694 0000 2f9d 0000 bb68 0000     _......../..h...
    b6f4:	a6dd 0000 3075 0000 bb70 0000 a719 0000     ....u0..p.......
    b704:	331d 0000 bb7a 0000 b370 0000 39ed 0000     .3..z...p....9..
    b714:	bb82 0000 b3dd 0000 3a35 0000 bb8b 0000     ........5:......
    b724:	b44b 0000 3a7d 0000 bb96 0000 b610 0000     K...}:..........
    b734:	2fe5 0000 bba1 0000 b645 0000 34fd 0000     ./......E....4..
    b744:	bbab 0000 b65c 0000 3441 0000 bbb6 0000     ....\...A4......
    b754:	b7c6 0000 3295 0000 bbc1 0000 b8be 0000     .....2..........
    b764:	30f5 0000 bbcb 0000 b8ea 0000 302d 0000     .0..........-0..
    b774:	bbd5 0000 b909 0000 421d 0000 bbdf 0000     .........B......
    b784:	b98d 0000 34c1 0000 bbe9 0000 b9b9 0000     .....4..........
    b794:	2f75 0000 bbf1 0000 bd2c 0000 35e5 0000     u/......,....5..
    b7a4:	0000 0000 0000 0000 0000 0000               ............

0000b7b0 <macroCLIDictName>:
    b7b0:	614d 7263 206f 6f4d 7564 656c 4320 6d6f     Macro Module Com
    b7c0:	616d 646e 0073                              mands.

0000b7c6 <macroDebugCLIDict_DescEntry>:
    b7c6:	6944 6173 6c62 7365 452f 616e 6c62 7365     Disables/Enables
    b7d6:	7320 6e65 6964 676e 5520 4253 6b20 7965      sending USB key
    b7e6:	6f63 6564 2073 6f74 7420 6568 4f20 7475     codes to the Out
    b7f6:	7570 2074 6f4d 7564 656c 6120 646e 7020     put Module and p
    b806:	6972 746e 2073 2f55 204b 6f63 6564 2e73     rints U/K codes.
    b816:	1b00 315b 333b 6d32 4e49 4f46 5b1b 6d30     ..[1;32mINFO.[0m
    b826:	2d20 5220 7365 6c75 2074 614d 7263 206f      - Result Macro 
    b836:	6e49 6564 3a78 0020 002c 5b1b 3b31 3233     Index: .,..[1;32
    b846:	496d 464e 1b4f 305b 206d 202d 7254 6769     mINFO.[0m - Trig
    b856:	6567 2072 614d 7263 206f 6e49 6564 3a78     ger Macro Index:
    b866:	0020 007c 003b 0a0d 6f50 6973 6974 6e6f      .|.;...Position
    b876:	203a 0d00 520a 7365 6c75 2074 614d 7263     : ...Result Macr
    b886:	206f 6e49 6564 3a78 0020 0a0d 7254 6769     o Index: ...Trig
    b896:	6567 2072 614d 7263 206f 7453 7461 3a65     ger Macro State:
    b8a6:	0020 7250 7365 7c73 6552 656c 7361 0065      .Press|Release.
    b8b6:	6157 7469 6e69 0067                         Waiting.

0000b8be <macroListCLIDict_DescEntry>:
    b8be:	694c 7473 7420 6568 6420 6665 6e69 6465     List the defined
    b8ce:	7420 6972 6767 7265 6120 646e 7220 7365      trigger and res
    b8de:	6c75 2074 616d 7263 736f 002e               ult macros..

0000b8ea <macroProcCLIDict_DescEntry>:
    b8ea:	6150 7375 2f65 6552 7573 656d 6d20 6361     Pause/Resume mac
    b8fa:	6f72 7020 6f72 6563 7373 6e69 2e67           ro processing..

0000b909 <macroShowCLIDict_DescEntry>:
    b909:	6853 776f 7420 6568 6d20 6361 6f72 6320     Show the macro c
    b919:	726f 6572 7073 6e6f 6964 676e 7420 206f     orresponding to 
    b929:	6874 2065 6967 6576 206e 6e69 6564 2e78     the given index.
    b939:	0a0d 0909 5b1b 3533 546d 3631 5b1b 6d30     .....[35mT16.[0m
    b949:	4920 646e 7865 6465 5420 6972 6767 7265      Indexed Trigger
    b959:	4d20 6361 6f72 3020 3178 2c30 1b20 335b      Macro 0x10, .[3
    b969:	6d35 3152 1b32 305b 206d 6e49 6564 6578     5mR12.[0m Indexe
    b979:	2064 6552 7573 746c 4d20 6361 6f72 3020     d Result Macro 0
    b989:	3078 0043                                   x0C.

0000b98d <macroStepCLIDict_DescEntry>:
    b98d:	6f44 4e20 6d20 6361 6f72 7020 6f72 6563     Do N macro proce
    b99d:	7373 6e69 2067 7473 7065 2e73 4420 6665     ssing steps. Def
    b9ad:	7561 746c 2073 6f74 3120 002e               aults to 1..

0000b9b9 <posListCLIDict_DescEntry>:
    b9b9:	694c 7473 7020 7968 6973 6163 206c 656b     List physical ke
    b9c9:	2079 6f70 6973 6974 6e6f 2073 7962 5320     y positions by S
    b9d9:	6163 436e 646f 2e65                          canCode..

0000b9e2 <rm0_guide>:
    b9e2:	0901 00b8                                    .....

0000b9e7 <rm10_guide>:
    b9e7:	1001 000a                                   ....

0000b9eb <rm11_guide>:
    b9eb:	1001 000b                                   ....

0000b9ef <rm12_guide>:
    b9ef:	1001 000c                                   ....

0000b9f3 <rm13_guide>:
    b9f3:	1001 000d                                   ....

0000b9f7 <rm14_guide>:
    b9f7:	1001 000e                                   ....

0000b9fb <rm15_guide>:
    b9fb:	1001 000f                                   ....

0000b9ff <rm16_guide>:
    b9ff:	1001 0010                                   ....

0000ba03 <rm17_guide>:
    ba03:	1001 0011                                   ....

0000ba07 <rm18_guide>:
    ba07:	1001 0012                                   ....

0000ba0b <rm19_guide>:
    ba0b:	1001 0013                                   ....

0000ba0f <rm1_guide>:
    ba0f:	0901 00e2                                    .....

0000ba14 <rm20_guide>:
    ba14:	1001 0014                                   ....

0000ba18 <rm21_guide>:
    ba18:	1001 0015                                   ....

0000ba1c <rm22_guide>:
    ba1c:	1001 0016                                   ....

0000ba20 <rm23_guide>:
    ba20:	1001 0017                                   ....

0000ba24 <rm24_guide>:
    ba24:	1001 0018                                   ....

0000ba28 <rm25_guide>:
    ba28:	1001 0019                                   ....

0000ba2c <rm26_guide>:
    ba2c:	1001 001a                                   ....

0000ba30 <rm27_guide>:
    ba30:	1001 001b                                   ....

0000ba34 <rm28_guide>:
    ba34:	1001 001c                                   ....

0000ba38 <rm29_guide>:
    ba38:	1001 001d                                   ....

0000ba3c <rm2_guide>:
    ba3c:	0901 00e9                                    .....

0000ba41 <rm30_guide>:
    ba41:	1001 001e                                   ....

0000ba45 <rm31_guide>:
    ba45:	1001 001f                                   ....

0000ba49 <rm32_guide>:
    ba49:	1001 0020                                   .. .

0000ba4d <rm33_guide>:
    ba4d:	1001 0021                                   ..!.

0000ba51 <rm34_guide>:
    ba51:	1001 0022                                   ..".

0000ba55 <rm35_guide>:
    ba55:	1001 0023                                   ..#.

0000ba59 <rm36_guide>:
    ba59:	1001 0024                                   ..$.

0000ba5d <rm37_guide>:
    ba5d:	1001 0025                                   ..%.

0000ba61 <rm38_guide>:
    ba61:	1001 0026                                   ..&.

0000ba65 <rm39_guide>:
    ba65:	1001 0027                                   ..'.

0000ba69 <rm3_guide>:
    ba69:	0901 00ea                                    .....

0000ba6e <rm40_guide>:
    ba6e:	1001 0028                                   ..(.

0000ba72 <rm41_guide>:
    ba72:	1001 0029                                   ..).

0000ba76 <rm42_guide>:
    ba76:	1001 002a                                   ..*.

0000ba7a <rm43_guide>:
    ba7a:	1001 002b                                   ..+.

0000ba7e <rm44_guide>:
    ba7e:	1001 002c                                   ..,.

0000ba82 <rm45_guide>:
    ba82:	1001 002d                                   ..-.

0000ba86 <rm46_guide>:
    ba86:	1001 002e                                   ....

0000ba8a <rm47_guide>:
    ba8a:	1001 002f                                   ../.

0000ba8e <rm48_guide>:
    ba8e:	1001 0030                                   ..0.

0000ba92 <rm49_guide>:
    ba92:	1001 0031                                   ..1.

0000ba96 <rm4_guide>:
    ba96:	1001 0004                                   ....

0000ba9a <rm50_guide>:
    ba9a:	1001 0033                                   ..3.

0000ba9e <rm51_guide>:
    ba9e:	1001 0034                                   ..4.

0000baa2 <rm52_guide>:
    baa2:	1001 0036                                   ..6.

0000baa6 <rm53_guide>:
    baa6:	1001 0037                                   ..7.

0000baaa <rm54_guide>:
    baaa:	1001 0038                                   ..8.

0000baae <rm55_guide>:
    baae:	1001 0039                                   ..9.

0000bab2 <rm56_guide>:
    bab2:	1001 003a                                   ..:.

0000bab6 <rm57_guide>:
    bab6:	1001 003b                                   ..;.

0000baba <rm58_guide>:
    baba:	1001 003c                                   ..<.

0000babe <rm59_guide>:
    babe:	1001 003d                                   ..=.

0000bac2 <rm5_guide>:
    bac2:	1001 0005                                   ....

0000bac6 <rm60_guide>:
    bac6:	1001 003e                                   ..>.

0000baca <rm61_guide>:
    baca:	1001 003f                                   ..?.

0000bace <rm62_guide>:
    bace:	1001 0040                                   ..@.

0000bad2 <rm63_guide>:
    bad2:	1001 0041                                   ..A.

0000bad6 <rm64_guide>:
    bad6:	1001 0042                                   ..B.

0000bada <rm65_guide>:
    bada:	1001 0043                                   ..C.

0000bade <rm66_guide>:
    bade:	1001 0044                                   ..D.

0000bae2 <rm67_guide>:
    bae2:	1001 0045                                   ..E.

0000bae6 <rm68_guide>:
    bae6:	1001 0046                                   ..F.

0000baea <rm69_guide>:
    baea:	1001 0047                                   ..G.

0000baee <rm6_guide>:
    baee:	1001 0006                                   ....

0000baf2 <rm70_guide>:
    baf2:	1001 0048                                   ..H.

0000baf6 <rm71_guide>:
    baf6:	1001 0049                                   ..I.

0000bafa <rm72_guide>:
    bafa:	1001 004a                                   ..J.

0000bafe <rm73_guide>:
    bafe:	1001 004b                                   ..K.

0000bb02 <rm74_guide>:
    bb02:	1001 004d                                   ..M.

0000bb06 <rm75_guide>:
    bb06:	1001 004e                                   ..N.

0000bb0a <rm76_guide>:
    bb0a:	1001 004f                                   ..O.

0000bb0e <rm77_guide>:
    bb0e:	1001 0050                                   ..P.

0000bb12 <rm78_guide>:
    bb12:	1001 0051                                   ..Q.

0000bb16 <rm79_guide>:
    bb16:	1001 0052                                   ..R.

0000bb1a <rm7_guide>:
    bb1a:	1001 0007                                   ....

0000bb1e <rm80_guide>:
    bb1e:	1001 0054                                   ..T.

0000bb22 <rm81_guide>:
    bb22:	1001 0055                                   ..U.

0000bb26 <rm82_guide>:
    bb26:	1001 0056                                   ..V.

0000bb2a <rm83_guide>:
    bb2a:	1001 0057                                   ..W.

0000bb2e <rm84_guide>:
    bb2e:	1001 00e0                                   ....

0000bb32 <rm85_guide>:
    bb32:	1001 00e1                                   ....

0000bb36 <rm86_guide>:
    bb36:	1001 00e2                                   ....

0000bb3a <rm87_guide>:
    bb3a:	1001 00e3                                   ....

0000bb3e <rm88_guide>:
    bb3e:	1001 00e4                                   ....

0000bb42 <rm89_guide>:
    bb42:	1001 00e5                                   ....

0000bb46 <rm8_guide>:
    bb46:	1001 0008                                   ....

0000bb4a <rm90_guide>:
    bb4a:	1001 00e6                                   ....

0000bb4e <rm91_guide>:
    bb4e:	0a01                                         ...

0000bb51 <rm92_guide>:
    bb51:	0301 0001                                    .....

0000bb56 <rm93_guide>:
    bb56:	0301 0002                                    .....

0000bb5b <rm9_guide>:
    bb5b:	1001 0009 6163 4470 6265 6775 6300 7061     ....capDebug.cap
    bb6b:	694c 7473 6300 7061 6553 656c 7463 6b00     List.capSelect.k
    bb7b:	7965 6f48 646c 6b00 7965 7250 7365 0073     eyHold.keyPress.
    bb8b:	656b 5279 6c65 6165 6573 6c00 7961 7265     keyRelease.layer
    bb9b:	6544 7562 0067 616c 6579 4c72 7369 0074     Debug.layerList.
    bbab:	616c 6579 5372 6174 6574 6d00 6361 6f72     layerState.macro
    bbbb:	6544 7562 0067 616d 7263 4c6f 7369 0074     Debug.macroList.
    bbcb:	616d 7263 506f 6f72 0063 616d 7263 536f     macroProc.macroS
    bbdb:	6f68 0077 616d 7263 536f 6574 0070 6f70     how.macroStep.po
    bbeb:	4c73 7369 0074 6f76 6574 6544 7562 0067     sList.voteDebug.

0000bbfb <tm0_guide>:
    bbfb:	0001 0180                                    .....

0000bc00 <tm10_guide>:
    bc00:	0001 0b80                                    .....

0000bc05 <tm11_guide>:
    bc05:	0001 0c80                                    .....

0000bc0a <tm12_guide>:
    bc0a:	0001 0d80                                    .....

0000bc0f <tm13_guide>:
    bc0f:	0001 0e80                                    .....

0000bc14 <tm14_guide>:
    bc14:	0001 1080                                    .....

0000bc19 <tm15_guide>:
    bc19:	0001 1180                                    .....

0000bc1e <tm16_guide>:
    bc1e:	0001 1280                                    .....

0000bc23 <tm17_guide>:
    bc23:	0001 1380                                    .....

0000bc28 <tm18_guide>:
    bc28:	0001 1480                                    .....

0000bc2d <tm19_guide>:
    bc2d:	0001 1580                                    .....

0000bc32 <tm1_guide>:
    bc32:	0001 0280                                    .....

0000bc37 <tm20_guide>:
    bc37:	0001 1680                                    .....

0000bc3c <tm21_guide>:
    bc3c:	0001 1780                                    .....

0000bc41 <tm22_guide>:
    bc41:	0001 1880                                    .....

0000bc46 <tm23_guide>:
    bc46:	0001 1980                                    .....

0000bc4b <tm24_guide>:
    bc4b:	0001 1a80                                    .....

0000bc50 <tm25_guide>:
    bc50:	0001 1b80                                    .....

0000bc55 <tm26_guide>:
    bc55:	0001 1c80                                    .....

0000bc5a <tm27_guide>:
    bc5a:	0001 1d80                                    .....

0000bc5f <tm28_guide>:
    bc5f:	0001 1e80                                    .....

0000bc64 <tm29_guide>:
    bc64:	0001 1f80                                    .....

0000bc69 <tm2_guide>:
    bc69:	0001 0380                                    .....

0000bc6e <tm30_guide>:
    bc6e:	0001 2080                                    ... .

0000bc73 <tm31_guide>:
    bc73:	0001 2180                                    ...!.

0000bc78 <tm32_guide>:
    bc78:	0001 2280                                    ...".

0000bc7d <tm33_guide>:
    bc7d:	0001 2380                                    ...#.

0000bc82 <tm34_guide>:
    bc82:	0001 2480                                    ...$.

0000bc87 <tm35_guide>:
    bc87:	0001 2580                                    ...%.

0000bc8c <tm36_guide>:
    bc8c:	0001 2680                                    ...&.

0000bc91 <tm37_guide>:
    bc91:	0001 2780                                    ...'.

0000bc96 <tm38_guide>:
    bc96:	0001 2880                                    ...(.

0000bc9b <tm39_guide>:
    bc9b:	0001 2980                                    ...).

0000bca0 <tm3_guide>:
    bca0:	0001 0480                                    .....

0000bca5 <tm40_guide>:
    bca5:	0001 2a80                                    ...*.

0000bcaa <tm41_guide>:
    bcaa:	0001 2b80                                    ...+.

0000bcaf <tm42_guide>:
    bcaf:	0001 2c80                                    ...,.

0000bcb4 <tm43_guide>:
    bcb4:	0001 2d80                                    ...-.

0000bcb9 <tm44_guide>:
    bcb9:	0001 2e80                                    .....

0000bcbe <tm45_guide>:
    bcbe:	0001 2f80                                    .../.

0000bcc3 <tm46_guide>:
    bcc3:	0001 3080                                    ...0.

0000bcc8 <tm47_guide>:
    bcc8:	0001 3180                                    ...1.

0000bccd <tm48_guide>:
    bccd:	0001 3280                                    ...2.

0000bcd2 <tm49_guide>:
    bcd2:	0001 3380                                    ...3.

0000bcd7 <tm4_guide>:
    bcd7:	0001 0580                                    .....

0000bcdc <tm50_guide>:
    bcdc:	0001 3480                                    ...4.

0000bce1 <tm51_guide>:
    bce1:	0001 3580                                    ...5.

0000bce6 <tm52_guide>:
    bce6:	0001 3680                                    ...6.

0000bceb <tm53_guide>:
    bceb:	0001 3880                                    ...8.

0000bcf0 <tm54_guide>:
    bcf0:	0001 3980                                    ...9.

0000bcf5 <tm55_guide>:
    bcf5:	0001 3a80                                    ...:.

0000bcfa <tm56_guide>:
    bcfa:	0001 3b80                                    ...;.

0000bcff <tm57_guide>:
    bcff:	0001 3c80                                    ...<.

0000bd04 <tm58_guide>:
    bd04:	0001 3d80                                    ...=.

0000bd09 <tm59_guide>:
    bd09:	0001 3e80                                    ...>.

0000bd0e <tm5_guide>:
    bd0e:	0001 0680                                    .....

0000bd13 <tm60_guide>:
    bd13:	0001 3f80                                    ...?.

0000bd18 <tm6_guide>:
    bd18:	0001 0780                                    .....

0000bd1d <tm7_guide>:
    bd1d:	0001 0880                                    .....

0000bd22 <tm8_guide>:
    bd22:	0001 0980                                    .....

0000bd27 <tm9_guide>:
    bd27:	0001 0a80                                    .....

0000bd2c <voteDebugCLIDict_DescEntry>:
    bd2c:	6853 776f 7220 7365 6c75 7374 6f20 2066     Show results of 
    bd3c:	7254 6769 6567 4572 6576 746e 7620 746f     TriggerEvent vot
    bd4c:	6e69 2e67 1b00 315b 353b 333b 6d31 5245     ing...[1;5;31mER
    bd5c:	4f52 1b52 305b 206d 202d 6f4e 6520 6576     ROR.[0m - No eve
    bd6c:	746e 6620 756f 646e 2021 7542 2167 0a0d     nt found! Bug!..
    bd7c:	1b00 315b 353b 333b 6d31 5245 4f52 1b52     ..[1;5;31mERROR.
    bd8c:	305b 206d 202d 6f43 6c75 2064 6f6e 2074     [0m - Could not 
    bd9c:	6966 646e 6520 6576 746e 6920 206e 7665     find event in ev
    bdac:	6e65 2074 7562 6666 7265 6620 726f 6120     ent buffer for a
    bdbc:	7463 7669 7461 6465 7420 6972 6767 7265     ctivated trigger
    bdcc:	2021 6854 7369 6920 2073 2061 7562 2167     ! This is a bug!
    bddc:	0a0d 1b00 315b 333b 6d35 4544 5542 1b47     ....[1;35mDEBUG.
    bdec:	305b 206d 202d 6153 6566 203a 1b00 315b     [0m - Safe: ..[1
    bdfc:	333b 6d33 4157 4e52 4e49 1b47 305b 206d     ;33mWARNING.[0m 
    be0c:	202d 6544 616c 6579 2064 6163 6170 6962     - Delayed capabi
    be1c:	696c 7974 7320 6174 6b63 6620 6c75 216c     lity stack full!
    be2c:	0a0d 1b00 315b 333b 6d35 4544 5542 1b47     ....[1;35mDEBUG.
    be3c:	305b 206d 202d 6e55 732d 6661 3a65 0020     [0m - Un-safe: .

0000be4c <CSWTCH.32>:
    be4c:	1808 1b10 315b 353b 333b 6d31 5245 4f52     ....[1;5;31mERRO
    be5c:	1b52 305b 206d 202d 6f52 6174 6974 6e6f     R.[0m - Rotation
    be6c:	5320 6174 6574 5420 7079 2065 4c28 6e6f      State Type (Lon
    be7c:	2067 614d 7263 736f 2029 202d 6f4e 2074     g Macros) - Not 
    be8c:	6d69 6c70 6d65 6e65 6574 2e64 2e2e 0a0d     implemented.....
    be9c:	1b00 315b 353b 333b 6d31 5245 4f52 1b52     ..[1;5;31mERROR.
    beac:	305b 206d 202d 7453 7461 2065 6353 6568     [0m - State Sche
    bebc:	7564 696c 676e 6e20 746f 6920 706d 656c     duling not imple
    becc:	656d 746e 6465 7920 7465 2e2e 0d2e 000a     mented yet......
    bedc:	5b1b 3b31 3b35 3133 456d 5252 524f 5b1b     .[1;5;31mERROR.[
    beec:	6d30 2d20 4120 616e 6f6c 2067 7453 7461     0m - Analog Stat
    befc:	2065 7954 6570 2d20 4e20 746f 6920 706d     e Type - Not imp
    bf0c:	656c 656d 746e 6465 2e2e 0d2e 000a 5b1b     lemented.......[
    bf1c:	3b31 3b35 3133 456d 5252 524f 5b1b 6d30     1;5;31mERROR.[0m
    bf2c:	2d20 4920 766e 6c61 6469 5320 6174 6574      - Invalid State
    bf3c:	5420 7079 2e65 5420 6968 2073 7369 6120      Type. This is a
    bf4c:	6220 6775 0d2e 000a 5420 6972 6767 7265      bug.... Trigger
    bf5c:	614d 7263 4c6f 7369 5b74 5d00 1b00 315b     MacroList[.]..[1
    bf6c:	333b 6d30 5054 1b65 305b 006d 4420 0052     ;30mTPe.[0m. DR.
    bf7c:	5f20 0a0d 2000 5244 5261 2000 0d52 000a      _... DRaR. R...
    bf8c:	3a56 0049 3a56 0052 3a56 0050 3a56 5250     V:I.V:R.V:P.V:PR
    bf9c:	5600 003a 0046 524e 4e00 1b00 315b 353b     .V:.F.NR.N..[1;5
    bfac:	333b 6d31 5245 4f52 1b52 305b 206d 202d     ;31mERROR.[0m - 
    bfbc:	6f4e 2074 6e65 756f 6867 6220 7479 7365     Not enough bytes
    bfcc:	6920 206e 4948 4944 204f 7562 6666 7265      in HIDIO buffer
    bfdc:	203a 2000 7962 6574 2073 656c 7466 202c     : . bytes left, 
    bfec:	2000 7962 6574 2073 6f74 6174 206c 2000     . bytes total . 
    bffc:	7962 6574 2073 6572 7571 7365 6574 0064     bytes requested.
    c00c:	5b1b 3b31 3b35 3133 456d 5252 524f 5b1b     .[1;5;31mERROR.[
    c01c:	6d30 2d20 5220 7165 6575 7473 6465 4820     0m - Requested H
    c02c:	4449 4f49 6220 6675 6566 2072 6f70 2070     IDIO buffer pop 
    c03c:	616c 6772 7265 7420 6168 206e 6e65 6974     larger than enti
    c04c:	6572 6220 6675 6566 3a72 0020 4146 4c49     re buffer: .FAIL
    c05c:	0a0d 5300 4e59 0043 5b1b 3b31 3333 576d     ...SYNC..[1;33mW
    c06c:	5241 494e 474e 5b1b 6d30 2d20 4420 6f72     ARNING.[0m - Dro
    c07c:	7070 6e69 2067 6e69 6f63 696d 676e 4320     pping incoming C
    c08c:	6e6f 6974 756e 6465 4420 7461 2061 6170     ontinued Data pa
    c09c:	6b63 7465 2e2e 0d2e 000a 5b1b 3b31 3333     cket.......[1;33
    c0ac:	576d 5241 494e 474e 5b1b 6d30 2d20 4420     mWARNING.[0m - D
    c0bc:	6f72 7070 6e69 2067 6e69 6f63 696d 676e     ropping incoming
    c0cc:	4420 7461 2061 6170 6b63 7465 202c 6f6e      Data packet, no
    c0dc:	2074 6e65 756f 6867 6220 6675 6566 2072     t enough buffer 
    c0ec:	7073 6361 2e65 2e2e 0a0d 6800 6165 3a64     space......head:
    c0fc:	0020 7420 6961 3a6c 0020 6220 7479 7365      . tail: . bytes
    c10c:	6c5f 6665 3a74 0020 7220 7165 6575 7473     _left: . request
    c11c:	203a 5400 444f 214f 0a0d 1b00 315b 353b     : .TODO!....[1;5
    c12c:	333b 6d31 5245 4f52 1b52 305b 206d 202d     ;31mERROR.[0m - 
    c13c:	4948 4944 5f4f 6449 4c5f 7369 2074 7369     HIDIO_Id_List is
    c14c:	6620 6c75 2c6c 6320 6e61 6f6e 2074 6572      full, cannot re
    c15c:	6967 7473 7265 4920 3a64 0020 4948 2d44     gister Id: .HID-
    c16c:	4f49 0000                                   IO..

0000c170 <hidioCLIDict>:
    c170:	0000 0000 0000 0000 0000 0000               ............

0000c17c <hidioCLIDictName>:
    c17c:	4948 2d44 4f49 4d20 646f 6c75 2065 6f43     HID-IO Module Co
    c18c:	6d6d 6e61 7364 4f00 7475 7570 5f74 6c66     mmands.Output_fl
    c19c:	7361 4d68 646f 2865 0029 5b1b 3b31 3233     ashMode()..[1;32
    c1ac:	496d 464e 1b4f 305b 206d 202d 7845 6574     mINFO.[0m - Exte
    c1bc:	6e72 6c61 4120 6176 6c69 6261 656c 4320     rnal Available C
    c1cc:	7275 6572 746e 4320 6168 676e 6465 202e     urrent Changed. 
    c1dc:	6f54 6174 206c 7641 6961 616c 6c62 3a65     Total Available:
    c1ec:	0020 6d20 0d41 000a 5b1b 3b31 3233 496d      . mA....[1;32mI
    c1fc:	464e 1b4f 305b 206d 202d 7543 7272 6e65     NFO.[0m - Curren
    c20c:	2074 7661 6961 616c 6c62 3a65 0020 6d20     t available: . m
    c21c:	0041                                        A.

0000c21e <currentCLIDict_DescEntry>:
    c21e:	6853 776f 2073 6874 2065 7563 7272 6e65     Shows the curren
    c22e:	2074 656e 6f67 6974 7461 6465 6320 7275     t negotiated cur
    c23e:	6572 746e 002e                              rent..

0000c244 <outputCLIDict>:
    c244:	c299 0000 c21e 0000 5c25 0000 c2a1 0000     ........%\......
    c254:	c27f 0000 5a79 0000 0000 0000 0000 0000     ....yZ..........
    c264:	0000 0000                                   ....

0000c268 <outputCLIDictName>:
    c268:	754f 7074 7475 4d20 646f 6c75 2065 6f43     Output Module Co
    c278:	6d6d 6e61 7364                               mmands.

0000c27f <outputDebugCLIDict_DescEntry>:
    c27f:	6f54 6767 656c 4f20 7475 7570 2074 6544     Toggle Output De
    c28f:	7562 2067 6f6d 6564 002e 7563 7272 6e65     bug mode..curren
    c29f:	0074 756f 7074 7475 6544 7562 0067          t.outputDebug.

0000c2ad <CSWTCH.72>:
    c2ad:	0000 0000 0000 0100 0101 0101 0101 0201     ................
    c2bd:	0202 0202 0202 0302 0303 0303 0303 0403     ................
    c2cd:	0404 0404 0404 0504 0505 0505 0505 0605     ................
    c2dd:	0606 0606 0606 0706 0707 0707 0707 0807     ................
    c2ed:	0808 0808 0808 0908 0909 0909 0909 0a09     ................
    c2fd:	0a0a 0a0a 0a0a 0b0a 0b0b 0b0b 0b0b 0c0b     ................
    c30d:	0c0c 0c0c 0c0c 0d0c 0d0d 0d0d 0d0d 0e0d     ................
    c31d:	0e0e 0e0e 0e0e 0f0e 0f0f 0f0f 0f0f 100f     ................
    c32d:	1010 1010 1010 1110 1111 1111 1111 1211     ................
    c33d:	1212 1212 1212 1312 1313 1313 1313 1413     ................
    c34d:	1414 1414 1414 0014 0000 0000 0000 1600     ................
    c35d:	1616 1616 1616 1716 1717 1717 1717 1817     ................
    c36d:	1818 1818 1818 1918 1919 1919 1919 1a19     ................
    c37d:	1a1a 1a1a 1a1a 1b1a 1b1b 1b1b 1b1b           ...............

0000c38c <CSWTCH.73>:
    c38c:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c39c:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c3ac:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c3bc:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c3cc:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c3dc:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c3ec:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c3fc:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c40c:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c41c:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c42c:	0201 0403 0605 0007 0000 0000 0000 0000     ................
    c43c:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c44c:	0201 0403 0605 0007 0201 0403 0605 0007     ................
    c45c:	0201 0403 0605 0007 0201 0403 0605 4f07     ...............O
    c46c:	7475 7570 5f74 6f63 736e 7443 6c72 6553     utput_consCtrlSe
    c47c:	646e 6328 6e6f 4373 646f 2965 4f00 7475     nd(consCode).Out
    c48c:	7570 5f74 626b 5064 6f72 6f74 6f63 426c     put_kbdProtocolB
    c49c:	6f6f 2874 0029 754f 7074 7475 6b5f 6462     oot().Output_kbd
    c4ac:	7250 746f 636f 6c6f 4b4e 4f52 2928 4f00     ProtocolNKRO().O
    c4bc:	7475 7570 5f74 6f6e 656e 6553 646e 2928     utput_noneSend()
    c4cc:	4f00 7475 7570 5f74 7973 4373 7274 536c     .Output_sysCtrlS
    c4dc:	6e65 2864 7973 4373 646f 2965 4f00 7475     end(sysCode).Out
    c4ec:	7570 5f74 6f74 6767 656c 624b 5064 6f72     put_toggleKbdPro
    c4fc:	6f74 6f63 286c 0029 754f 7074 7475 755f     tocol().Output_u
    c50c:	6273 6f43 6564 6553 646e 7528 6273 6f43     sbCodeSend(usbCo
    c51c:	6564 0029 5b1b 3b31 3433 556d 4253 5b1b     de)..[1;34mUSB.[
    c52c:	6d30 0020 5b1b 3b31 3333 576d 5241 494e     0m ..[1;33mWARNI
    c53c:	474e 5b1b 6d30 2d20 5520 4253 4b20 7965     NG.[0m - USB Key
    c54c:	6c20 6d69 7469 7220 6165 6863 6465 0a0d      limit reached..
    c55c:	1b00 315b 333b 6d33 4157 4e52 4e49 1b47     ..[1;33mWARNING.
    c56c:	305b 206d 202d 5355 2042 6f43 6564 6e20     [0m - USB Code n
    c57c:	746f 7720 7469 6968 206e 2d34 3531 2035     ot within 4-155 
    c58c:	3028 3478 302d 3978 2942 202c 3531 2d37     (0x4-0x9B), 157-
    c59c:	3631 2034 3028 3978 2d44 7830 3441 2c29     164 (0x9D-0xA4),
    c5ac:	3120 3637 322d 3132 2820 7830 3042 302d      176-221 (0xB0-0
    c5bc:	4478 2944 6f20 2072 3232 2d34 3332 2031     xDD) or 224-231 
    c5cc:	3028 4578 2d30 7830 3745 2029 4b4e 4f52     (0xE0-0xE7) NKRO
    c5dc:	4d20 646f 3a65 0020 754f 7074 7475 755f      Mode: .Output_u
    c5ec:	6273 6f4d 7375 5765 6568 6c65 7628 7265     sbMouseWheel(ver
    c5fc:	2c74 6f68 6972 0029 754f 7074 7475 755f     t,hori).Output_u
    c60c:	6273 6f4d 7375 2865 6f6d 7375 4265 7475     sbMouse(mouseBut
    c61c:	6f74 2c6e 6572 586c 722c 6c65 2959 1b00     ton,relX,relY)..
    c62c:	315b 333b 6d34 4b36 4f52 5b1b 6d30 0020     [1;34m6KRO.[0m .
    c63c:	5b1b 3b31 3433 436d 6e6f 4373 7274 1b6c     .[1;34mConsCtrl.
    c64c:	305b 5b6d 1b00 315b 333b 6d34 4b4e 4f52     [0m[..[1;34mNKRO
    c65c:	5b1b 6d30 0020 5b1b 3b31 3433 536d 7379     .[0m ..[1;34mSys
    c66c:	7443 6c72 5b1b 6d30 005b 205d 0a0d 5500     Ctrl.[0m[.] ...U
    c67c:	4253 754f 7074 7475 6550 6972 5500 4253     SBOutputPeri.USB
    c68c:	754f 7074 7475 6f50 6c6c 1b00 315b 333b     OutputPoll..[1;3
    c69c:	6d32 4e49 4f46 5b1b 6d30 2d20 5520 4253     2mINFO.[0m - USB
    c6ac:	4920 6c64 2065 6f43 666e 6769 203a 2000      Idle Config: . 
    c6bc:	736d 2d20 0020 5b1b 3b31 3233 496d 464e     ms - ..[1;32mINF
    c6cc:	1b4f 305b 206d 202d 6553 7474 6e69 2067     O.[0m - Setting 
    c6dc:	654b 6279 616f 6472 5020 6f72 6f74 6f63     Keyboard Protoco
    c6ec:	206c 6f74 203a 1b00 315b 333b 6d32 4e49     l to: ..[1;32mIN
    c6fc:	4f46 5b1b 6d30 2d20 4b20 7965 6f62 7261     FO.[0m - Keyboar
    c70c:	2064 7250 746f 636f 6c6f 203a 1b00 315b     d Protocol: ..[1
    c71c:	333b 6d32 4e49 4f46 5b1b 6d30 2d20 4c20     ;32mINFO.[0m - L
    c72c:	4445 5320 6174 6574 203a 1b00 315b 333b     ED State: ..[1;3
    c73c:	6d32 4e49 4f46 5b1b 6d30 2d20 5520 4253     2mINFO.[0m - USB
    c74c:	4120 6464 6572 7373 203a 1b00 315b 333b      Address: ..[1;3
    c75c:	6d32 4e49 4f46 5b1b 6d30 2d20 5520 4253     2mINFO.[0m - USB
    c76c:	4320 6e6f 6966 7567 6572 3a64 0020 5b1b      Configured: ..[
    c77c:	3b31 3233 496d 464e 1b4f 305b 206d 202d     1;32mINFO.[0m - 
    c78c:	5355 2042 6e49 7469 5420 6d69 3a65 0020     USB Init Time: .
    c79c:	7420 6369 736b                                ticks.

0000c7a3 <idleCLIDict_DescEntry>:
    c7a3:	6853 776f 732f 7465 7420 6568 4820 4449     Show/set the HID
    c7b3:	4920 6c64 2065 6974 656d 2820 756d 746c      Idle time (mult
    c7c3:	7069 656c 2073 666f 3420 6d20 2973 002e     iples of 4 ms)..

0000c7d3 <kbdProtocolCLIDict_DescEntry>:
    c7d3:	654b 6279 616f 6472 5020 6f72 6f74 6f63     Keyboard Protoco
    c7e3:	206c 6f4d 6564 203a 2030 202d 6f42 746f     l Mode: 0 - Boot
    c7f3:	202c 2031 202d 534f 4e2f 524b 204f 6f4d     , 1 - OS/NKRO Mo
    c803:	6564 002e                                   de..

0000c807 <readLEDsCLIDict_DescEntry>:
    c807:	6552 6461 4c20 4445 6220 7479 3a65 0a0d     Read LED byte:..
    c817:	0909 2031 754e 4c6d 6b63 202c 2032 6143     ..1 NumLck, 2 Ca
    c827:	7370 634c 2c6b 3420 5320 7263 4c6c 6b63     psLck, 4 ScrlLck
    c837:	202c 3631 4b20 6e61 2c61 6520 6374 002e     , 16 Kana, etc..
    c847:	6469 656c 6b00 6462 7250 746f 636f 6c6f     idle.kbdProtocol
    c857:	7200 6165 4c64 4445 0073 7375 4162 6464     .readLEDs.usbAdd
    c867:	0072 7375 4362 6e6f 0066 7375 4962 696e     r.usbConf.usbIni
    c877:	5474 6d69 0065                              tTime.

0000c87d <usbAddrCLIDict_DescEntry>:
    c87d:	6853 776f 2073 6874 2065 656e 6f67 6974     Shows the negoti
    c88d:	7461 6465 5520 4253 7520 696e 7571 2065     ated USB unique 
    c89d:	6449 202c 6967 6576 206e 6f74 6420 7665     Id, given to dev
    c8ad:	6369 2065 7962 6820 736f 2e74 0000           ice by host....

0000c8bc <usbCLIDict>:
    c8bc:	c847 0000 c7a3 0000 5e91 0000 c84c 0000     G........^..L...
    c8cc:	c7d3 0000 5fa1 0000 c858 0000 c807 0000     ....._..X.......
    c8dc:	5e11 0000 c861 0000 c87d 0000 5e51 0000     .^..a...}...Q^..
    c8ec:	c869 0000 c924 0000 5efd 0000 c871 0000     i...$....^..q...
    c8fc:	c94c 0000 5f39 0000 0000 0000 0000 0000     L...9_..........
    c90c:	0000 0000                                   ....

0000c910 <usbCLIDictName>:
    c910:	5355 2042 6f4d 7564 656c 4320 6d6f 616d     USB Module Comma
    c920:	646e 0073                                   nds.

0000c924 <usbConfCLIDict_DescEntry>:
    c924:	6853 776f 2073 6877 7465 6568 2072 5355     Shows whether US
    c934:	2042 7369 6320 6e6f 6966 7567 6572 2064     B is configured 
    c944:	726f 6e20 746f 002e                         or not..

0000c94c <usbInitTimeCLIDict_DescEntry>:
    c94c:	6944 7073 616c 7379 7420 6568 7420 6d69     Displays the tim
    c95c:	2065 6e69 6d20 2073 7266 6d6f 7520 6273     e in ms from usb
    c96c:	695f 696e 2874 2029 6974 6c6c 7420 6568     _init() till the
    c97c:	6c20 7361 2074 6573 7574 2070 6163 6c6c      last setup call
    c98c:	002e 0000                                   ....

0000c990 <usb_descriptor_list>:
    c990:	0100 0000 ec79 1fff 0012 0000 0200 0000     ....y...........
    c9a0:	ebaa 1fff 00cf 0000 0600 0000 f466 1fff     ............f...
    c9b0:	0001 0000 0a00 0000 f467 1fff 0001 0000     ........g.......
    c9c0:	0300 0000 edb8 1fff 0000 0000 0301 0409     ................
    c9d0:	ee96 1fff 0000 0000 0302 0409 eeda 1fff     ................
    c9e0:	0000 0000 0303 0409 ef64 1fff 0000 0000     ........d.......
    c9f0:	0304 0409 ee6c 1fff 0000 0000 2200 0000     ....l........"..
    ca00:	ec8b 1fff 0043 0000 2100 0000 ebbc 1fff     ....C....!......
    ca10:	0009 0000 2200 0001 ed3b 1fff 0061 0000     ....."..;...a...
    ca20:	2100 0001 ebd5 1fff 0009 0000 2200 0002     .!..........."..
    ca30:	edbc 1fff 0035 0000 2100 0002 ebee 1fff     ....5....!......
    ca40:	0009 0000 0305 0409 ee78 1fff 0000 0000     ........x.......
    ca50:	0306 0409 eebc 1fff 0000 0000 0307 0409     ................
    ca60:	efc0 1fff 0000 0000 0308 0409 ee30 1fff     ............0...
    ca70:	0000 0000 0309 0409 edf8 1fff 0000 0000     ................
    ca80:	2200 0006 ed9c 1fff 001c 0000 2100 0006     ."...........!..
    ca90:	ec49 1fff 0009 0000 030b 0409 ef3a 1fff     I...........:...
    caa0:	0000 0000 2200 0005 ecce 1fff 006d 0000     ....."......m...
    cab0:	2100 0005 ec69 1fff 0009 0000 030a 0409     .!..i...........
    cac0:	eeae 1fff 0000 0000 0000 0000 0000 0000     ................
    cad0:	0000 0000                                   ....

0000cad4 <usb_endpoint_config_table>:
    cad4:	1515 1515 1519 1915 1515 5b1b 3b31 3333     ...........[1;33
    cae4:	576d 5241 494e 474e 5b1b 6d30 2d20 2820     mWARNING.[0m - (
    caf4:	4553 5f54 4552 4f50 5452 202c 5542 4b4c     SET_REPORT, BULK
    cb04:	2029 6e55 6e6b 776f 206e 6e69 6574 6672     ) Unknown interf
    cb14:	6361 2065 202d 1b00 315b 333b 6d33 4157     ace - ..[1;33mWA
    cb24:	4e52 4e49 1b47 305b 206d 202d 5355 2042     RNING.[0m - USB 
    cb34:	6f4c 2077 6f50 6577 2072 654e 6f67 6174     Low Power Negota
    cb44:	6974 6e6f 4420 7369 6261 656c 2c64 6320     tion Disabled, c
    cb54:	6e6f 6964 6974 6e6f 6420 7465 6365 6574     ondition detecte
    cb64:	2e64 1b00 315b 333b 6d33 4157 4e52 4e49     d...[1;33mWARNIN
    cb74:	1b47 305b 206d 202d 4553 5f54 4546 5441     G.[0m - SET_FEAT
    cb84:	5255 2045 202d 6544 6976 6563 7720 6156     URE - Device wVa
    cb94:	756c 2865 1b00 315b 333b 6d33 4157 4e52     lue(..[1;33mWARN
    cba4:	4e49 1b47 305b 206d 202d 4c43 4145 5f52     ING.[0m - CLEAR_
    cbb4:	4546 5441 5255 2045 202d 6e49 6574 6672     FEATURE - Interf
    cbc4:	6361 2065 5677 6c61 6575 0028 2029 4977     ace wValue(.) wI
    cbd4:	646e 7865 0028 5b1b 3b31 3333 576d 5241     ndex(..[1;33mWAR
    cbe4:	494e 474e 5b1b 6d30 2d20 2820 4553 5f54     NING.[0m - (SET_
    cbf4:	4546 5441 5255 2c45 5320 5445 5055 2029     FEATURE, SETUP) 
    cc04:	2d20 0020 5b1b 3b31 3333 576d 5241 494e      - ..[1;33mWARNI
    cc14:	474e 5b1b 6d30 2d20 5320 5445 465f 4145     NG.[0m - SET_FEA
    cc24:	5554 4552 2d20 4920 746e 7265 6166 6563     TURE - Interface
    cc34:	7720 6156 756c 2865 1b00 315b 333b 6d33      wValue(..[1;33m
    cc44:	4157 4e52 4e49 1b47 305b 206d 202d 5328     WARNING.[0m - (S
    cc54:	5445 525f 5045 524f 2c54 5320 5445 5055     ET_REPORT, SETUP
    cc64:	2029 6e55 6e6b 776f 206e 6e69 6574 6672     ) Unknown interf
    cc74:	6361 2065 202d 1b00 315b 353b 333b 6d31     ace - ..[1;5;31m
    cc84:	5245 4f52 1b52 305b 206d 202d 5355 2042     ERROR.[0m - USB 
    cc94:	6f6e 2074 6f63 666e 6769 7275 6465 2e2e     not configured..
    cca4:	0d2e 000a 5b1b 3b31 3333 576d 5241 494e     .....[1;33mWARNI
    ccb4:	474e 5b1b 6d30 2d20 5520 4253 5420 6172     NG.[0m - USB Tra
    ccc4:	736e 696d 2074 6954 656d 756f 2e74 2e2e     nsmit Timeout...
    ccd4:	7561 6f74 722d 7365 6174 7472 6420 7369     auto-restart dis
    cce4:	6261 656c 0d64 000a 5b1b 3b31 3533 446d     abled....[1;35mD
    ccf4:	4245 4755 5b1b 6d30 2d20 4e20 524b 204f     EBUG.[0m - NKRO 
    cd04:	5355 3a42 0020 5b1b 3b31 3333 576d 5241     USB: ..[1;33mWAR
    cd14:	494e 474e 5b1b 6d30 2d20 5520 4253 5420     NING.[0m - USB T
    cd24:	6172 736e 696d 2074 6954 656d 756f 2e74     ransmit Timeout.
    cd34:	2e2e 0a0d 1b00 315b 333b 6d33 4157 4e52     ......[1;33mWARN
    cd44:	4e49 1b47 305b 206d 202d 4152 4957 204f     ING.[0m - RAWIO 
    cd54:	7852 2d20 5420 6d69 6f65 7475 202c 7264     Rx - Timeout, dr
    cd64:	706f 6970 676e 7020 6361 656b 2e74 1b00     opping packet...
    cd74:	315b 333b 6d33 4157 4e52 4e49 1b47 305b     [1;33mWARNING.[0
    cd84:	206d 202d 4152 4957 204f 7854 2d20 5420     m - RAWIO Tx - T
    cd94:	6d69 6f65 7475 202c 7264 706f 6970 676e     imeout, dropping
    cda4:	7020 6361 656b 2e74 0000 0000 4500 5252      packet......ERR
    cdb4:	524f 3100 353b 333b 0031 5b1b 2200 6920     OR.1;5;31..[." i
    cdc4:	2073 6f6e 2074 2061 6176 696c 2064 6f63     s not a valid co
    cdd4:	6d6d 6e61 2e64 2e2e 7974 6570 1b20 335b     mmand...type .[3
    cde4:	6d35 6568 706c 5b1b 6d30 2200 1b00 305b     5mhelp.[0m."..[0
    cdf4:	206d 202d 1b00 315b 353b 333b 6d31 5245     m - ..[1;5;31mER
    ce04:	4f52 1b52 305b 206d 202d 6553 6972 6c61     ROR.[0m - Serial
    ce14:	6c20 6e69 2065 7562 6666 7265 6920 2073      line buffer is 
    ce24:	7566 6c6c 202c 7264 706f 6970 676e 6320     full, dropping c
    ce34:	6168 6172 7463 7265 6120 646e 7220 7365     haracter and res
    ce44:	7465 6974 676e 2e2e 0d2e 000a 5b1b 0d73     etting.......[s.
    ce54:	000a 5b1b 4b32 1b00 755b 0800 0820 1b00     ...[2K..[u.. ...
    ce64:	315b 353b 333b 6d31 5245 4f52 1b52 305b     [1;5;31mERROR.[0
    ce74:	206d 202d 614d 2078 756e 626d 7265 6f20     m - Max number o
    ce84:	2066 6964 7463 6f69 616e 6972 7365 6420     f dictionaries d
    ce94:	6665 6e69 6465 6120 726c 6165 7964 2e2e     efined already..
    cea4:	0d2e 000a 5241 004d 6f43 7472 7865 4d2d     ....ARM.Cortex-M
    ceb4:	0030 6f43 7472 7865 4d2d 0033 6f43 7472     0.Cortex-M3.Cort
    cec4:	7865 4d2d 2b30 4300 726f 6574 2d78 344d     ex-M0+.Cortex-M4
    ced4:	2d00 002d                                   .--.

0000ced8 <ChipVersion_eepromsize>:
    ced8:	4000 2000 1000 0800 0400 0200 0100 0080     .@. ............
    cee8:	0040 0020 ffff ffff ffff ffff ffff 0000     @. .............
    cef8:	6b6d 3032 7864 3231 7638 666c 0035 6b6d     mk20dx128vlf5.mk
    cf08:	3032 7864 3231 7638 686c 0037 6b6d 3032     20dx128vlh7.mk20
    cf18:	7864 3231 5838 5858 0058 6b6d 3032 7864     dx128XXXX.mk20dx
    cf28:	3532 7636 686c 0037 6b6d 3032 7864 3532     256vlh7.mk20dx25
    cf38:	7636 636d 0037 6b6d 3032 7864 3532 5836     6vmc7.mk20dx256X
    cf48:	5858 0058 6b6d 3032 7864 5858 7658 686c     XXX.mk20dxXXXvlh
    cf58:	0037 6b6d 3232 7866 3135 6132 6c76 3168     7.mk22fx512avlh1
    cf68:	0032 6b6d 3232 7866 5858 6158 6c76 3168     2.mk22fxXXXavlh1
    cf78:	0032                                        2.

0000cf7a <ChipVersion_nvmsize>:
    cf7a:	0000 ffff ffff 0020 0040 0080 ffff 0100     ...... .@.......
    cf8a:	ffff 0200 ffff ffff ffff ffff 0200          ..............

0000cf98 <ChipVersion_pflashsize>:
    cf98:	ffff ffff ffff 0020 ffff 0040 ffff 0080     ...... ...@.....
    cfa8:	ffff 0100 ffff 0200 ffff 0400 ffff 0400     ................

0000cfb8 <ChipVersion_ramsize>:
    cfb8:	ffff 0008 ffff 0010 0018 0020 0030 0040     .......... .0.@.
    cfc8:	0060 0080 ffff 0100 ffff ffff ffff ffff     `...............

0000cfd8 <basicCLIDict>:
    cfd8:	d943 0000 d091 0000 8239 0000 d949 0000     C.......9...I...
    cfe8:	d0a3 0000 8499 0000 d952 0000 d6c5 0000     ........R.......
    cff8:	8261 0000 d95c 0000 d726 0000 82f9 0000     a...\...&.......
    d008:	d961 0000 d73e 0000 9111 0000 d969 0000     a...>.......i...
    d018:	d78e 0000 83d5 0000 d96d 0000 d824 0000     ........m...$...
    d028:	8a71 0000 d976 0000 d86f 0000 84e9 0000     q...v...o.......
    d038:	d97b 0000 d8a3 0000 8295 0000 d982 0000     {...............
    d048:	d8ce 0000 82d1 0000 d988 0000 d8fc 0000     ................
    d058:	8405 0000 d990 0000 da0c 0000 8429 0000     ............)...
    d068:	d995 0000 da56 0000 86b1 0000 0000 0000     ....V...........
    d078:	0000 0000 0000 0000                         ........

0000d080 <basicCLIDictName>:
    d080:	6547 656e 6172 206c 6f43 6d6d 6e61 7364     General Commands
    d090:	                                             .

0000d091 <clearCLIDict_DescEntry>:
    d091:	6c43 6165 2072 6874 2065 6373 6572 6e65     Clear the screen
    d0a1:	002e                                        ..

0000d0a3 <cliDebugCLIDict_DescEntry>:
    d0a3:	6e45 6261 656c 2f73 6944 6173 6c62 7365     Enables/Disables
    d0b3:	6820 7865 6f20 7475 7570 2074 666f 7420      hex output of t
    d0c3:	6568 6d20 736f 2074 6572 6563 746e 6320     he most recent c
    d0d3:	696c 6920 706e 7475 002e 5b1b 4a32 5b1b     li input...[2J.[
    d0e3:	0d48 1b00 315b 333b 6d32 4e49 4f46 5b1b     H...[1;32mINFO.[
    d0f3:	6d30 2d20 4820 7865 6420 6265 6775 6d20     0m - Hex debug m
    d103:	646f 2065 6964 6173 6c62 6465 2e2e 0d2e     ode disabled....
    d113:	000a 5b1b 3b31 3233 496d 464e 1b4f 305b     ...[1;32mINFO.[0
    d123:	206d 202d 6548 2078 6564 7562 2067 6f6d     m - Hex debug mo
    d133:	6564 6520 616e 6c62 6465 2e2e 0d2e 000a     de enabled......
    d143:	5b1b 3833 323b 323b 3535 313b 3030 303b     .[38;2;255;100;0
    d153:	546d 5552 4345 4c4f 524f 5b1b 6d30 0d00     mTRUECOLOR.[0m..
    d163:	1b0a 315b 333b 6d32 1b00 305b 0d6d 000a     ..[1;32m..[0m...
    d173:	1b20 335b 6d35 4c00 7461 6e65 7963 0a0d      .[35m.Latency..
    d183:	3c00 3e69 3c3a 6f6d 7564 656c 093e 633c     .<i>:<module>.<c
    d193:	756f 746e 093e 6d3c 6e69 093e 613c 6776     ount>.<min>.<avg
    d1a3:	093e 6c3c 7361 3e74 3c09 616d 3e78 1b00     >.<last>.<max>..
    d1b3:	315b 333b 6d32 4e49 4f46 5b1b 6d30 2d20     [1;32mINFO.[0m -
    d1c3:	5020 7265 6f69 2064 6c43 636f 206b 7943      Period Clock Cy
    d1d3:	6c63 7365 203a 1b00 315b 333b 6d33 4157     cles: ..[1;33mWA
    d1e3:	4e52 4e49 1b47 305b 206d 202d 6f4e 6520     RNING.[0m - No e
    d1f3:	746e 6f72 7970 6120 6176 6c69 6261 656c     ntropy available
    d203:	0d21 000a 5b1b 3b31 3233 496d 464e 1b4f     !....[1;32mINFO.
    d213:	305b 206d 202d 6152 646e 203a 1b00 0063     [0m - Rand: ..c.
    d223:	5b1b 3b31 3233 496d 464e 1b4f 305b 206d     .[1;32mINFO.[0m 
    d233:	202d 736e 7020 7265 6320 6379 656c 6974     - ns per cycleti
    d243:	6b63 203a 1b00 315b 333b 6d32 4e49 4f46     ck: ..[1;32mINFO
    d253:	5b1b 6d30 2d20 3c20 7973 7473 6369 206b     .[0m - <systick 
    d263:	736d 3a3e 633c 6379 656c 6974 6b63 2073     ms>:<cycleticks 
    d273:	6973 636e 2065 7973 7473 6369 3e6b 0a0d     since systick>..
    d283:	2000 5b1b 6d31 6552 6976 6973 6e6f 1b3a     . .[1mRevision:.
    d293:	305b 206d 2020 2020 3520 3863 3238 3862     [0m      5c882b8
    d2a3:	3238 3661 3966 3965 6335 3830 6364 6331     82a6f9e95c08dc1c
    d2b3:	3063 3832 6137 3931 6234 3566 6438 3430     c0287a194bf58d04
    d2c3:	0d35 000a 1b20 315b 526d 7665 7369 6f69     5... .[1mRevisio
    d2d3:	206e 3a23 5b1b 6d30 2020 2020 3233 0a0d     n #:.[0m    32..
    d2e3:	2000 5b1b 6d31 6556 7372 6f69 3a6e 5b1b     . .[1mVersion:.[
    d2f3:	6d30 2020 2020 2020 2020 2b28 3a00 3233     0m        (+.:32
    d303:	0d29 000a 1b20 315b 426d 6172 636e 3a68     )... .[1mBranch:
    d313:	5b1b 6d30 2020 2020 2020 2020 616d 7473     .[0m        mast
    d323:	7265 0a0d 2000 5b1b 6d31 7254 6565 5320     er... .[1mTree S
    d333:	6174 7574 3a73 5b1b 6d30 2020 4320 656c     tatus:.[0m   Cle
    d343:	6e61 0a0d 0d09 000a 1b20 315b 526d 7065     an...... .[1mRep
    d353:	206f 724f 6769 6e69 1b3a 305b 206d 2020     o Origin:.[0m   
    d363:	6967 4074 6967 6874 6275 632e 6d6f 743a     git@github.com:t
    d373:	6568 6f74 636d 6172 6769 6b2f 7965 6f62     hetomcraig/keybo
    d383:	7261 5f64 7475 6c69 7469 6569 2e73 6967     ard_utilities.gi
    d393:	0d74 000a 1b20 315b 436d 6d6f 696d 2074     t... .[1mCommit 
    d3a3:	6144 6574 1b3a 305b 206d 2020 3032 3831     Date:.[0m   2018
    d3b3:	312d 2d31 3731 3120 3a39 3035 343a 2036     -11-17 19:50:46 
    d3c3:	302d 3038 0d30 000a 1b20 315b 436d 6d6f     -0800... .[1mCom
    d3d3:	696d 2074 7541 6874 726f 1b3a 305b 206d     mit Author:.[0m 
    d3e3:	6f54 206d 7243 6961 2067 743c 6568 6f74     Tom Craig <theto
    d3f3:	636d 6172 6769 6940 6c63 756f 2e64 6f63     mcraig@icloud.co
    d403:	3e6d 0a0d 2000 5b1b 6d31 7542 6c69 2064     m>... .[1mBuild 
    d413:	6144 6574 1b3a 305b 206d 2020 3220 3130     Date:.[0m    201
    d423:	2d38 3131 312d 2037 3931 353a 3a39 3933     8-11-17 19:59:39
    d433:	2d20 3830 3030 0a0d 2000 5b1b 6d31 7542      -0800... .[1mBu
    d443:	6c69 2064 534f 1b3a 305b 206d 2020 2020     ild OS:.[0m     
    d453:	4720 6e65 7265 6369 0a0d 2000 5b1b 6d31      Generic... .[1m
    d463:	6f43 706d 6c69 7265 1b3a 305b 206d 2020     Compiler:.[0m   
    d473:	2020 2f20 7375 2f72 6f6c 6163 2f6c 6962        /usr/local/bi
    d483:	2f6e 7261 2d6d 6f6e 656e 652d 6261 2d69     n/arm-none-eabi-
    d493:	6367 2063 2e37 2e33 0d31 000a 1b20 315b     gcc 7.3.1... .[1
    d4a3:	416d 6372 6968 6574 7463 7275 3a65 5b1b     mArchitecture:.[
    d4b3:	6d30 2020 7261 0d6d 000a 1b20 315b 436d     0m  arm... .[1mC
    d4c3:	6968 2070 6f43 706d 6c69 6465 1b3a 305b     hip Compiled:.[0
    d4d3:	206d 6b6d 3032 7864 3231 2038 6d28 326b     m mk20dx128 (mk2
    d4e3:	6430 3178 3832 6c76 3566 0d29 000a 1b20     0dx128vlf5)... .
    d4f3:	315b 436d 5550 1b3a 305b 206d 2020 2020     [1mCPU:.[0m     
    d503:	2020 2020 2020 6f63 7472 7865 6d2d 0d34           cortex-m4.
    d513:	000a 1b20 315b 446d 7665 6369 3a65 5b1b     .. .[1mDevice:.[
    d523:	6d30 2020 2020 2020 2020 654b 6279 616f     0m        Keyboa
    d533:	6472 0a0d 2000 5b1b 6d31 6f4d 7564 656c     rd... .[1mModule
    d543:	3a73 5b1b 6d30 2020 2020 2020 5320 6163     s:.[0m       Sca
    d553:	286e 6e49 6966 696e 7974 365f 3a30 6c61     n(Infinity_60:al
    d563:	6870 6261 7465 2029 614d 7263 286f 6150     phabet) Macro(Pa
    d573:	7472 6169 4d6c 7061 2029 754f 7074 7475     rtialMap) Output
    d583:	5528 4253 2029 6544 7562 2867 7566 6c6c     (USB) Debug(full
    d593:	0d29 000a 1b20 315b 436d 5550 4420 7465     )... .[1mCPU Det
    d5a3:	6365 6574 3a64 5b1b 6d30 2020 2000 5b1b     ected:.[0m  . .[
    d5b3:	6d31 5043 2055 6449 1b3a 305b 206d 2020     1mCPU Id:.[0m   
    d5c3:	2020 2020 0020 0a0d 2020 4928 706d 656c          ...  (Imple
    d5d3:	656d 746e 726f 003a 2829 6156 6972 6e61     mentor:.)(Varian
    d5e3:	3a74 2900 4128 6372 3a68 2900 5028 7261     t:.)(Arch:.)(Par
    d5f3:	4e74 3a6f 2900 5228 7665 7369 6f69 3a6e     tNo:.)(Revision:
    d603:	2000 5b1b 6d31 6544 6976 6563 4920 3a64     . .[1mDevice Id:
    d613:	5b1b 6d30 2020 2020 0020 0a0d 2020 5028     .[0m     ...  (P
    d623:	6e69 6f63 6e75 3a74 2900 4628 6d61 6c69     incount:.)(Famil
    d633:	3a79 2900 4428 6569 003a 2829 6552 3a76     y:.)(Die:.)(Rev:
    d643:	2000 5b1b 6d31 6c46 7361 2068 6643 3a67     . .[1mFlash Cfg:
    d653:	5b1b 6d30 2020 2020 0020 0a0d 2020 4628     .[0m     ...  (F
    d663:	656c 4e78 4d56 003a 426b 2829 4650 616c     lexNVM:.kB)(PFla
    d673:	6873 003a 426b 2829 4545 5250 4d4f 003a     sh:.kB)(EEPROM:.
    d683:	2829 4544 4150 5452 003a 1b20 315b 526d     )(DEPART:. .[1mR
    d693:	4d41 1b3a 305b 206d 2020 2020 2020 2020     AM:.[0m         
    d6a3:	2020 2000 426b 0a0d 2000 5b1b 6d31 6e55       . kB... .[1mUn
    d6b3:	7169 6575 4920 3a64 5b1b 6d30 2020 2020     ique Id:.[0m    
    d6c3:	0020                                         .

0000d6c5 <colorTestCLIDict_DescEntry>:
    d6c5:	6944 7073 616c 7379 6120 5420 7572 2065     Displays a True 
    d6d5:	6f43 6f6c 2072 4e41 4953 7420 7365 2074     Color ANSI test 
    d6e5:	6573 7571 6e65 6563 7420 206f 6574 7473     sequence to test
    d6f5:	7420 7265 696d 616e 2e6c 4920 2066 7469      terminal. If it
    d705:	6420 7369 6c70 7961 2073 6e69 6320 6c6f      displays in col
    d715:	726f 202c 6f79 2775 6572 6720 6f6f 2e64     or, you're good.
    d725:	                                             .

0000d726 <helpCLIDict_DescEntry>:
    d726:	6f59 2775 6572 6c20 6f6f 696b 676e 6120     You're looking a
    d736:	2074 7469 3a20 0050                         t it :P.

0000d73e <latencyCLIDict_DescEntry>:
    d73e:	6853 776f 6c20 7461 6e65 7963 6f20 2066     Show latency of 
    d74e:	7073 6365 6669 6369 6d20 646f 6c75 7365     specific modules
    d75e:	6120 646e 7220 756f 6974 6e69 7365 202e      and routiines. 
    d76e:	7053 6365 6669 2079 6e69 6564 2078 6f66     Specify index fo
    d77e:	2072 2061 6973 676e 656c 6920 6574 006d     r a single item.

0000d78e <ledCLIDict_DescEntry>:
    d78e:	6e45 6261 656c 2f73 6944 6173 6c62 7365     Enables/Disables
    d79e:	6920 646e 6369 7461 726f 4c20 4445 202e      indicator LED. 
    d7ae:	7254 2079 2061 6f63 7075 656c 7420 6d69     Try a couple tim
    d7be:	7365 6a20 7375 2074 6e69 6320 7361 2065     es just in case 
    d7ce:	6874 2065 454c 2044 7369 6920 206e 6e61     the LED is in an
    d7de:	6f20 6464 7320 6174 6574 0d2e 090a 1b09      odd state......
    d7ee:	335b 6d33 6157 6e72 6e69 1b67 305b 3a6d     [33mWarning.[0m:
    d7fe:	4d20 7961 6120 7664 7265 6573 796c 6120      May adversely a
    d80e:	6666 6365 2074 6f73 656d 6d20 646f 6c75     ffect some modul
    d81e:	7365 2e2e 002e                              es....

0000d824 <periodicCLIDict_DescEntry>:
    d824:	6553 2074 6874 2065 756e 626d 7265 6f20     Set the number o
    d834:	2066 6c63 636f 206b 7963 6c63 7365 6220     f clock cycles b
    d844:	7465 6577 6e65 7020 7265 6f69 6964 2063     etween periodic 
    d854:	6373 6e61 2e73 1b00 325b 0d4b 1b00 315b     scans...[2K...[1
    d864:	333b 6d34 1b3a 305b 206d                     ;34m:.[0m .

0000d86f <randCLIDict_DescEntry>:
    d86f:	6649 6520 746e 6f72 7970 6120 6176 6c69     If entropy avail
    d87f:	6261 656c 202c 7270 6e69 2074 2061 6172     able, print a ra
    d88f:	646e 6d6f 3320 2d32 6962 2074 756e 626d     ndom 32-bit numb
    d89f:	7265 002e                                   er..

0000d8a3 <reloadCLIDict_DescEntry>:
    d8a3:	6953 6e67 6c61 2073 696d 7263 636f 6e6f     Signals microcon
    d8b3:	7274 6c6f 656c 2072 6f74 7220 6665 616c     troller to refla
    d8c3:	6873 722f 6c65 616f 2e64                     sh/reload..

0000d8ce <resetCLIDict_DescEntry>:
    d8ce:	6552 6573 7374 7420 6568 7420 7265 696d     Resets the termi
    d8de:	616e 206c 6162 6b63 7420 206f 6e69 7469     nal back to init
    d8ee:	6169 206c 6573 7474 6e69 7367 002e          ial settings..

0000d8fc <restartCLIDict_DescEntry>:
    d8fc:	6553 646e 2073 2061 6f73 7466 6177 6572     Sends a software
    d90c:	7220 7365 6174 7472 202c 6873 756f 646c      restart, should
    d91c:	6220 2065 6973 696d 616c 2072 6f74 7020      be similar to p
    d92c:	776f 7265 6e69 2067 6e6f 7420 6568 6420     owering on the d
    d93c:	7665 6369 2e65 6300 656c 7261 6300 696c     evice..clear.cli
    d94c:	6544 7562 0067 6f63 6f6c 5472 7365 0074     Debug.colorTest.
    d95c:	6568 706c 6c00 7461 6e65 7963 6c00 6465     help.latency.led
    d96c:	7000 7265 6f69 6964 0063 6172 646e 7200     .periodic.rand.r
    d97c:	6c65 616f 0064 6572 6573 0074 6572 7473     eload.reset.rest
    d98c:	7261 0074 6974 6b63 7600 7265 6973 6e6f     art.tick.version
    d99c:	4b00 3031 312f 0032 324b 2f30 3232 4b00     .K10/12.K20/22.K
    d9ac:	3033 312f 2f31 3136 4b00 3034 322f 0031     30/11/61.K40/21.
    d9bc:	364b 2f30 3236 4b00 3037 3300 2d32 6970     K60/62.K70.32-pi
    d9cc:	006e 3834 702d 6e69 3600 2d34 6970 006e     n.48-pin.64-pin.
    d9dc:	3038 702d 6e69 3800 2f31 3231 2d31 6970     80-pin.81/121-pi
    d9ec:	006e 3031 2d30 6970 006e 3431 2d34 6970     n.100-pin.144-pi
    d9fc:	006e 4c57 5343 0050 3532 2d36 6970 006e     n.WLCSP.256-pin.

0000da0c <tickCLIDict_DescEntry>:
    da0c:	6944 7073 616c 7379 7420 6568 6620 6e75     Displays the fun
    da1c:	6164 656d 746e 6c61 7420 6369 206b 6973     damental tick si
    da2c:	657a 202c 6e61 2064 7563 7272 6e65 2074     ze, and current 
    da3c:	6974 6b63 2073 6973 636e 2065 616c 7473     ticks since last
    da4c:	7320 7379 6974 6b63 002e                     systick..

0000da56 <versionCLIDict_DescEntry>:
    da56:	6556 7372 6f69 206e 6e69 6f66 6d72 7461     Version informat
    da66:	6f69 206e 6261 756f 2074 6874 7369 6620     ion about this f
    da76:	7269 776d 7261 2e65 1b00 315b 353b 333b     irmware...[1;5;3
    da86:	6d31 5245 4f52 1b52 305b 206d 202d 6f4e     1mERROR.[0m - No
    da96:	6d20 726f 2065 616c 6574 636e 2079 6572      more latency re
    daa6:	6f73 7275 6563 2073 7661 6961 616c 6c62     sources availabl
    dab6:	2e65 2e2e 0a0d                               e......

0000dabd <led_pin>:
    dabd:	1300                                         ...
