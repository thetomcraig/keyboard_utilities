
kiibohd.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001537c  00002000  00002000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .usbdescriptortable 00000160  1fff8000  1fff8000  00028000  2**2
                  ALLOC
  2 .dmabuffers   00000000  1fff8160  1fff8160  000192d4  2**0
                  CONTENTS
  3 .usbbuffers   00000870  1fff8160  1fff8160  00028000  2**0
                  ALLOC
  4 .data         00000904  1fff89d0  0001737c  000189d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00002078  1fff92d4  00017c80  000192d4  2**2
                  ALLOC
  6 .debug_info   00027f3f  00000000  00000000  000192d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000596e  00000000  00000000  00041213  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000011a8  00000000  00000000  00046b81  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000027c0  00000000  00000000  00047d29  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  0001299d  00000000  00000000  0004a4e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000103ba  00000000  00000000  0005ce86  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0003c249  00000000  00000000  0006d240  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000007f  00000000  00000000  000a9489  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000033  00000000  00000000  000a9508  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00003ee4  00000000  00000000  000a953c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0000f7cf  00000000  00000000  000ad420  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00002000 <gVectors>:
    2000:	00 80 00 20 bd 21 00 00 55 25 00 00 7d 25 00 00     ... .!..U%..}%..
    2010:	c9 25 00 00 21 26 00 00 79 26 00 00 fd 24 00 00     .%..!&..y&...$..
    2020:	fd 24 00 00 fd 24 00 00 fd 24 00 00 45 25 00 00     .$...$...$..E%..
    2030:	45 25 00 00 fd 24 00 00 45 25 00 00 a1 24 00 00     E%...$..E%...$..
    2040:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2050:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2060:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2070:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2080:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2090:	45 25 00 00 45 25 00 00 b9 26 00 00 45 25 00 00     E%..E%...&..E%..
    20a0:	c9 35 00 00 ed 35 00 00 45 25 00 00 45 25 00 00     .5...5..E%..E%..
    20b0:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    20c0:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    20d0:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    20e0:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    20f0:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2100:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2110:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2120:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2130:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2140:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2150:	dd 2c 00 00 45 25 00 00 45 25 00 00 45 25 00 00     .,..E%..E%..E%..
    2160:	45 25 00 00 29 d6 00 00 45 25 00 00 45 25 00 00     E%..)...E%..E%..
    2170:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2180:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    2190:	45 25 00 00 c9 29 00 00 45 25 00 00 45 25 00 00     E%...)..E%..E%..
    21a0:	45 25 00 00 45 25 00 00 45 25 00 00 45 25 00 00     E%..E%..E%..E%..
    21b0:	45 25 00 00 45 25 00 00 45 25 00 00                 E%..E%..E%..

000021bc <ResetHandler>:

// ----- Chip Entry Point -----

__attribute__ ((section(".startup")))
void ResetHandler()
{
    21bc:	b507      	push	{r0, r1, r2, lr}
    21be:	4b46      	ldr	r3, [pc, #280]	; (22d8 <ResetHandler+0x11c>)
	// Disable Watchdog
	while ( WDOG_TMROUTL < 2 ); // Must wait for WDOG timer if already running, before jumping
    21c0:	4a46      	ldr	r2, [pc, #280]	; (22dc <ResetHandler+0x120>)
{
    21c2:	681b      	ldr	r3, [r3, #0]
    21c4:	9301      	str	r3, [sp, #4]
	while ( WDOG_TMROUTL < 2 ); // Must wait for WDOG timer if already running, before jumping
    21c6:	8813      	ldrh	r3, [r2, #0]
    21c8:	2b01      	cmp	r3, #1
    21ca:	d9fc      	bls.n	21c6 <ResetHandler+0xa>
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
    21cc:	4b44      	ldr	r3, [pc, #272]	; (22e0 <ResetHandler+0x124>)
    21ce:	f24c 5220 	movw	r2, #50464	; 0xc520
    21d2:	801a      	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
    21d4:	f64d 1228 	movw	r2, #55592	; 0xd928
    21d8:	801a      	strh	r2, [r3, #0]
	WDOG_STCTRLH &= ~WDOG_STCTRLH_WDOGEN;
    21da:	4a42      	ldr	r2, [pc, #264]	; (22e4 <ResetHandler+0x128>)
    21dc:	8813      	ldrh	r3, [r2, #0]
    21de:	f023 0301 	bic.w	r3, r3, #1
    21e2:	041b      	lsls	r3, r3, #16
    21e4:	0c1b      	lsrs	r3, r3, #16
    21e6:	8013      	strh	r3, [r2, #0]

	uint32_t *src = (uint32_t*)&_etext;
	uint32_t *dest = (uint32_t*)&_sdata;

	// Enable clocks to always-used peripherals
	SIM_SCGC5 = 0x00043F82; // Clocks active to all GPIO
    21e8:	4b3f      	ldr	r3, [pc, #252]	; (22e8 <ResetHandler+0x12c>)
    21ea:	4a40      	ldr	r2, [pc, #256]	; (22ec <ResetHandler+0x130>)
    21ec:	601a      	str	r2, [r3, #0]
	SIM_SCGC6 = SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
    21ee:	4a40      	ldr	r2, [pc, #256]	; (22f0 <ResetHandler+0x134>)
    21f0:	605a      	str	r2, [r3, #4]
#if defined(_teensy_3_0_)
	SIM_SCGC6 |= SIM_SCGC6_RTC;
#elif defined(_kii_v2_)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
    21f2:	4a40      	ldr	r2, [pc, #256]	; (22f4 <ResetHandler+0x138>)
    21f4:	f04f 6110 	mov.w	r1, #150994944	; 0x9000000
    21f8:	6011      	str	r1, [r2, #0]
	SIM_SCGC6 |= SIM_SCGC6_RTC;
    21fa:	685a      	ldr	r2, [r3, #4]
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
	// Prepare RAM
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    21fc:	493e      	ldr	r1, [pc, #248]	; (22f8 <ResetHandler+0x13c>)
	SIM_SCGC6 |= SIM_SCGC6_RTC;
    21fe:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
    2202:	605a      	str	r2, [r3, #4]
	if ( PMC_REGSC & PMC_REGSC_ACKISO )
    2204:	f503 3353 	add.w	r3, r3, #216064	; 0x34c00
    2208:	f203 33ca 	addw	r3, r3, #970	; 0x3ca
    220c:	781a      	ldrb	r2, [r3, #0]
    220e:	0710      	lsls	r0, r2, #28
		PMC_REGSC |= PMC_REGSC_ACKISO;
    2210:	bf42      	ittt	mi
    2212:	781a      	ldrbmi	r2, [r3, #0]
    2214:	f042 0208 	orrmi.w	r2, r2, #8
    2218:	701a      	strbmi	r2, [r3, #0]
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
    221a:	4b38      	ldr	r3, [pc, #224]	; (22fc <ResetHandler+0x140>)
    221c:	222a      	movs	r2, #42	; 0x2a
    221e:	701a      	strb	r2, [r3, #0]
    2220:	4a37      	ldr	r2, [pc, #220]	; (2300 <ResetHandler+0x144>)
    2222:	4b38      	ldr	r3, [pc, #224]	; (2304 <ResetHandler+0x148>)
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    2224:	428b      	cmp	r3, r1
    2226:	d34e      	bcc.n	22c6 <ResetHandler+0x10a>
	dest = (uint32_t*)&_sbss;
    2228:	4b37      	ldr	r3, [pc, #220]	; (2308 <ResetHandler+0x14c>)
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;
    222a:	4a38      	ldr	r2, [pc, #224]	; (230c <ResetHandler+0x150>)
    222c:	2100      	movs	r1, #0
    222e:	4293      	cmp	r3, r2
    2230:	d34e      	bcc.n	22d0 <ResetHandler+0x114>
    2232:	4b37      	ldr	r3, [pc, #220]	; (2310 <ResetHandler+0x154>)
	// use vector table in flash
	SCB_VTOR = 0;
#endif

	// default all interrupts to medium priority level
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
    2234:	4a37      	ldr	r2, [pc, #220]	; (2314 <ResetHandler+0x158>)
	{
		NVIC_SET_PRIORITY( i, 128 );
    2236:	2180      	movs	r1, #128	; 0x80
    2238:	f803 1b01 	strb.w	r1, [r3], #1
	for ( unsigned int i = 0; i < NVIC_NUM_INTERRUPTS; i++ )
    223c:	4293      	cmp	r3, r2
    223e:	d1fb      	bne.n	2238 <ResetHandler+0x7c>
	}

	// start in FEI mode
	// enable capacitors for crystal
	OSC0_CR = OSC_SC8P | OSC_SC2P;
    2240:	4b35      	ldr	r3, [pc, #212]	; (2318 <ResetHandler+0x15c>)
    2242:	220a      	movs	r2, #10
    2244:	701a      	strb	r2, [r3, #0]

	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0( 2 ) | MCG_C2_EREFS;
    2246:	f6a3 73ff 	subw	r3, r3, #4095	; 0xfff
    224a:	2224      	movs	r2, #36	; 0x24
    224c:	701a      	strb	r2, [r3, #0]

	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS( 2 ) | MCG_C1_FRDIV( 4 );
    224e:	22a0      	movs	r2, #160	; 0xa0
    2250:	f803 2c01 	strb.w	r2, [r3, #-1]

	// wait for crystal oscillator to begin
	while ( (MCG_S & MCG_S_OSCINIT0) == 0 );
    2254:	3305      	adds	r3, #5
    2256:	461a      	mov	r2, r3
    2258:	7819      	ldrb	r1, [r3, #0]
    225a:	0789      	lsls	r1, r1, #30
    225c:	d5fc      	bpl.n	2258 <ResetHandler+0x9c>

	// wait for FLL to use oscillator
	while ( (MCG_S & MCG_S_IREFST) != 0 );
    225e:	7813      	ldrb	r3, [r2, #0]
    2260:	06d8      	lsls	r0, r3, #27
    2262:	d4fc      	bmi.n	225e <ResetHandler+0xa2>

	// wait for MCGOUT to use oscillator
	while ( (MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST( 2 ) );
    2264:	7813      	ldrb	r3, [r2, #0]
    2266:	f003 030c 	and.w	r3, r3, #12
    226a:	2b08      	cmp	r3, #8
    226c:	d1fa      	bne.n	2264 <ResetHandler+0xa8>

	// now we're in FBE mode
#if F_CPU == 72000000
	// config PLL input for 16 MHz Crystal / 8 = 2 MHz
	MCG_C5 = MCG_C5_PRDIV0( 7 );
    226e:	4b2b      	ldr	r3, [pc, #172]	; (231c <ResetHandler+0x160>)
    2270:	2207      	movs	r2, #7
    2272:	701a      	strb	r2, [r3, #0]
	MCG_C5 = MCG_C5_PRDIV0( 3 );
#endif

#if F_CPU == 72000000
	// config PLL for 72 MHz output (36 * 2 MHz Ext PLL)
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0( 12 );
    2274:	224c      	movs	r2, #76	; 0x4c
    2276:	705a      	strb	r2, [r3, #1]
	// config PLL for 96 MHz output
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0( 0 );
#endif

	// wait for PLL to start using xtal as its input
	while ( !(MCG_S & MCG_S_PLLST) );
    2278:	3302      	adds	r3, #2
    227a:	461a      	mov	r2, r3
    227c:	7819      	ldrb	r1, [r3, #0]
    227e:	0689      	lsls	r1, r1, #26
    2280:	d5fc      	bpl.n	227c <ResetHandler+0xc0>

	// wait for PLL to lock
	while ( !(MCG_S & MCG_S_LOCK0) );
    2282:	7813      	ldrb	r3, [r2, #0]
    2284:	065b      	lsls	r3, r3, #25
    2286:	d5fc      	bpl.n	2282 <ResetHandler+0xc6>
#if F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 0 ) | SIM_CLKDIV1_OUTDIV2( 1 ) | SIM_CLKDIV1_OUTDIV4( 3 );
#elif F_CPU == 72000000
	// config divisors: 72 MHz core, 36 MHz bus, 24 MHz flash
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 0 ) | SIM_CLKDIV1_OUTDIV2( 1 ) | SIM_CLKDIV1_OUTDIV4( 2 );
    2288:	4b25      	ldr	r3, [pc, #148]	; (2320 <ResetHandler+0x164>)
    228a:	f04f 7281 	mov.w	r2, #16908288	; 0x1020000
    228e:	601a      	str	r2, [r3, #0]
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1( 3 ) | SIM_CLKDIV1_OUTDIV2( 3 ) | SIM_CLKDIV1_OUTDIV4( 3 );
#else
#error "Error, F_CPU must be 96000000, 72000000, 48000000, or 24000000"
#endif
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS( 0 ) | MCG_C1_FRDIV( 4 );
    2290:	4b24      	ldr	r3, [pc, #144]	; (2324 <ResetHandler+0x168>)
    2292:	2220      	movs	r2, #32
    2294:	701a      	strb	r2, [r3, #0]

	// wait for PLL clock to be used
	while ( (MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST( 3 ) );
    2296:	4a24      	ldr	r2, [pc, #144]	; (2328 <ResetHandler+0x16c>)
    2298:	7813      	ldrb	r3, [r2, #0]
    229a:	f003 030c 	and.w	r3, r3, #12
    229e:	2b0c      	cmp	r3, #12
    22a0:	d1fa      	bne.n	2298 <ResetHandler+0xdc>

	// now we're in PEE mode
#if F_CPU == 72000000
	// configure USB for 48 MHz clock
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV( 2 ) | SIM_CLKDIV2_USBFRAC; // USB = 72 MHz PLL / 1.5
    22a2:	4b22      	ldr	r3, [pc, #136]	; (232c <ResetHandler+0x170>)
    22a4:	2205      	movs	r2, #5
    22a6:	601a      	str	r2, [r3, #0]
	// configure USB for 48 MHz clock
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV( 1 ); // USB = 96 MHz PLL / 2
#endif

	// USB uses PLL clock, trace is CPU clock, CLKOUT=OSCERCLK0
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL( 6 );
    22a8:	4a21      	ldr	r2, [pc, #132]	; (2330 <ResetHandler+0x174>)
    22aa:	f843 2c44 	str.w	r2, [r3, #-68]

#endif

	// Initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
    22ae:	4b21      	ldr	r3, [pc, #132]	; (2334 <ResetHandler+0x178>)
    22b0:	4a21      	ldr	r2, [pc, #132]	; (2338 <ResetHandler+0x17c>)
    22b2:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
    22b4:	2207      	movs	r2, #7
    22b6:	f843 2c04 	str.w	r2, [r3, #-4]

	// Enable IRQs
	__enable_irq();
    22ba:	b662      	cpsie	i

	// Intialize entropy for random numbers
	rand_initialize();
    22bc:	f000 faf6 	bl	28ac <rand_initialize>

	// Start main
	main();
    22c0:	f000 f8ca 	bl	2458 <main>
    22c4:	e7fe      	b.n	22c4 <ResetHandler+0x108>
	while ( dest < (uint32_t*)&_edata ) *dest++ = *src++;
    22c6:	f852 0f04 	ldr.w	r0, [r2, #4]!
    22ca:	f843 0b04 	str.w	r0, [r3], #4
    22ce:	e7a9      	b.n	2224 <ResetHandler+0x68>
	while ( dest < (uint32_t*)&_ebss ) *dest++ = 0;
    22d0:	f843 1b04 	str.w	r1, [r3], #4
    22d4:	e7ab      	b.n	222e <ResetHandler+0x72>
    22d6:	bf00      	nop
    22d8:	1fff89d0 	.word	0x1fff89d0
    22dc:	40052012 	.word	0x40052012
    22e0:	4005200e 	.word	0x4005200e
    22e4:	40052000 	.word	0x40052000
    22e8:	40048038 	.word	0x40048038
    22ec:	00043f82 	.word	0x00043f82
    22f0:	0b000001 	.word	0x0b000001
    22f4:	40048030 	.word	0x40048030
    22f8:	1fff92d4 	.word	0x1fff92d4
    22fc:	4007e000 	.word	0x4007e000
    2300:	00017378 	.word	0x00017378
    2304:	1fff89d0 	.word	0x1fff89d0
    2308:	1fff92d4 	.word	0x1fff92d4
    230c:	1fffb34c 	.word	0x1fffb34c
    2310:	e000e400 	.word	0xe000e400
    2314:	e000e45f 	.word	0xe000e45f
    2318:	40065000 	.word	0x40065000
    231c:	40064004 	.word	0x40064004
    2320:	40048044 	.word	0x40048044
    2324:	40064000 	.word	0x40064000
    2328:	40064006 	.word	0x40064006
    232c:	40048048 	.word	0x40048048
    2330:	000510c0 	.word	0x000510c0
    2334:	e000e014 	.word	0xe000e014
    2338:	0001193f 	.word	0x0001193f
    233c:	00000000 	.word	0x00000000
    2340:	00000000 	.word	0x00000000
    2344:	00000000 	.word	0x00000000
    2348:	00000000 	.word	0x00000000
    234c:	00000000 	.word	0x00000000
    2350:	00000000 	.word	0x00000000
    2354:	00000000 	.word	0x00000000
    2358:	00000000 	.word	0x00000000
    235c:	00000000 	.word	0x00000000
    2360:	00000000 	.word	0x00000000
    2364:	00000000 	.word	0x00000000
    2368:	00000000 	.word	0x00000000
    236c:	00000000 	.word	0x00000000
    2370:	00000000 	.word	0x00000000
    2374:	00000000 	.word	0x00000000
    2378:	00000000 	.word	0x00000000
    237c:	00000000 	.word	0x00000000
    2380:	00000000 	.word	0x00000000
    2384:	00000000 	.word	0x00000000
    2388:	00000000 	.word	0x00000000
    238c:	00000000 	.word	0x00000000
    2390:	00000000 	.word	0x00000000
    2394:	00000000 	.word	0x00000000
    2398:	00000000 	.word	0x00000000
    239c:	00000000 	.word	0x00000000
    23a0:	00000000 	.word	0x00000000
    23a4:	00000000 	.word	0x00000000
    23a8:	00000000 	.word	0x00000000
    23ac:	00000000 	.word	0x00000000
    23b0:	00000000 	.word	0x00000000
    23b4:	00000000 	.word	0x00000000
    23b8:	00000000 	.word	0x00000000
    23bc:	00000000 	.word	0x00000000
    23c0:	00000000 	.word	0x00000000
    23c4:	00000000 	.word	0x00000000
    23c8:	00000000 	.word	0x00000000
    23cc:	00000000 	.word	0x00000000
    23d0:	00000000 	.word	0x00000000
    23d4:	00000000 	.word	0x00000000
    23d8:	00000000 	.word	0x00000000
    23dc:	00000000 	.word	0x00000000
    23e0:	00000000 	.word	0x00000000
    23e4:	00000000 	.word	0x00000000
    23e8:	00000000 	.word	0x00000000
    23ec:	00000000 	.word	0x00000000
    23f0:	00000000 	.word	0x00000000
    23f4:	00000000 	.word	0x00000000
    23f8:	00000000 	.word	0x00000000
    23fc:	00000000 	.word	0x00000000

00002400 <main_periodic>:
// And have negative effect being delayed or stretched too much
//
// Returns 1 if full rotation has completed
// Returns 0 otherwise
int main_periodic()
{
    2400:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2402:	4c13      	ldr	r4, [pc, #76]	; (2450 <main_periodic+0x50>)
	// Scan module periodic routines
	switch ( stage_tracker )
    2404:	4d13      	ldr	r5, [pc, #76]	; (2454 <main_periodic+0x54>)
{
    2406:	6823      	ldr	r3, [r4, #0]
    2408:	9301      	str	r3, [sp, #4]
	switch ( stage_tracker )
    240a:	782b      	ldrb	r3, [r5, #0]
    240c:	b2db      	uxtb	r3, r3
    240e:	2b01      	cmp	r3, #1
    2410:	d00c      	beq.n	242c <main_periodic+0x2c>
    2412:	d303      	bcc.n	241c <main_periodic+0x1c>
    2414:	2b02      	cmp	r3, #2
    2416:	d00d      	beq.n	2434 <main_periodic+0x34>

		// Full rotation
		return 1;
	}

	return 0;
    2418:	2000      	movs	r0, #0
    241a:	e010      	b.n	243e <main_periodic+0x3e>
		Scan_poll();
    241c:	f004 f8fe 	bl	661c <Scan_poll>
		if ( Scan_periodic() )
    2420:	f004 f912 	bl	6648 <Scan_periodic>
    2424:	b158      	cbz	r0, 243e <main_periodic+0x3e>
			stage_tracker = PeriodicStage_Macro;
    2426:	2301      	movs	r3, #1
		stage_tracker = PeriodicStage_Output;
    2428:	702b      	strb	r3, [r5, #0]
    242a:	e7f5      	b.n	2418 <main_periodic+0x18>
		Macro_periodic();
    242c:	f005 fc72 	bl	7d14 <Macro_periodic>
		stage_tracker = PeriodicStage_Output;
    2430:	2302      	movs	r3, #2
    2432:	e7f9      	b.n	2428 <main_periodic+0x28>
		Output_periodic();
    2434:	f009 fcba 	bl	bdac <Output_periodic>
		stage_tracker = PeriodicStage_Scan;
    2438:	2300      	movs	r3, #0
    243a:	702b      	strb	r3, [r5, #0]
		return 1;
    243c:	2001      	movs	r0, #1
}
    243e:	9a01      	ldr	r2, [sp, #4]
    2440:	6823      	ldr	r3, [r4, #0]
    2442:	429a      	cmp	r2, r3
    2444:	d001      	beq.n	244a <main_periodic+0x4a>
    2446:	f000 f973 	bl	2730 <__stack_chk_fail>
    244a:	b003      	add	sp, #12
    244c:	bd30      	pop	{r4, r5, pc}
    244e:	bf00      	nop
    2450:	1fff89d0 	.word	0x1fff89d0
    2454:	1fff92d4 	.word	0x1fff92d4

00002458 <main>:

// ----- MCU-only Functions -----
#if !defined(_host_)

int main()
{
    2458:	b507      	push	{r0, r1, r2, lr}
    245a:	4b0e      	ldr	r3, [pc, #56]	; (2494 <main+0x3c>)
    245c:	681b      	ldr	r3, [r3, #0]
    245e:	9301      	str	r3, [sp, #4]
	SEGGER_SYSVIEW_OnTaskCreate(TASK_MACRO_POLL);
	SEGGER_SYSVIEW_OnTaskCreate(TASK_OUTPUT_POLL);
#endif

	// Setup Latency Measurements
	Latency_init();
    2460:	f00c ff0c 	bl	f27c <Latency_init>

	// Enable CLI
	CLI_init();
    2464:	f00c fc40 	bl	ece8 <CLI_init>

	// Setup periodic timer function
	Periodic_function( &main_periodic );
    2468:	480b      	ldr	r0, [pc, #44]	; (2498 <main+0x40>)
    246a:	f000 fc0f 	bl	2c8c <Periodic_function>
#if Storage_Enable_define == 1
	Storage_init();
#endif

	// Setup Modules
	Output_setup();
    246e:	f009 fc77 	bl	bd60 <Output_setup>
	Macro_setup();
    2472:	f005 fd2b 	bl	7ecc <Macro_setup>
	Scan_setup();
    2476:	f004 f8b1 	bl	65dc <Scan_setup>
#if Storage_Enable_define == 1
	storage_load_settings();
#endif

	// Start scanning on first periodic loop
	stage_tracker = PeriodicStage_Scan;
    247a:	4b08      	ldr	r3, [pc, #32]	; (249c <main+0x44>)
    247c:	2200      	movs	r2, #0
    247e:	701a      	strb	r2, [r3, #0]
		// While counter-intuitive, things such as LED/Display modules should be run as poll
		// as they need to run as quickly as possible, in case there needs to be frame drops

		// Process CLI
		SEGGER_SYSVIEW_OnTaskStartExec(TASK_CLI_PROCESS);
		CLI_process();
    2480:	f00c fd56 	bl	ef30 <CLI_process>

		//SEGGER_SYSVIEW_OnIdle();

		// Scan module poll routines
		SEGGER_SYSVIEW_OnTaskStartExec(TASK_SCAN_POLL);
		Scan_poll();
    2484:	f004 f8ca 	bl	661c <Scan_poll>

		//SEGGER_SYSVIEW_OnIdle();

		// Macro module poll routines
		SEGGER_SYSVIEW_OnTaskStartExec(TASK_MACRO_POLL);
		Macro_poll();
    2488:	f005 fc32 	bl	7cf0 <Macro_poll>
		SEGGER_SYSVIEW_OnTaskTerminate(TASK_MACRO_POLL);

		// Output module poll routines
		SEGGER_SYSVIEW_OnTaskStartExec(TASK_OUTPUT_POLL);
		Output_poll();
    248c:	f009 fc7c 	bl	bd88 <Output_poll>
    2490:	e7f6      	b.n	2480 <main+0x28>
    2492:	bf00      	nop
    2494:	1fff89d0 	.word	0x1fff89d0
    2498:	00002401 	.word	0x00002401
    249c:	1fff92d4 	.word	0x1fff92d4

000024a0 <systick_default_isr>:
{
    24a0:	b507      	push	{r0, r1, r2, lr}
    24a2:	4911      	ldr	r1, [pc, #68]	; (24e8 <systick_default_isr+0x48>)
	systick_millis_count++;
    24a4:	4a11      	ldr	r2, [pc, #68]	; (24ec <systick_default_isr+0x4c>)
{
    24a6:	680b      	ldr	r3, [r1, #0]
    24a8:	9301      	str	r3, [sp, #4]
	systick_millis_count++;
    24aa:	6813      	ldr	r3, [r2, #0]
    24ac:	3301      	adds	r3, #1
    24ae:	6013      	str	r3, [r2, #0]
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    24b0:	4a0f      	ldr	r2, [pc, #60]	; (24f0 <systick_default_isr+0x50>)
    24b2:	6813      	ldr	r3, [r2, #0]
    24b4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    24b8:	6013      	str	r3, [r2, #0]
	ARM_DWT_CTRL &= ~ARM_DWT_CTRL_CYCCNTENA;
    24ba:	4b0e      	ldr	r3, [pc, #56]	; (24f4 <systick_default_isr+0x54>)
    24bc:	681a      	ldr	r2, [r3, #0]
    24be:	f022 0201 	bic.w	r2, r2, #1
    24c2:	601a      	str	r2, [r3, #0]
	if ( ARM_DWT_CYCCNT > F_CPU / 1000 + 30 )
    24c4:	4a0c      	ldr	r2, [pc, #48]	; (24f8 <systick_default_isr+0x58>)
    24c6:	6810      	ldr	r0, [r2, #0]
	ARM_DWT_CYCCNT = 0;
    24c8:	2000      	movs	r0, #0
    24ca:	6010      	str	r0, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    24cc:	681a      	ldr	r2, [r3, #0]
    24ce:	f042 0201 	orr.w	r2, r2, #1
    24d2:	601a      	str	r2, [r3, #0]
}
    24d4:	9a01      	ldr	r2, [sp, #4]
    24d6:	680b      	ldr	r3, [r1, #0]
    24d8:	429a      	cmp	r2, r3
    24da:	d001      	beq.n	24e0 <systick_default_isr+0x40>
    24dc:	f000 f928 	bl	2730 <__stack_chk_fail>
    24e0:	b003      	add	sp, #12
    24e2:	f85d fb04 	ldr.w	pc, [sp], #4
    24e6:	bf00      	nop
    24e8:	1fff89d0 	.word	0x1fff89d0
    24ec:	1fff92d8 	.word	0x1fff92d8
    24f0:	e000edfc 	.word	0xe000edfc
    24f4:	e0001000 	.word	0xe0001000
    24f8:	e0001004 	.word	0xe0001004

000024fc <fault_isr>:
{
    24fc:	b507      	push	{r0, r1, r2, lr}
    24fe:	4b0e      	ldr	r3, [pc, #56]	; (2538 <fault_isr+0x3c>)
	print("Fault!" NL );
    2500:	480e      	ldr	r0, [pc, #56]	; (253c <fault_isr+0x40>)
{
    2502:	681b      	ldr	r3, [r3, #0]
    2504:	9301      	str	r3, [sp, #4]
		if ( SIM_SCGC4 & SIM_SCGC4_USBOTG ) usb_isr();
    2506:	4d0e      	ldr	r5, [pc, #56]	; (2540 <fault_isr+0x44>)
	print("Fault!" NL );
    2508:	f00d f832 	bl	f570 <_print>
    250c:	462c      	mov	r4, r5
		if ( SIM_SCGC4 & SIM_SCGC4_USBOTG ) usb_isr();
    250e:	682b      	ldr	r3, [r5, #0]
    2510:	0358      	lsls	r0, r3, #13
    2512:	d501      	bpl.n	2518 <fault_isr+0x1c>
    2514:	f00b f888 	bl	d628 <usb_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART0 )  uart0_status_isr();
    2518:	6823      	ldr	r3, [r4, #0]
    251a:	0559      	lsls	r1, r3, #21
    251c:	d501      	bpl.n	2522 <fault_isr+0x26>
    251e:	f000 f811 	bl	2544 <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART1 )  uart1_status_isr();
    2522:	6823      	ldr	r3, [r4, #0]
    2524:	051a      	lsls	r2, r3, #20
    2526:	d501      	bpl.n	252c <fault_isr+0x30>
    2528:	f000 f80c 	bl	2544 <unused_isr>
		if ( SIM_SCGC4 & SIM_SCGC4_UART2 )  uart2_status_isr();
    252c:	6823      	ldr	r3, [r4, #0]
    252e:	04db      	lsls	r3, r3, #19
    2530:	d5ed      	bpl.n	250e <fault_isr+0x12>
    2532:	f000 f807 	bl	2544 <unused_isr>
    2536:	e7ea      	b.n	250e <fault_isr+0x12>
    2538:	1fff89d0 	.word	0x1fff89d0
    253c:	00010c85 	.word	0x00010c85
    2540:	40048034 	.word	0x40048034

00002544 <unused_isr>:
{
    2544:	b507      	push	{r0, r1, r2, lr}
    2546:	4b02      	ldr	r3, [pc, #8]	; (2550 <unused_isr+0xc>)
    2548:	681b      	ldr	r3, [r3, #0]
    254a:	9301      	str	r3, [sp, #4]
	fault_isr();
    254c:	f7ff ffd6 	bl	24fc <fault_isr>
    2550:	1fff89d0 	.word	0x1fff89d0

00002554 <nmi_default_isr>:
{
    2554:	b507      	push	{r0, r1, r2, lr}
    2556:	4b07      	ldr	r3, [pc, #28]	; (2574 <nmi_default_isr+0x20>)
    2558:	681a      	ldr	r2, [r3, #0]
    255a:	9201      	str	r2, [sp, #4]
	print("NMI!" NL );
    255c:	9a01      	ldr	r2, [sp, #4]
    255e:	681b      	ldr	r3, [r3, #0]
    2560:	429a      	cmp	r2, r3
    2562:	d001      	beq.n	2568 <nmi_default_isr+0x14>
    2564:	f000 f8e4 	bl	2730 <__stack_chk_fail>
    2568:	4803      	ldr	r0, [pc, #12]	; (2578 <nmi_default_isr+0x24>)
}
    256a:	b003      	add	sp, #12
    256c:	f85d eb04 	ldr.w	lr, [sp], #4
	print("NMI!" NL );
    2570:	f00c bffe 	b.w	f570 <_print>
    2574:	1fff89d0 	.word	0x1fff89d0
    2578:	0000fa1e 	.word	0x0000fa1e

0000257c <hard_fault_default_isr>:
{
    257c:	b513      	push	{r0, r1, r4, lr}
    257e:	4c0c      	ldr	r4, [pc, #48]	; (25b0 <hard_fault_default_isr+0x34>)
	print("Hard Fault! SCB_HFSR: ");
    2580:	480c      	ldr	r0, [pc, #48]	; (25b4 <hard_fault_default_isr+0x38>)
{
    2582:	6823      	ldr	r3, [r4, #0]
    2584:	9301      	str	r3, [sp, #4]
	print("Hard Fault! SCB_HFSR: ");
    2586:	f00c fff3 	bl	f570 <_print>
	printHex32( SCB_HFSR );
    258a:	4b0b      	ldr	r3, [pc, #44]	; (25b8 <hard_fault_default_isr+0x3c>)
    258c:	2101      	movs	r1, #1
    258e:	6818      	ldr	r0, [r3, #0]
    2590:	f00d f966 	bl	f860 <printHex32_op>
	print( NL );
    2594:	4809      	ldr	r0, [pc, #36]	; (25bc <hard_fault_default_isr+0x40>)
    2596:	f00c ffeb 	bl	f570 <_print>
	SOFTWARE_RESET();
    259a:	4b09      	ldr	r3, [pc, #36]	; (25c0 <hard_fault_default_isr+0x44>)
    259c:	4a09      	ldr	r2, [pc, #36]	; (25c4 <hard_fault_default_isr+0x48>)
    259e:	601a      	str	r2, [r3, #0]
}
    25a0:	9a01      	ldr	r2, [sp, #4]
    25a2:	6823      	ldr	r3, [r4, #0]
    25a4:	429a      	cmp	r2, r3
    25a6:	d001      	beq.n	25ac <hard_fault_default_isr+0x30>
    25a8:	f000 f8c2 	bl	2730 <__stack_chk_fail>
    25ac:	b002      	add	sp, #8
    25ae:	bd10      	pop	{r4, pc}
    25b0:	1fff89d0 	.word	0x1fff89d0
    25b4:	0000f9da 	.word	0x0000f9da
    25b8:	e000ed2c 	.word	0xe000ed2c
    25bc:	00015df4 	.word	0x00015df4
    25c0:	e000ed0c 	.word	0xe000ed0c
    25c4:	05fa0004 	.word	0x05fa0004

000025c8 <memmanage_fault_default_isr>:
{
    25c8:	b513      	push	{r0, r1, r4, lr}
    25ca:	4c0f      	ldr	r4, [pc, #60]	; (2608 <memmanage_fault_default_isr+0x40>)
	print("Memory Manager Fault! SCB_CFSR: ");
    25cc:	480f      	ldr	r0, [pc, #60]	; (260c <memmanage_fault_default_isr+0x44>)
{
    25ce:	6823      	ldr	r3, [r4, #0]
    25d0:	9301      	str	r3, [sp, #4]
	print("Memory Manager Fault! SCB_CFSR: ");
    25d2:	f00c ffcd 	bl	f570 <_print>
	printHex32( SCB_CFSR );
    25d6:	4b0e      	ldr	r3, [pc, #56]	; (2610 <memmanage_fault_default_isr+0x48>)
    25d8:	2101      	movs	r1, #1
    25da:	6818      	ldr	r0, [r3, #0]
    25dc:	f00d f940 	bl	f860 <printHex32_op>
	print(" SCB_MMAR: ");
    25e0:	480c      	ldr	r0, [pc, #48]	; (2614 <memmanage_fault_default_isr+0x4c>)
    25e2:	f00c ffc5 	bl	f570 <_print>
	printHex32( SCB_MMAR );
    25e6:	4b0c      	ldr	r3, [pc, #48]	; (2618 <memmanage_fault_default_isr+0x50>)
    25e8:	2101      	movs	r1, #1
    25ea:	6818      	ldr	r0, [r3, #0]
    25ec:	f00d f938 	bl	f860 <printHex32_op>
	print( NL );
    25f0:	9a01      	ldr	r2, [sp, #4]
    25f2:	6823      	ldr	r3, [r4, #0]
    25f4:	429a      	cmp	r2, r3
    25f6:	d001      	beq.n	25fc <memmanage_fault_default_isr+0x34>
    25f8:	f000 f89a 	bl	2730 <__stack_chk_fail>
    25fc:	4807      	ldr	r0, [pc, #28]	; (261c <memmanage_fault_default_isr+0x54>)
}
    25fe:	b002      	add	sp, #8
    2600:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    2604:	f00c bfb4 	b.w	f570 <_print>
    2608:	1fff89d0 	.word	0x1fff89d0
    260c:	0000f9f1 	.word	0x0000f9f1
    2610:	e000ed28 	.word	0xe000ed28
    2614:	0000fa12 	.word	0x0000fa12
    2618:	e000ed34 	.word	0xe000ed34
    261c:	00015df4 	.word	0x00015df4

00002620 <bus_fault_default_isr>:
{
    2620:	b513      	push	{r0, r1, r4, lr}
    2622:	4c0f      	ldr	r4, [pc, #60]	; (2660 <bus_fault_default_isr+0x40>)
	print("Bus Fault! SCB_CFSR: ");
    2624:	480f      	ldr	r0, [pc, #60]	; (2664 <bus_fault_default_isr+0x44>)
{
    2626:	6823      	ldr	r3, [r4, #0]
    2628:	9301      	str	r3, [sp, #4]
	print("Bus Fault! SCB_CFSR: ");
    262a:	f00c ffa1 	bl	f570 <_print>
	printHex32( SCB_CFSR );
    262e:	4b0e      	ldr	r3, [pc, #56]	; (2668 <bus_fault_default_isr+0x48>)
    2630:	2101      	movs	r1, #1
    2632:	6818      	ldr	r0, [r3, #0]
    2634:	f00d f914 	bl	f860 <printHex32_op>
	print(" SCB_BFAR: ");
    2638:	480c      	ldr	r0, [pc, #48]	; (266c <bus_fault_default_isr+0x4c>)
    263a:	f00c ff99 	bl	f570 <_print>
	printHex32( SCB_BFAR );
    263e:	4b0c      	ldr	r3, [pc, #48]	; (2670 <bus_fault_default_isr+0x50>)
    2640:	2101      	movs	r1, #1
    2642:	6818      	ldr	r0, [r3, #0]
    2644:	f00d f90c 	bl	f860 <printHex32_op>
	print( NL );
    2648:	9a01      	ldr	r2, [sp, #4]
    264a:	6823      	ldr	r3, [r4, #0]
    264c:	429a      	cmp	r2, r3
    264e:	d001      	beq.n	2654 <bus_fault_default_isr+0x34>
    2650:	f000 f86e 	bl	2730 <__stack_chk_fail>
    2654:	4807      	ldr	r0, [pc, #28]	; (2674 <bus_fault_default_isr+0x54>)
}
    2656:	b002      	add	sp, #8
    2658:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    265c:	f00c bf88 	b.w	f570 <_print>
    2660:	1fff89d0 	.word	0x1fff89d0
    2664:	0000f9b8 	.word	0x0000f9b8
    2668:	e000ed28 	.word	0xe000ed28
    266c:	0000f9ce 	.word	0x0000f9ce
    2670:	e000ed38 	.word	0xe000ed38
    2674:	00015df4 	.word	0x00015df4

00002678 <usage_fault_default_isr>:
{
    2678:	b513      	push	{r0, r1, r4, lr}
    267a:	4c0b      	ldr	r4, [pc, #44]	; (26a8 <usage_fault_default_isr+0x30>)
	print("Usage Fault! SCB_CFSR: ");
    267c:	480b      	ldr	r0, [pc, #44]	; (26ac <usage_fault_default_isr+0x34>)
{
    267e:	6823      	ldr	r3, [r4, #0]
    2680:	9301      	str	r3, [sp, #4]
	print("Usage Fault! SCB_CFSR: ");
    2682:	f00c ff75 	bl	f570 <_print>
	printHex32( SCB_CFSR );
    2686:	4b0a      	ldr	r3, [pc, #40]	; (26b0 <usage_fault_default_isr+0x38>)
    2688:	2101      	movs	r1, #1
    268a:	6818      	ldr	r0, [r3, #0]
    268c:	f00d f8e8 	bl	f860 <printHex32_op>
	print( NL );
    2690:	9a01      	ldr	r2, [sp, #4]
    2692:	6823      	ldr	r3, [r4, #0]
    2694:	429a      	cmp	r2, r3
    2696:	d001      	beq.n	269c <usage_fault_default_isr+0x24>
    2698:	f000 f84a 	bl	2730 <__stack_chk_fail>
    269c:	4805      	ldr	r0, [pc, #20]	; (26b4 <usage_fault_default_isr+0x3c>)
}
    269e:	b002      	add	sp, #8
    26a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    26a4:	f00c bf64 	b.w	f570 <_print>
    26a8:	1fff89d0 	.word	0x1fff89d0
    26ac:	0000fa3b 	.word	0x0000fa3b
    26b0:	e000ed28 	.word	0xe000ed28
    26b4:	00015df4 	.word	0x00015df4

000026b8 <watchdog_default_isr>:
{
    26b8:	b513      	push	{r0, r1, r4, lr}
    26ba:	4c15      	ldr	r4, [pc, #84]	; (2710 <watchdog_default_isr+0x58>)
	print("Watchdog timeout! ");
    26bc:	4815      	ldr	r0, [pc, #84]	; (2714 <watchdog_default_isr+0x5c>)
{
    26be:	6823      	ldr	r3, [r4, #0]
    26c0:	9301      	str	r3, [sp, #4]
	print("Watchdog timeout! ");
    26c2:	f00c ff55 	bl	f570 <_print>
	printHex( WDOG_TMROUTH );
    26c6:	4b14      	ldr	r3, [pc, #80]	; (2718 <watchdog_default_isr+0x60>)
    26c8:	2101      	movs	r1, #1
    26ca:	8818      	ldrh	r0, [r3, #0]
    26cc:	f00d f876 	bl	f7bc <printHex_op>
	print(" ");
    26d0:	4812      	ldr	r0, [pc, #72]	; (271c <watchdog_default_isr+0x64>)
    26d2:	f00c ff4d 	bl	f570 <_print>
	printHex( WDOG_TMROUTL );
    26d6:	4b12      	ldr	r3, [pc, #72]	; (2720 <watchdog_default_isr+0x68>)
    26d8:	2101      	movs	r1, #1
    26da:	8818      	ldrh	r0, [r3, #0]
    26dc:	f00d f86e 	bl	f7bc <printHex_op>
	print( NL );
    26e0:	4810      	ldr	r0, [pc, #64]	; (2724 <watchdog_default_isr+0x6c>)
    26e2:	f00c ff45 	bl	f570 <_print>
	print("Watchdog Reset Count: ");
    26e6:	4810      	ldr	r0, [pc, #64]	; (2728 <watchdog_default_isr+0x70>)
    26e8:	f00c ff42 	bl	f570 <_print>
	printHex( WDOG_RSTCNT );
    26ec:	4b0f      	ldr	r3, [pc, #60]	; (272c <watchdog_default_isr+0x74>)
    26ee:	2101      	movs	r1, #1
    26f0:	8818      	ldrh	r0, [r3, #0]
    26f2:	f00d f863 	bl	f7bc <printHex_op>
	print( NL );
    26f6:	9a01      	ldr	r2, [sp, #4]
    26f8:	6823      	ldr	r3, [r4, #0]
    26fa:	429a      	cmp	r2, r3
    26fc:	d001      	beq.n	2702 <watchdog_default_isr+0x4a>
    26fe:	f000 f817 	bl	2730 <__stack_chk_fail>
    2702:	4808      	ldr	r0, [pc, #32]	; (2724 <watchdog_default_isr+0x6c>)
}
    2704:	b002      	add	sp, #8
    2706:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    270a:	f00c bf31 	b.w	f570 <_print>
    270e:	bf00      	nop
    2710:	1fff89d0 	.word	0x1fff89d0
    2714:	0000fa53 	.word	0x0000fa53
    2718:	40052010 	.word	0x40052010
    271c:	00016f5e 	.word	0x00016f5e
    2720:	40052012 	.word	0x40052012
    2724:	00015df4 	.word	0x00015df4
    2728:	0000fa66 	.word	0x0000fa66
    272c:	40052014 	.word	0x40052014

00002730 <__stack_chk_fail>:
{
    2730:	b507      	push	{r0, r1, r2, lr}
    2732:	4b04      	ldr	r3, [pc, #16]	; (2744 <__stack_chk_fail+0x14>)
	print("Segfault!" NL );
    2734:	4804      	ldr	r0, [pc, #16]	; (2748 <__stack_chk_fail+0x18>)
{
    2736:	681b      	ldr	r3, [r3, #0]
    2738:	9301      	str	r3, [sp, #4]
	print("Segfault!" NL );
    273a:	f00c ff19 	bl	f570 <_print>
	fault_isr();
    273e:	f7ff fedd 	bl	24fc <fault_isr>
    2742:	bf00      	nop
    2744:	1fff89d0 	.word	0x1fff89d0
    2748:	0000f9ac 	.word	0x0000f9ac

0000274c <memset>:
{
    274c:	b513      	push	{r0, r1, r4, lr}
    274e:	4b09      	ldr	r3, [pc, #36]	; (2774 <memset+0x28>)
    2750:	681c      	ldr	r4, [r3, #0]
    2752:	9401      	str	r4, [sp, #4]
    2754:	4402      	add	r2, r0
	char *buf = addr;
    2756:	4604      	mov	r4, r0
	for (; len > 0; --len, ++buf)
    2758:	4294      	cmp	r4, r2
    275a:	d105      	bne.n	2768 <memset+0x1c>
}
    275c:	9a01      	ldr	r2, [sp, #4]
    275e:	681b      	ldr	r3, [r3, #0]
    2760:	429a      	cmp	r2, r3
    2762:	d004      	beq.n	276e <memset+0x22>
    2764:	f7ff ffe4 	bl	2730 <__stack_chk_fail>
		*buf = val;
    2768:	f804 1b01 	strb.w	r1, [r4], #1
    276c:	e7f4      	b.n	2758 <memset+0xc>
}
    276e:	b002      	add	sp, #8
    2770:	bd10      	pop	{r4, pc}
    2772:	bf00      	nop
    2774:	1fff89d0 	.word	0x1fff89d0

00002778 <memcpy>:
{
    2778:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    277a:	4b11      	ldr	r3, [pc, #68]	; (27c0 <memcpy+0x48>)
    277c:	681c      	ldr	r4, [r3, #0]
    277e:	9401      	str	r4, [sp, #4]
	uint32_t endLen = len & 0x03;
    2780:	f002 0403 	and.w	r4, r2, #3
    2784:	f022 0203 	bic.w	r2, r2, #3
    2788:	1f05      	subs	r5, r0, #4
    278a:	188e      	adds	r6, r1, r2
	for ( i = 0; i < numLongs; i++ )
    278c:	42b1      	cmp	r1, r6
    278e:	d10a      	bne.n	27a6 <memcpy+0x2e>
    2790:	4402      	add	r2, r0
    2792:	3901      	subs	r1, #1
    2794:	4414      	add	r4, r2
	for (; endLen > 0; --endLen, ++dstbuf, ++srcbuf)
    2796:	42a2      	cmp	r2, r4
    2798:	d10a      	bne.n	27b0 <memcpy+0x38>
}
    279a:	9a01      	ldr	r2, [sp, #4]
    279c:	681b      	ldr	r3, [r3, #0]
    279e:	429a      	cmp	r2, r3
    27a0:	d00b      	beq.n	27ba <memcpy+0x42>
    27a2:	f7ff ffc5 	bl	2730 <__stack_chk_fail>
		*pLongDest++ = *pLongSrc++;
    27a6:	f851 7b04 	ldr.w	r7, [r1], #4
    27aa:	f845 7f04 	str.w	r7, [r5, #4]!
    27ae:	e7ed      	b.n	278c <memcpy+0x14>
		*dstbuf = *srcbuf;
    27b0:	f811 5f01 	ldrb.w	r5, [r1, #1]!
    27b4:	f802 5b01 	strb.w	r5, [r2], #1
    27b8:	e7ed      	b.n	2796 <memcpy+0x1e>
}
    27ba:	b003      	add	sp, #12
    27bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    27be:	bf00      	nop
    27c0:	1fff89d0 	.word	0x1fff89d0

000027c4 <us_now>:
// Current us count for CPU
// Uses both cycle count and systick
// TODO (HaaTa) - Make it possible to use dynamic F_CPU
//                Possibly using a table of supported frequencies?
uint32_t us_now()
{
    27c4:	b507      	push	{r0, r1, r2, lr}
    27c6:	4a12      	ldr	r2, [pc, #72]	; (2810 <us_now+0x4c>)
    27c8:	6813      	ldr	r3, [r2, #0]
    27ca:	9301      	str	r3, [sp, #4]
	uint32_t count;
	uint32_t current;
	uint32_t pending;

	// Snapshot both the cycle count and ms counter
	__disable_irq();
    27cc:	b672      	cpsid	i

	count = systick_millis_count;
    27ce:	4b11      	ldr	r3, [pc, #68]	; (2814 <us_now+0x50>)
	current  = cycle_now();

	#if defined(_kinetis_)
	pending = SCB_ICSR & SCB_ICSR_PENDSTSET; // bit 26 indicates if systick exception pending
    27d0:	4811      	ldr	r0, [pc, #68]	; (2818 <us_now+0x54>)
	count = systick_millis_count;
    27d2:	6819      	ldr	r1, [r3, #0]
	return SYST_CVR;
    27d4:	4b11      	ldr	r3, [pc, #68]	; (281c <us_now+0x58>)
    27d6:	681b      	ldr	r3, [r3, #0]
	pending = SCB_ICSR & SCB_ICSR_PENDSTSET; // bit 26 indicates if systick exception pending
    27d8:	6800      	ldr	r0, [r0, #0]
	#elif defined(_sam_)
	pending = SCB->ICSR & SCB_ICSR_PENDSTSET_Msk;
	#endif

	__enable_irq();
    27da:	b662      	cpsie	i

	// Check for pending systick, and increment if one is it was
	if ( pending && current > ( ( F_CPU / 1000 ) - 50 ) )
    27dc:	0140      	lsls	r0, r0, #5
    27de:	d503      	bpl.n	27e8 <us_now+0x24>
    27e0:	480f      	ldr	r0, [pc, #60]	; (2820 <us_now+0x5c>)
    27e2:	4283      	cmp	r3, r0
	{
		count++;
    27e4:	bf88      	it	hi
    27e6:	3101      	addhi	r1, #1
	}
	// Determine cycles since systick (approx.)
	current = ( ( F_CPU / 1000 ) - 1 ) - current;
    27e8:	f5c3 338c 	rsb	r3, r3, #71680	; 0x11800

	// Add ms and cycles (since systick), converted as us
	return count * 1000 + current / ( F_CPU / 1000000 );
    27ec:	2048      	movs	r0, #72	; 0x48
	current = ( ( F_CPU / 1000 ) - 1 ) - current;
    27ee:	f203 133f 	addw	r3, r3, #319	; 0x13f
	return count * 1000 + current / ( F_CPU / 1000000 );
    27f2:	fbb3 f3f0 	udiv	r3, r3, r0
#else
#warning "us_now not implemented"
	return 0;
#endif
}
    27f6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    27fa:	fb00 3001 	mla	r0, r0, r1, r3
    27fe:	9901      	ldr	r1, [sp, #4]
    2800:	6813      	ldr	r3, [r2, #0]
    2802:	4299      	cmp	r1, r3
    2804:	d001      	beq.n	280a <us_now+0x46>
    2806:	f7ff ff93 	bl	2730 <__stack_chk_fail>
    280a:	b003      	add	sp, #12
    280c:	f85d fb04 	ldr.w	pc, [sp], #4
    2810:	1fff89d0 	.word	0x1fff89d0
    2814:	1fff92d8 	.word	0x1fff92d8
    2818:	e000ed04 	.word	0xe000ed04
    281c:	e000e018 	.word	0xe000e018
    2820:	0001190e 	.word	0x0001190e

00002824 <yield>:


// - Misc Functions -

void yield()
{
    2824:	b507      	push	{r0, r1, r2, lr}
    2826:	4b06      	ldr	r3, [pc, #24]	; (2840 <yield+0x1c>)
    2828:	681a      	ldr	r2, [r3, #0]
    282a:	9201      	str	r2, [sp, #4]
}
    282c:	9a01      	ldr	r2, [sp, #4]
    282e:	681b      	ldr	r3, [r3, #0]
    2830:	429a      	cmp	r2, r3
    2832:	d001      	beq.n	2838 <yield+0x14>
    2834:	f7ff ff7c 	bl	2730 <__stack_chk_fail>
    2838:	b003      	add	sp, #12
    283a:	f85d fb04 	ldr.w	pc, [sp], #4
    283e:	bf00      	nop
    2840:	1fff89d0 	.word	0x1fff89d0

00002844 <delay_us>:
{
    2844:	b573      	push	{r0, r1, r4, r5, r6, lr}
    2846:	4c0b      	ldr	r4, [pc, #44]	; (2874 <delay_us+0x30>)
    2848:	6823      	ldr	r3, [r4, #0]
    284a:	9301      	str	r3, [sp, #4]
    284c:	4605      	mov	r5, r0
	uint32_t start = us_now();
    284e:	f7ff ffb9 	bl	27c4 <us_now>
    2852:	4606      	mov	r6, r0
	while ( us_now() - start <= us )
    2854:	f7ff ffb6 	bl	27c4 <us_now>
    2858:	1b80      	subs	r0, r0, r6
    285a:	42a8      	cmp	r0, r5
    285c:	d905      	bls.n	286a <delay_us+0x26>
}
    285e:	9a01      	ldr	r2, [sp, #4]
    2860:	6823      	ldr	r3, [r4, #0]
    2862:	429a      	cmp	r2, r3
    2864:	d004      	beq.n	2870 <delay_us+0x2c>
    2866:	f7ff ff63 	bl	2730 <__stack_chk_fail>
		yield();
    286a:	f7ff ffdb 	bl	2824 <yield>
    286e:	e7f1      	b.n	2854 <delay_us+0x10>
}
    2870:	b002      	add	sp, #8
    2872:	bd70      	pop	{r4, r5, r6, pc}
    2874:	1fff89d0 	.word	0x1fff89d0

00002878 <delay_ms>:
{
    2878:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    287a:	4c0a      	ldr	r4, [pc, #40]	; (28a4 <delay_ms+0x2c>)
	return systick_millis_count; // single aligned 32 bit is atomic;
    287c:	4d0a      	ldr	r5, [pc, #40]	; (28a8 <delay_ms+0x30>)
{
    287e:	6822      	ldr	r2, [r4, #0]
    2880:	9201      	str	r2, [sp, #4]
	return systick_millis_count; // single aligned 32 bit is atomic;
    2882:	682f      	ldr	r7, [r5, #0]
{
    2884:	4606      	mov	r6, r0
	return systick_millis_count; // single aligned 32 bit is atomic;
    2886:	682b      	ldr	r3, [r5, #0]
	while ( ms_now() - start <= ms )
    2888:	1bdb      	subs	r3, r3, r7
    288a:	42b3      	cmp	r3, r6
    288c:	d905      	bls.n	289a <delay_ms+0x22>
}
    288e:	9a01      	ldr	r2, [sp, #4]
    2890:	6823      	ldr	r3, [r4, #0]
    2892:	429a      	cmp	r2, r3
    2894:	d004      	beq.n	28a0 <delay_ms+0x28>
    2896:	f7ff ff4b 	bl	2730 <__stack_chk_fail>
		yield();
    289a:	f7ff ffc3 	bl	2824 <yield>
    289e:	e7f2      	b.n	2886 <delay_ms+0xe>
}
    28a0:	b003      	add	sp, #12
    28a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    28a4:	1fff89d0 	.word	0x1fff89d0
    28a8:	1fff92d8 	.word	0x1fff92d8

000028ac <rand_initialize>:
// This function initializes the global variables needed to implement the circular entropy pool and
// the buffer that holds the raw Timer 1 values that are used to create the entropy pool.  It then
// Initializes the Low Power Timer (LPTMR) to perform an interrupt every 2048 clock cycles, (about
// 16 ms) which is as fast as it can be set.
void rand_initialize()
{
    28ac:	b507      	push	{r0, r1, r2, lr}
    28ae:	4a14      	ldr	r2, [pc, #80]	; (2900 <rand_initialize+0x54>)
	gWDT_buffer_position = 0;
    28b0:	4914      	ldr	r1, [pc, #80]	; (2904 <rand_initialize+0x58>)
{
    28b2:	6813      	ldr	r3, [r2, #0]
    28b4:	9301      	str	r3, [sp, #4]
	gWDT_buffer_position = 0;
    28b6:	2300      	movs	r3, #0
    28b8:	700b      	strb	r3, [r1, #0]
	gWDT_pool_start = 0;
    28ba:	4913      	ldr	r1, [pc, #76]	; (2908 <rand_initialize+0x5c>)
    28bc:	700b      	strb	r3, [r1, #0]
	gWDT_pool_end = 0;
    28be:	4913      	ldr	r1, [pc, #76]	; (290c <rand_initialize+0x60>)
    28c0:	700b      	strb	r3, [r1, #0]
	gWDT_pool_count = 0;
    28c2:	4913      	ldr	r1, [pc, #76]	; (2910 <rand_initialize+0x64>)
    28c4:	700b      	strb	r3, [r1, #0]

	SIM_SCGC5 |= SIM_SCGC5_LPTIMER;
    28c6:	4913      	ldr	r1, [pc, #76]	; (2914 <rand_initialize+0x68>)
    28c8:	680b      	ldr	r3, [r1, #0]
    28ca:	f043 0301 	orr.w	r3, r3, #1
    28ce:	600b      	str	r3, [r1, #0]
	LPTMR0_CSR = 0b10000100;
    28d0:	4b11      	ldr	r3, [pc, #68]	; (2918 <rand_initialize+0x6c>)
    28d2:	2184      	movs	r1, #132	; 0x84
    28d4:	6019      	str	r1, [r3, #0]
	LPTMR0_PSR = 0b00000101; // PCS=01 : 1 kHz clock
    28d6:	4911      	ldr	r1, [pc, #68]	; (291c <rand_initialize+0x70>)
    28d8:	2005      	movs	r0, #5
    28da:	6008      	str	r0, [r1, #0]
	LPTMR0_CMR = 0x0006;     // smaller number = faster random numbers...
    28dc:	2006      	movs	r0, #6
    28de:	6048      	str	r0, [r1, #4]
	LPTMR0_CSR = 0b01000101;
    28e0:	2145      	movs	r1, #69	; 0x45
    28e2:	6019      	str	r1, [r3, #0]
	NVIC_ENABLE_IRQ( IRQ_LPTMR );
    28e4:	4b0e      	ldr	r3, [pc, #56]	; (2920 <rand_initialize+0x74>)
    28e6:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
    28ea:	6019      	str	r1, [r3, #0]
}
    28ec:	9901      	ldr	r1, [sp, #4]
    28ee:	6813      	ldr	r3, [r2, #0]
    28f0:	4299      	cmp	r1, r3
    28f2:	d001      	beq.n	28f8 <rand_initialize+0x4c>
    28f4:	f7ff ff1c 	bl	2730 <__stack_chk_fail>
    28f8:	b003      	add	sp, #12
    28fa:	f85d fb04 	ldr.w	pc, [sp], #4
    28fe:	bf00      	nop
    2900:	1fff89d0 	.word	0x1fff89d0
    2904:	1fff9ecc 	.word	0x1fff9ecc
    2908:	1fff9eee 	.word	0x1fff9eee
    290c:	1fff9eef 	.word	0x1fff9eef
    2910:	1fff9eed 	.word	0x1fff9eed
    2914:	40048038 	.word	0x40048038
    2918:	40040000 	.word	0x40040000
    291c:	40040004 	.word	0x40040004
    2920:	e000e108 	.word	0xe000e108

00002924 <rand_value32>:
// otherwise.  To ensure a proper random return the available() function
// should be called first to ensure that entropy exists.
//
// The pool is implemented as an 8 value circular buffer
uint32_t rand_value32()
{
    2924:	b537      	push	{r0, r1, r2, r4, r5, lr}
    2926:	4c1a      	ldr	r4, [pc, #104]	; (2990 <rand_value32+0x6c>)
    2928:	6822      	ldr	r2, [r4, #0]
    292a:	9201      	str	r2, [sp, #4]
	uint32_t retVal = 0;
	uint8_t waiting;
	while ( gWDT_pool_count < 1 )
    292c:	4a19      	ldr	r2, [pc, #100]	; (2994 <rand_value32+0x70>)
    292e:	7813      	ldrb	r3, [r2, #0]
    2930:	2b00      	cmp	r3, #0
    2932:	d0fc      	beq.n	292e <rand_value32+0xa>

// returns 0 if interrupts enabled, 1 if disabled
static __inline__ uint32_t __get_primask()
{
	uint32_t primask = 0;
	__asm__ volatile ("MRS %[result], PRIMASK\n\t":[result]"=r"(primask)::);
    2934:	f3ef 8510 	mrs	r5, PRIMASK
	return 1;
}

static __inline__ uint32_t __iCliRetVal()
{
	__asm__ volatile ("CPSID i\n\t""dmb\n\t""dsb\n\t""isb\n\t");
    2938:	b672      	cpsid	i
    293a:	f3bf 8f5f 	dmb	sy
    293e:	f3bf 8f4f 	dsb	sy
    2942:	f3bf 8f6f 	isb	sy
		waiting += 1;
	}

	ATOMIC_BLOCK( ATOMIC_RESTORESTATE )
	{
		retVal = gWDT_entropy_pool[gWDT_pool_start];
    2946:	4914      	ldr	r1, [pc, #80]	; (2998 <rand_value32+0x74>)
    2948:	4814      	ldr	r0, [pc, #80]	; (299c <rand_value32+0x78>)
    294a:	780b      	ldrb	r3, [r1, #0]
    294c:	b2db      	uxtb	r3, r3
    294e:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
		gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    2952:	780b      	ldrb	r3, [r1, #0]
    2954:	3301      	adds	r3, #1
    2956:	f003 0307 	and.w	r3, r3, #7
    295a:	700b      	strb	r3, [r1, #0]
		--gWDT_pool_count;
    295c:	7813      	ldrb	r3, [r2, #0]
    295e:	3b01      	subs	r3, #1
    2960:	b2db      	uxtb	r3, r3
    2962:	7013      	strb	r3, [r2, #0]
	__asm__ volatile ("MSR PRIMASK, %[value]\n\t""dmb\n\t""dsb\n\t""isb\n\t"::[value]"r"(setval):);
    2964:	f385 8810 	msr	PRIMASK, r5
    2968:	f3bf 8f5f 	dmb	sy
    296c:	f3bf 8f4f 	dsb	sy
    2970:	f3bf 8f6f 	isb	sy
	(void)__s;
}

static __inline__ void __iRestore( const  uint32_t *__s )
{
	__set_primask(*__s); __asm__ volatile ("dmb\n\t""dsb\n\t""isb\n\t");
    2974:	f3bf 8f5f 	dmb	sy
    2978:	f3bf 8f4f 	dsb	sy
    297c:	f3bf 8f6f 	isb	sy
	}

	return retVal;
}
    2980:	9a01      	ldr	r2, [sp, #4]
    2982:	6823      	ldr	r3, [r4, #0]
    2984:	429a      	cmp	r2, r3
    2986:	d001      	beq.n	298c <rand_value32+0x68>
    2988:	f7ff fed2 	bl	2730 <__stack_chk_fail>
    298c:	b003      	add	sp, #12
    298e:	bd30      	pop	{r4, r5, pc}
    2990:	1fff89d0 	.word	0x1fff89d0
    2994:	1fff9eed 	.word	0x1fff9eed
    2998:	1fff9eee 	.word	0x1fff9eee
    299c:	1fff9eac 	.word	0x1fff9eac

000029a0 <rand_available>:


// This function returns a unsigned char (8-bit) with the number of unsigned long values
// in the entropy pool
uint8_t rand_available()
{
    29a0:	b507      	push	{r0, r1, r2, lr}
    29a2:	4b07      	ldr	r3, [pc, #28]	; (29c0 <rand_available+0x20>)
    29a4:	681a      	ldr	r2, [r3, #0]
    29a6:	9201      	str	r2, [sp, #4]
	return gWDT_pool_count;
    29a8:	4a06      	ldr	r2, [pc, #24]	; (29c4 <rand_available+0x24>)
    29aa:	7810      	ldrb	r0, [r2, #0]
}
    29ac:	9a01      	ldr	r2, [sp, #4]
    29ae:	681b      	ldr	r3, [r3, #0]
    29b0:	429a      	cmp	r2, r3
    29b2:	d001      	beq.n	29b8 <rand_available+0x18>
    29b4:	f7ff febc 	bl	2730 <__stack_chk_fail>
    29b8:	b003      	add	sp, #12
    29ba:	f85d fb04 	ldr.w	pc, [sp], #4
    29be:	bf00      	nop
    29c0:	1fff89d0 	.word	0x1fff89d0
    29c4:	1fff9eed 	.word	0x1fff9eed

000029c8 <lptmr_isr>:


// ----- Interrupts -----

void lptmr_isr()
{
    29c8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    29cc:	4e44      	ldr	r6, [pc, #272]	; (2ae0 <lptmr_isr+0x118>)
	gWDT_buffer[gWDT_buffer_position] = val;
    29ce:	4c45      	ldr	r4, [pc, #276]	; (2ae4 <lptmr_isr+0x11c>)
{
    29d0:	6833      	ldr	r3, [r6, #0]
    29d2:	9301      	str	r3, [sp, #4]
	LPTMR0_CSR = 0b10000100;
    29d4:	4b44      	ldr	r3, [pc, #272]	; (2ae8 <lptmr_isr+0x120>)
    29d6:	2284      	movs	r2, #132	; 0x84
    29d8:	601a      	str	r2, [r3, #0]
	LPTMR0_CSR = 0b01000101;
    29da:	2245      	movs	r2, #69	; 0x45
    29dc:	601a      	str	r2, [r3, #0]
	isr_hardware_neutral(SYST_CVR);
    29de:	4b43      	ldr	r3, [pc, #268]	; (2aec <lptmr_isr+0x124>)
	gWDT_buffer[gWDT_buffer_position] = val;
    29e0:	4a43      	ldr	r2, [pc, #268]	; (2af0 <lptmr_isr+0x128>)
	isr_hardware_neutral(SYST_CVR);
    29e2:	6819      	ldr	r1, [r3, #0]
	gWDT_buffer[gWDT_buffer_position] = val;
    29e4:	7823      	ldrb	r3, [r4, #0]
	isr_hardware_neutral(SYST_CVR);
    29e6:	54d1      	strb	r1, [r2, r3]
	gWDT_buffer_position++; // every time the WDT interrupt is triggered
    29e8:	3301      	adds	r3, #1
    29ea:	b2db      	uxtb	r3, r3
	if ( gWDT_buffer_position >= gWDT_buffer_SIZE )
    29ec:	2b1f      	cmp	r3, #31
	gWDT_buffer_position++; // every time the WDT interrupt is triggered
    29ee:	7023      	strb	r3, [r4, #0]
    29f0:	4694      	mov	ip, r2
	if ( gWDT_buffer_position >= gWDT_buffer_SIZE )
    29f2:	d96b      	bls.n	2acc <lptmr_isr+0x104>
		gWDT_pool_end = (gWDT_pool_start + gWDT_pool_count) % WDT_POOL_SIZE;
    29f4:	483f      	ldr	r0, [pc, #252]	; (2af4 <lptmr_isr+0x12c>)
    29f6:	4940      	ldr	r1, [pc, #256]	; (2af8 <lptmr_isr+0x130>)
    29f8:	7803      	ldrb	r3, [r0, #0]
    29fa:	780a      	ldrb	r2, [r1, #0]
    29fc:	4413      	add	r3, r2
    29fe:	4a3f      	ldr	r2, [pc, #252]	; (2afc <lptmr_isr+0x134>)
    2a00:	f003 0307 	and.w	r3, r3, #7
    2a04:	7013      	strb	r3, [r2, #0]
			gWDT_entropy_pool[gWDT_pool_end] += gWDT_buffer[gWDT_loop_counter];
    2a06:	4b3e      	ldr	r3, [pc, #248]	; (2b00 <lptmr_isr+0x138>)
		gWDT_pool_end = (gWDT_pool_start + gWDT_pool_count) % WDT_POOL_SIZE;
    2a08:	2500      	movs	r5, #0
			gWDT_entropy_pool[gWDT_pool_end] += gWDT_buffer[gWDT_loop_counter];
    2a0a:	7817      	ldrb	r7, [r2, #0]
    2a0c:	f81c e005 	ldrb.w	lr, [ip, r5]
    2a10:	b2ff      	uxtb	r7, r7
    2a12:	3501      	adds	r5, #1
    2a14:	f853 8027 	ldr.w	r8, [r3, r7, lsl #2]
    2a18:	44c6      	add	lr, r8
    2a1a:	f843 e027 	str.w	lr, [r3, r7, lsl #2]
			gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 10);
    2a1e:	7817      	ldrb	r7, [r2, #0]
    2a20:	b2ff      	uxtb	r7, r7
		for ( gWDT_loop_counter = 0; gWDT_loop_counter < gWDT_buffer_SIZE; ++gWDT_loop_counter )
    2a22:	2d20      	cmp	r5, #32
			gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 10);
    2a24:	f853 8027 	ldr.w	r8, [r3, r7, lsl #2]
    2a28:	7817      	ldrb	r7, [r2, #0]
    2a2a:	b2ff      	uxtb	r7, r7
    2a2c:	f853 e027 	ldr.w	lr, [r3, r7, lsl #2]
    2a30:	eb0e 2e88 	add.w	lr, lr, r8, lsl #10
    2a34:	f843 e027 	str.w	lr, [r3, r7, lsl #2]
			gWDT_entropy_pool[gWDT_pool_end] ^= (gWDT_entropy_pool[gWDT_pool_end] >> 6);
    2a38:	7817      	ldrb	r7, [r2, #0]
    2a3a:	b2ff      	uxtb	r7, r7
    2a3c:	f853 8027 	ldr.w	r8, [r3, r7, lsl #2]
    2a40:	7817      	ldrb	r7, [r2, #0]
    2a42:	b2ff      	uxtb	r7, r7
    2a44:	f853 e027 	ldr.w	lr, [r3, r7, lsl #2]
    2a48:	ea8e 1e98 	eor.w	lr, lr, r8, lsr #6
    2a4c:	f843 e027 	str.w	lr, [r3, r7, lsl #2]
		for ( gWDT_loop_counter = 0; gWDT_loop_counter < gWDT_buffer_SIZE; ++gWDT_loop_counter )
    2a50:	d1db      	bne.n	2a0a <lptmr_isr+0x42>
    2a52:	4f2c      	ldr	r7, [pc, #176]	; (2b04 <lptmr_isr+0x13c>)
    2a54:	703d      	strb	r5, [r7, #0]
		gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 3);
    2a56:	7815      	ldrb	r5, [r2, #0]
    2a58:	b2ed      	uxtb	r5, r5
    2a5a:	f853 c025 	ldr.w	ip, [r3, r5, lsl #2]
    2a5e:	7815      	ldrb	r5, [r2, #0]
    2a60:	b2ed      	uxtb	r5, r5
    2a62:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    2a66:	eb07 07cc 	add.w	r7, r7, ip, lsl #3
    2a6a:	f843 7025 	str.w	r7, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] ^= (gWDT_entropy_pool[gWDT_pool_end] >> 11);
    2a6e:	7815      	ldrb	r5, [r2, #0]
    2a70:	b2ed      	uxtb	r5, r5
    2a72:	f853 c025 	ldr.w	ip, [r3, r5, lsl #2]
    2a76:	7815      	ldrb	r5, [r2, #0]
    2a78:	b2ed      	uxtb	r5, r5
    2a7a:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    2a7e:	ea87 27dc 	eor.w	r7, r7, ip, lsr #11
    2a82:	f843 7025 	str.w	r7, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] += (gWDT_entropy_pool[gWDT_pool_end] << 15);
    2a86:	7815      	ldrb	r5, [r2, #0]
    2a88:	b2ed      	uxtb	r5, r5
    2a8a:	f853 c025 	ldr.w	ip, [r3, r5, lsl #2]
    2a8e:	7815      	ldrb	r5, [r2, #0]
    2a90:	b2ed      	uxtb	r5, r5
    2a92:	f853 7025 	ldr.w	r7, [r3, r5, lsl #2]
    2a96:	eb07 37cc 	add.w	r7, r7, ip, lsl #15
    2a9a:	f843 7025 	str.w	r7, [r3, r5, lsl #2]
		gWDT_entropy_pool[gWDT_pool_end] = gWDT_entropy_pool[gWDT_pool_end];
    2a9e:	7815      	ldrb	r5, [r2, #0]
    2aa0:	7812      	ldrb	r2, [r2, #0]
    2aa2:	b2ed      	uxtb	r5, r5
    2aa4:	b2d2      	uxtb	r2, r2
    2aa6:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
    2aaa:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
		gWDT_buffer_position = 0;
    2aae:	2300      	movs	r3, #0
    2ab0:	7023      	strb	r3, [r4, #0]
		if (gWDT_pool_count == WDT_POOL_SIZE)
    2ab2:	780b      	ldrb	r3, [r1, #0]
    2ab4:	2b08      	cmp	r3, #8
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    2ab6:	bf0b      	itete	eq
    2ab8:	7803      	ldrbeq	r3, [r0, #0]
			++gWDT_pool_count;
    2aba:	780b      	ldrbne	r3, [r1, #0]
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    2abc:	3301      	addeq	r3, #1
			++gWDT_pool_count;
    2abe:	3301      	addne	r3, #1
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    2ac0:	bf0b      	itete	eq
    2ac2:	f003 0307 	andeq.w	r3, r3, #7
			++gWDT_pool_count;
    2ac6:	b2db      	uxtbne	r3, r3
			gWDT_pool_start = (gWDT_pool_start + 1) % WDT_POOL_SIZE;
    2ac8:	7003      	strbeq	r3, [r0, #0]
			++gWDT_pool_count;
    2aca:	700b      	strbne	r3, [r1, #0]
}
    2acc:	9a01      	ldr	r2, [sp, #4]
    2ace:	6833      	ldr	r3, [r6, #0]
    2ad0:	429a      	cmp	r2, r3
    2ad2:	d001      	beq.n	2ad8 <lptmr_isr+0x110>
    2ad4:	f7ff fe2c 	bl	2730 <__stack_chk_fail>
    2ad8:	b002      	add	sp, #8
    2ada:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2ade:	bf00      	nop
    2ae0:	1fff89d0 	.word	0x1fff89d0
    2ae4:	1fff9ecc 	.word	0x1fff9ecc
    2ae8:	40040000 	.word	0x40040000
    2aec:	e000e018 	.word	0xe000e018
    2af0:	1fff9ecd 	.word	0x1fff9ecd
    2af4:	1fff9eee 	.word	0x1fff9eee
    2af8:	1fff9eed 	.word	0x1fff9eed
    2afc:	1fff9eef 	.word	0x1fff9eef
    2b00:	1fff9eac 	.word	0x1fff9eac
    2b04:	1fff9ef0 	.word	0x1fff9ef0

00002b08 <GPIO_Ctrl>:
// ----- Functions -----

// Pin action (Strobe, Sense, Strobe Setup, Sense Setup)
// GPIO_Config is only set with DriveSetup and ReadSetup, otherwise it is ignored
uint8_t GPIO_Ctrl( GPIO_Pin gpio, GPIO_Type type, GPIO_Config config )
{
    2b08:	b5f0      	push	{r4, r5, r6, r7, lr}
    2b0a:	4d2f      	ldr	r5, [pc, #188]	; (2bc8 <GPIO_Ctrl+0xc0>)
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;

	// Assumes 0x40 between GPIO Port registers and 0x1000 between PORT pin registers
	// See Lib/kinetis.h
	volatile unsigned int *GPIO_PDDR = (unsigned int*)(&GPIOA_PDDR) + gpio_offset;
    2b0c:	4e2f      	ldr	r6, [pc, #188]	; (2bcc <GPIO_Ctrl+0xc4>)
{
    2b0e:	682b      	ldr	r3, [r5, #0]
    2b10:	b085      	sub	sp, #20
    2b12:	f8ad 0004 	strh.w	r0, [sp, #4]
    2b16:	9303      	str	r3, [sp, #12]
    2b18:	f89d 0005 	ldrb.w	r0, [sp, #5]
    2b1c:	f89d 3004 	ldrb.w	r3, [sp, #4]
	unsigned int gpio_offset = gpio.port * 0x40   / sizeof(unsigned int*);
    2b20:	019c      	lsls	r4, r3, #6
	unsigned int port_offset = gpio.port * 0x1000 / sizeof(unsigned int*) + gpio.pin;
    2b22:	eb00 2383 	add.w	r3, r0, r3, lsl #10
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
	volatile unsigned int *GPIO_PTOR = (unsigned int*)(&GPIOA_PTOR) + gpio_offset;
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
	volatile unsigned int *PORT_PCR  = (unsigned int*)(&PORTA_PCR0) + port_offset;
    2b26:	009b      	lsls	r3, r3, #2
    2b28:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    2b2c:	f503 2392 	add.w	r3, r3, #299008	; 0x49000

	// Operation depends on Type
	switch ( type )
    2b30:	2905      	cmp	r1, #5
    2b32:	d80b      	bhi.n	2b4c <GPIO_Ctrl+0x44>
    2b34:	e8df f001 	tbb	[pc, r1]
    2b38:	100e0c03 	.word	0x100e0c03
    2b3c:	2f20      	.short	0x2f20
	volatile unsigned int *GPIO_PSOR = (unsigned int*)(&GPIOA_PSOR) + gpio_offset;
    2b3e:	4a24      	ldr	r2, [pc, #144]	; (2bd0 <GPIO_Ctrl+0xc8>)
	case GPIO_Type_DriveLow:
		*GPIO_PCOR |= (1 << gpio.pin);
		break;

	case GPIO_Type_DriveToggle:
		*GPIO_PTOR |= (1 << gpio.pin);
    2b40:	58a1      	ldr	r1, [r4, r2]
    2b42:	2301      	movs	r3, #1
    2b44:	fa03 f000 	lsl.w	r0, r3, r0
    2b48:	4308      	orrs	r0, r1
    2b4a:	50a0      	str	r0, [r4, r2]
		pio->PIO_PER |= (1 << gpio.pin);
		break;
	}
#endif

	return 0;
    2b4c:	2000      	movs	r0, #0
			break;
    2b4e:	e01c      	b.n	2b8a <GPIO_Ctrl+0x82>
	volatile unsigned int *GPIO_PCOR = (unsigned int*)(&GPIOA_PCOR) + gpio_offset;
    2b50:	4a20      	ldr	r2, [pc, #128]	; (2bd4 <GPIO_Ctrl+0xcc>)
    2b52:	e7f5      	b.n	2b40 <GPIO_Ctrl+0x38>
	volatile unsigned int *GPIO_PTOR = (unsigned int*)(&GPIOA_PTOR) + gpio_offset;
    2b54:	4a20      	ldr	r2, [pc, #128]	; (2bd8 <GPIO_Ctrl+0xd0>)
    2b56:	e7f3      	b.n	2b40 <GPIO_Ctrl+0x38>
		*GPIO_PDDR |= (1 << gpio.pin);
    2b58:	59a7      	ldr	r7, [r4, r6]
    2b5a:	2101      	movs	r1, #1
    2b5c:	fa01 f000 	lsl.w	r0, r1, r0
    2b60:	4338      	orrs	r0, r7
		*PORT_PCR = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    2b62:	f44f 71a2 	mov.w	r1, #324	; 0x144
		switch ( config )
    2b66:	2a03      	cmp	r2, #3
		*GPIO_PDDR |= (1 << gpio.pin);
    2b68:	51a0      	str	r0, [r4, r6]
		*PORT_PCR = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    2b6a:	6019      	str	r1, [r3, #0]
		switch ( config )
    2b6c:	d1ee      	bne.n	2b4c <GPIO_Ctrl+0x44>
			*PORT_PCR |= PORT_PCR_ODE;
    2b6e:	681a      	ldr	r2, [r3, #0]
    2b70:	f042 0220 	orr.w	r2, r2, #32
			*PORT_PCR |= PORT_PCR_PE;
    2b74:	601a      	str	r2, [r3, #0]
    2b76:	e7e9      	b.n	2b4c <GPIO_Ctrl+0x44>
	volatile unsigned int *GPIO_PDIR = (unsigned int*)(&GPIOA_PDIR) + gpio_offset;
    2b78:	4b18      	ldr	r3, [pc, #96]	; (2bdc <GPIO_Ctrl+0xd4>)
		return *GPIO_PDIR & (1 << gpio.pin) ? 1 : 0;
    2b7a:	58e2      	ldr	r2, [r4, r3]
    2b7c:	2301      	movs	r3, #1
    2b7e:	fa03 f000 	lsl.w	r0, r3, r0
    2b82:	4210      	tst	r0, r2
    2b84:	bf14      	ite	ne
    2b86:	4618      	movne	r0, r3
    2b88:	2000      	moveq	r0, #0
}
    2b8a:	9a03      	ldr	r2, [sp, #12]
    2b8c:	682b      	ldr	r3, [r5, #0]
    2b8e:	429a      	cmp	r2, r3
    2b90:	d017      	beq.n	2bc2 <GPIO_Ctrl+0xba>
    2b92:	f7ff fdcd 	bl	2730 <__stack_chk_fail>
		*GPIO_PDDR &= ~(1 << gpio.pin);
    2b96:	59a1      	ldr	r1, [r4, r6]
    2b98:	2701      	movs	r7, #1
    2b9a:	fa07 f000 	lsl.w	r0, r7, r0
    2b9e:	ea21 0000 	bic.w	r0, r1, r0
		switch ( config )
    2ba2:	42ba      	cmp	r2, r7
		*PORT_PCR = PORT_PCR_PFE | PORT_PCR_MUX(1);
    2ba4:	f44f 7188 	mov.w	r1, #272	; 0x110
		*GPIO_PDDR &= ~(1 << gpio.pin);
    2ba8:	51a0      	str	r0, [r4, r6]
		*PORT_PCR = PORT_PCR_PFE | PORT_PCR_MUX(1);
    2baa:	6019      	str	r1, [r3, #0]
		switch ( config )
    2bac:	d005      	beq.n	2bba <GPIO_Ctrl+0xb2>
    2bae:	2a02      	cmp	r2, #2
    2bb0:	d1cc      	bne.n	2b4c <GPIO_Ctrl+0x44>
			*PORT_PCR |= PORT_PCR_PE;
    2bb2:	681a      	ldr	r2, [r3, #0]
    2bb4:	f042 0202 	orr.w	r2, r2, #2
    2bb8:	e7dc      	b.n	2b74 <GPIO_Ctrl+0x6c>
			*PORT_PCR |= PORT_PCR_PE | PORT_PCR_PS;
    2bba:	681a      	ldr	r2, [r3, #0]
    2bbc:	f042 0203 	orr.w	r2, r2, #3
    2bc0:	e7d8      	b.n	2b74 <GPIO_Ctrl+0x6c>
}
    2bc2:	b005      	add	sp, #20
    2bc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2bc6:	bf00      	nop
    2bc8:	1fff89d0 	.word	0x1fff89d0
    2bcc:	400ff014 	.word	0x400ff014
    2bd0:	400ff004 	.word	0x400ff004
    2bd4:	400ff008 	.word	0x400ff008
    2bd8:	400ff00c 	.word	0x400ff00c
    2bdc:	400ff010 	.word	0x400ff010

00002be0 <Periodic_init>:
// ----- Functions -----

#if defined(_kinetis_k_)
// Must set function pointer first!!
void Periodic_init( uint32_t cycles )
{
    2be0:	b513      	push	{r0, r1, r4, lr}
    2be2:	4a11      	ldr	r2, [pc, #68]	; (2c28 <Periodic_init+0x48>)
	// Setup PIT (Programmable Interrupt Timer)
	SIM_SCGC6 |= SIM_SCGC6_PIT;;
    2be4:	4911      	ldr	r1, [pc, #68]	; (2c2c <Periodic_init+0x4c>)
{
    2be6:	6813      	ldr	r3, [r2, #0]
    2be8:	9301      	str	r3, [sp, #4]
	SIM_SCGC6 |= SIM_SCGC6_PIT;;
    2bea:	680b      	ldr	r3, [r1, #0]
	PIT_TCTRL0 = 0x00; // Make sure timer is disabled first
	PIT_MCR = 0x00; // Enable module, do not freeze timers in debug mode
    2bec:	4c10      	ldr	r4, [pc, #64]	; (2c30 <Periodic_init+0x50>)
	SIM_SCGC6 |= SIM_SCGC6_PIT;;
    2bee:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
    2bf2:	600b      	str	r3, [r1, #0]
	PIT_TCTRL0 = 0x00; // Make sure timer is disabled first
    2bf4:	4b0f      	ldr	r3, [pc, #60]	; (2c34 <Periodic_init+0x54>)
    2bf6:	2100      	movs	r1, #0
    2bf8:	6019      	str	r1, [r3, #0]
	PIT_MCR = 0x00; // Enable module, do not freeze timers in debug mode
    2bfa:	6021      	str	r1, [r4, #0]

	// Timer Count-down value
	// Number of cycles to count from CPU clock before calling interrupt
	PIT_LDVAL0 = cycles;
    2bfc:	490e      	ldr	r1, [pc, #56]	; (2c38 <Periodic_init+0x58>)
    2bfe:	6008      	str	r0, [r1, #0]

	// Enable Timer, Enable interrupt
	PIT_TCTRL0 = PIT_TCTRL_TIE | PIT_TCTRL_TEN;
    2c00:	2103      	movs	r1, #3
    2c02:	6019      	str	r1, [r3, #0]

	// Enable PIT Ch0 interrupt
	NVIC_ENABLE_IRQ( IRQ_PIT_CH0 );
    2c04:	f103 4320 	add.w	r3, r3, #2684354560	; 0xa0000000
    2c08:	f5a3 3324 	sub.w	r3, r3, #167936	; 0x29000
    2c0c:	2110      	movs	r1, #16
    2c0e:	6019      	str	r1, [r3, #0]

	// Set PIT0 interrupt to a low priority
	NVIC_SET_PRIORITY( IRQ_PIT_CH0, 200 );
    2c10:	21c8      	movs	r1, #200	; 0xc8
    2c12:	f883 133c 	strb.w	r1, [r3, #828]	; 0x33c
}
    2c16:	9901      	ldr	r1, [sp, #4]
    2c18:	6813      	ldr	r3, [r2, #0]
    2c1a:	4299      	cmp	r1, r3
    2c1c:	d001      	beq.n	2c22 <Periodic_init+0x42>
    2c1e:	f7ff fd87 	bl	2730 <__stack_chk_fail>
    2c22:	b002      	add	sp, #8
    2c24:	bd10      	pop	{r4, pc}
    2c26:	bf00      	nop
    2c28:	1fff89d0 	.word	0x1fff89d0
    2c2c:	4004803c 	.word	0x4004803c
    2c30:	40037000 	.word	0x40037000
    2c34:	40037108 	.word	0x40037108
    2c38:	40037100 	.word	0x40037100

00002c3c <Periodic_enable>:

void Periodic_enable()
{
    2c3c:	b507      	push	{r0, r1, r2, lr}
    2c3e:	4b07      	ldr	r3, [pc, #28]	; (2c5c <Periodic_enable+0x20>)
    2c40:	681a      	ldr	r2, [r3, #0]
    2c42:	9201      	str	r2, [sp, #4]
	// Used to re-enable IRQ
	NVIC_ENABLE_IRQ( IRQ_PIT_CH0 );
    2c44:	4a06      	ldr	r2, [pc, #24]	; (2c60 <Periodic_enable+0x24>)
    2c46:	2110      	movs	r1, #16
    2c48:	6011      	str	r1, [r2, #0]
}
    2c4a:	9a01      	ldr	r2, [sp, #4]
    2c4c:	681b      	ldr	r3, [r3, #0]
    2c4e:	429a      	cmp	r2, r3
    2c50:	d001      	beq.n	2c56 <Periodic_enable+0x1a>
    2c52:	f7ff fd6d 	bl	2730 <__stack_chk_fail>
    2c56:	b003      	add	sp, #12
    2c58:	f85d fb04 	ldr.w	pc, [sp], #4
    2c5c:	1fff89d0 	.word	0x1fff89d0
    2c60:	e000e108 	.word	0xe000e108

00002c64 <Periodic_disable>:

void Periodic_disable()
{
    2c64:	b507      	push	{r0, r1, r2, lr}
    2c66:	4b07      	ldr	r3, [pc, #28]	; (2c84 <Periodic_disable+0x20>)
    2c68:	681a      	ldr	r2, [r3, #0]
    2c6a:	9201      	str	r2, [sp, #4]
	// Used to disable IRQ
	NVIC_DISABLE_IRQ( IRQ_PIT_CH0 );
    2c6c:	4a06      	ldr	r2, [pc, #24]	; (2c88 <Periodic_disable+0x24>)
    2c6e:	2110      	movs	r1, #16
    2c70:	6011      	str	r1, [r2, #0]
}
    2c72:	9a01      	ldr	r2, [sp, #4]
    2c74:	681b      	ldr	r3, [r3, #0]
    2c76:	429a      	cmp	r2, r3
    2c78:	d001      	beq.n	2c7e <Periodic_disable+0x1a>
    2c7a:	f7ff fd59 	bl	2730 <__stack_chk_fail>
    2c7e:	b003      	add	sp, #12
    2c80:	f85d fb04 	ldr.w	pc, [sp], #4
    2c84:	1fff89d0 	.word	0x1fff89d0
    2c88:	e000e188 	.word	0xe000e188

00002c8c <Periodic_function>:

void Periodic_function( void *func )
{
    2c8c:	b507      	push	{r0, r1, r2, lr}
    2c8e:	4b07      	ldr	r3, [pc, #28]	; (2cac <Periodic_function+0x20>)
    2c90:	681a      	ldr	r2, [r3, #0]
    2c92:	9201      	str	r2, [sp, #4]
	// Set function pointer
	periodic_func = func;
    2c94:	4a06      	ldr	r2, [pc, #24]	; (2cb0 <Periodic_function+0x24>)
    2c96:	6010      	str	r0, [r2, #0]
}
    2c98:	9a01      	ldr	r2, [sp, #4]
    2c9a:	681b      	ldr	r3, [r3, #0]
    2c9c:	429a      	cmp	r2, r3
    2c9e:	d001      	beq.n	2ca4 <Periodic_function+0x18>
    2ca0:	f7ff fd46 	bl	2730 <__stack_chk_fail>
    2ca4:	b003      	add	sp, #12
    2ca6:	f85d fb04 	ldr.w	pc, [sp], #4
    2caa:	bf00      	nop
    2cac:	1fff89d0 	.word	0x1fff89d0
    2cb0:	1fff92dc 	.word	0x1fff92dc

00002cb4 <Periodic_cycles>:

uint32_t Periodic_cycles()
{
    2cb4:	b507      	push	{r0, r1, r2, lr}
    2cb6:	4b07      	ldr	r3, [pc, #28]	; (2cd4 <Periodic_cycles+0x20>)
    2cb8:	681a      	ldr	r2, [r3, #0]
    2cba:	9201      	str	r2, [sp, #4]
	return PIT_LDVAL0;
    2cbc:	4a06      	ldr	r2, [pc, #24]	; (2cd8 <Periodic_cycles+0x24>)
    2cbe:	6810      	ldr	r0, [r2, #0]
}
    2cc0:	9a01      	ldr	r2, [sp, #4]
    2cc2:	681b      	ldr	r3, [r3, #0]
    2cc4:	429a      	cmp	r2, r3
    2cc6:	d001      	beq.n	2ccc <Periodic_cycles+0x18>
    2cc8:	f7ff fd32 	bl	2730 <__stack_chk_fail>
    2ccc:	b003      	add	sp, #12
    2cce:	f85d fb04 	ldr.w	pc, [sp], #4
    2cd2:	bf00      	nop
    2cd4:	1fff89d0 	.word	0x1fff89d0
    2cd8:	40037100 	.word	0x40037100

00002cdc <pit0_isr>:

void pit0_isr()
{
    2cdc:	b513      	push	{r0, r1, r4, lr}
    2cde:	4c08      	ldr	r4, [pc, #32]	; (2d00 <pit0_isr+0x24>)
    2ce0:	6823      	ldr	r3, [r4, #0]
    2ce2:	9301      	str	r3, [sp, #4]
	// Call specified function
	(*periodic_func)();
    2ce4:	4b07      	ldr	r3, [pc, #28]	; (2d04 <pit0_isr+0x28>)
    2ce6:	681b      	ldr	r3, [r3, #0]
    2ce8:	4798      	blx	r3

	// Clear the interrupt
	PIT_TFLG0 = PIT_TFLG_TIF;
    2cea:	4b07      	ldr	r3, [pc, #28]	; (2d08 <pit0_isr+0x2c>)
    2cec:	2201      	movs	r2, #1
    2cee:	601a      	str	r2, [r3, #0]
}
    2cf0:	9a01      	ldr	r2, [sp, #4]
    2cf2:	6823      	ldr	r3, [r4, #0]
    2cf4:	429a      	cmp	r2, r3
    2cf6:	d001      	beq.n	2cfc <pit0_isr+0x20>
    2cf8:	f7ff fd1a 	bl	2730 <__stack_chk_fail>
    2cfc:	b002      	add	sp, #8
    2cfe:	bd10      	pop	{r4, pc}
    2d00:	1fff89d0 	.word	0x1fff89d0
    2d04:	1fff92dc 	.word	0x1fff92dc
    2d08:	4003710c 	.word	0x4003710c

00002d0c <Time_now>:

// ----- Functions -----

// Get current time
Time Time_now()
{
    2d0c:	b513      	push	{r0, r1, r4, lr}
    2d0e:	4b08      	ldr	r3, [pc, #32]	; (2d30 <Time_now+0x24>)
    2d10:	6819      	ldr	r1, [r3, #0]
    2d12:	9101      	str	r1, [sp, #4]
#if defined(_kinetis_)
	Time time = {
    2d14:	4907      	ldr	r1, [pc, #28]	; (2d34 <Time_now+0x28>)
    2d16:	680c      	ldr	r4, [r1, #0]
		.ms    = systick_millis_count,
		.ticks = ARM_DWT_CYCCNT,
    2d18:	4907      	ldr	r1, [pc, #28]	; (2d38 <Time_now+0x2c>)
    2d1a:	6809      	ldr	r1, [r1, #0]
	// No time facilities...
	Time time = Time_init();
#endif

	return time;
}
    2d1c:	9a01      	ldr	r2, [sp, #4]
    2d1e:	681b      	ldr	r3, [r3, #0]
    2d20:	429a      	cmp	r2, r3
	return time;
    2d22:	e9c0 4100 	strd	r4, r1, [r0]
}
    2d26:	d001      	beq.n	2d2c <Time_now+0x20>
    2d28:	f7ff fd02 	bl	2730 <__stack_chk_fail>
    2d2c:	b002      	add	sp, #8
    2d2e:	bd10      	pop	{r4, pc}
    2d30:	1fff89d0 	.word	0x1fff89d0
    2d34:	1fff92d8 	.word	0x1fff92d8
    2d38:	e0001004 	.word	0xe0001004

00002d3c <Time_init>:
// Get zero'd Time
#if !defined(_host_)
inline
#endif
Time Time_init()
{
    2d3c:	b507      	push	{r0, r1, r2, lr}
    2d3e:	4b07      	ldr	r3, [pc, #28]	; (2d5c <Time_init+0x20>)
    2d40:	6819      	ldr	r1, [r3, #0]
    2d42:	9101      	str	r1, [sp, #4]
	Time time = {
		.ms    = 0,
		.ticks = 0,
	};
	return time;
}
    2d44:	9a01      	ldr	r2, [sp, #4]
    2d46:	681b      	ldr	r3, [r3, #0]
	return time;
    2d48:	2100      	movs	r1, #0
}
    2d4a:	429a      	cmp	r2, r3
	return time;
    2d4c:	e9c0 1100 	strd	r1, r1, [r0]
}
    2d50:	d001      	beq.n	2d56 <Time_init+0x1a>
    2d52:	f7ff fced 	bl	2730 <__stack_chk_fail>
    2d56:	b003      	add	sp, #12
    2d58:	f85d fb04 	ldr.w	pc, [sp], #4
    2d5c:	1fff89d0 	.word	0x1fff89d0

00002d60 <Time_add>:

// Add time amount to a given variable
// Returns 1 if there was an ms rollover
uint8_t Time_add( Time *current, Time add )
{
    2d60:	b530      	push	{r4, r5, lr}
    2d62:	b085      	sub	sp, #20
    2d64:	466b      	mov	r3, sp
    2d66:	e883 0006 	stmia.w	r3, {r1, r2}
    2d6a:	4912      	ldr	r1, [pc, #72]	; (2db4 <Time_add+0x54>)
	Time data = Time_init();
	data.ms = 0;
	data.ticks = current->ticks + add.ticks;
    2d6c:	9c01      	ldr	r4, [sp, #4]
{
    2d6e:	680b      	ldr	r3, [r1, #0]
    2d70:	9303      	str	r3, [sp, #12]
	data.ticks = current->ticks + add.ticks;
    2d72:	6843      	ldr	r3, [r0, #4]
		data.ms++;
	}

	// It's ok if ms rolls over (it will eventually anyways)
	uint8_t rollover = 0;
	data.ms += current->ms + add.ms;
    2d74:	6805      	ldr	r5, [r0, #0]
    2d76:	9a00      	ldr	r2, [sp, #0]
	data.ticks = current->ticks + add.ticks;
    2d78:	4423      	add	r3, r4
	if ( data.ticks >= Time_maxTicks )
    2d7a:	4c0f      	ldr	r4, [pc, #60]	; (2db8 <Time_add+0x58>)
    2d7c:	42a3      	cmp	r3, r4
	data.ms += current->ms + add.ms;
    2d7e:	442a      	add	r2, r5
    2d80:	460c      	mov	r4, r1
		data.ms++;
    2d82:	bf8a      	itet	hi
    2d84:	2101      	movhi	r1, #1
	data.ms = 0;
    2d86:	2100      	movls	r1, #0
		data.ticks -= Time_maxTicks;
    2d88:	f5a3 338c 	subhi.w	r3, r3, #71680	; 0x11800
	data.ms += current->ms + add.ms;
    2d8c:	4411      	add	r1, r2
		data.ticks -= Time_maxTicks;
    2d8e:	bf88      	it	hi
    2d90:	f5a3 73a0 	subhi.w	r3, r3, #320	; 0x140
	if ( data.ms + current->ms + add.ms <= current->ms )
    2d94:	440a      	add	r2, r1

	// Set the time
	*current = data;

	return rollover;
}
    2d96:	4295      	cmp	r5, r2
	*current = data;
    2d98:	e9c0 1300 	strd	r1, r3, [r0]
}
    2d9c:	9a03      	ldr	r2, [sp, #12]
    2d9e:	6823      	ldr	r3, [r4, #0]
    2da0:	bf34      	ite	cc
    2da2:	2000      	movcc	r0, #0
    2da4:	2001      	movcs	r0, #1
    2da6:	429a      	cmp	r2, r3
    2da8:	d001      	beq.n	2dae <Time_add+0x4e>
    2daa:	f7ff fcc1 	bl	2730 <__stack_chk_fail>
    2dae:	b005      	add	sp, #20
    2db0:	bd30      	pop	{r4, r5, pc}
    2db2:	bf00      	nop
    2db4:	1fff89d0 	.word	0x1fff89d0
    2db8:	0001193f 	.word	0x0001193f

00002dbc <Time_compare>:
// Compares two Time variables
// -1 if compare is less than base
//  0 if compare is the same
//  1 if compare is more than base
int8_t Time_compare( Time base, Time compare )
{
    2dbc:	b510      	push	{r4, lr}
    2dbe:	b086      	sub	sp, #24
    2dc0:	ac02      	add	r4, sp, #8
    2dc2:	e884 0003 	stmia.w	r4, {r0, r1}
    2dc6:	4669      	mov	r1, sp
    2dc8:	e881 000c 	stmia.w	r1, {r2, r3}
	// First compare ms
	if ( base.ms > compare.ms )
    2dcc:	4604      	mov	r4, r0
{
    2dce:	4b0e      	ldr	r3, [pc, #56]	; (2e08 <Time_compare+0x4c>)
	if ( base.ms > compare.ms )
    2dd0:	9800      	ldr	r0, [sp, #0]
{
    2dd2:	681a      	ldr	r2, [r3, #0]
    2dd4:	9205      	str	r2, [sp, #20]
	if ( base.ms > compare.ms )
    2dd6:	4284      	cmp	r4, r0
    2dd8:	9903      	ldr	r1, [sp, #12]
    2dda:	9a01      	ldr	r2, [sp, #4]
    2ddc:	d80e      	bhi.n	2dfc <Time_compare+0x40>
	{
		return -1;
	}
	else if ( base.ms < compare.ms )
    2dde:	d30b      	bcc.n	2df8 <Time_compare+0x3c>
	{
		return 1;
	}

	// Next compare ticks (ms is the same)
	if ( base.ticks > compare.ticks )
    2de0:	4291      	cmp	r1, r2
    2de2:	d80b      	bhi.n	2dfc <Time_compare+0x40>
	{
		return -1;
	}
	else if ( base.ticks < compare.ticks )
    2de4:	bf34      	ite	cc
    2de6:	2001      	movcc	r0, #1
    2de8:	2000      	movcs	r0, #0
		return -1;
    2dea:	b240      	sxtb	r0, r0
		return 1;
	}

	// Otherwise base and compare are identical
	return 0;
}
    2dec:	9a05      	ldr	r2, [sp, #20]
    2dee:	681b      	ldr	r3, [r3, #0]
    2df0:	429a      	cmp	r2, r3
    2df2:	d006      	beq.n	2e02 <Time_compare+0x46>
    2df4:	f7ff fc9c 	bl	2730 <__stack_chk_fail>
		return 1;
    2df8:	2001      	movs	r0, #1
    2dfa:	e7f7      	b.n	2dec <Time_compare+0x30>
		return -1;
    2dfc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2e00:	e7f4      	b.n	2dec <Time_compare+0x30>
}
    2e02:	b006      	add	sp, #24
    2e04:	bd10      	pop	{r4, pc}
    2e06:	bf00      	nop
    2e08:	1fff89d0 	.word	0x1fff89d0

00002e0c <Time_ms>:

#if !defined(_host_)
inline
#endif
uint32_t Time_ms( Time time )
{
    2e0c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2e0e:	466b      	mov	r3, sp
    2e10:	e883 0003 	stmia.w	r3, {r0, r1}
    2e14:	4b05      	ldr	r3, [pc, #20]	; (2e2c <Time_ms+0x20>)
    2e16:	681a      	ldr	r2, [r3, #0]
    2e18:	9203      	str	r2, [sp, #12]
	return time.ms;
}
    2e1a:	9a03      	ldr	r2, [sp, #12]
    2e1c:	681b      	ldr	r3, [r3, #0]
    2e1e:	429a      	cmp	r2, r3
    2e20:	d001      	beq.n	2e26 <Time_ms+0x1a>
    2e22:	f7ff fc85 	bl	2730 <__stack_chk_fail>
    2e26:	b005      	add	sp, #20
    2e28:	f85d fb04 	ldr.w	pc, [sp], #4
    2e2c:	1fff89d0 	.word	0x1fff89d0

00002e30 <Time_us>:

#if !defined(_host_)
inline
#endif
uint32_t Time_us( Time time )
{
    2e30:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2e32:	466b      	mov	r3, sp
    2e34:	e883 0003 	stmia.w	r3, {r0, r1}
    2e38:	4b0d      	ldr	r3, [pc, #52]	; (2e70 <Time_us+0x40>)
    2e3a:	681a      	ldr	r2, [r3, #0]
    2e3c:	9203      	str	r2, [sp, #12]
	// Return max uint32_t if ms count is too high
	if ( time.ms >= (0xFFFFFFFF / 1000) )
    2e3e:	4a0d      	ldr	r2, [pc, #52]	; (2e74 <Time_us+0x44>)
    2e40:	4290      	cmp	r0, r2
	{
		return 0xFFFFFFFF;
	}

	uint32_t us = time.ms * 1000 + time.ticks / (Time_maxTicks / 1000);
    2e42:	bf9f      	itttt	ls
    2e44:	460a      	movls	r2, r1
    2e46:	2148      	movls	r1, #72	; 0x48
    2e48:	fbb2 f2f1 	udivls	r2, r2, r1
    2e4c:	f44f 717a 	movls.w	r1, #1000	; 0x3e8
    2e50:	bf98      	it	ls
    2e52:	fb01 2000 	mlals	r0, r1, r0, r2
	return us;
}
    2e56:	9a03      	ldr	r2, [sp, #12]
    2e58:	681b      	ldr	r3, [r3, #0]
		return 0xFFFFFFFF;
    2e5a:	bf88      	it	hi
    2e5c:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
}
    2e60:	429a      	cmp	r2, r3
    2e62:	d001      	beq.n	2e68 <Time_us+0x38>
    2e64:	f7ff fc64 	bl	2730 <__stack_chk_fail>
    2e68:	b005      	add	sp, #20
    2e6a:	f85d fb04 	ldr.w	pc, [sp], #4
    2e6e:	bf00      	nop
    2e70:	1fff89d0 	.word	0x1fff89d0
    2e74:	00418936 	.word	0x00418936

00002e78 <Time_ns>:

#if !defined(_host_)
inline
#endif
uint32_t Time_ns( Time time )
{
    2e78:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    2e7a:	466b      	mov	r3, sp
    2e7c:	e883 0003 	stmia.w	r3, {r0, r1}
    2e80:	4b0f      	ldr	r3, [pc, #60]	; (2ec0 <Time_ns+0x48>)
    2e82:	681a      	ldr	r2, [r3, #0]
    2e84:	9203      	str	r2, [sp, #12]
	// Return max uint32_t if ms count is too high
	if ( time.ms >= (0xFFFFFFFF / 1000000) )
    2e86:	f241 02c5 	movw	r2, #4293	; 0x10c5
    2e8a:	4290      	cmp	r0, r2
    2e8c:	461a      	mov	r2, r3
	//              converting to ns is more interesting.
	//              For example, 120 MHz /w 400 ticks is 8.333..ns * 400 ticks = 3333.2 ns
	//              To do this with integers only, we multiply the ns constant to us, then divide by 1000 at the end.
	//               400 * 8333 / 1000 = 3333 ns
	//              Not exact, but pretty close.
	uint32_t ns = time.ms * 1000000 + (time.ticks * Time_ticksPer_ns_x1000 / 1000);
    2e8e:	bf9f      	itttt	ls
    2e90:	f243 6341 	movwls	r3, #13889	; 0x3641
    2e94:	434b      	mulls	r3, r1
    2e96:	f44f 717a 	movls.w	r1, #1000	; 0x3e8
    2e9a:	fbb3 f3f1 	udivls	r3, r3, r1
    2e9e:	bf9c      	itt	ls
    2ea0:	4908      	ldrls	r1, [pc, #32]	; (2ec4 <Time_ns+0x4c>)
    2ea2:	fb01 3000 	mlals	r0, r1, r0, r3
	return ns;
}
    2ea6:	9903      	ldr	r1, [sp, #12]
    2ea8:	6813      	ldr	r3, [r2, #0]
		return 0xFFFFFFFF;
    2eaa:	bf88      	it	hi
    2eac:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
}
    2eb0:	4299      	cmp	r1, r3
    2eb2:	d001      	beq.n	2eb8 <Time_ns+0x40>
    2eb4:	f7ff fc3c 	bl	2730 <__stack_chk_fail>
    2eb8:	b005      	add	sp, #20
    2eba:	f85d fb04 	ldr.w	pc, [sp], #4
    2ebe:	bf00      	nop
    2ec0:	1fff89d0 	.word	0x1fff89d0
    2ec4:	000f4240 	.word	0x000f4240

00002ec8 <Time_duration_rollover>:
// Time since the given time
// If the given time value is lower, then assume a single register wrap
// This is around 49 days (plenty of time for most tasks)

Time Time_duration_rollover( Time now, Time since )
{
    2ec8:	b082      	sub	sp, #8
    2eca:	b530      	push	{r4, r5, lr}
    2ecc:	b087      	sub	sp, #28
    2ece:	4604      	mov	r4, r0
    2ed0:	a802      	add	r0, sp, #8
    2ed2:	e880 0006 	stmia.w	r0, {r1, r2}
    2ed6:	aa0a      	add	r2, sp, #40	; 0x28
	// Ticks do not rollover, they are computed from the last increment of ms
	// Depending on the set clock speed, the maximum number of ticks per ms may vary
	duration.ticks = now.ticks + ( Time_maxTicks - since.ticks );

	// If ticks have exceeded 1 ms, increment ms
	if ( duration.ticks >= Time_maxTicks )
    2ed8:	4d14      	ldr	r5, [pc, #80]	; (2f2c <Time_duration_rollover+0x64>)
{
    2eda:	f842 3f04 	str.w	r3, [r2, #4]!
    2ede:	e892 0003 	ldmia.w	r2, {r0, r1}
    2ee2:	466b      	mov	r3, sp
    2ee4:	9a02      	ldr	r2, [sp, #8]
    2ee6:	e883 0003 	stmia.w	r3, {r0, r1}
    2eea:	4911      	ldr	r1, [pc, #68]	; (2f30 <Time_duration_rollover+0x68>)
	if ( now.ms < since.ms )
    2eec:	4282      	cmp	r2, r0
{
    2eee:	680b      	ldr	r3, [r1, #0]
    2ef0:	9305      	str	r3, [sp, #20]
		duration.ms = now.ms + ( 0xFFFFFFFF - since.ms );
    2ef2:	bf38      	it	cc
    2ef4:	f102 32ff 	addcc.w	r2, r2, #4294967295	; 0xffffffff
		duration.ms = now.ms - since.ms;
    2ef8:	1a13      	subs	r3, r2, r0
	duration.ticks = now.ticks + ( Time_maxTicks - since.ticks );
    2efa:	9a01      	ldr	r2, [sp, #4]
    2efc:	9803      	ldr	r0, [sp, #12]
    2efe:	1a80      	subs	r0, r0, r2
    2f00:	f500 328c 	add.w	r2, r0, #71680	; 0x11800
    2f04:	f502 72a0 	add.w	r2, r2, #320	; 0x140
	if ( duration.ticks >= Time_maxTicks )
    2f08:	42aa      	cmp	r2, r5
	{
		duration.ms++;
    2f0a:	bf84      	itt	hi
    2f0c:	4602      	movhi	r2, r0
    2f0e:	3301      	addhi	r3, #1
		duration.ticks -= Time_maxTicks;
	}

	return duration;
    2f10:	e9c4 3200 	strd	r3, r2, [r4]
}
    2f14:	9a05      	ldr	r2, [sp, #20]
    2f16:	680b      	ldr	r3, [r1, #0]
    2f18:	429a      	cmp	r2, r3
    2f1a:	4620      	mov	r0, r4
    2f1c:	d001      	beq.n	2f22 <Time_duration_rollover+0x5a>
    2f1e:	f7ff fc07 	bl	2730 <__stack_chk_fail>
    2f22:	b007      	add	sp, #28
    2f24:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    2f28:	b002      	add	sp, #8
    2f2a:	4770      	bx	lr
    2f2c:	0001193f 	.word	0x0001193f
    2f30:	1fff89d0 	.word	0x1fff89d0

00002f34 <Time_duration_rollover_now>:

Time Time_duration_rollover_now( Time since )
{
    2f34:	b530      	push	{r4, r5, lr}
    2f36:	4c0f      	ldr	r4, [pc, #60]	; (2f74 <Time_duration_rollover_now+0x40>)
    2f38:	b089      	sub	sp, #36	; 0x24
    2f3a:	ab02      	add	r3, sp, #8
    2f3c:	e883 0006 	stmia.w	r3, {r1, r2}
    2f40:	6823      	ldr	r3, [r4, #0]
    2f42:	9307      	str	r3, [sp, #28]
	Time time = {
    2f44:	4b0c      	ldr	r3, [pc, #48]	; (2f78 <Time_duration_rollover_now+0x44>)
    2f46:	681a      	ldr	r2, [r3, #0]
		.ticks = ARM_DWT_CYCCNT,
    2f48:	4b0c      	ldr	r3, [pc, #48]	; (2f7c <Time_duration_rollover_now+0x48>)
    2f4a:	681b      	ldr	r3, [r3, #0]
	return time;
    2f4c:	e9cd 2305 	strd	r2, r3, [sp, #20]
	Time now = Time_now();
	return Time_duration_rollover( now, since );
    2f50:	9b03      	ldr	r3, [sp, #12]
    2f52:	9300      	str	r3, [sp, #0]
    2f54:	aa05      	add	r2, sp, #20
    2f56:	460b      	mov	r3, r1
    2f58:	ca06      	ldmia	r2, {r1, r2}
{
    2f5a:	4605      	mov	r5, r0
	return Time_duration_rollover( now, since );
    2f5c:	f7ff ffb4 	bl	2ec8 <Time_duration_rollover>
}
    2f60:	9a07      	ldr	r2, [sp, #28]
    2f62:	6823      	ldr	r3, [r4, #0]
    2f64:	429a      	cmp	r2, r3
    2f66:	4628      	mov	r0, r5
    2f68:	d001      	beq.n	2f6e <Time_duration_rollover_now+0x3a>
    2f6a:	f7ff fbe1 	bl	2730 <__stack_chk_fail>
    2f6e:	b009      	add	sp, #36	; 0x24
    2f70:	bd30      	pop	{r4, r5, pc}
    2f72:	bf00      	nop
    2f74:	1fff89d0 	.word	0x1fff89d0
    2f78:	1fff92d8 	.word	0x1fff92d8
    2f7c:	e0001004 	.word	0xe0001004

00002f80 <Time_duration>:

Time Time_duration( Time since )
{
    2f80:	b530      	push	{r4, r5, lr}
    2f82:	b085      	sub	sp, #20
    2f84:	466b      	mov	r3, sp
    2f86:	e883 0006 	stmia.w	r3, {r1, r2}
    2f8a:	4c08      	ldr	r4, [pc, #32]	; (2fac <Time_duration+0x2c>)
    2f8c:	6822      	ldr	r2, [r4, #0]
    2f8e:	9203      	str	r2, [sp, #12]
	return Time_duration_rollover_now( since );
    2f90:	e893 0006 	ldmia.w	r3, {r1, r2}
{
    2f94:	4605      	mov	r5, r0
	return Time_duration_rollover_now( since );
    2f96:	f7ff ffcd 	bl	2f34 <Time_duration_rollover_now>
}
    2f9a:	9a03      	ldr	r2, [sp, #12]
    2f9c:	6823      	ldr	r3, [r4, #0]
    2f9e:	429a      	cmp	r2, r3
    2fa0:	4628      	mov	r0, r5
    2fa2:	d001      	beq.n	2fa8 <Time_duration+0x28>
    2fa4:	f7ff fbc4 	bl	2730 <__stack_chk_fail>
    2fa8:	b005      	add	sp, #20
    2faa:	bd30      	pop	{r4, r5, pc}
    2fac:	1fff89d0 	.word	0x1fff89d0

00002fb0 <Time_duration_ms>:
	Time duration = Time_duration_rollover_now( since );
	return Time_seconds( duration );
}

uint32_t Time_duration_ms( Time since )
{
    2fb0:	b510      	push	{r4, lr}
    2fb2:	b086      	sub	sp, #24
    2fb4:	466b      	mov	r3, sp
    2fb6:	e883 0003 	stmia.w	r3, {r0, r1}
    2fba:	4c08      	ldr	r4, [pc, #32]	; (2fdc <Time_duration_ms+0x2c>)
    2fbc:	6822      	ldr	r2, [r4, #0]
    2fbe:	9205      	str	r2, [sp, #20]
	Time duration = Time_duration_rollover_now( since );
    2fc0:	a803      	add	r0, sp, #12
    2fc2:	e893 0006 	ldmia.w	r3, {r1, r2}
    2fc6:	f7ff ffb5 	bl	2f34 <Time_duration_rollover_now>
	return Time_ms( duration );
}
    2fca:	9a05      	ldr	r2, [sp, #20]
    2fcc:	6823      	ldr	r3, [r4, #0]
    2fce:	9803      	ldr	r0, [sp, #12]
    2fd0:	429a      	cmp	r2, r3
    2fd2:	d001      	beq.n	2fd8 <Time_duration_ms+0x28>
    2fd4:	f7ff fbac 	bl	2730 <__stack_chk_fail>
    2fd8:	b006      	add	sp, #24
    2fda:	bd10      	pop	{r4, pc}
    2fdc:	1fff89d0 	.word	0x1fff89d0

00002fe0 <Time_duration_us>:

uint32_t Time_duration_us( Time since )
{
    2fe0:	b530      	push	{r4, r5, lr}
    2fe2:	b087      	sub	sp, #28
    2fe4:	466b      	mov	r3, sp
    2fe6:	e883 0003 	stmia.w	r3, {r0, r1}
    2fea:	4d0b      	ldr	r5, [pc, #44]	; (3018 <Time_duration_us+0x38>)
	Time duration = Time_duration_rollover_now( since );
    2fec:	ac03      	add	r4, sp, #12
{
    2fee:	682a      	ldr	r2, [r5, #0]
    2ff0:	9205      	str	r2, [sp, #20]
	Time duration = Time_duration_rollover_now( since );
    2ff2:	4620      	mov	r0, r4
    2ff4:	e893 0006 	ldmia.w	r3, {r1, r2}
    2ff8:	f7ff ff9c 	bl	2f34 <Time_duration_rollover_now>
	return Time_us( duration );
    2ffc:	9a05      	ldr	r2, [sp, #20]
    2ffe:	682b      	ldr	r3, [r5, #0]
    3000:	429a      	cmp	r2, r3
    3002:	d001      	beq.n	3008 <Time_duration_us+0x28>
    3004:	f7ff fb94 	bl	2730 <__stack_chk_fail>
    3008:	e894 0003 	ldmia.w	r4, {r0, r1}
}
    300c:	b007      	add	sp, #28
    300e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return Time_us( duration );
    3012:	f7ff bf0d 	b.w	2e30 <Time_us>
    3016:	bf00      	nop
    3018:	1fff89d0 	.word	0x1fff89d0

0000301c <Time_duration_ns>:

uint32_t Time_duration_ns( Time since )
{
    301c:	b530      	push	{r4, r5, lr}
    301e:	b087      	sub	sp, #28
    3020:	466b      	mov	r3, sp
    3022:	e883 0003 	stmia.w	r3, {r0, r1}
    3026:	4d0b      	ldr	r5, [pc, #44]	; (3054 <Time_duration_ns+0x38>)
	Time duration = Time_duration_rollover_now( since );
    3028:	ac03      	add	r4, sp, #12
{
    302a:	682a      	ldr	r2, [r5, #0]
    302c:	9205      	str	r2, [sp, #20]
	Time duration = Time_duration_rollover_now( since );
    302e:	4620      	mov	r0, r4
    3030:	e893 0006 	ldmia.w	r3, {r1, r2}
    3034:	f7ff ff7e 	bl	2f34 <Time_duration_rollover_now>
	return Time_ns( duration );
    3038:	9a05      	ldr	r2, [sp, #20]
    303a:	682b      	ldr	r3, [r5, #0]
    303c:	429a      	cmp	r2, r3
    303e:	d001      	beq.n	3044 <Time_duration_ns+0x28>
    3040:	f7ff fb76 	bl	2730 <__stack_chk_fail>
    3044:	e894 0003 	ldmia.w	r4, {r0, r1}
}
    3048:	b007      	add	sp, #28
    304a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return Time_ns( duration );
    304e:	f7ff bf13 	b.w	2e78 <Time_ns>
    3052:	bf00      	nop
    3054:	1fff89d0 	.word	0x1fff89d0

00003058 <Time_duration_ticks>:

// Number of ticks since
uint32_t Time_duration_ticks( Time since )
{
    3058:	b510      	push	{r4, lr}
    305a:	b086      	sub	sp, #24
    305c:	466b      	mov	r3, sp
    305e:	e883 0003 	stmia.w	r3, {r0, r1}
    3062:	4c0e      	ldr	r4, [pc, #56]	; (309c <Time_duration_ticks+0x44>)
    3064:	6822      	ldr	r2, [r4, #0]
    3066:	9205      	str	r2, [sp, #20]
	Time duration = Time_duration_rollover_now( since );
    3068:	a803      	add	r0, sp, #12
    306a:	e893 0006 	ldmia.w	r3, {r1, r2}
    306e:	f7ff ff61 	bl	2f34 <Time_duration_rollover_now>
    3072:	e9dd 0303 	ldrd	r0, r3, [sp, #12]
	if ( time.ms >= Time_maxTicks_ms )
    3076:	f64e 1203 	movw	r2, #59651	; 0xe903
    307a:	4290      	cmp	r0, r2
	ticks += time.ticks;
    307c:	bf9c      	itt	ls
    307e:	4a08      	ldrls	r2, [pc, #32]	; (30a0 <Time_duration_ticks+0x48>)
    3080:	fb02 3000 	mlals	r0, r2, r0, r3
	return Time_ticks( duration );
}
    3084:	9a05      	ldr	r2, [sp, #20]
    3086:	6823      	ldr	r3, [r4, #0]
		return 0xFFFFFFFF;
    3088:	bf88      	it	hi
    308a:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
}
    308e:	429a      	cmp	r2, r3
    3090:	d001      	beq.n	3096 <Time_duration_ticks+0x3e>
    3092:	f7ff fb4d 	bl	2730 <__stack_chk_fail>
    3096:	b006      	add	sp, #24
    3098:	bd10      	pop	{r4, pc}
    309a:	bf00      	nop
    309c:	1fff89d0 	.word	0x1fff89d0
    30a0:	00011940 	.word	0x00011940

000030a4 <Time_tick_reset>:
	// Reset last_tick and ticks_since_start
	Time_tick_reset( store );
}

void Time_tick_reset( TickStore *store )
{
    30a4:	b507      	push	{r0, r1, r2, lr}
    30a6:	4b0b      	ldr	r3, [pc, #44]	; (30d4 <Time_tick_reset+0x30>)
    30a8:	681a      	ldr	r2, [r3, #0]
    30aa:	9201      	str	r2, [sp, #4]
	Time time = {
    30ac:	4a0a      	ldr	r2, [pc, #40]	; (30d8 <Time_tick_reset+0x34>)
    30ae:	6811      	ldr	r1, [r2, #0]
		.ticks = ARM_DWT_CYCCNT,
    30b0:	4a0a      	ldr	r2, [pc, #40]	; (30dc <Time_tick_reset+0x38>)
    30b2:	6812      	ldr	r2, [r2, #0]
	// Reset last_tick and ticks_since_start
	store->last_tick = Time_now();
    30b4:	e9c0 1200 	strd	r1, r2, [r0]
	store->ticks_since_start = 0;
    30b8:	2200      	movs	r2, #0
    30ba:	6102      	str	r2, [r0, #16]

	// Mark as a fresh TickStore
	store->fresh_store = 1;
    30bc:	2201      	movs	r2, #1
    30be:	7602      	strb	r2, [r0, #24]
}
    30c0:	9a01      	ldr	r2, [sp, #4]
    30c2:	681b      	ldr	r3, [r3, #0]
    30c4:	429a      	cmp	r2, r3
    30c6:	d001      	beq.n	30cc <Time_tick_reset+0x28>
    30c8:	f7ff fb32 	bl	2730 <__stack_chk_fail>
    30cc:	b003      	add	sp, #12
    30ce:	f85d fb04 	ldr.w	pc, [sp], #4
    30d2:	bf00      	nop
    30d4:	1fff89d0 	.word	0x1fff89d0
    30d8:	1fff92d8 	.word	0x1fff92d8
    30dc:	e0001004 	.word	0xe0001004

000030e0 <Time_tick_start>:
{
    30e0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    30e2:	4604      	mov	r4, r0
    30e4:	4668      	mov	r0, sp
    30e6:	e880 0006 	stmia.w	r0, {r1, r2}
    30ea:	4d0a      	ldr	r5, [pc, #40]	; (3114 <Time_tick_start+0x34>)
    30ec:	6829      	ldr	r1, [r5, #0]
    30ee:	9103      	str	r1, [sp, #12]
	store->tick_duration = duration;
    30f0:	c803      	ldmia	r0, {r0, r1}
    30f2:	f104 0608 	add.w	r6, r4, #8
    30f6:	e886 0005 	stmia.w	r6, {r0, r2}
	Time_tick_reset( store );
    30fa:	9a03      	ldr	r2, [sp, #12]
	store->max_ticks = max_ticks;
    30fc:	6163      	str	r3, [r4, #20]
	Time_tick_reset( store );
    30fe:	682b      	ldr	r3, [r5, #0]
    3100:	429a      	cmp	r2, r3
    3102:	d001      	beq.n	3108 <Time_tick_start+0x28>
    3104:	f7ff fb14 	bl	2730 <__stack_chk_fail>
    3108:	4620      	mov	r0, r4
}
    310a:	b004      	add	sp, #16
    310c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	Time_tick_reset( store );
    3110:	f7ff bfc8 	b.w	30a4 <Time_tick_reset>
    3114:	1fff89d0 	.word	0x1fff89d0

00003118 <Time_tick_update>:

uint32_t Time_tick_update( TickStore *store )
{
    3118:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    311c:	4e1b      	ldr	r6, [pc, #108]	; (318c <Time_tick_update+0x74>)
    311e:	6833      	ldr	r3, [r6, #0]
    3120:	9303      	str	r3, [sp, #12]
	// TODO (HaaTa) Handle rollover case (only happens once every 49 days while the keyboard is on)
	// Check if we've already gotten to the max tick threshold
	if ( store->ticks_since_start > store->max_ticks )
    3122:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
    3126:	429a      	cmp	r2, r3
{
    3128:	4604      	mov	r4, r0
	if ( store->ticks_since_start > store->max_ticks )
    312a:	d829      	bhi.n	3180 <Time_tick_update+0x68>
	Time time = {
    312c:	4b18      	ldr	r3, [pc, #96]	; (3190 <Time_tick_update+0x78>)
    312e:	681a      	ldr	r2, [r3, #0]
		.ticks = ARM_DWT_CYCCNT,
    3130:	4b18      	ldr	r3, [pc, #96]	; (3194 <Time_tick_update+0x7c>)
    3132:	681b      	ldr	r3, [r3, #0]

	// Query current time
	Time now = Time_now();

	// Previous time
	Time prev = store->last_tick;
    3134:	e9d0 8700 	ldrd	r8, r7, [r0]
	return time;
    3138:	e9cd 2301 	strd	r2, r3, [sp, #4]
	uint32_t ticks = 0;
    313c:	2500      	movs	r5, #0

	// Otherwise just increment until we've gone too far
	while ( Time_compare( now, store->last_tick ) <= 0 )
    313e:	f10d 0904 	add.w	r9, sp, #4
	{
		prev = store->last_tick;
		Time_add( &store->last_tick, store->tick_duration );
    3142:	f100 0a08 	add.w	sl, r0, #8
	while ( Time_compare( now, store->last_tick ) <= 0 )
    3146:	e894 000c 	ldmia.w	r4, {r2, r3}
    314a:	e899 0003 	ldmia.w	r9, {r0, r1}
    314e:	f7ff fe35 	bl	2dbc <Time_compare>
    3152:	2800      	cmp	r0, #0
    3154:	dd0b      	ble.n	316e <Time_tick_update+0x56>
	// Reverse back to previous tick
	ticks -= 1;
	store->last_tick = prev;

	// Add ticks to store
	store->ticks_since_start += ticks;
    3156:	6923      	ldr	r3, [r4, #16]
	ticks -= 1;
    3158:	1e68      	subs	r0, r5, #1
	store->last_tick = prev;
    315a:	e9c4 8700 	strd	r8, r7, [r4]
	store->ticks_since_start += ticks;
    315e:	4403      	add	r3, r0
    3160:	6123      	str	r3, [r4, #16]

	return ticks;
}
    3162:	9a03      	ldr	r2, [sp, #12]
    3164:	6833      	ldr	r3, [r6, #0]
    3166:	429a      	cmp	r2, r3
    3168:	d00c      	beq.n	3184 <Time_tick_update+0x6c>
    316a:	f7ff fae1 	bl	2730 <__stack_chk_fail>
		Time_add( &store->last_tick, store->tick_duration );
    316e:	e89a 0006 	ldmia.w	sl, {r1, r2}
    3172:	4620      	mov	r0, r4
		prev = store->last_tick;
    3174:	e9d4 8700 	ldrd	r8, r7, [r4]
		ticks++;
    3178:	3501      	adds	r5, #1
		Time_add( &store->last_tick, store->tick_duration );
    317a:	f7ff fdf1 	bl	2d60 <Time_add>
    317e:	e7e2      	b.n	3146 <Time_tick_update+0x2e>
		return 0;
    3180:	2000      	movs	r0, #0
    3182:	e7ee      	b.n	3162 <Time_tick_update+0x4a>
}
    3184:	b004      	add	sp, #16
    3186:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    318a:	bf00      	nop
    318c:	1fff89d0 	.word	0x1fff89d0
    3190:	1fff92d8 	.word	0x1fff92d8
    3194:	e0001004 	.word	0xe0001004

00003198 <i2c_initial>:

void i2c_isr( uint8_t ch );

// Initialize error counters
void i2c_initial()
{
    3198:	b507      	push	{r0, r1, r2, lr}
    319a:	4b08      	ldr	r3, [pc, #32]	; (31bc <i2c_initial+0x24>)
    319c:	681a      	ldr	r2, [r3, #0]
    319e:	9201      	str	r2, [sp, #4]
	for ( uint8_t ch = ISSI_I2C_FirstBus_define; ch < ISSI_I2C_Buses_define + ISSI_I2C_FirstBus_define; ch++ )
	{
		volatile I2C_Channel *channel = &( i2c_channels[ch - ISSI_I2C_FirstBus_define] );
		channel->error_count = 0;
    31a0:	4a07      	ldr	r2, [pc, #28]	; (31c0 <i2c_initial+0x28>)
    31a2:	2100      	movs	r1, #0
    31a4:	6191      	str	r1, [r2, #24]
		channel->last_error = 0; // No error to begin with (resets on successful transaction)
    31a6:	61d1      	str	r1, [r2, #28]
	}
}
    31a8:	9a01      	ldr	r2, [sp, #4]
    31aa:	681b      	ldr	r3, [r3, #0]
    31ac:	429a      	cmp	r2, r3
    31ae:	d001      	beq.n	31b4 <i2c_initial+0x1c>
    31b0:	f7ff fabe 	bl	2730 <__stack_chk_fail>
    31b4:	b003      	add	sp, #12
    31b6:	f85d fb04 	ldr.w	pc, [sp], #4
    31ba:	bf00      	nop
    31bc:	1fff89d0 	.word	0x1fff89d0
    31c0:	1fff9ef4 	.word	0x1fff9ef4

000031c4 <i2c_setup>:

void i2c_setup()
{
    31c4:	b507      	push	{r0, r1, r2, lr}
    31c6:	4915      	ldr	r1, [pc, #84]	; (321c <i2c_setup+0x58>)

		switch ( ch )
		{
		case 0:
			// Enable I2C internal clock
			SIM_SCGC4 |= SIM_SCGC4_I2C0; // Bus 0
    31c8:	4815      	ldr	r0, [pc, #84]	; (3220 <i2c_setup+0x5c>)
{
    31ca:	680b      	ldr	r3, [r1, #0]
    31cc:	9301      	str	r3, [sp, #4]
			SIM_SCGC4 |= SIM_SCGC4_I2C0; // Bus 0
    31ce:	6802      	ldr	r2, [r0, #0]
		volatile uint8_t *I2C_F   = (uint8_t*)(&I2C0_F) + i2c_offset[ch];
    31d0:	4b14      	ldr	r3, [pc, #80]	; (3224 <i2c_setup+0x60>)
			SIM_SCGC4 |= SIM_SCGC4_I2C0; // Bus 0
    31d2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
		volatile uint8_t *I2C_F   = (uint8_t*)(&I2C0_F) + i2c_offset[ch];
    31d6:	681b      	ldr	r3, [r3, #0]
			SIM_SCGC4 |= SIM_SCGC4_I2C0; // Bus 0
    31d8:	6002      	str	r2, [r0, #0]

			// External pull-up resistor
			PORTB_PCR0 = PORT_PCR_ODE | PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(2);
    31da:	4813      	ldr	r0, [pc, #76]	; (3228 <i2c_setup+0x64>)
    31dc:	f44f 7219 	mov.w	r2, #612	; 0x264
    31e0:	6002      	str	r2, [r0, #0]
			PORTB_PCR1 = PORT_PCR_ODE | PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(2);
    31e2:	6042      	str	r2, [r0, #4]
		*I2C_FLT = 0x05;
	#elif ISSI_Chip_31FL3731_define == 1 && defined(_kii_v2_)
		// 0x4E -> 36 MHz / (2 * 56) = 321.428 kBaud
		// 0x40 => mul(2)
		// 0x0E => ICR(56)
		*I2C_F = 0x4E;
    31e4:	4a11      	ldr	r2, [pc, #68]	; (322c <i2c_setup+0x68>)
    31e6:	204e      	movs	r0, #78	; 0x4e
    31e8:	5498      	strb	r0, [r3, r2]
		*I2C_FLT = 0x04;
    31ea:	3205      	adds	r2, #5
    31ec:	2004      	movs	r0, #4
    31ee:	5498      	strb	r0, [r3, r2]
		// 0x40 => mul(2)
		// 0x00 => ICR(20)
		*I2C_F = 0x40;
		*I2C_FLT = 0x02;
	#endif
		*I2C_C1 = I2C_C1_IICEN;
    31f0:	3a04      	subs	r2, #4
    31f2:	2080      	movs	r0, #128	; 0x80
    31f4:	5498      	strb	r0, [r3, r2]
		*I2C_C2 = I2C_C2_HDRS; // High drive select
    31f6:	3203      	adds	r2, #3
    31f8:	2020      	movs	r0, #32
    31fa:	5498      	strb	r0, [r3, r2]

		switch ( ch )
		{
		case 0:
			// Enable I2C Interrupt
			NVIC_ENABLE_IRQ( IRQ_I2C0 );
    31fc:	4b0c      	ldr	r3, [pc, #48]	; (3230 <i2c_setup+0x6c>)
    31fe:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    3202:	601a      	str	r2, [r3, #0]

			// Set priority below USB, but not too low to maintain performance
			NVIC_SET_PRIORITY( IRQ_PIT_CH0, 150 );
    3204:	2296      	movs	r2, #150	; 0x96
    3206:	f883 2344 	strb.w	r2, [r3, #836]	; 0x344
			break;
		}

#endif
	}
}
    320a:	9a01      	ldr	r2, [sp, #4]
    320c:	680b      	ldr	r3, [r1, #0]
    320e:	429a      	cmp	r2, r3
    3210:	d001      	beq.n	3216 <i2c_setup+0x52>
    3212:	f7ff fa8d 	bl	2730 <__stack_chk_fail>
    3216:	b003      	add	sp, #12
    3218:	f85d fb04 	ldr.w	pc, [sp], #4
    321c:	1fff89d0 	.word	0x1fff89d0
    3220:	40048034 	.word	0x40048034
    3224:	1fff89d8 	.word	0x1fff89d8
    3228:	4004a000 	.word	0x4004a000
    322c:	40066001 	.word	0x40066001
    3230:	e000e100 	.word	0xe000e100

00003234 <i2c_error>:

// Checks if any bus has errored
uint8_t i2c_error()
{
    3234:	b507      	push	{r0, r1, r2, lr}
    3236:	4b08      	ldr	r3, [pc, #32]	; (3258 <i2c_error+0x24>)
    3238:	681a      	ldr	r2, [r3, #0]
    323a:	9201      	str	r2, [sp, #4]
	for ( uint8_t ch = ISSI_I2C_FirstBus_define; ch < ISSI_I2C_Buses_define + ISSI_I2C_FirstBus_define; ch++ )
	{
		volatile I2C_Channel *channel = &( i2c_channels[ch - ISSI_I2C_FirstBus_define] );
		if ( channel->status == I2C_ERROR )
    323c:	4a07      	ldr	r2, [pc, #28]	; (325c <i2c_error+0x28>)
    323e:	7d50      	ldrb	r0, [r2, #21]
			return 1;
		}
	}

	return 0;
}
    3240:	1e82      	subs	r2, r0, #2
    3242:	4250      	negs	r0, r2
    3244:	4150      	adcs	r0, r2
    3246:	9a01      	ldr	r2, [sp, #4]
    3248:	681b      	ldr	r3, [r3, #0]
    324a:	429a      	cmp	r2, r3
    324c:	d001      	beq.n	3252 <i2c_error+0x1e>
    324e:	f7ff fa6f 	bl	2730 <__stack_chk_fail>
    3252:	b003      	add	sp, #12
    3254:	f85d fb04 	ldr.w	pc, [sp], #4
    3258:	1fff89d0 	.word	0x1fff89d0
    325c:	1fff9ef4 	.word	0x1fff9ef4

00003260 <i2c_reset>:

void i2c_reset()
{
    3260:	b507      	push	{r0, r1, r2, lr}
    3262:	4b08      	ldr	r3, [pc, #32]	; (3284 <i2c_reset+0x24>)
    3264:	681a      	ldr	r2, [r3, #0]
    3266:	9201      	str	r2, [sp, #4]
	// Cleanup after an I2C error
	for ( uint8_t ch = ISSI_I2C_FirstBus_define; ch < ISSI_I2C_Buses_define + ISSI_I2C_FirstBus_define; ch++ )
	{
		volatile I2C_Channel *channel = &( i2c_channels[ch - ISSI_I2C_FirstBus_define] );
		channel->status = I2C_AVAILABLE;
    3268:	4a07      	ldr	r2, [pc, #28]	; (3288 <i2c_reset+0x28>)
    326a:	2100      	movs	r1, #0
    326c:	7551      	strb	r1, [r2, #21]
	}

	i2c_setup();
    326e:	9a01      	ldr	r2, [sp, #4]
    3270:	681b      	ldr	r3, [r3, #0]
    3272:	429a      	cmp	r2, r3
    3274:	d001      	beq.n	327a <i2c_reset+0x1a>
    3276:	f7ff fa5b 	bl	2730 <__stack_chk_fail>
}
    327a:	b003      	add	sp, #12
    327c:	f85d eb04 	ldr.w	lr, [sp], #4
	i2c_setup();
    3280:	f7ff bfa0 	b.w	31c4 <i2c_setup>
    3284:	1fff89d0 	.word	0x1fff89d0
    3288:	1fff9ef4 	.word	0x1fff9ef4

0000328c <i2c_busy>:

uint8_t i2c_busy( uint8_t ch )
{
    328c:	b507      	push	{r0, r1, r2, lr}
    328e:	4a09      	ldr	r2, [pc, #36]	; (32b4 <i2c_busy+0x28>)
    3290:	6813      	ldr	r3, [r2, #0]
    3292:	9301      	str	r3, [sp, #4]
	volatile I2C_Channel *channel = &( i2c_channels[ch - ISSI_I2C_FirstBus_define] );
	if ( channel->status == I2C_BUSY )
    3294:	4b08      	ldr	r3, [pc, #32]	; (32b8 <i2c_busy+0x2c>)
    3296:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    329a:	7d40      	ldrb	r0, [r0, #21]
	{
		return 1;
	}

	return 0;
}
    329c:	9901      	ldr	r1, [sp, #4]
    329e:	1e43      	subs	r3, r0, #1
    32a0:	4258      	negs	r0, r3
    32a2:	4158      	adcs	r0, r3
    32a4:	6813      	ldr	r3, [r2, #0]
    32a6:	4299      	cmp	r1, r3
    32a8:	d001      	beq.n	32ae <i2c_busy+0x22>
    32aa:	f7ff fa41 	bl	2730 <__stack_chk_fail>
    32ae:	b003      	add	sp, #12
    32b0:	f85d fb04 	ldr.w	pc, [sp], #4
    32b4:	1fff89d0 	.word	0x1fff89d0
    32b8:	1fff9ef4 	.word	0x1fff9ef4

000032bc <i2c_send_sequence>:
	uint16_t *sequence,
	uint32_t sequence_length,
	uint8_t *received_data,
	void ( *callback_fn )( void* ),
	void *user_data
) {
    32bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    32c0:	b089      	sub	sp, #36	; 0x24
    32c2:	4688      	mov	r8, r1
    32c4:	9912      	ldr	r1, [sp, #72]	; 0x48
    32c6:	9101      	str	r1, [sp, #4]
    32c8:	9913      	ldr	r1, [sp, #76]	; 0x4c
    32ca:	9102      	str	r1, [sp, #8]
    32cc:	493c      	ldr	r1, [pc, #240]	; (33c0 <i2c_send_sequence+0x104>)
	volatile uint8_t *I2C_D   = (uint8_t*)(&I2C0_D) + i2c_offset[ch];
#elif defined(_sam_)
	Twi *twi_dev = twi_devs[ch];
#endif

	if ( channel->status == I2C_BUSY )
    32ce:	4d3d      	ldr	r5, [pc, #244]	; (33c4 <i2c_send_sequence+0x108>)
	volatile uint8_t *I2C_C1  = (uint8_t*)(&I2C0_C1) + i2c_offset[ch];
    32d0:	4f3d      	ldr	r7, [pc, #244]	; (33c8 <i2c_send_sequence+0x10c>)
	volatile uint8_t *I2C_S   = (uint8_t*)(&I2C0_S) + i2c_offset[ch];
    32d2:	f8df 9110 	ldr.w	r9, [pc, #272]	; 33e4 <i2c_send_sequence+0x128>
    32d6:	9103      	str	r1, [sp, #12]
) {
    32d8:	4683      	mov	fp, r0
	if ( channel->status == I2C_BUSY )
    32da:	ea4f 164b 	mov.w	r6, fp, lsl #5
) {
    32de:	6808      	ldr	r0, [r1, #0]
    32e0:	9007      	str	r0, [sp, #28]
	if ( channel->status == I2C_BUSY )
    32e2:	eb05 0a06 	add.w	sl, r5, r6
	volatile uint8_t *I2C_C1  = (uint8_t*)(&I2C0_C1) + i2c_offset[ch];
    32e6:	4839      	ldr	r0, [pc, #228]	; (33cc <i2c_send_sequence+0x110>)
    32e8:	f850 402b 	ldr.w	r4, [r0, fp, lsl #2]
	if ( channel->status == I2C_BUSY )
    32ec:	f89a 0015 	ldrb.w	r0, [sl, #21]
    32f0:	2801      	cmp	r0, #1
    32f2:	d052      	beq.n	339a <i2c_send_sequence+0xde>
		return -1;
	}

	// Check if there are back-to-back errors
	// in succession
	if ( channel->last_error > 5 )
    32f4:	f8da 101c 	ldr.w	r1, [sl, #28]
    32f8:	2905      	cmp	r1, #5
    32fa:	d913      	bls.n	3324 <i2c_send_sequence+0x68>
	{
		warn_msg("I2C Bus Error: ");
    32fc:	4834      	ldr	r0, [pc, #208]	; (33d0 <i2c_send_sequence+0x114>)
    32fe:	e9cd 2304 	strd	r2, r3, [sp, #16]
    3302:	f00c f935 	bl	f570 <_print>
		printInt8( ch );
    3306:	4658      	mov	r0, fp
    3308:	f00c f99c 	bl	f644 <printInt8>
		print(" errors: ");
    330c:	4831      	ldr	r0, [pc, #196]	; (33d4 <i2c_send_sequence+0x118>)
    330e:	f00c f92f 	bl	f570 <_print>
		printInt32( channel->error_count );
    3312:	f8da 0018 	ldr.w	r0, [sl, #24]
    3316:	f00c fa01 	bl	f71c <printInt32>
		print( NL );
    331a:	482f      	ldr	r0, [pc, #188]	; (33d8 <i2c_send_sequence+0x11c>)
    331c:	f00c f928 	bl	f570 <_print>
    3320:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
		print(" ");
	}
	print(NL);
	*/

	channel->sequence = sequence;
    3324:	eb05 0a06 	add.w	sl, r5, r6
	channel->sequence_end = sequence + sequence_length;
    3328:	eb08 0242 	add.w	r2, r8, r2, lsl #1
	channel->sequence = sequence;
    332c:	f845 8006 	str.w	r8, [r5, r6]
	channel->sequence_end = sequence + sequence_length;
    3330:	f8ca 2004 	str.w	r2, [sl, #4]
	channel->received_data = received_data;
    3334:	f8ca 3008 	str.w	r3, [sl, #8]
	channel->status = I2C_BUSY;
    3338:	2301      	movs	r3, #1
    333a:	f88a 3015 	strb.w	r3, [sl, #21]
	channel->txrx = I2C_WRITING;
    333e:	2300      	movs	r3, #0
    3340:	f88a 3016 	strb.w	r3, [sl, #22]
	channel->callback_fn = callback_fn;
    3344:	9b01      	ldr	r3, [sp, #4]
    3346:	f8ca 300c 	str.w	r3, [sl, #12]
	channel->user_data = user_data;
    334a:	9b02      	ldr	r3, [sp, #8]
    334c:	f8ca 3010 	str.w	r3, [sl, #16]

	// reads_ahead does not need to be initialized

#if defined(_kinetis_)
	// Acknowledge the interrupt request, just in case
	*I2C_S |= I2C_S_IICIF;
    3350:	f814 3009 	ldrb.w	r3, [r4, r9]
    3354:	f043 0302 	orr.w	r3, r3, #2
    3358:	f804 3009 	strb.w	r3, [r4, r9]
	*I2C_C1 = ( I2C_C1_IICEN | I2C_C1_IICIE );
    335c:	23c0      	movs	r3, #192	; 0xc0
    335e:	55e3      	strb	r3, [r4, r7]

	// Generate a start condition and prepare for transmitting.
	*I2C_C1 |= ( I2C_C1_MST | I2C_C1_TX );
    3360:	5de3      	ldrb	r3, [r4, r7]
    3362:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    3366:	55e3      	strb	r3, [r4, r7]

	status = *I2C_S;
    3368:	f814 0009 	ldrb.w	r0, [r4, r9]
	if ( status & I2C_S_ARBL )
    336c:	f010 0010 	ands.w	r0, r0, #16
    3370:	d016      	beq.n	33a0 <i2c_send_sequence+0xe4>
	{
		warn_print("Arbitration lost");
    3372:	481a      	ldr	r0, [pc, #104]	; (33dc <i2c_send_sequence+0x120>)
    3374:	f00c f8fc 	bl	f570 <_print>
	// Everything is OK.
	return result;

i2c_send_sequence_cleanup:
	// Record error, and reset last error counter
	channel->error_count++;
    3378:	f8da 3018 	ldr.w	r3, [sl, #24]
    337c:	3301      	adds	r3, #1
    337e:	f8ca 3018 	str.w	r3, [sl, #24]
	channel->last_error++;
    3382:	f8da 301c 	ldr.w	r3, [sl, #28]
    3386:	3301      	adds	r3, #1
    3388:	f8ca 301c 	str.w	r3, [sl, #28]

	// Generate STOP and disable further interrupts.
	*I2C_C1 &= ~( I2C_C1_IICIE | I2C_C1_MST | I2C_C1_TX );
    338c:	5de3      	ldrb	r3, [r4, r7]
    338e:	f003 038f 	and.w	r3, r3, #143	; 0x8f
    3392:	55e3      	strb	r3, [r4, r7]
	channel->status = I2C_ERROR;
    3394:	2302      	movs	r3, #2
    3396:	f88a 3015 	strb.w	r3, [sl, #21]
		return -1;
    339a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    339e:	e005      	b.n	33ac <i2c_send_sequence+0xf0>
	address = *channel->sequence++;
    33a0:	59ab      	ldr	r3, [r5, r6]
    33a2:	1c9a      	adds	r2, r3, #2
    33a4:	51aa      	str	r2, [r5, r6]
    33a6:	781a      	ldrb	r2, [r3, #0]
	*I2C_D = address;
    33a8:	4b0d      	ldr	r3, [pc, #52]	; (33e0 <i2c_send_sequence+0x124>)
    33aa:	54e2      	strb	r2, [r4, r3]
	// Everything is OK.
	return result;
#endif

	return result;
}
    33ac:	9b03      	ldr	r3, [sp, #12]
    33ae:	9a07      	ldr	r2, [sp, #28]
    33b0:	681b      	ldr	r3, [r3, #0]
    33b2:	429a      	cmp	r2, r3
    33b4:	d001      	beq.n	33ba <i2c_send_sequence+0xfe>
    33b6:	f7ff f9bb 	bl	2730 <__stack_chk_fail>
    33ba:	b009      	add	sp, #36	; 0x24
    33bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    33c0:	1fff89d0 	.word	0x1fff89d0
    33c4:	1fff9ef4 	.word	0x1fff9ef4
    33c8:	40066002 	.word	0x40066002
    33cc:	1fff89d8 	.word	0x1fff89d8
    33d0:	0000facd 	.word	0x0000facd
    33d4:	0000faf2 	.word	0x0000faf2
    33d8:	00015df4 	.word	0x00015df4
    33dc:	0000fafc 	.word	0x0000fafc
    33e0:	40066004 	.word	0x40066004
    33e4:	40066003 	.word	0x40066003

000033e8 <i2c_isr>:


void i2c_isr( uint8_t ch )
{
    33e8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    33ec:	4d6e      	ldr	r5, [pc, #440]	; (35a8 <i2c_isr+0x1c0>)
	volatile I2C_Channel* channel = &i2c_channels[ch - ISSI_I2C_FirstBus_define];
#if defined(_kinetis_)
	volatile uint8_t *I2C_C1  = (uint8_t*)(&I2C0_C1) + i2c_offset[ch];
    33ee:	4f6f      	ldr	r7, [pc, #444]	; (35ac <i2c_isr+0x1c4>)
{
    33f0:	682b      	ldr	r3, [r5, #0]
    33f2:	9301      	str	r3, [sp, #4]
	volatile uint8_t *I2C_C1  = (uint8_t*)(&I2C0_C1) + i2c_offset[ch];
    33f4:	4b6e      	ldr	r3, [pc, #440]	; (35b0 <i2c_isr+0x1c8>)
    33f6:	4e6f      	ldr	r6, [pc, #444]	; (35b4 <i2c_isr+0x1cc>)
    33f8:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
	volatile uint8_t *I2C_S   = (uint8_t*)(&I2C0_S) + i2c_offset[ch];
    33fc:	4b6e      	ldr	r3, [pc, #440]	; (35b8 <i2c_isr+0x1d0>)

	uint16_t element;
	uint8_t status;

#if defined(_kinetis_)
	status = *I2C_S;
    33fe:	5ce1      	ldrb	r1, [r4, r3]

	// Acknowledge the interrupt request
	*I2C_S |= I2C_S_IICIF;
    3400:	5ce2      	ldrb	r2, [r4, r3]
	status = *I2C_S;
    3402:	b2c9      	uxtb	r1, r1
	*I2C_S |= I2C_S_IICIF;
    3404:	f042 0202 	orr.w	r2, r2, #2

	// Arbitration problem
	if ( status & I2C_S_ARBL )
    3408:	f011 0f10 	tst.w	r1, #16
    340c:	46a8      	mov	r8, r5
	*I2C_S |= I2C_S_IICIF;
    340e:	54e2      	strb	r2, [r4, r3]
    3410:	ea4f 1540 	mov.w	r5, r0, lsl #5
	if ( status & I2C_S_ARBL )
    3414:	d014      	beq.n	3440 <i2c_isr+0x58>
		warn_msg("Arbitration error. Bus: ");
		printHex( ch );
		print(NL);
		*/

		*I2C_S |= I2C_S_ARBL;
    3416:	5ce2      	ldrb	r2, [r4, r3]
    3418:	f042 0210 	orr.w	r2, r2, #16
    341c:	54e2      	strb	r2, [r4, r3]
	}
	return;

i2c_isr_error:
	// Record error, and reset last error counter
	channel->error_count++;
    341e:	4435      	add	r5, r6
	channel->last_error++;

	// Generate STOP and disable further interrupts.
	warn_print("ISR error");
    3420:	4866      	ldr	r0, [pc, #408]	; (35bc <i2c_isr+0x1d4>)
	channel->error_count++;
    3422:	69ab      	ldr	r3, [r5, #24]
    3424:	3301      	adds	r3, #1
    3426:	61ab      	str	r3, [r5, #24]
	channel->last_error++;
    3428:	69eb      	ldr	r3, [r5, #28]
    342a:	3301      	adds	r3, #1
    342c:	61eb      	str	r3, [r5, #28]
	warn_print("ISR error");
    342e:	f00c f89f 	bl	f570 <_print>
#if defined(_kinetis_)
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE );
    3432:	5de3      	ldrb	r3, [r4, r7]
    3434:	f003 039f 	and.w	r3, r3, #159	; 0x9f
    3438:	55e3      	strb	r3, [r4, r7]
#elif defined(_sam_)
	twi_dev->TWI_CR |= TWI_CR_STOP;
	twi_dev->TWI_IDR = 0xFFFFFFFF;
#endif
	channel->status = I2C_ERROR;
    343a:	2302      	movs	r3, #2
    343c:	756b      	strb	r3, [r5, #21]
	return;
    343e:	e03d      	b.n	34bc <i2c_isr+0xd4>
	if ( channel->txrx == I2C_READING )
    3440:	1973      	adds	r3, r6, r5
	volatile uint8_t *I2C_D   = (uint8_t*)(&I2C0_D) + i2c_offset[ch];
    3442:	4a5f      	ldr	r2, [pc, #380]	; (35c0 <i2c_isr+0x1d8>)
	if ( channel->txrx == I2C_READING )
    3444:	7d98      	ldrb	r0, [r3, #22]
    3446:	2801      	cmp	r0, #1
    3448:	d145      	bne.n	34d6 <i2c_isr+0xee>
		switch( channel->reads_ahead )
    344a:	7d19      	ldrb	r1, [r3, #20]
    344c:	f001 00ff 	and.w	r0, r1, #255	; 0xff
    3450:	b139      	cbz	r1, 3462 <i2c_isr+0x7a>
    3452:	2801      	cmp	r0, #1
    3454:	d03a      	beq.n	34cc <i2c_isr+0xe4>
			*channel->received_data++ = *I2C_D;
    3456:	6899      	ldr	r1, [r3, #8]
    3458:	1c48      	adds	r0, r1, #1
    345a:	6098      	str	r0, [r3, #8]
    345c:	5ca3      	ldrb	r3, [r4, r2]
    345e:	700b      	strb	r3, [r1, #0]
			break;
    3460:	e021      	b.n	34a6 <i2c_isr+0xbe>
			*I2C_C1 |= I2C_C1_TX;
    3462:	5de1      	ldrb	r1, [r4, r7]
    3464:	f041 0110 	orr.w	r1, r1, #16
    3468:	55e1      	strb	r1, [r4, r7]
			*channel->received_data++ = *I2C_D;
    346a:	6899      	ldr	r1, [r3, #8]
    346c:	f101 0c01 	add.w	ip, r1, #1
    3470:	f8c3 c008 	str.w	ip, [r3, #8]
    3474:	f814 c002 	ldrb.w	ip, [r4, r2]
    3478:	f881 c000 	strb.w	ip, [r1]
			if ( ( channel->sequence < channel->sequence_end ) && ( *channel->sequence == I2C_RESTART ) )
    347c:	f856 c005 	ldr.w	ip, [r6, r5]
    3480:	6859      	ldr	r1, [r3, #4]
    3482:	458c      	cmp	ip, r1
    3484:	d275      	bcs.n	3572 <i2c_isr+0x18a>
    3486:	5971      	ldr	r1, [r6, r5]
    3488:	8809      	ldrh	r1, [r1, #0]
    348a:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
    348e:	d170      	bne.n	3572 <i2c_isr+0x18a>
				*I2C_C1 |= I2C_C1_RSTA;
    3490:	5de1      	ldrb	r1, [r4, r7]
    3492:	f041 0104 	orr.w	r1, r1, #4
    3496:	55e1      	strb	r1, [r4, r7]
				channel->txrx = I2C_WRITING;
    3498:	7598      	strb	r0, [r3, #22]
				channel->sequence++;
    349a:	5973      	ldr	r3, [r6, r5]
    349c:	3302      	adds	r3, #2
    349e:	5173      	str	r3, [r6, r5]
				element = *channel->sequence;
    34a0:	5973      	ldr	r3, [r6, r5]
				*I2C_D = element;
    34a2:	781b      	ldrb	r3, [r3, #0]
    34a4:	54a3      	strb	r3, [r4, r2]
		channel->reads_ahead--;
    34a6:	1972      	adds	r2, r6, r5
    34a8:	7d13      	ldrb	r3, [r2, #20]
    34aa:	3b01      	subs	r3, #1
    34ac:	b2db      	uxtb	r3, r3
    34ae:	7513      	strb	r3, [r2, #20]
	channel->sequence++;
    34b0:	5973      	ldr	r3, [r6, r5]
    34b2:	1972      	adds	r2, r6, r5
    34b4:	3302      	adds	r3, #2
    34b6:	5173      	str	r3, [r6, r5]
	channel->last_error = 0; // No error
    34b8:	2300      	movs	r3, #0
    34ba:	61d3      	str	r3, [r2, #28]
}
    34bc:	9a01      	ldr	r2, [sp, #4]
    34be:	f8d8 3000 	ldr.w	r3, [r8]
    34c2:	429a      	cmp	r2, r3
    34c4:	d169      	bne.n	359a <i2c_isr+0x1b2>
    34c6:	b002      	add	sp, #8
    34c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			*I2C_C1 |= I2C_C1_TXAK;
    34cc:	5de1      	ldrb	r1, [r4, r7]
    34ce:	f041 0108 	orr.w	r1, r1, #8
    34d2:	55e1      	strb	r1, [r4, r7]
    34d4:	e7bf      	b.n	3456 <i2c_isr+0x6e>
		if ( channel->sequence == channel->sequence_end )
    34d6:	f856 c005 	ldr.w	ip, [r6, r5]
    34da:	6858      	ldr	r0, [r3, #4]
    34dc:	4584      	cmp	ip, r0
    34de:	d048      	beq.n	3572 <i2c_isr+0x18a>
		if ( status & I2C_S_RXAK )
    34e0:	07c9      	lsls	r1, r1, #31
    34e2:	d503      	bpl.n	34ec <i2c_isr+0x104>
			warn_print("NACK Received");
    34e4:	4837      	ldr	r0, [pc, #220]	; (35c4 <i2c_isr+0x1dc>)
    34e6:	f00c f843 	bl	f570 <_print>
			goto i2c_isr_error;
    34ea:	e798      	b.n	341e <i2c_isr+0x36>
		element = *channel->sequence;
    34ec:	5971      	ldr	r1, [r6, r5]
    34ee:	8809      	ldrh	r1, [r1, #0]
		if ( element == I2C_RESTART )
    34f0:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
    34f4:	d10a      	bne.n	350c <i2c_isr+0x124>
			*I2C_C1 |= I2C_C1_RSTA | I2C_C1_TX;
    34f6:	5de3      	ldrb	r3, [r4, r7]
    34f8:	f043 0314 	orr.w	r3, r3, #20
    34fc:	55e3      	strb	r3, [r4, r7]
			channel->sequence++;
    34fe:	5973      	ldr	r3, [r6, r5]
    3500:	3302      	adds	r3, #2
    3502:	5173      	str	r3, [r6, r5]
			element = *channel->sequence;
    3504:	5973      	ldr	r3, [r6, r5]
			*I2C_D = element;
    3506:	781b      	ldrb	r3, [r3, #0]
    3508:	54a3      	strb	r3, [r4, r2]
    350a:	e7d1      	b.n	34b0 <i2c_isr+0xc8>
			if ( element == I2C_READ ) {
    350c:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    3510:	d12c      	bne.n	356c <i2c_isr+0x184>
				channel->txrx = I2C_READING;
    3512:	2101      	movs	r1, #1
    3514:	7599      	strb	r1, [r3, #22]
					channel->reads_ahead++;
    3516:	7519      	strb	r1, [r3, #20]
					(  ( channel->sequence + channel->reads_ahead ) < channel->sequence_end ) &&
    3518:	6819      	ldr	r1, [r3, #0]
    351a:	f893 c014 	ldrb.w	ip, [r3, #20]
    351e:	6858      	ldr	r0, [r3, #4]
    3520:	eb01 014c 	add.w	r1, r1, ip, lsl #1
				while (
    3524:	4288      	cmp	r0, r1
    3526:	d906      	bls.n	3536 <i2c_isr+0x14e>
					( *( channel->sequence + channel->reads_ahead ) == I2C_READ )
    3528:	6819      	ldr	r1, [r3, #0]
    352a:	7d18      	ldrb	r0, [r3, #20]
					(  ( channel->sequence + channel->reads_ahead ) < channel->sequence_end ) &&
    352c:	f831 1010 	ldrh.w	r1, [r1, r0, lsl #1]
    3530:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
    3534:	d016      	beq.n	3564 <i2c_isr+0x17c>
				*I2C_C1 &= ~I2C_C1_TX;
    3536:	5de3      	ldrb	r3, [r4, r7]
    3538:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    353c:	55e3      	strb	r3, [r4, r7]
				if ( channel->reads_ahead == 1 )
    353e:	1973      	adds	r3, r6, r5
				*channel->received_data = *I2C_D;
    3540:	1971      	adds	r1, r6, r5
				if ( channel->reads_ahead == 1 )
    3542:	7d1b      	ldrb	r3, [r3, #20]
    3544:	2b01      	cmp	r3, #1
					*I2C_C1 |= I2C_C1_TXAK;
    3546:	5de3      	ldrb	r3, [r4, r7]
    3548:	bf0c      	ite	eq
    354a:	f043 0308 	orreq.w	r3, r3, #8
					*I2C_C1 &= ~( I2C_C1_TXAK );
    354e:	f003 03f7 	andne.w	r3, r3, #247	; 0xf7
    3552:	55e3      	strb	r3, [r4, r7]
				*channel->received_data = *I2C_D;
    3554:	688b      	ldr	r3, [r1, #8]
    3556:	5ca2      	ldrb	r2, [r4, r2]
    3558:	701a      	strb	r2, [r3, #0]
				channel->reads_ahead--;
    355a:	7d0b      	ldrb	r3, [r1, #20]
    355c:	3b01      	subs	r3, #1
    355e:	b2db      	uxtb	r3, r3
    3560:	750b      	strb	r3, [r1, #20]
    3562:	e7a5      	b.n	34b0 <i2c_isr+0xc8>
					channel->reads_ahead++;
    3564:	7d19      	ldrb	r1, [r3, #20]
    3566:	3101      	adds	r1, #1
    3568:	b2c9      	uxtb	r1, r1
    356a:	e7d4      	b.n	3516 <i2c_isr+0x12e>
				*I2C_D = element;
    356c:	b2c9      	uxtb	r1, r1
    356e:	54a1      	strb	r1, [r4, r2]
    3570:	e79e      	b.n	34b0 <i2c_isr+0xc8>
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE | I2C_C1_TXAK );
    3572:	5de3      	ldrb	r3, [r4, r7]
	channel->status = I2C_AVAILABLE;
    3574:	4435      	add	r5, r6
	*I2C_C1 &= ~( I2C_C1_MST | I2C_C1_IICIE | I2C_C1_TXAK );
    3576:	f003 0397 	and.w	r3, r3, #151	; 0x97
    357a:	55e3      	strb	r3, [r4, r7]
	channel->status = I2C_AVAILABLE;
    357c:	2300      	movs	r3, #0
    357e:	756b      	strb	r3, [r5, #21]
	if ( channel->callback_fn )
    3580:	68eb      	ldr	r3, [r5, #12]
    3582:	2b00      	cmp	r3, #0
    3584:	d09a      	beq.n	34bc <i2c_isr+0xd4>
		delay_us(25);
    3586:	2019      	movs	r0, #25
    3588:	f7ff f95c 	bl	2844 <delay_us>
		( *channel->callback_fn )( channel->user_data );
    358c:	68eb      	ldr	r3, [r5, #12]
    358e:	6928      	ldr	r0, [r5, #16]
    3590:	9901      	ldr	r1, [sp, #4]
    3592:	f8d8 2000 	ldr.w	r2, [r8]
    3596:	4291      	cmp	r1, r2
    3598:	d001      	beq.n	359e <i2c_isr+0x1b6>
}
    359a:	f7ff f8c9 	bl	2730 <__stack_chk_fail>
    359e:	b002      	add	sp, #8
    35a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		( *channel->callback_fn )( channel->user_data );
    35a4:	4718      	bx	r3
    35a6:	bf00      	nop
    35a8:	1fff89d0 	.word	0x1fff89d0
    35ac:	40066002 	.word	0x40066002
    35b0:	1fff89d8 	.word	0x1fff89d8
    35b4:	1fff9ef4 	.word	0x1fff9ef4
    35b8:	40066003 	.word	0x40066003
    35bc:	0000faac 	.word	0x0000faac
    35c0:	40066004 	.word	0x40066004
    35c4:	0000fa87 	.word	0x0000fa87

000035c8 <i2c0_isr>:

#if defined(_kinetis_)
void i2c0_isr()
{
    35c8:	b507      	push	{r0, r1, r2, lr}
    35ca:	4b07      	ldr	r3, [pc, #28]	; (35e8 <i2c0_isr+0x20>)
    35cc:	681a      	ldr	r2, [r3, #0]
    35ce:	9201      	str	r2, [sp, #4]
	i2c_isr( 0 );
    35d0:	9a01      	ldr	r2, [sp, #4]
    35d2:	681b      	ldr	r3, [r3, #0]
    35d4:	429a      	cmp	r2, r3
    35d6:	d001      	beq.n	35dc <i2c0_isr+0x14>
    35d8:	f7ff f8aa 	bl	2730 <__stack_chk_fail>
    35dc:	2000      	movs	r0, #0
}
    35de:	b003      	add	sp, #12
    35e0:	f85d eb04 	ldr.w	lr, [sp], #4
	i2c_isr( 0 );
    35e4:	f7ff bf00 	b.w	33e8 <i2c_isr>
    35e8:	1fff89d0 	.word	0x1fff89d0

000035ec <i2c1_isr>:

void i2c1_isr()
{
    35ec:	b507      	push	{r0, r1, r2, lr}
    35ee:	4b07      	ldr	r3, [pc, #28]	; (360c <i2c1_isr+0x20>)
    35f0:	681a      	ldr	r2, [r3, #0]
    35f2:	9201      	str	r2, [sp, #4]
	i2c_isr( 1 );
    35f4:	9a01      	ldr	r2, [sp, #4]
    35f6:	681b      	ldr	r3, [r3, #0]
    35f8:	429a      	cmp	r2, r3
    35fa:	d001      	beq.n	3600 <i2c1_isr+0x14>
    35fc:	f7ff f898 	bl	2730 <__stack_chk_fail>
    3600:	2001      	movs	r0, #1
}
    3602:	b003      	add	sp, #12
    3604:	f85d eb04 	ldr.w	lr, [sp], #4
	i2c_isr( 1 );
    3608:	f7ff beee 	b.w	33e8 <i2c_isr>
    360c:	1fff89d0 	.word	0x1fff89d0

00003610 <cliFunc_ledToggle>:
	printInt32( LED_framerate );
	print("ms");
}

void cliFunc_ledToggle( char* args )
{
    3610:	b513      	push	{r0, r1, r4, lr}
    3612:	4c0b      	ldr	r4, [pc, #44]	; (3640 <cliFunc_ledToggle+0x30>)
	print( NL ); // No \r\n by default after the command is entered
    3614:	480b      	ldr	r0, [pc, #44]	; (3644 <cliFunc_ledToggle+0x34>)
{
    3616:	6823      	ldr	r3, [r4, #0]
    3618:	9301      	str	r3, [sp, #4]
	print( NL ); // No \r\n by default after the command is entered
    361a:	f00b ffa9 	bl	f570 <_print>
	info_msg("LEDs Toggle");
    361e:	480a      	ldr	r0, [pc, #40]	; (3648 <cliFunc_ledToggle+0x38>)
    3620:	f00b ffa6 	bl	f570 <_print>
	LED_enable = !LED_enable;
    3624:	4a09      	ldr	r2, [pc, #36]	; (364c <cliFunc_ledToggle+0x3c>)
    3626:	7813      	ldrb	r3, [r2, #0]
    3628:	fab3 f383 	clz	r3, r3
    362c:	095b      	lsrs	r3, r3, #5
    362e:	7013      	strb	r3, [r2, #0]
}
    3630:	9a01      	ldr	r2, [sp, #4]
    3632:	6823      	ldr	r3, [r4, #0]
    3634:	429a      	cmp	r2, r3
    3636:	d001      	beq.n	363c <cliFunc_ledToggle+0x2c>
    3638:	f7ff f87a 	bl	2730 <__stack_chk_fail>
    363c:	b002      	add	sp, #8
    363e:	bd10      	pop	{r4, pc}
    3640:	1fff89d0 	.word	0x1fff89d0
    3644:	00015df4 	.word	0x00015df4
    3648:	0000fc2c 	.word	0x0000fc2c
    364c:	1fffa04c 	.word	0x1fffa04c

00003650 <cliFunc_ledCheck>:
{
    3650:	b507      	push	{r0, r1, r2, lr}
    3652:	4b07      	ldr	r3, [pc, #28]	; (3670 <cliFunc_ledCheck+0x20>)
    3654:	681a      	ldr	r2, [r3, #0]
    3656:	9201      	str	r2, [sp, #4]
	print( NL ); // No \r\n by default after the command is entered
    3658:	9a01      	ldr	r2, [sp, #4]
    365a:	681b      	ldr	r3, [r3, #0]
    365c:	429a      	cmp	r2, r3
    365e:	d001      	beq.n	3664 <cliFunc_ledCheck+0x14>
    3660:	f7ff f866 	bl	2730 <__stack_chk_fail>
    3664:	4803      	ldr	r0, [pc, #12]	; (3674 <cliFunc_ledCheck+0x24>)
}
    3666:	b003      	add	sp, #12
    3668:	f85d eb04 	ldr.w	lr, [sp], #4
	print( NL ); // No \r\n by default after the command is entered
    366c:	f00b bf80 	b.w	f570 <_print>
    3670:	1fff89d0 	.word	0x1fff89d0
    3674:	00015df4 	.word	0x00015df4

00003678 <cliFunc_ledSet>:
	// XXX (HaaTa) - Brightness is emulated
#endif
}

void cliFunc_ledSet( char* args )
{
    3678:	b530      	push	{r4, r5, lr}
    367a:	4c12      	ldr	r4, [pc, #72]	; (36c4 <cliFunc_ledSet+0x4c>)
    367c:	b085      	sub	sp, #20
    367e:	4605      	mov	r5, r0
    3680:	6823      	ldr	r3, [r4, #0]
	print( NL ); // No \r\n by default after the command is entered
    3682:	4811      	ldr	r0, [pc, #68]	; (36c8 <cliFunc_ledSet+0x50>)
{
    3684:	9303      	str	r3, [sp, #12]
	print( NL ); // No \r\n by default after the command is entered
    3686:	f00b ff73 	bl	f570 <_print>

	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    368a:	aa04      	add	r2, sp, #16

	// Process speed argument if given
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    368c:	4628      	mov	r0, r5
	char* arg2Ptr = args;
    368e:	f842 5d08 	str.w	r5, [r2, #-8]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3692:	a901      	add	r1, sp, #4
    3694:	f00b fa3e 	bl	eb14 <CLI_argumentIsolation>

	// Reset brightness
	if ( *arg1Ptr == '\0' )
    3698:	9801      	ldr	r0, [sp, #4]
    369a:	4d0c      	ldr	r5, [pc, #48]	; (36cc <cliFunc_ledSet+0x54>)
    369c:	7803      	ldrb	r3, [r0, #0]
    369e:	b953      	cbnz	r3, 36b6 <cliFunc_ledSet+0x3e>
	LED_brightness = brightness;
    36a0:	23ff      	movs	r3, #255	; 0xff
    36a2:	702b      	strb	r3, [r5, #0]
	else
	{
		LED_setBrightness( numToInt(arg1Ptr) );
	}

	info_msg("LED Brightness Set");
    36a4:	480a      	ldr	r0, [pc, #40]	; (36d0 <cliFunc_ledSet+0x58>)
    36a6:	f00b ff63 	bl	f570 <_print>

}
    36aa:	9a03      	ldr	r2, [sp, #12]
    36ac:	6823      	ldr	r3, [r4, #0]
    36ae:	429a      	cmp	r2, r3
    36b0:	d005      	beq.n	36be <cliFunc_ledSet+0x46>
    36b2:	f7ff f83d 	bl	2730 <__stack_chk_fail>
		LED_setBrightness( numToInt(arg1Ptr) );
    36b6:	f00c f92b 	bl	f910 <numToInt>
    36ba:	7028      	strb	r0, [r5, #0]
    36bc:	e7f2      	b.n	36a4 <cliFunc_ledSet+0x2c>
}
    36be:	b005      	add	sp, #20
    36c0:	bd30      	pop	{r4, r5, pc}
    36c2:	bf00      	nop
    36c4:	1fff89d0 	.word	0x1fff89d0
    36c8:	00015df4 	.word	0x00015df4
    36cc:	1fffa040 	.word	0x1fffa040
    36d0:	0000fc07 	.word	0x0000fc07

000036d4 <LED_linkedSend>:
{
    36d4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    36d8:	4d16      	ldr	r5, [pc, #88]	; (3734 <LED_linkedSend+0x60>)
	if ( LED_chipSend >= ISSI_Chips_define )
    36da:	4c17      	ldr	r4, [pc, #92]	; (3738 <LED_linkedSend+0x64>)
{
    36dc:	682a      	ldr	r2, [r5, #0]
    36de:	9203      	str	r2, [sp, #12]
	if ( LED_chipSend >= ISSI_Chips_define )
    36e0:	7822      	ldrb	r2, [r4, #0]
    36e2:	4b16      	ldr	r3, [pc, #88]	; (373c <LED_linkedSend+0x68>)
    36e4:	b13a      	cbz	r2, 36f6 <LED_linkedSend+0x22>
		Pixel_FrameState = FrameState_Update;
    36e6:	2202      	movs	r2, #2
    36e8:	701a      	strb	r2, [r3, #0]
}
    36ea:	9a03      	ldr	r2, [sp, #12]
    36ec:	682b      	ldr	r3, [r5, #0]
    36ee:	429a      	cmp	r2, r3
    36f0:	d01c      	beq.n	372c <LED_linkedSend+0x58>
    36f2:	f7ff f81d 	bl	2730 <__stack_chk_fail>
	Pixel_FrameState = FrameState_Sending;
    36f6:	2201      	movs	r2, #1
		(uint16_t*)&LED_pageBuffer_brightness[ LED_chipSend ],
    36f8:	4e11      	ldr	r6, [pc, #68]	; (3740 <LED_linkedSend+0x6c>)
	while ( i2c_send_sequence(
    36fa:	f8df 8048 	ldr.w	r8, [pc, #72]	; 3744 <LED_linkedSend+0x70>
	Pixel_FrameState = FrameState_Sending;
    36fe:	701a      	strb	r2, [r3, #0]
		(uint16_t*)&LED_pageBuffer_brightness[ LED_chipSend ],
    3700:	f44f 7792 	mov.w	r7, #292	; 0x124
    3704:	7821      	ldrb	r1, [r4, #0]
	while ( i2c_send_sequence(
    3706:	2300      	movs	r3, #0
    3708:	e9cd 8300 	strd	r8, r3, [sp]
    370c:	2292      	movs	r2, #146	; 0x92
    370e:	fb07 6101 	mla	r1, r7, r1, r6
    3712:	4618      	mov	r0, r3
    3714:	f7ff fdd2 	bl	32bc <i2c_send_sequence>
    3718:	3001      	adds	r0, #1
    371a:	d003      	beq.n	3724 <LED_linkedSend+0x50>
	LED_chipSend++;
    371c:	7823      	ldrb	r3, [r4, #0]
    371e:	3301      	adds	r3, #1
    3720:	7023      	strb	r3, [r4, #0]
    3722:	e7e2      	b.n	36ea <LED_linkedSend+0x16>
		delay_us( delay_tm );
    3724:	20c8      	movs	r0, #200	; 0xc8
    3726:	f7ff f88d 	bl	2844 <delay_us>
    372a:	e7eb      	b.n	3704 <LED_linkedSend+0x30>
}
    372c:	b004      	add	sp, #16
    372e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3732:	bf00      	nop
    3734:	1fff89d0 	.word	0x1fff89d0
    3738:	1fff9f18 	.word	0x1fff9f18
    373c:	1fffab55 	.word	0x1fffab55
    3740:	1fff9f1c 	.word	0x1fff9f1c
    3744:	000036d5 	.word	0x000036d5

00003748 <cliFunc_ledFPS>:
{
    3748:	b530      	push	{r4, r5, lr}
    374a:	4c1c      	ldr	r4, [pc, #112]	; (37bc <cliFunc_ledFPS+0x74>)
    374c:	b085      	sub	sp, #20
    374e:	4605      	mov	r5, r0
    3750:	6823      	ldr	r3, [r4, #0]
	print( NL ); // No \r\n by default after the command is entered
    3752:	481b      	ldr	r0, [pc, #108]	; (37c0 <cliFunc_ledFPS+0x78>)
{
    3754:	9303      	str	r3, [sp, #12]
	print( NL ); // No \r\n by default after the command is entered
    3756:	f00b ff0b 	bl	f570 <_print>
	char* arg2Ptr = args;
    375a:	aa04      	add	r2, sp, #16
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    375c:	4628      	mov	r0, r5
	char* arg2Ptr = args;
    375e:	f842 5d08 	str.w	r5, [r2, #-8]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    3762:	a901      	add	r1, sp, #4
    3764:	f00b f9d6 	bl	eb14 <CLI_argumentIsolation>
	if ( *arg1Ptr == '\0' )
    3768:	9801      	ldr	r0, [sp, #4]
    376a:	7803      	ldrb	r3, [r0, #0]
    376c:	4625      	mov	r5, r4
    376e:	b973      	cbnz	r3, 378e <cliFunc_ledFPS+0x46>
		info_msg("FPS Toggle");
    3770:	4814      	ldr	r0, [pc, #80]	; (37c4 <cliFunc_ledFPS+0x7c>)
    3772:	f00b fefd 	bl	f570 <_print>
		LED_displayFPS = !LED_displayFPS;
    3776:	4a14      	ldr	r2, [pc, #80]	; (37c8 <cliFunc_ledFPS+0x80>)
    3778:	7813      	ldrb	r3, [r2, #0]
    377a:	fab3 f383 	clz	r3, r3
    377e:	095b      	lsrs	r3, r3, #5
    3780:	7013      	strb	r3, [r2, #0]
}
    3782:	9a03      	ldr	r2, [sp, #12]
    3784:	682b      	ldr	r3, [r5, #0]
    3786:	429a      	cmp	r2, r3
    3788:	d016      	beq.n	37b8 <cliFunc_ledFPS+0x70>
    378a:	f7fe ffd1 	bl	2730 <__stack_chk_fail>
	switch ( *arg1Ptr )
    378e:	2b52      	cmp	r3, #82	; 0x52
    3790:	4c0e      	ldr	r4, [pc, #56]	; (37cc <cliFunc_ledFPS+0x84>)
    3792:	d001      	beq.n	3798 <cliFunc_ledFPS+0x50>
    3794:	2b72      	cmp	r3, #114	; 0x72
    3796:	d10b      	bne.n	37b0 <cliFunc_ledFPS+0x68>
		LED_framerate = ISSI_FrameRate_ms_define;
    3798:	2364      	movs	r3, #100	; 0x64
    379a:	6023      	str	r3, [r4, #0]
	info_msg("Setting framerate to: ");
    379c:	480c      	ldr	r0, [pc, #48]	; (37d0 <cliFunc_ledFPS+0x88>)
    379e:	f00b fee7 	bl	f570 <_print>
	printInt32( LED_framerate );
    37a2:	6820      	ldr	r0, [r4, #0]
    37a4:	f00b ffba 	bl	f71c <printInt32>
	print("ms");
    37a8:	480a      	ldr	r0, [pc, #40]	; (37d4 <cliFunc_ledFPS+0x8c>)
    37aa:	f00b fee1 	bl	f570 <_print>
    37ae:	e7e8      	b.n	3782 <cliFunc_ledFPS+0x3a>
		LED_framerate = numToInt( arg1Ptr );
    37b0:	f00c f8ae 	bl	f910 <numToInt>
    37b4:	6020      	str	r0, [r4, #0]
		break;
    37b6:	e7f1      	b.n	379c <cliFunc_ledFPS+0x54>
}
    37b8:	b005      	add	sp, #20
    37ba:	bd30      	pop	{r4, r5, pc}
    37bc:	1fff89d0 	.word	0x1fff89d0
    37c0:	00015df4 	.word	0x00015df4
    37c4:	0000fbbe 	.word	0x0000fbbe
    37c8:	1fff9f1b 	.word	0x1fff9f1b
    37cc:	1fff9f14 	.word	0x1fff9f14
    37d0:	0000fbdb 	.word	0x0000fbdb
    37d4:	0000fc04 	.word	0x0000fc04

000037d8 <LED_setupPage>:
{
    37d8:	b570      	push	{r4, r5, r6, lr}
    37da:	4c15      	ldr	r4, [pc, #84]	; (3830 <LED_setupPage+0x58>)
    37dc:	b086      	sub	sp, #24
    37de:	4605      	mov	r5, r0
	uint16_t pageSetup[] = { addr, 0xFD, page };
    37e0:	f8ad 100c 	strh.w	r1, [sp, #12]
{
    37e4:	6820      	ldr	r0, [r4, #0]
    37e6:	9005      	str	r0, [sp, #20]
	uint16_t pageSetup[] = { addr, 0xFD, page };
    37e8:	21fd      	movs	r1, #253	; 0xfd
    37ea:	f8ad 100e 	strh.w	r1, [sp, #14]
    37ee:	f8ad 2010 	strh.w	r2, [sp, #16]
	while ( i2c_send( bus, pageSetup, sizeof( pageSetup ) / 2 ) == -1 )
    37f2:	2600      	movs	r6, #0
    37f4:	e9cd 6600 	strd	r6, r6, [sp]
    37f8:	2300      	movs	r3, #0
    37fa:	2203      	movs	r2, #3
    37fc:	a903      	add	r1, sp, #12
    37fe:	4628      	mov	r0, r5
    3800:	f7ff fd5c 	bl	32bc <i2c_send_sequence>
    3804:	3001      	adds	r0, #1
    3806:	d009      	beq.n	381c <LED_setupPage+0x44>
	while ( i2c_busy( bus ) )
    3808:	4628      	mov	r0, r5
    380a:	f7ff fd3f 	bl	328c <i2c_busy>
    380e:	b948      	cbnz	r0, 3824 <LED_setupPage+0x4c>
}
    3810:	9a05      	ldr	r2, [sp, #20]
    3812:	6823      	ldr	r3, [r4, #0]
    3814:	429a      	cmp	r2, r3
    3816:	d009      	beq.n	382c <LED_setupPage+0x54>
    3818:	f7fe ff8a 	bl	2730 <__stack_chk_fail>
		delay_us( ISSI_SendDelay );
    381c:	20c8      	movs	r0, #200	; 0xc8
    381e:	f7ff f811 	bl	2844 <delay_us>
    3822:	e7e7      	b.n	37f4 <LED_setupPage+0x1c>
		delay_us( ISSI_SendDelay );
    3824:	20c8      	movs	r0, #200	; 0xc8
    3826:	f7ff f80d 	bl	2844 <delay_us>
    382a:	e7ed      	b.n	3808 <LED_setupPage+0x30>
}
    382c:	b006      	add	sp, #24
    382e:	bd70      	pop	{r4, r5, r6, pc}
    3830:	1fff89d0 	.word	0x1fff89d0

00003834 <LED_zeroPages>:
{
    3834:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3838:	b0de      	sub	sp, #376	; 0x178
    383a:	4e22      	ldr	r6, [pc, #136]	; (38c4 <LED_zeroPages+0x90>)
    383c:	f89d 519c 	ldrb.w	r5, [sp, #412]	; 0x19c
    3840:	f89d a198 	ldrb.w	sl, [sp, #408]	; 0x198
    3844:	4689      	mov	r9, r1
    3846:	4614      	mov	r4, r2
    3848:	4698      	mov	r8, r3
    384a:	4607      	mov	r7, r0
    384c:	6833      	ldr	r3, [r6, #0]
    384e:	935d      	str	r3, [sp, #372]	; 0x174
	uint16_t clearPage[2 + ISSI_PageLength] = { 0 };
    3850:	f44f 72b6 	mov.w	r2, #364	; 0x16c
    3854:	2100      	movs	r1, #0
    3856:	a802      	add	r0, sp, #8
		while ( i2c_send( bus, clearPage, 2 + endReg - startReg ) == -1 )
    3858:	3502      	adds	r5, #2
	uint16_t clearPage[2 + ISSI_PageLength] = { 0 };
    385a:	f7fe ff77 	bl	274c <memset>
	for ( uint8_t page = startPage; page < startPage + numPages; page++ )
    385e:	44a0      	add	r8, r4
	clearPage[0] = addr;
    3860:	f8ad 9008 	strh.w	r9, [sp, #8]
	clearPage[1] = startReg;
    3864:	f8ad a00a 	strh.w	sl, [sp, #10]
		while ( i2c_send( bus, clearPage, 2 + endReg - startReg ) == -1 )
    3868:	eba5 050a 	sub.w	r5, r5, sl
	for ( uint8_t page = startPage; page < startPage + numPages; page++ )
    386c:	4544      	cmp	r4, r8
    386e:	db09      	blt.n	3884 <LED_zeroPages+0x50>
	while ( i2c_busy( bus ) )
    3870:	4638      	mov	r0, r7
    3872:	f7ff fd0b 	bl	328c <i2c_busy>
    3876:	b9e8      	cbnz	r0, 38b4 <LED_zeroPages+0x80>
}
    3878:	9a5d      	ldr	r2, [sp, #372]	; 0x174
    387a:	6833      	ldr	r3, [r6, #0]
    387c:	429a      	cmp	r2, r3
    387e:	d01d      	beq.n	38bc <LED_zeroPages+0x88>
    3880:	f7fe ff56 	bl	2730 <__stack_chk_fail>
		LED_setupPage( bus, addr, page );
    3884:	4622      	mov	r2, r4
    3886:	4649      	mov	r1, r9
    3888:	4638      	mov	r0, r7
    388a:	f7ff ffa5 	bl	37d8 <LED_setupPage>
		while ( i2c_send( bus, clearPage, 2 + endReg - startReg ) == -1 )
    388e:	f04f 0a00 	mov.w	sl, #0
    3892:	e9cd aa00 	strd	sl, sl, [sp]
    3896:	2300      	movs	r3, #0
    3898:	462a      	mov	r2, r5
    389a:	a902      	add	r1, sp, #8
    389c:	4638      	mov	r0, r7
    389e:	f7ff fd0d 	bl	32bc <i2c_send_sequence>
    38a2:	3001      	adds	r0, #1
    38a4:	d002      	beq.n	38ac <LED_zeroPages+0x78>
	for ( uint8_t page = startPage; page < startPage + numPages; page++ )
    38a6:	3401      	adds	r4, #1
    38a8:	b2e4      	uxtb	r4, r4
    38aa:	e7df      	b.n	386c <LED_zeroPages+0x38>
			delay_us( ISSI_SendDelay );
    38ac:	20c8      	movs	r0, #200	; 0xc8
    38ae:	f7fe ffc9 	bl	2844 <delay_us>
    38b2:	e7ee      	b.n	3892 <LED_zeroPages+0x5e>
		delay_us( ISSI_SendDelay );
    38b4:	20c8      	movs	r0, #200	; 0xc8
    38b6:	f7fe ffc5 	bl	2844 <delay_us>
    38ba:	e7d9      	b.n	3870 <LED_zeroPages+0x3c>
}
    38bc:	b05e      	add	sp, #376	; 0x178
    38be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    38c2:	bf00      	nop
    38c4:	1fff89d0 	.word	0x1fff89d0

000038c8 <LED_zeroControlPages>:
{
    38c8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    38ca:	4c0a      	ldr	r4, [pc, #40]	; (38f4 <LED_zeroControlPages+0x2c>)
    38cc:	6823      	ldr	r3, [r4, #0]
    38ce:	9303      	str	r3, [sp, #12]
		LED_zeroPages( bus, addr, ISSI_ConfigPage, 1, 0x00, ISSI_ConfigPageLength ); // Control Registers
    38d0:	2000      	movs	r0, #0
    38d2:	230c      	movs	r3, #12
    38d4:	e9cd 0300 	strd	r0, r3, [sp]
    38d8:	220b      	movs	r2, #11
    38da:	2301      	movs	r3, #1
    38dc:	21e8      	movs	r1, #232	; 0xe8
    38de:	f7ff ffa9 	bl	3834 <LED_zeroPages>
}
    38e2:	9a03      	ldr	r2, [sp, #12]
    38e4:	6823      	ldr	r3, [r4, #0]
    38e6:	429a      	cmp	r2, r3
    38e8:	d001      	beq.n	38ee <LED_zeroControlPages+0x26>
    38ea:	f7fe ff21 	bl	2730 <__stack_chk_fail>
    38ee:	b004      	add	sp, #16
    38f0:	bd10      	pop	{r4, pc}
    38f2:	bf00      	nop
    38f4:	1fff89d0 	.word	0x1fff89d0

000038f8 <LED_sendPage>:
{
    38f8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    38fc:	4c10      	ldr	r4, [pc, #64]	; (3940 <LED_sendPage+0x48>)
    38fe:	4617      	mov	r7, r2
    3900:	4698      	mov	r8, r3
    3902:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
    3906:	6823      	ldr	r3, [r4, #0]
    3908:	9303      	str	r3, [sp, #12]
    390a:	4606      	mov	r6, r0
	LED_setupPage( bus, addr, page );
    390c:	f7ff ff64 	bl	37d8 <LED_setupPage>
	while ( i2c_send( bus, buffer, len ) == -1 )
    3910:	2500      	movs	r5, #0
    3912:	e9cd 5500 	strd	r5, r5, [sp]
    3916:	2300      	movs	r3, #0
    3918:	4642      	mov	r2, r8
    391a:	4639      	mov	r1, r7
    391c:	4630      	mov	r0, r6
    391e:	f7ff fccd 	bl	32bc <i2c_send_sequence>
    3922:	3001      	adds	r0, #1
    3924:	d005      	beq.n	3932 <LED_sendPage+0x3a>
}
    3926:	9a03      	ldr	r2, [sp, #12]
    3928:	6823      	ldr	r3, [r4, #0]
    392a:	429a      	cmp	r2, r3
    392c:	d005      	beq.n	393a <LED_sendPage+0x42>
    392e:	f7fe feff 	bl	2730 <__stack_chk_fail>
		delay_us( ISSI_SendDelay );
    3932:	20c8      	movs	r0, #200	; 0xc8
    3934:	f7fe ff86 	bl	2844 <delay_us>
    3938:	e7eb      	b.n	3912 <LED_sendPage+0x1a>
}
    393a:	b004      	add	sp, #16
    393c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3940:	1fff89d0 	.word	0x1fff89d0

00003944 <LED_writeReg>:
{
    3944:	b5f0      	push	{r4, r5, r6, r7, lr}
    3946:	b087      	sub	sp, #28
    3948:	4c16      	ldr	r4, [pc, #88]	; (39a4 <LED_writeReg+0x60>)
    394a:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
    394e:	6827      	ldr	r7, [r4, #0]
	uint16_t writeData[] = { addr, reg, val };
    3950:	f8ad 200e 	strh.w	r2, [sp, #14]
	LED_setupPage( bus, addr, page );
    3954:	4632      	mov	r2, r6
{
    3956:	4605      	mov	r5, r0
    3958:	9705      	str	r7, [sp, #20]
	uint16_t writeData[] = { addr, reg, val };
    395a:	f8ad 100c 	strh.w	r1, [sp, #12]
    395e:	f8ad 3010 	strh.w	r3, [sp, #16]
	LED_setupPage( bus, addr, page );
    3962:	f7ff ff39 	bl	37d8 <LED_setupPage>
	while ( i2c_send( bus, writeData, sizeof( writeData ) / 2 ) == -1 )
    3966:	2600      	movs	r6, #0
    3968:	e9cd 6600 	strd	r6, r6, [sp]
    396c:	2300      	movs	r3, #0
    396e:	2203      	movs	r2, #3
    3970:	a903      	add	r1, sp, #12
    3972:	4628      	mov	r0, r5
    3974:	f7ff fca2 	bl	32bc <i2c_send_sequence>
    3978:	3001      	adds	r0, #1
    397a:	d009      	beq.n	3990 <LED_writeReg+0x4c>
	while ( i2c_busy( bus ) )
    397c:	4628      	mov	r0, r5
    397e:	f7ff fc85 	bl	328c <i2c_busy>
    3982:	b948      	cbnz	r0, 3998 <LED_writeReg+0x54>
}
    3984:	9a05      	ldr	r2, [sp, #20]
    3986:	6823      	ldr	r3, [r4, #0]
    3988:	429a      	cmp	r2, r3
    398a:	d009      	beq.n	39a0 <LED_writeReg+0x5c>
    398c:	f7fe fed0 	bl	2730 <__stack_chk_fail>
		delay_us( ISSI_SendDelay );
    3990:	20c8      	movs	r0, #200	; 0xc8
    3992:	f7fe ff57 	bl	2844 <delay_us>
    3996:	e7e7      	b.n	3968 <LED_writeReg+0x24>
		delay_us( ISSI_SendDelay );
    3998:	20c8      	movs	r0, #200	; 0xc8
    399a:	f7fe ff53 	bl	2844 <delay_us>
    399e:	e7ed      	b.n	397c <LED_writeReg+0x38>
}
    39a0:	b007      	add	sp, #28
    39a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    39a4:	1fff89d0 	.word	0x1fff89d0

000039a8 <LED_reset>:
{
    39a8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    39ac:	4d1d      	ldr	r5, [pc, #116]	; (3a24 <LED_reset+0x7c>)
	Pixel_FrameState = FrameState_Sending;
    39ae:	4e1e      	ldr	r6, [pc, #120]	; (3a28 <LED_reset+0x80>)
{
    39b0:	682b      	ldr	r3, [r5, #0]
    39b2:	9303      	str	r3, [sp, #12]
	LED_displayFPS = 0;
    39b4:	4b1d      	ldr	r3, [pc, #116]	; (3a2c <LED_reset+0x84>)
    39b6:	2400      	movs	r4, #0
    39b8:	701c      	strb	r4, [r3, #0]
		LED_zeroPages( bus, addr, 0x00, ISSI_LEDPages, 0x00, ISSI_PageLength ); // LED Registers
    39ba:	23b4      	movs	r3, #180	; 0xb4
	Pixel_FrameState = FrameState_Sending;
    39bc:	2701      	movs	r7, #1
		LED_zeroPages( bus, addr, 0x00, ISSI_LEDPages, 0x00, ISSI_PageLength ); // LED Registers
    39be:	e9cd 4300 	strd	r4, r3, [sp]
    39c2:	4622      	mov	r2, r4
    39c4:	2308      	movs	r3, #8
    39c6:	21e8      	movs	r1, #232	; 0xe8
    39c8:	4620      	mov	r0, r4
	Pixel_FrameState = FrameState_Sending;
    39ca:	7037      	strb	r7, [r6, #0]
		LED_zeroPages( bus, addr, 0x00, ISSI_LEDPages, 0x00, ISSI_PageLength ); // LED Registers
    39cc:	f7ff ff32 	bl	3834 <LED_zeroPages>
		LED_sendPage(
    39d0:	2314      	movs	r3, #20
    39d2:	4a17      	ldr	r2, [pc, #92]	; (3a30 <LED_reset+0x88>)
    39d4:	9400      	str	r4, [sp, #0]
    39d6:	21e8      	movs	r1, #232	; 0xe8
    39d8:	4620      	mov	r0, r4
    39da:	f7ff ff8d 	bl	38f8 <LED_sendPage>
	LED_brightness = ISSI_Global_Brightness_define;
    39de:	4b15      	ldr	r3, [pc, #84]	; (3a34 <LED_reset+0x8c>)
    39e0:	22ff      	movs	r2, #255	; 0xff
		LED_writeReg( bus, addr, 0x00, 0x00, ISSI_ConfigPage );
    39e2:	f04f 080b 	mov.w	r8, #11
	LED_brightness = ISSI_Global_Brightness_define;
    39e6:	701a      	strb	r2, [r3, #0]
		LED_writeReg( bus, addr, 0x00, 0x00, ISSI_ConfigPage );
    39e8:	21e8      	movs	r1, #232	; 0xe8
    39ea:	4623      	mov	r3, r4
    39ec:	4622      	mov	r2, r4
    39ee:	4620      	mov	r0, r4
    39f0:	f8cd 8000 	str.w	r8, [sp]
    39f4:	f7ff ffa6 	bl	3944 <LED_writeReg>
		LED_writeReg( bus, addr, 0x0A, 0x01, ISSI_ConfigPage );
    39f8:	463b      	mov	r3, r7
    39fa:	220a      	movs	r2, #10
    39fc:	f8cd 8000 	str.w	r8, [sp]
    3a00:	21e8      	movs	r1, #232	; 0xe8
    3a02:	4620      	mov	r0, r4
    3a04:	f7ff ff9e 	bl	3944 <LED_writeReg>
	Pixel_FrameState = FrameState_Update;
    3a08:	2302      	movs	r3, #2
    3a0a:	7033      	strb	r3, [r6, #0]
	LED_pause = 0;
    3a0c:	4b0a      	ldr	r3, [pc, #40]	; (3a38 <LED_reset+0x90>)
}
    3a0e:	9a03      	ldr	r2, [sp, #12]
	LED_pause = 0;
    3a10:	701c      	strb	r4, [r3, #0]
}
    3a12:	682b      	ldr	r3, [r5, #0]
    3a14:	429a      	cmp	r2, r3
    3a16:	d001      	beq.n	3a1c <LED_reset+0x74>
    3a18:	f7fe fe8a 	bl	2730 <__stack_chk_fail>
    3a1c:	b004      	add	sp, #16
    3a1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3a22:	bf00      	nop
    3a24:	1fff89d0 	.word	0x1fff89d0
    3a28:	1fffab55 	.word	0x1fffab55
    3a2c:	1fff9f1b 	.word	0x1fff9f1b
    3a30:	0000fb48 	.word	0x0000fb48
    3a34:	1fffa040 	.word	0x1fffa040
    3a38:	1fff9f19 	.word	0x1fff9f19

00003a3c <cliFunc_ledReset>:
{
    3a3c:	b513      	push	{r0, r1, r4, lr}
    3a3e:	4c0d      	ldr	r4, [pc, #52]	; (3a74 <cliFunc_ledReset+0x38>)
	print( NL ); // No \r\n by default after the command is entered
    3a40:	480d      	ldr	r0, [pc, #52]	; (3a78 <cliFunc_ledReset+0x3c>)
{
    3a42:	6823      	ldr	r3, [r4, #0]
    3a44:	9301      	str	r3, [sp, #4]
	print( NL ); // No \r\n by default after the command is entered
    3a46:	f00b fd93 	bl	f570 <_print>
	i2c_reset();
    3a4a:	f7ff fc09 	bl	3260 <i2c_reset>
	LED_zeroControlPages();
    3a4e:	f7ff ff3b 	bl	38c8 <LED_zeroControlPages>
		memset( (void*)LED_pageBuffer[ buf ].buffer, 0, LED_BufferLength * 2 );
    3a52:	f44f 7290 	mov.w	r2, #288	; 0x120
    3a56:	2100      	movs	r1, #0
    3a58:	4808      	ldr	r0, [pc, #32]	; (3a7c <cliFunc_ledReset+0x40>)
    3a5a:	f7fe fe77 	bl	274c <memset>
	LED_reset();
    3a5e:	9a01      	ldr	r2, [sp, #4]
    3a60:	6823      	ldr	r3, [r4, #0]
    3a62:	429a      	cmp	r2, r3
    3a64:	d001      	beq.n	3a6a <cliFunc_ledReset+0x2e>
    3a66:	f7fe fe63 	bl	2730 <__stack_chk_fail>
}
    3a6a:	b002      	add	sp, #8
    3a6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LED_reset();
    3a70:	f7ff bf9a 	b.w	39a8 <LED_reset>
    3a74:	1fff89d0 	.word	0x1fff89d0
    3a78:	00015df4 	.word	0x00015df4
    3a7c:	1fffadbe 	.word	0x1fffadbe

00003a80 <LED_setup>:
{
    3a80:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    3a84:	4e2a      	ldr	r6, [pc, #168]	; (3b30 <LED_setup+0xb0>)
	CLI_registerDictionary( ledCLIDict, ledCLIDictName );
    3a86:	492b      	ldr	r1, [pc, #172]	; (3b34 <LED_setup+0xb4>)
{
    3a88:	6833      	ldr	r3, [r6, #0]
	CLI_registerDictionary( ledCLIDict, ledCLIDictName );
    3a8a:	482b      	ldr	r0, [pc, #172]	; (3b38 <LED_setup+0xb8>)
{
    3a8c:	9303      	str	r3, [sp, #12]
	LED_timePrev = Time_now();
    3a8e:	466c      	mov	r4, sp
	CLI_registerDictionary( ledCLIDict, ledCLIDictName );
    3a90:	f00b f8fe 	bl	ec90 <CLI_registerDictionary>
	LED_timePrev = Time_now();
    3a94:	4620      	mov	r0, r4
    3a96:	f7ff f939 	bl	2d0c <Time_now>
	LED_framerate = ISSI_FrameRate_ms_define;
    3a9a:	4b28      	ldr	r3, [pc, #160]	; (3b3c <LED_setup+0xbc>)
	LED_timePrev = Time_now();
    3a9c:	4d28      	ldr	r5, [pc, #160]	; (3b40 <LED_setup+0xc0>)
	LED_enable = ISSI_Enable_define;
    3a9e:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 3b60 <LED_setup+0xe0>
	LED_enable_current = ISSI_Enable_define; // Needs a default setting, almost always unset immediately
    3aa2:	4f28      	ldr	r7, [pc, #160]	; (3b44 <LED_setup+0xc4>)
	LED_timePrev = Time_now();
    3aa4:	e894 0003 	ldmia.w	r4, {r0, r1}
	LED_framerate = ISSI_FrameRate_ms_define;
    3aa8:	2264      	movs	r2, #100	; 0x64
    3aaa:	601a      	str	r2, [r3, #0]
	LED_brightness = ISSI_Global_Brightness_define;
    3aac:	4b26      	ldr	r3, [pc, #152]	; (3b48 <LED_setup+0xc8>)
    3aae:	22ff      	movs	r2, #255	; 0xff
	LED_timePrev = Time_now();
    3ab0:	e885 0003 	stmia.w	r5, {r0, r1}
	LED_brightness = ISSI_Global_Brightness_define;
    3ab4:	701a      	strb	r2, [r3, #0]
	i2c_initial();
    3ab6:	f7ff fb6f 	bl	3198 <i2c_initial>
	i2c_setup();
    3aba:	f7ff fb83 	bl	31c4 <i2c_setup>
	LED_pageBuffer[0].i2c_addr = LED_MapCh1_Addr_define;
    3abe:	4b23      	ldr	r3, [pc, #140]	; (3b4c <LED_setup+0xcc>)
    3ac0:	21e8      	movs	r1, #232	; 0xe8
	LED_pageBuffer[0].reg_addr = ISSI_LEDPwmRegStart;
    3ac2:	2224      	movs	r2, #36	; 0x24
	LED_pageBuffer[0].i2c_addr = LED_MapCh1_Addr_define;
    3ac4:	8019      	strh	r1, [r3, #0]
	LED_pageBuffer[0].reg_addr = ISSI_LEDPwmRegStart;
    3ac6:	805a      	strh	r2, [r3, #2]
	LED_pageBuffer_brightness[0].i2c_addr = LED_MapCh1_Addr_define;
    3ac8:	4b21      	ldr	r3, [pc, #132]	; (3b50 <LED_setup+0xd0>)
    3aca:	8019      	strh	r1, [r3, #0]
	LED_pageBuffer_brightness[0].reg_addr = ISSI_LEDPwmRegStart;
    3acc:	805a      	strh	r2, [r3, #2]
	GPIO_Ctrl( hardware_shutdown_pin, GPIO_Type_DriveSetup, GPIO_Config_Pullup );
    3ace:	4b21      	ldr	r3, [pc, #132]	; (3b54 <LED_setup+0xd4>)
    3ad0:	781d      	ldrb	r5, [r3, #0]
    3ad2:	785b      	ldrb	r3, [r3, #1]
	LED_enable = ISSI_Enable_define;
    3ad4:	2401      	movs	r4, #1
	GPIO_Ctrl( hardware_shutdown_pin, GPIO_Type_DriveSetup, GPIO_Config_Pullup );
    3ad6:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    3ada:	4622      	mov	r2, r4
    3adc:	2103      	movs	r1, #3
    3ade:	4628      	mov	r0, r5
	LED_enable = ISSI_Enable_define;
    3ae0:	f888 4000 	strb.w	r4, [r8]
	LED_enable_current = ISSI_Enable_define; // Needs a default setting, almost always unset immediately
    3ae4:	703c      	strb	r4, [r7, #0]
	GPIO_Ctrl( hardware_shutdown_pin, GPIO_Type_DriveSetup, GPIO_Config_Pullup );
    3ae6:	f7ff f80f 	bl	2b08 <GPIO_Ctrl>
	GPIO_Ctrl( hardware_shutdown_pin, GPIO_Type_DriveLow, GPIO_Config_Pullup );
    3aea:	4622      	mov	r2, r4
    3aec:	4621      	mov	r1, r4
    3aee:	4628      	mov	r0, r5
    3af0:	f7ff f80a 	bl	2b08 <GPIO_Ctrl>
	LED_zeroControlPages();
    3af4:	f7ff fee8 	bl	38c8 <LED_zeroControlPages>
	if ( LED_enable && LED_enable_current )
    3af8:	f898 3000 	ldrb.w	r3, [r8]
    3afc:	b133      	cbz	r3, 3b0c <LED_setup+0x8c>
    3afe:	783b      	ldrb	r3, [r7, #0]
    3b00:	b123      	cbz	r3, 3b0c <LED_setup+0x8c>
		GPIO_Ctrl( hardware_shutdown_pin, GPIO_Type_DriveHigh, GPIO_Config_Pullup );
    3b02:	4622      	mov	r2, r4
    3b04:	2100      	movs	r1, #0
    3b06:	4628      	mov	r0, r5
    3b08:	f7fe fffe 	bl	2b08 <GPIO_Ctrl>
	LED_reset();
    3b0c:	f7ff ff4c 	bl	39a8 <LED_reset>
	ledLatencyResource = Latency_add_resource("ISSILed", LatencyOption_Ticks);
    3b10:	2100      	movs	r1, #0
    3b12:	4811      	ldr	r0, [pc, #68]	; (3b58 <LED_setup+0xd8>)
    3b14:	f00b fbe2 	bl	f2dc <Latency_add_resource>
    3b18:	4b10      	ldr	r3, [pc, #64]	; (3b5c <LED_setup+0xdc>)
}
    3b1a:	9a03      	ldr	r2, [sp, #12]
	ledLatencyResource = Latency_add_resource("ISSILed", LatencyOption_Ticks);
    3b1c:	7018      	strb	r0, [r3, #0]
}
    3b1e:	6833      	ldr	r3, [r6, #0]
    3b20:	429a      	cmp	r2, r3
    3b22:	d001      	beq.n	3b28 <LED_setup+0xa8>
    3b24:	f7fe fe04 	bl	2730 <__stack_chk_fail>
    3b28:	b004      	add	sp, #16
    3b2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3b2e:	bf00      	nop
    3b30:	1fff89d0 	.word	0x1fff89d0
    3b34:	0000fc94 	.word	0x0000fc94
    3b38:	0000fc4c 	.word	0x0000fc4c
    3b3c:	1fff9f14 	.word	0x1fff9f14
    3b40:	1fffa044 	.word	0x1fffa044
    3b44:	1fff9f1a 	.word	0x1fff9f1a
    3b48:	1fffa040 	.word	0x1fffa040
    3b4c:	1fffadba 	.word	0x1fffadba
    3b50:	1fff9f1c 	.word	0x1fff9f1c
    3b54:	0000fc4a 	.word	0x0000fc4a
    3b58:	0000fbb6 	.word	0x0000fbb6
    3b5c:	1fff92e4 	.word	0x1fff92e4
    3b60:	1fffa04c 	.word	0x1fffa04c

00003b64 <LED_scan>:
{
    3b64:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3b68:	4e5b      	ldr	r6, [pc, #364]	; (3cd8 <LED_scan+0x174>)
	Latency_start_time( ledLatencyResource );
    3b6a:	4d5c      	ldr	r5, [pc, #368]	; (3cdc <LED_scan+0x178>)
	if ( LED_currentEvent )
    3b6c:	4c5c      	ldr	r4, [pc, #368]	; (3ce0 <LED_scan+0x17c>)
{
    3b6e:	6833      	ldr	r3, [r6, #0]
	Latency_start_time( ledLatencyResource );
    3b70:	7828      	ldrb	r0, [r5, #0]
{
    3b72:	b089      	sub	sp, #36	; 0x24
    3b74:	9307      	str	r3, [sp, #28]
	Latency_start_time( ledLatencyResource );
    3b76:	f00b fc29 	bl	f3cc <Latency_start_time>
	if ( LED_currentEvent )
    3b7a:	6822      	ldr	r2, [r4, #0]
    3b7c:	b16a      	cbz	r2, 3b9a <LED_scan+0x36>
		if ( LED_currentEvent < 150 )
    3b7e:	2a95      	cmp	r2, #149	; 0x95
    3b80:	4b58      	ldr	r3, [pc, #352]	; (3ce4 <LED_scan+0x180>)
			LED_enable_current = 0;
    3b82:	bf95      	itete	ls
    3b84:	2200      	movls	r2, #0
			LED_enable_current = 1;
    3b86:	2201      	movhi	r2, #1
			Pixel_setAnimationControl( AnimationControl_WipePause );
    3b88:	2005      	movls	r0, #5
			Pixel_setAnimationControl( AnimationControl_Forward );
    3b8a:	2000      	movhi	r0, #0
			LED_enable_current = 0;
    3b8c:	bf94      	ite	ls
    3b8e:	701a      	strbls	r2, [r3, #0]
			LED_enable_current = 1;
    3b90:	701a      	strbhi	r2, [r3, #0]
			Pixel_setAnimationControl( AnimationControl_Forward );
    3b92:	f006 ffcf 	bl	ab34 <Pixel_setAnimationControl>
		LED_currentEvent = 0;
    3b96:	2300      	movs	r3, #0
    3b98:	6023      	str	r3, [r4, #0]
	if ( LED_pause )
    3b9a:	4b53      	ldr	r3, [pc, #332]	; (3ce8 <LED_scan+0x184>)
    3b9c:	7819      	ldrb	r1, [r3, #0]
    3b9e:	2900      	cmp	r1, #0
    3ba0:	f040 8082 	bne.w	3ca8 <LED_scan+0x144>
	if ( LED_enable && LED_enable_current )
    3ba4:	4b51      	ldr	r3, [pc, #324]	; (3cec <LED_scan+0x188>)
    3ba6:	781a      	ldrb	r2, [r3, #0]
    3ba8:	4b51      	ldr	r3, [pc, #324]	; (3cf0 <LED_scan+0x18c>)
		GPIO_Ctrl( hardware_shutdown_pin, GPIO_Type_DriveHigh, GPIO_Config_Pullup );
    3baa:	7818      	ldrb	r0, [r3, #0]
    3bac:	785b      	ldrb	r3, [r3, #1]
	if ( LED_enable && LED_enable_current )
    3bae:	2a00      	cmp	r2, #0
    3bb0:	d074      	beq.n	3c9c <LED_scan+0x138>
    3bb2:	4a4c      	ldr	r2, [pc, #304]	; (3ce4 <LED_scan+0x180>)
    3bb4:	7812      	ldrb	r2, [r2, #0]
    3bb6:	2a00      	cmp	r2, #0
    3bb8:	d070      	beq.n	3c9c <LED_scan+0x138>
		GPIO_Ctrl( hardware_shutdown_pin, GPIO_Type_DriveHigh, GPIO_Config_Pullup );
    3bba:	2201      	movs	r2, #1
    3bbc:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    3bc0:	f7fe ffa2 	bl	2b08 <GPIO_Ctrl>
	if ( i2c_error() )
    3bc4:	f7ff fb36 	bl	3234 <i2c_error>
    3bc8:	4c4a      	ldr	r4, [pc, #296]	; (3cf4 <LED_scan+0x190>)
    3bca:	b118      	cbz	r0, 3bd4 <LED_scan+0x70>
		i2c_reset();
    3bcc:	f7ff fb48 	bl	3260 <i2c_reset>
		Pixel_FrameState = FrameState_Update;
    3bd0:	2302      	movs	r3, #2
    3bd2:	7023      	strb	r3, [r4, #0]
	if ( Pixel_FrameState != FrameState_Ready )
    3bd4:	7823      	ldrb	r3, [r4, #0]
    3bd6:	2b00      	cmp	r3, #0
    3bd8:	d166      	bne.n	3ca8 <LED_scan+0x144>
	Time duration = Time_duration( LED_timePrev );
    3bda:	4c47      	ldr	r4, [pc, #284]	; (3cf8 <LED_scan+0x194>)
	if ( duration.ms < LED_framerate )
    3bdc:	4f47      	ldr	r7, [pc, #284]	; (3cfc <LED_scan+0x198>)
	Time duration = Time_duration( LED_timePrev );
    3bde:	f10d 0814 	add.w	r8, sp, #20
    3be2:	e894 0006 	ldmia.w	r4, {r1, r2}
    3be6:	4640      	mov	r0, r8
    3be8:	f7ff f9ca 	bl	2f80 <Time_duration>
    3bec:	f8dd 9014 	ldr.w	r9, [sp, #20]
	if ( duration.ms < LED_framerate )
    3bf0:	683b      	ldr	r3, [r7, #0]
    3bf2:	454b      	cmp	r3, r9
    3bf4:	d858      	bhi.n	3ca8 <LED_scan+0x144>
	if ( LED_displayFPS )
    3bf6:	4b42      	ldr	r3, [pc, #264]	; (3d00 <LED_scan+0x19c>)
    3bf8:	781b      	ldrb	r3, [r3, #0]
    3bfa:	b1eb      	cbz	r3, 3c38 <LED_scan+0xd4>
		dbug_msg("1frame/");
    3bfc:	4841      	ldr	r0, [pc, #260]	; (3d04 <LED_scan+0x1a0>)
    3bfe:	f00b fcb7 	bl	f570 <_print>
		printInt32( Time_ms( duration ) );
    3c02:	e898 0003 	ldmia.w	r8, {r0, r1}
    3c06:	f7ff f901 	bl	2e0c <Time_ms>
    3c0a:	f00b fd87 	bl	f71c <printInt32>
		print("ms + ");
    3c0e:	483e      	ldr	r0, [pc, #248]	; (3d08 <LED_scan+0x1a4>)
    3c10:	f00b fcae 	bl	f570 <_print>
		printInt32( duration.ticks );
    3c14:	9806      	ldr	r0, [sp, #24]
    3c16:	f00b fd81 	bl	f71c <printInt32>
		print(" ticks");
    3c1a:	483c      	ldr	r0, [pc, #240]	; (3d0c <LED_scan+0x1a8>)
    3c1c:	f00b fca8 	bl	f570 <_print>
		if ( duration.ms > LED_framerate )
    3c20:	683b      	ldr	r3, [r7, #0]
    3c22:	454b      	cmp	r3, r9
    3c24:	d205      	bcs.n	3c32 <LED_scan+0xce>
			print(" - Could not meet framerate: ");
    3c26:	483a      	ldr	r0, [pc, #232]	; (3d10 <LED_scan+0x1ac>)
    3c28:	f00b fca2 	bl	f570 <_print>
			printInt32( LED_framerate );
    3c2c:	6838      	ldr	r0, [r7, #0]
    3c2e:	f00b fd75 	bl	f71c <printInt32>
		print( NL );
    3c32:	4838      	ldr	r0, [pc, #224]	; (3d14 <LED_scan+0x1b0>)
    3c34:	f00b fc9c 	bl	f570 <_print>
			if ( LED_pageBuffer[ chip ].buffer[ ch ] == 0 || LED_brightness == 0 )
    3c38:	4b37      	ldr	r3, [pc, #220]	; (3d18 <LED_scan+0x1b4>)
    3c3a:	4f38      	ldr	r7, [pc, #224]	; (3d1c <LED_scan+0x1b8>)
    3c3c:	7818      	ldrb	r0, [r3, #0]
    3c3e:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 3d28 <LED_scan+0x1c4>
				(LED_pageBuffer[ chip ].buffer[ ch ] * LED_brightness) / 0xFF;
    3c42:	2100      	movs	r1, #0
				LED_pageBuffer_brightness[ chip ].buffer[ ch ] = 0;
    3c44:	468e      	mov	lr, r1
				(LED_pageBuffer[ chip ].buffer[ ch ] * LED_brightness) / 0xFF;
    3c46:	f04f 08ff 	mov.w	r8, #255	; 0xff
			if ( LED_pageBuffer[ chip ].buffer[ ch ] == 0 || LED_brightness == 0 )
    3c4a:	f837 3f02 	ldrh.w	r3, [r7, #2]!
    3c4e:	004a      	lsls	r2, r1, #1
    3c50:	b103      	cbz	r3, 3c54 <LED_scan+0xf0>
    3c52:	bb78      	cbnz	r0, 3cb4 <LED_scan+0x150>
				LED_pageBuffer_brightness[ chip ].buffer[ ch ] = 0;
    3c54:	4462      	add	r2, ip
    3c56:	f8a2 e004 	strh.w	lr, [r2, #4]
    3c5a:	3101      	adds	r1, #1
		for ( uint8_t ch = 0; ch < LED_BufferLength; ch++ )
    3c5c:	2990      	cmp	r1, #144	; 0x90
    3c5e:	d1f4      	bne.n	3c4a <LED_scan+0xe6>
	LED_timePrev = Time_now();
    3c60:	af02      	add	r7, sp, #8
    3c62:	4638      	mov	r0, r7
    3c64:	f7ff f852 	bl	2d0c <Time_now>
    3c68:	e897 0003 	ldmia.w	r7, {r0, r1}
		LED_setupPage(
    3c6c:	2200      	movs	r2, #0
	LED_timePrev = Time_now();
    3c6e:	e884 0003 	stmia.w	r4, {r0, r1}
		LED_setupPage(
    3c72:	21e8      	movs	r1, #232	; 0xe8
    3c74:	4610      	mov	r0, r2
    3c76:	f7ff fdaf 	bl	37d8 <LED_setupPage>
		while ( i2c_send( bus, (uint16_t*)&LED_ledEnableMask[ ch ], sizeof( LED_EnableBuffer ) / 2 ) == -1 )
    3c7a:	4f29      	ldr	r7, [pc, #164]	; (3d20 <LED_scan+0x1bc>)
    3c7c:	2400      	movs	r4, #0
    3c7e:	2300      	movs	r3, #0
    3c80:	e9cd 4400 	strd	r4, r4, [sp]
    3c84:	2214      	movs	r2, #20
    3c86:	4639      	mov	r1, r7
    3c88:	4618      	mov	r0, r3
    3c8a:	f7ff fb17 	bl	32bc <i2c_send_sequence>
    3c8e:	3001      	adds	r0, #1
    3c90:	d017      	beq.n	3cc2 <LED_scan+0x15e>
	LED_chipSend = 0; // Start with chip 0
    3c92:	4b24      	ldr	r3, [pc, #144]	; (3d24 <LED_scan+0x1c0>)
    3c94:	701c      	strb	r4, [r3, #0]
	LED_linkedSend();
    3c96:	f7ff fd1d 	bl	36d4 <LED_linkedSend>
    3c9a:	e005      	b.n	3ca8 <LED_scan+0x144>
		GPIO_Ctrl( hardware_shutdown_pin, GPIO_Type_DriveLow, GPIO_Config_Pullup );
    3c9c:	2201      	movs	r2, #1
    3c9e:	4611      	mov	r1, r2
    3ca0:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    3ca4:	f7fe ff30 	bl	2b08 <GPIO_Ctrl>
	Latency_end_time( ledLatencyResource );
    3ca8:	9a07      	ldr	r2, [sp, #28]
    3caa:	6833      	ldr	r3, [r6, #0]
    3cac:	429a      	cmp	r2, r3
    3cae:	d00c      	beq.n	3cca <LED_scan+0x166>
    3cb0:	f7fe fd3e 	bl	2730 <__stack_chk_fail>
			LED_pageBuffer_brightness[ chip ].buffer[ ch ] =
    3cb4:	4462      	add	r2, ip
				(LED_pageBuffer[ chip ].buffer[ ch ] * LED_brightness) / 0xFF;
    3cb6:	4343      	muls	r3, r0
    3cb8:	fb93 f3f8 	sdiv	r3, r3, r8
			LED_pageBuffer_brightness[ chip ].buffer[ ch ] =
    3cbc:	b29b      	uxth	r3, r3
    3cbe:	8093      	strh	r3, [r2, #4]
    3cc0:	e7cb      	b.n	3c5a <LED_scan+0xf6>
			delay_us( ISSI_SendDelay );
    3cc2:	20c8      	movs	r0, #200	; 0xc8
    3cc4:	f7fe fdbe 	bl	2844 <delay_us>
    3cc8:	e7d9      	b.n	3c7e <LED_scan+0x11a>
	Latency_end_time( ledLatencyResource );
    3cca:	7828      	ldrb	r0, [r5, #0]
}
    3ccc:	b009      	add	sp, #36	; 0x24
    3cce:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	Latency_end_time( ledLatencyResource );
    3cd2:	f00b bb99 	b.w	f408 <Latency_end_time>
    3cd6:	bf00      	nop
    3cd8:	1fff89d0 	.word	0x1fff89d0
    3cdc:	1fff92e4 	.word	0x1fff92e4
    3ce0:	1fff92e0 	.word	0x1fff92e0
    3ce4:	1fff9f1a 	.word	0x1fff9f1a
    3ce8:	1fff9f19 	.word	0x1fff9f19
    3cec:	1fffa04c 	.word	0x1fffa04c
    3cf0:	0000fc4a 	.word	0x0000fc4a
    3cf4:	1fffab55 	.word	0x1fffab55
    3cf8:	1fffa044 	.word	0x1fffa044
    3cfc:	1fff9f14 	.word	0x1fff9f14
    3d00:	1fff9f1b 	.word	0x1fff9f1b
    3d04:	0000fb70 	.word	0x0000fb70
    3d08:	0000fb8b 	.word	0x0000fb8b
    3d0c:	0000fb91 	.word	0x0000fb91
    3d10:	0000fb98 	.word	0x0000fb98
    3d14:	00015df4 	.word	0x00015df4
    3d18:	1fffa040 	.word	0x1fffa040
    3d1c:	1fffadbc 	.word	0x1fffadbc
    3d20:	0000fb48 	.word	0x0000fb48
    3d24:	1fff9f18 	.word	0x1fff9f18
    3d28:	1fff9f1c 	.word	0x1fff9f1c

00003d2c <LED_currentChange>:
{
    3d2c:	b507      	push	{r0, r1, r2, lr}
    3d2e:	4b07      	ldr	r3, [pc, #28]	; (3d4c <LED_currentChange+0x20>)
    3d30:	681a      	ldr	r2, [r3, #0]
    3d32:	9201      	str	r2, [sp, #4]
	LED_currentEvent = current;
    3d34:	4a06      	ldr	r2, [pc, #24]	; (3d50 <LED_currentChange+0x24>)
    3d36:	6010      	str	r0, [r2, #0]
}
    3d38:	9a01      	ldr	r2, [sp, #4]
    3d3a:	681b      	ldr	r3, [r3, #0]
    3d3c:	429a      	cmp	r2, r3
    3d3e:	d001      	beq.n	3d44 <LED_currentChange+0x18>
    3d40:	f7fe fcf6 	bl	2730 <__stack_chk_fail>
    3d44:	b003      	add	sp, #12
    3d46:	f85d fb04 	ldr.w	pc, [sp], #4
    3d4a:	bf00      	nop
    3d4c:	1fff89d0 	.word	0x1fff89d0
    3d50:	1fff92e0 	.word	0x1fff92e0

00003d54 <LED_control>:
{
    3d54:	b507      	push	{r0, r1, r2, lr}
    3d56:	4a25      	ldr	r2, [pc, #148]	; (3dec <LED_control+0x98>)
    3d58:	6813      	ldr	r3, [r2, #0]
    3d5a:	9301      	str	r3, [sp, #4]
	switch ( control )
    3d5c:	2808      	cmp	r0, #8
    3d5e:	d80f      	bhi.n	3d80 <LED_control+0x2c>
    3d60:	e8df f000 	tbb	[pc, r0]
    3d64:	241e1405 	.word	0x241e1405
    3d68:	33312a27 	.word	0x33312a27
    3d6c:	3a          	.byte	0x3a
    3d6d:	00          	.byte	0x00
		LED_enable = 1;
    3d6e:	4b20      	ldr	r3, [pc, #128]	; (3df0 <LED_control+0x9c>)
    3d70:	2001      	movs	r0, #1
    3d72:	7018      	strb	r0, [r3, #0]
		if ( LED_brightness - arg < 0 )
    3d74:	481f      	ldr	r0, [pc, #124]	; (3df4 <LED_control+0xa0>)
    3d76:	7803      	ldrb	r3, [r0, #0]
    3d78:	1a59      	subs	r1, r3, r1
    3d7a:	d52b      	bpl.n	3dd4 <LED_control+0x80>
			LED_brightness = 0;
    3d7c:	2300      	movs	r3, #0
			LED_brightness = 0xFF;
    3d7e:	7003      	strb	r3, [r0, #0]
}
    3d80:	9901      	ldr	r1, [sp, #4]
    3d82:	6813      	ldr	r3, [r2, #0]
    3d84:	4299      	cmp	r1, r3
    3d86:	d02d      	beq.n	3de4 <LED_control+0x90>
    3d88:	f7fe fcd2 	bl	2730 <__stack_chk_fail>
		LED_enable = 1;
    3d8c:	4b18      	ldr	r3, [pc, #96]	; (3df0 <LED_control+0x9c>)
    3d8e:	2001      	movs	r0, #1
    3d90:	7018      	strb	r0, [r3, #0]
		if ( LED_brightness + arg > 0xFF )
    3d92:	4818      	ldr	r0, [pc, #96]	; (3df4 <LED_control+0xa0>)
    3d94:	7803      	ldrb	r3, [r0, #0]
    3d96:	4419      	add	r1, r3
    3d98:	29ff      	cmp	r1, #255	; 0xff
    3d9a:	dd1b      	ble.n	3dd4 <LED_control+0x80>
			LED_brightness = 0xFF;
    3d9c:	23ff      	movs	r3, #255	; 0xff
    3d9e:	e7ee      	b.n	3d7e <LED_control+0x2a>
		LED_enable = 1;
    3da0:	4b13      	ldr	r3, [pc, #76]	; (3df0 <LED_control+0x9c>)
    3da2:	2001      	movs	r0, #1
    3da4:	7018      	strb	r0, [r3, #0]
		LED_brightness = arg;
    3da6:	4b13      	ldr	r3, [pc, #76]	; (3df4 <LED_control+0xa0>)
		LED_displayFPS = (uint32_t)arg;
    3da8:	7019      	strb	r1, [r3, #0]
		return;
    3daa:	e7e9      	b.n	3d80 <LED_control+0x2c>
		LED_enable = 0;
    3dac:	4b10      	ldr	r3, [pc, #64]	; (3df0 <LED_control+0x9c>)
    3dae:	2100      	movs	r1, #0
    3db0:	e7fa      	b.n	3da8 <LED_control+0x54>
		LED_enable = 1;
    3db2:	4b0f      	ldr	r3, [pc, #60]	; (3df0 <LED_control+0x9c>)
    3db4:	2101      	movs	r1, #1
    3db6:	e7f7      	b.n	3da8 <LED_control+0x54>
		LED_enable = !LED_enable;
    3db8:	490d      	ldr	r1, [pc, #52]	; (3df0 <LED_control+0x9c>)
    3dba:	780b      	ldrb	r3, [r1, #0]
    3dbc:	fab3 f383 	clz	r3, r3
    3dc0:	095b      	lsrs	r3, r3, #5
    3dc2:	700b      	strb	r3, [r1, #0]
		return;
    3dc4:	e7dc      	b.n	3d80 <LED_control+0x2c>
		LED_displayFPS = (uint32_t)arg;
    3dc6:	4b0c      	ldr	r3, [pc, #48]	; (3df8 <LED_control+0xa4>)
    3dc8:	e7ee      	b.n	3da8 <LED_control+0x54>
		if ( LED_displayFPS < 0xFF )
    3dca:	480b      	ldr	r0, [pc, #44]	; (3df8 <LED_control+0xa4>)
    3dcc:	7803      	ldrb	r3, [r0, #0]
    3dce:	2bff      	cmp	r3, #255	; 0xff
    3dd0:	d0d6      	beq.n	3d80 <LED_control+0x2c>
			LED_displayFPS += arg;
    3dd2:	4419      	add	r1, r3
			LED_displayFPS -= arg;
    3dd4:	7001      	strb	r1, [r0, #0]
    3dd6:	e7d3      	b.n	3d80 <LED_control+0x2c>
		if ( LED_displayFPS > 1 )
    3dd8:	4807      	ldr	r0, [pc, #28]	; (3df8 <LED_control+0xa4>)
    3dda:	7803      	ldrb	r3, [r0, #0]
    3ddc:	2b01      	cmp	r3, #1
    3dde:	d9cf      	bls.n	3d80 <LED_control+0x2c>
			LED_displayFPS -= arg;
    3de0:	1a59      	subs	r1, r3, r1
    3de2:	e7f7      	b.n	3dd4 <LED_control+0x80>
}
    3de4:	b003      	add	sp, #12
    3de6:	f85d fb04 	ldr.w	pc, [sp], #4
    3dea:	bf00      	nop
    3dec:	1fff89d0 	.word	0x1fff89d0
    3df0:	1fffa04c 	.word	0x1fffa04c
    3df4:	1fffa040 	.word	0x1fffa040
    3df8:	1fff9f1b 	.word	0x1fff9f1b

00003dfc <LED_control_capability>:
{
    3dfc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    3e00:	4c1d      	ldr	r4, [pc, #116]	; (3e78 <LED_control_capability+0x7c>)
    3e02:	b085      	sub	sp, #20
    3e04:	460e      	mov	r6, r1
    3e06:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    3e08:	4611      	mov	r1, r2
{
    3e0a:	6823      	ldr	r3, [r4, #0]
    3e0c:	9303      	str	r3, [sp, #12]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    3e0e:	4630      	mov	r0, r6
{
    3e10:	4617      	mov	r7, r2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    3e12:	f002 fc95 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    3e16:	2801      	cmp	r0, #1
    3e18:	d00d      	beq.n	3e36 <LED_control_capability+0x3a>
    3e1a:	28ff      	cmp	r0, #255	; 0xff
		print("LED_control_capability(mode,amount)");
    3e1c:	9a03      	ldr	r2, [sp, #12]
    3e1e:	6823      	ldr	r3, [r4, #0]
	switch ( cstate )
    3e20:	d125      	bne.n	3e6e <LED_control_capability+0x72>
		print("LED_control_capability(mode,amount)");
    3e22:	429a      	cmp	r2, r3
    3e24:	d001      	beq.n	3e2a <LED_control_capability+0x2e>
}
    3e26:	f7fe fc83 	bl	2730 <__stack_chk_fail>
		print("LED_control_capability(mode,amount)");
    3e2a:	4814      	ldr	r0, [pc, #80]	; (3e7c <LED_control_capability+0x80>)
}
    3e2c:	b005      	add	sp, #20
    3e2e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		print("LED_control_capability(mode,amount)");
    3e32:	f00b bb9d 	b.w	f570 <_print>
	uint8_t addr = Connect_id + 1;
    3e36:	4b12      	ldr	r3, [pc, #72]	; (3e80 <LED_control_capability+0x84>)
	LedControl control = (LedControl)args[0];
    3e38:	f895 8000 	ldrb.w	r8, [r5]
	uint8_t addr = Connect_id + 1;
    3e3c:	7818      	ldrb	r0, [r3, #0]
	Connect_send_RemoteCapability(
    3e3e:	4b11      	ldr	r3, [pc, #68]	; (3e84 <LED_control_capability+0x88>)
    3e40:	9501      	str	r5, [sp, #4]
    3e42:	7d1b      	ldrb	r3, [r3, #20]
    3e44:	9300      	str	r3, [sp, #0]
	uint8_t addr = Connect_id + 1;
    3e46:	3001      	adds	r0, #1
	Connect_send_RemoteCapability(
    3e48:	463b      	mov	r3, r7
    3e4a:	4632      	mov	r2, r6
    3e4c:	2102      	movs	r1, #2
    3e4e:	b2c0      	uxtb	r0, r0
	uint8_t arg = (uint8_t)args[1];
    3e50:	f895 9001 	ldrb.w	r9, [r5, #1]
	Connect_send_RemoteCapability(
    3e54:	f001 fed4 	bl	5c00 <Connect_send_RemoteCapability>
	LED_control( control, arg );
    3e58:	9a03      	ldr	r2, [sp, #12]
    3e5a:	6823      	ldr	r3, [r4, #0]
    3e5c:	429a      	cmp	r2, r3
    3e5e:	d1e2      	bne.n	3e26 <LED_control_capability+0x2a>
    3e60:	4649      	mov	r1, r9
    3e62:	4640      	mov	r0, r8
}
    3e64:	b005      	add	sp, #20
    3e66:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	LED_control( control, arg );
    3e6a:	f7ff bf73 	b.w	3d54 <LED_control>
}
    3e6e:	429a      	cmp	r2, r3
    3e70:	d1d9      	bne.n	3e26 <LED_control_capability+0x2a>
    3e72:	b005      	add	sp, #20
    3e74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    3e78:	1fff89d0 	.word	0x1fff89d0
    3e7c:	0000fb24 	.word	0x0000fb24
    3e80:	1fff89e2 	.word	0x1fff89e2
    3e84:	00011460 	.word	0x00011460

00003e88 <cliFunc_matrixState>:
	info_msg("Matrix Debug Mode: ");
	printInt8( matrixDebugMode );
}

void cliFunc_matrixState( char* args )
{
    3e88:	b530      	push	{r4, r5, lr}
    3e8a:	4c0d      	ldr	r4, [pc, #52]	; (3ec0 <cliFunc_matrixState+0x38>)
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	matrixDebugStateCounter = 1;
    3e8c:	4d0d      	ldr	r5, [pc, #52]	; (3ec4 <cliFunc_matrixState+0x3c>)
{
    3e8e:	6823      	ldr	r3, [r4, #0]
    3e90:	b085      	sub	sp, #20
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3e92:	aa02      	add	r2, sp, #8
    3e94:	a901      	add	r1, sp, #4
{
    3e96:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3e98:	f00a fe3c 	bl	eb14 <CLI_argumentIsolation>

	if ( arg1Ptr[0] != '\0' )
    3e9c:	9801      	ldr	r0, [sp, #4]
	matrixDebugStateCounter = 1;
    3e9e:	2301      	movs	r3, #1
    3ea0:	802b      	strh	r3, [r5, #0]
	if ( arg1Ptr[0] != '\0' )
    3ea2:	7803      	ldrb	r3, [r0, #0]
    3ea4:	b11b      	cbz	r3, 3eae <cliFunc_matrixState+0x26>
	{
		matrixDebugStateCounter = (uint16_t)numToInt( arg1Ptr );
    3ea6:	f00b fd33 	bl	f910 <numToInt>
    3eaa:	b280      	uxth	r0, r0
    3eac:	8028      	strh	r0, [r5, #0]
	}
}
    3eae:	9a03      	ldr	r2, [sp, #12]
    3eb0:	6823      	ldr	r3, [r4, #0]
    3eb2:	429a      	cmp	r2, r3
    3eb4:	d001      	beq.n	3eba <cliFunc_matrixState+0x32>
    3eb6:	f7fe fc3b 	bl	2730 <__stack_chk_fail>
    3eba:	b005      	add	sp, #20
    3ebc:	bd30      	pop	{r4, r5, pc}
    3ebe:	bf00      	nop
    3ec0:	1fff89d0 	.word	0x1fff89d0
    3ec4:	1fff9496 	.word	0x1fff9496

00003ec8 <cliFunc_debounce>:
{
    3ec8:	b530      	push	{r4, r5, lr}
    3eca:	4c12      	ldr	r4, [pc, #72]	; (3f14 <cliFunc_debounce+0x4c>)
    3ecc:	4d12      	ldr	r5, [pc, #72]	; (3f18 <cliFunc_debounce+0x50>)
    3ece:	6823      	ldr	r3, [r4, #0]
    3ed0:	b085      	sub	sp, #20
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3ed2:	aa02      	add	r2, sp, #8
    3ed4:	a901      	add	r1, sp, #4
{
    3ed6:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3ed8:	f00a fe1c 	bl	eb14 <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    3edc:	9801      	ldr	r0, [sp, #4]
    3ede:	7803      	ldrb	r3, [r0, #0]
    3ee0:	b11b      	cbz	r3, 3eea <cliFunc_debounce+0x22>
		debounceExpiryTime = (uint8_t)numToInt( arg1Ptr );
    3ee2:	f00b fd15 	bl	f910 <numToInt>
    3ee6:	b2c0      	uxtb	r0, r0
    3ee8:	7028      	strb	r0, [r5, #0]
	print( NL );
    3eea:	480c      	ldr	r0, [pc, #48]	; (3f1c <cliFunc_debounce+0x54>)
    3eec:	f00b fb40 	bl	f570 <_print>
	info_msg("Debounce Timer: ");
    3ef0:	480b      	ldr	r0, [pc, #44]	; (3f20 <cliFunc_debounce+0x58>)
    3ef2:	f00b fb3d 	bl	f570 <_print>
	printInt8( debounceExpiryTime );
    3ef6:	7828      	ldrb	r0, [r5, #0]
    3ef8:	f00b fba4 	bl	f644 <printInt8>
	print("ms");
    3efc:	4809      	ldr	r0, [pc, #36]	; (3f24 <cliFunc_debounce+0x5c>)
    3efe:	f00b fb37 	bl	f570 <_print>
}
    3f02:	9a03      	ldr	r2, [sp, #12]
    3f04:	6823      	ldr	r3, [r4, #0]
    3f06:	429a      	cmp	r2, r3
    3f08:	d001      	beq.n	3f0e <cliFunc_debounce+0x46>
    3f0a:	f7fe fc11 	bl	2730 <__stack_chk_fail>
    3f0e:	b005      	add	sp, #20
    3f10:	bd30      	pop	{r4, r5, pc}
    3f12:	bf00      	nop
    3f14:	1fff89d0 	.word	0x1fff89d0
    3f18:	1fff9474 	.word	0x1fff9474
    3f1c:	00015df4 	.word	0x00015df4
    3f20:	0000fe8c 	.word	0x0000fe8c
    3f24:	0000fc04 	.word	0x0000fc04

00003f28 <cliFunc_matrixInfo>:
{
    3f28:	b513      	push	{r0, r1, r4, lr}
    3f2a:	4c13      	ldr	r4, [pc, #76]	; (3f78 <cliFunc_matrixInfo+0x50>)
	print( NL );
    3f2c:	4813      	ldr	r0, [pc, #76]	; (3f7c <cliFunc_matrixInfo+0x54>)
{
    3f2e:	6823      	ldr	r3, [r4, #0]
    3f30:	9301      	str	r3, [sp, #4]
	print( NL );
    3f32:	f00b fb1d 	bl	f570 <_print>
	info_msg("Columns:  ");
    3f36:	4812      	ldr	r0, [pc, #72]	; (3f80 <cliFunc_matrixInfo+0x58>)
    3f38:	f00b fb1a 	bl	f570 <_print>
	printInt8( Matrix_colsNum );
    3f3c:	2009      	movs	r0, #9
    3f3e:	f00b fb81 	bl	f644 <printInt8>
	print( NL );
    3f42:	480e      	ldr	r0, [pc, #56]	; (3f7c <cliFunc_matrixInfo+0x54>)
    3f44:	f00b fb14 	bl	f570 <_print>
	info_msg("Rows:     ");
    3f48:	480e      	ldr	r0, [pc, #56]	; (3f84 <cliFunc_matrixInfo+0x5c>)
    3f4a:	f00b fb11 	bl	f570 <_print>
	printInt8( Matrix_rowsNum );
    3f4e:	2005      	movs	r0, #5
    3f50:	f00b fb78 	bl	f644 <printInt8>
	print( NL );
    3f54:	4809      	ldr	r0, [pc, #36]	; (3f7c <cliFunc_matrixInfo+0x54>)
    3f56:	f00b fb0b 	bl	f570 <_print>
	info_msg("Max Keys: ");
    3f5a:	480b      	ldr	r0, [pc, #44]	; (3f88 <cliFunc_matrixInfo+0x60>)
    3f5c:	f00b fb08 	bl	f570 <_print>
	printInt8( Matrix_maxKeys );
    3f60:	9a01      	ldr	r2, [sp, #4]
    3f62:	6823      	ldr	r3, [r4, #0]
    3f64:	429a      	cmp	r2, r3
    3f66:	d001      	beq.n	3f6c <cliFunc_matrixInfo+0x44>
    3f68:	f7fe fbe2 	bl	2730 <__stack_chk_fail>
    3f6c:	202d      	movs	r0, #45	; 0x2d
}
    3f6e:	b002      	add	sp, #8
    3f70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( Matrix_maxKeys );
    3f74:	f00b bb66 	b.w	f644 <printInt8>
    3f78:	1fff89d0 	.word	0x1fff89d0
    3f7c:	00015df4 	.word	0x00015df4
    3f80:	0000fed5 	.word	0x0000fed5
    3f84:	0000fef2 	.word	0x0000fef2
    3f88:	0000ff0f 	.word	0x0000ff0f

00003f8c <cliFunc_matrixDebug>:
{
    3f8c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    3f8e:	4c1f      	ldr	r4, [pc, #124]	; (400c <cliFunc_matrixDebug+0x80>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3f90:	aa02      	add	r2, sp, #8
{
    3f92:	6823      	ldr	r3, [r4, #0]
    3f94:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    3f96:	a901      	add	r1, sp, #4
    3f98:	f00a fdbc 	bl	eb14 <CLI_argumentIsolation>
	switch ( arg1Ptr[0] )
    3f9c:	9b01      	ldr	r3, [sp, #4]
    3f9e:	781b      	ldrb	r3, [r3, #0]
    3fa0:	2b32      	cmp	r3, #50	; 0x32
    3fa2:	d015      	beq.n	3fd0 <cliFunc_matrixDebug+0x44>
    3fa4:	d808      	bhi.n	3fb8 <cliFunc_matrixDebug+0x2c>
    3fa6:	b333      	cbz	r3, 3ff6 <cliFunc_matrixDebug+0x6a>
    3fa8:	2b31      	cmp	r3, #49	; 0x31
    3faa:	d024      	beq.n	3ff6 <cliFunc_matrixDebug+0x6a>
}
    3fac:	9a03      	ldr	r2, [sp, #12]
    3fae:	6823      	ldr	r3, [r4, #0]
    3fb0:	429a      	cmp	r2, r3
    3fb2:	d028      	beq.n	4006 <cliFunc_matrixDebug+0x7a>
    3fb4:	f7fe fbbc 	bl	2730 <__stack_chk_fail>
	switch ( arg1Ptr[0] )
    3fb8:	2b54      	cmp	r3, #84	; 0x54
    3fba:	d009      	beq.n	3fd0 <cliFunc_matrixDebug+0x44>
    3fbc:	2b74      	cmp	r3, #116	; 0x74
    3fbe:	d007      	beq.n	3fd0 <cliFunc_matrixDebug+0x44>
    3fc0:	2b33      	cmp	r3, #51	; 0x33
    3fc2:	d1f3      	bne.n	3fac <cliFunc_matrixDebug+0x20>
		matrixDebugMode = matrixDebugMode != 3 ? 3 : 0;
    3fc4:	4b12      	ldr	r3, [pc, #72]	; (4010 <cliFunc_matrixDebug+0x84>)
    3fc6:	781a      	ldrb	r2, [r3, #0]
    3fc8:	2a03      	cmp	r2, #3
    3fca:	bf18      	it	ne
    3fcc:	2203      	movne	r2, #3
    3fce:	e004      	b.n	3fda <cliFunc_matrixDebug+0x4e>
		matrixDebugMode = matrixDebugMode != 2 ? 2 : 0;
    3fd0:	4b0f      	ldr	r3, [pc, #60]	; (4010 <cliFunc_matrixDebug+0x84>)
    3fd2:	781a      	ldrb	r2, [r3, #0]
    3fd4:	2a02      	cmp	r2, #2
    3fd6:	bf18      	it	ne
    3fd8:	2202      	movne	r2, #2
		matrixDebugMode = matrixDebugMode != 3 ? 3 : 0;
    3fda:	bf08      	it	eq
    3fdc:	2200      	moveq	r2, #0
    3fde:	701a      	strb	r2, [r3, #0]
	print( NL );
    3fe0:	480c      	ldr	r0, [pc, #48]	; (4014 <cliFunc_matrixDebug+0x88>)
    3fe2:	f00b fac5 	bl	f570 <_print>
	info_msg("Matrix Debug Mode: ");
    3fe6:	480c      	ldr	r0, [pc, #48]	; (4018 <cliFunc_matrixDebug+0x8c>)
    3fe8:	f00b fac2 	bl	f570 <_print>
	printInt8( matrixDebugMode );
    3fec:	4b08      	ldr	r3, [pc, #32]	; (4010 <cliFunc_matrixDebug+0x84>)
    3fee:	7818      	ldrb	r0, [r3, #0]
    3ff0:	f00b fb28 	bl	f644 <printInt8>
    3ff4:	e7da      	b.n	3fac <cliFunc_matrixDebug+0x20>
		matrixDebugMode = matrixDebugMode != 1 ? 1 : 0;
    3ff6:	4a06      	ldr	r2, [pc, #24]	; (4010 <cliFunc_matrixDebug+0x84>)
    3ff8:	7813      	ldrb	r3, [r2, #0]
    3ffa:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    3ffe:	bf18      	it	ne
    4000:	2301      	movne	r3, #1
    4002:	7013      	strb	r3, [r2, #0]
		break;
    4004:	e7ec      	b.n	3fe0 <cliFunc_matrixDebug+0x54>
}
    4006:	b004      	add	sp, #16
    4008:	bd10      	pop	{r4, pc}
    400a:	bf00      	nop
    400c:	1fff89d0 	.word	0x1fff89d0
    4010:	1fff9495 	.word	0x1fff9495
    4014:	00015df4 	.word	0x00015df4
    4018:	0000feaf 	.word	0x0000feaf

0000401c <cliFunc_strobeDelay>:

void cliFunc_strobeDelay( char* args )
{
    401c:	b530      	push	{r4, r5, lr}
    401e:	4c12      	ldr	r4, [pc, #72]	; (4068 <cliFunc_strobeDelay+0x4c>)
    4020:	4d12      	ldr	r5, [pc, #72]	; (406c <cliFunc_strobeDelay+0x50>)
    4022:	6823      	ldr	r3, [r4, #0]
    4024:	b085      	sub	sp, #20
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    4026:	aa02      	add	r2, sp, #8
    4028:	a901      	add	r1, sp, #4
{
    402a:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    402c:	f00a fd72 	bl	eb14 <CLI_argumentIsolation>

	if ( arg1Ptr[0] != '\0' )
    4030:	9801      	ldr	r0, [sp, #4]
    4032:	7803      	ldrb	r3, [r0, #0]
    4034:	b11b      	cbz	r3, 403e <cliFunc_strobeDelay+0x22>
	{
		strobeDelayTime = (uint8_t)numToInt( arg1Ptr );
    4036:	f00b fc6b 	bl	f910 <numToInt>
    403a:	b2c0      	uxtb	r0, r0
    403c:	7028      	strb	r0, [r5, #0]
	}

	print( NL );
    403e:	480c      	ldr	r0, [pc, #48]	; (4070 <cliFunc_strobeDelay+0x54>)
    4040:	f00b fa96 	bl	f570 <_print>
	info_msg("Strobe Delay: ");
    4044:	480b      	ldr	r0, [pc, #44]	; (4074 <cliFunc_strobeDelay+0x58>)
    4046:	f00b fa93 	bl	f570 <_print>
	printInt8( strobeDelayTime );
    404a:	7828      	ldrb	r0, [r5, #0]
    404c:	f00b fafa 	bl	f644 <printInt8>
	print("us");
    4050:	4809      	ldr	r0, [pc, #36]	; (4078 <cliFunc_strobeDelay+0x5c>)
    4052:	f00b fa8d 	bl	f570 <_print>
}
    4056:	9a03      	ldr	r2, [sp, #12]
    4058:	6823      	ldr	r3, [r4, #0]
    405a:	429a      	cmp	r2, r3
    405c:	d001      	beq.n	4062 <cliFunc_strobeDelay+0x46>
    405e:	f7fe fb67 	bl	2730 <__stack_chk_fail>
    4062:	b005      	add	sp, #20
    4064:	bd30      	pop	{r4, r5, pc}
    4066:	bf00      	nop
    4068:	1fff89d0 	.word	0x1fff89d0
    406c:	1fff94a0 	.word	0x1fff94a0
    4070:	00015df4 	.word	0x00015df4
    4074:	0000ff2c 	.word	0x0000ff2c
    4078:	00011054 	.word	0x00011054

0000407c <Matrix_setup>:
{
    407c:	b5f0      	push	{r4, r5, r6, r7, lr}
    407e:	4e37      	ldr	r6, [pc, #220]	; (415c <Matrix_setup+0xe0>)
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    4080:	4937      	ldr	r1, [pc, #220]	; (4160 <Matrix_setup+0xe4>)
{
    4082:	6833      	ldr	r3, [r6, #0]
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    4084:	4837      	ldr	r0, [pc, #220]	; (4164 <Matrix_setup+0xe8>)
		GPIO_Ctrl( Matrix_cols[ pin ], GPIO_Type_DriveSetup, Matrix_type );
    4086:	4d38      	ldr	r5, [pc, #224]	; (4168 <Matrix_setup+0xec>)
{
    4088:	b085      	sub	sp, #20
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    408a:	2400      	movs	r4, #0
{
    408c:	9303      	str	r3, [sp, #12]
	CLI_registerDictionary( matrixCLIDict, matrixCLIDictName );
    408e:	f00a fdff 	bl	ec90 <CLI_registerDictionary>
		GPIO_Ctrl( Matrix_cols[ pin ], GPIO_Type_DriveSetup, Matrix_type );
    4092:	eb05 0244 	add.w	r2, r5, r4, lsl #1
    4096:	f815 3014 	ldrb.w	r3, [r5, r4, lsl #1]
    409a:	7850      	ldrb	r0, [r2, #1]
    409c:	2103      	movs	r1, #3
    409e:	2202      	movs	r2, #2
    40a0:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    40a4:	3401      	adds	r4, #1
    40a6:	f7fe fd2f 	bl	2b08 <GPIO_Ctrl>
	for ( uint8_t pin = 0; pin < Matrix_colsNum; pin++ )
    40aa:	2c09      	cmp	r4, #9
    40ac:	d1f1      	bne.n	4092 <Matrix_setup+0x16>
		GPIO_Ctrl( Matrix_rows[ pin ], GPIO_Type_ReadSetup, Matrix_type );
    40ae:	4d2f      	ldr	r5, [pc, #188]	; (416c <Matrix_setup+0xf0>)
    40b0:	2400      	movs	r4, #0
    40b2:	eb05 0244 	add.w	r2, r5, r4, lsl #1
    40b6:	f815 3014 	ldrb.w	r3, [r5, r4, lsl #1]
    40ba:	7850      	ldrb	r0, [r2, #1]
    40bc:	2105      	movs	r1, #5
    40be:	2202      	movs	r2, #2
    40c0:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
    40c4:	3401      	adds	r4, #1
    40c6:	f7fe fd1f 	bl	2b08 <GPIO_Ctrl>
	for ( uint8_t pin = 0; pin < Matrix_rowsNum; pin++ )
    40ca:	2c05      	cmp	r4, #5
    40cc:	d1f1      	bne.n	40b2 <Matrix_setup+0x36>
    40ce:	2300      	movs	r3, #0
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    40d0:	4927      	ldr	r1, [pc, #156]	; (4170 <Matrix_setup+0xf4>)
    40d2:	461c      	mov	r4, r3
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold; // Start at 'off' steady state
    40d4:	20ff      	movs	r0, #255	; 0xff
		Matrix_scanArray[ item ].prevState        = KeyState_Off;
    40d6:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
    40da:	7094      	strb	r4, [r2, #2]
		Matrix_scanArray[ item ].curState         = KeyState_Off;
    40dc:	70d4      	strb	r4, [r2, #3]
		Matrix_scanArray[ item ].activeCount      = 0;
    40de:	f801 4033 	strb.w	r4, [r1, r3, lsl #3]
    40e2:	3301      	adds	r3, #1
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    40e4:	2b2d      	cmp	r3, #45	; 0x2d
		Matrix_scanArray[ item ].inactiveCount    = DebounceDivThreshold; // Start at 'off' steady state
    40e6:	7050      	strb	r0, [r2, #1]
		Matrix_scanArray[ item ].prevDecisionTime = 0;
    40e8:	6054      	str	r4, [r2, #4]
	for ( uint8_t item = 0; item < Matrix_maxKeys; item++ )
    40ea:	d1f4      	bne.n	40d6 <Matrix_setup+0x5a>
	matrixCurrentStrobe = 0;
    40ec:	4b21      	ldr	r3, [pc, #132]	; (4174 <Matrix_setup+0xf8>)
	activity_tick_duration = Time_init();
    40ee:	4d22      	ldr	r5, [pc, #136]	; (4178 <Matrix_setup+0xfc>)
	matrixCurrentStrobe = 0;
    40f0:	701c      	strb	r4, [r3, #0]
	matrixDebugMode = 0;
    40f2:	4b22      	ldr	r3, [pc, #136]	; (417c <Matrix_setup+0x100>)
    40f4:	701c      	strb	r4, [r3, #0]
	matrixDebugStateCounter = 0;
    40f6:	4b22      	ldr	r3, [pc, #136]	; (4180 <Matrix_setup+0x104>)
    40f8:	801c      	strh	r4, [r3, #0]
	debounceExpiryTime = MinDebounceTime_define;
    40fa:	4b22      	ldr	r3, [pc, #136]	; (4184 <Matrix_setup+0x108>)
    40fc:	2206      	movs	r2, #6
    40fe:	701a      	strb	r2, [r3, #0]
	activity_tick_duration = Time_init();
    4100:	466f      	mov	r7, sp
	strobeDelayTime = StrobeDelay_define;
    4102:	4b21      	ldr	r3, [pc, #132]	; (4188 <Matrix_setup+0x10c>)
	activity_tick_duration = Time_init();
    4104:	4638      	mov	r0, r7
	strobeDelayTime = StrobeDelay_define;
    4106:	701c      	strb	r4, [r3, #0]
	activity_tick_duration = Time_init();
    4108:	f7fe fe18 	bl	2d3c <Time_init>
    410c:	e897 0003 	ldmia.w	r7, {r0, r1}
    4110:	e885 0003 	stmia.w	r5, {r0, r1}
	activity_tick_duration.ms = 1000 * ActivityTimerMultiplier_define;
    4114:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    4118:	602b      	str	r3, [r5, #0]
	Time_tick_start( &activity_tickstore, activity_tick_duration, TickStore_MaxTicks );
    411a:	e895 0006 	ldmia.w	r5, {r1, r2}
    411e:	23ff      	movs	r3, #255	; 0xff
    4120:	481a      	ldr	r0, [pc, #104]	; (418c <Matrix_setup+0x110>)
    4122:	f7fe ffdd 	bl	30e0 <Time_tick_start>
	Time_tick_start( &inactivity_tickstore, activity_tick_duration, TickStore_MaxTicks );
    4126:	e895 0006 	ldmia.w	r5, {r1, r2}
    412a:	23ff      	movs	r3, #255	; 0xff
    412c:	4818      	ldr	r0, [pc, #96]	; (4190 <Matrix_setup+0x114>)
    412e:	f7fe ffd7 	bl	30e0 <Time_tick_start>
	matrixStateActiveCount = 0;
    4132:	4b18      	ldr	r3, [pc, #96]	; (4194 <Matrix_setup+0x118>)
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    4134:	4818      	ldr	r0, [pc, #96]	; (4198 <Matrix_setup+0x11c>)
	matrixStateActiveCount = 0;
    4136:	801c      	strh	r4, [r3, #0]
	matrixStatePressCount = 0;
    4138:	4b18      	ldr	r3, [pc, #96]	; (419c <Matrix_setup+0x120>)
    413a:	801c      	strh	r4, [r3, #0]
	matrixStateReleaseCount = 0;
    413c:	4b18      	ldr	r3, [pc, #96]	; (41a0 <Matrix_setup+0x124>)
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    413e:	2100      	movs	r1, #0
	matrixStateReleaseCount = 0;
    4140:	801c      	strh	r4, [r3, #0]
	matrixLatencyResource = Latency_add_resource("MatrixARMPeri", LatencyOption_Ticks);
    4142:	f00b f8cb 	bl	f2dc <Latency_add_resource>
    4146:	4b17      	ldr	r3, [pc, #92]	; (41a4 <Matrix_setup+0x128>)
    4148:	7018      	strb	r0, [r3, #0]
}
    414a:	9a03      	ldr	r2, [sp, #12]
    414c:	6833      	ldr	r3, [r6, #0]
    414e:	429a      	cmp	r2, r3
    4150:	d001      	beq.n	4156 <Matrix_setup+0xda>
    4152:	f7fe faed 	bl	2730 <__stack_chk_fail>
    4156:	b005      	add	sp, #20
    4158:	bdf0      	pop	{r4, r5, r6, r7, pc}
    415a:	bf00      	nop
    415c:	1fff89d0 	.word	0x1fff89d0
    4160:	0000ffd0 	.word	0x0000ffd0
    4164:	0000ff88 	.word	0x0000ff88
    4168:	0000fd8b 	.word	0x0000fd8b
    416c:	0000fddb 	.word	0x0000fddb
    4170:	1fff92e8 	.word	0x1fff92e8
    4174:	1fff9494 	.word	0x1fff9494
    4178:	1fff9450 	.word	0x1fff9450
    417c:	1fff9495 	.word	0x1fff9495
    4180:	1fff9496 	.word	0x1fff9496
    4184:	1fff9474 	.word	0x1fff9474
    4188:	1fff94a0 	.word	0x1fff94a0
    418c:	1fff9458 	.word	0x1fff9458
    4190:	1fff9478 	.word	0x1fff9478
    4194:	1fff949a 	.word	0x1fff949a
    4198:	0000fde5 	.word	0x0000fde5
    419c:	1fff949c 	.word	0x1fff949c
    41a0:	1fff949e 	.word	0x1fff949e
    41a4:	1fff9498 	.word	0x1fff9498

000041a8 <Matrix_keyPositionDebug>:
{
    41a8:	b507      	push	{r0, r1, r2, lr}
    41aa:	4b16      	ldr	r3, [pc, #88]	; (4204 <Matrix_keyPositionDebug+0x5c>)
    41ac:	681a      	ldr	r2, [r3, #0]
    41ae:	9201      	str	r2, [sp, #4]
	switch ( pos )
    41b0:	2803      	cmp	r0, #3
    41b2:	d821      	bhi.n	41f8 <Matrix_keyPositionDebug+0x50>
    41b4:	e8df f000 	tbb	[pc, r0]
    41b8:	1a140e02 	.word	0x1a140e02
		print("\033[1mO\033[0m");
    41bc:	9a01      	ldr	r2, [sp, #4]
    41be:	681b      	ldr	r3, [r3, #0]
    41c0:	429a      	cmp	r2, r3
    41c2:	d001      	beq.n	41c8 <Matrix_keyPositionDebug+0x20>
		print("\033[1;31mI\033[0m");
    41c4:	f7fe fab4 	bl	2730 <__stack_chk_fail>
		print("\033[1mO\033[0m");
    41c8:	480f      	ldr	r0, [pc, #60]	; (4208 <Matrix_keyPositionDebug+0x60>)
}
    41ca:	b003      	add	sp, #12
    41cc:	f85d eb04 	ldr.w	lr, [sp], #4
		print("\033[1;31mI\033[0m");
    41d0:	f00b b9ce 	b.w	f570 <_print>
		print("\033[1;33mP\033[0m");
    41d4:	9a01      	ldr	r2, [sp, #4]
    41d6:	681b      	ldr	r3, [r3, #0]
    41d8:	429a      	cmp	r2, r3
    41da:	d1f3      	bne.n	41c4 <Matrix_keyPositionDebug+0x1c>
    41dc:	480b      	ldr	r0, [pc, #44]	; (420c <Matrix_keyPositionDebug+0x64>)
    41de:	e7f4      	b.n	41ca <Matrix_keyPositionDebug+0x22>
		print("\033[1;32mH\033[0m");
    41e0:	9a01      	ldr	r2, [sp, #4]
    41e2:	681b      	ldr	r3, [r3, #0]
    41e4:	429a      	cmp	r2, r3
    41e6:	d1ed      	bne.n	41c4 <Matrix_keyPositionDebug+0x1c>
    41e8:	4809      	ldr	r0, [pc, #36]	; (4210 <Matrix_keyPositionDebug+0x68>)
    41ea:	e7ee      	b.n	41ca <Matrix_keyPositionDebug+0x22>
		print("\033[1;35mR\033[0m");
    41ec:	9a01      	ldr	r2, [sp, #4]
    41ee:	681b      	ldr	r3, [r3, #0]
    41f0:	429a      	cmp	r2, r3
    41f2:	d1e7      	bne.n	41c4 <Matrix_keyPositionDebug+0x1c>
    41f4:	4807      	ldr	r0, [pc, #28]	; (4214 <Matrix_keyPositionDebug+0x6c>)
    41f6:	e7e8      	b.n	41ca <Matrix_keyPositionDebug+0x22>
		print("\033[1;31mI\033[0m");
    41f8:	9a01      	ldr	r2, [sp, #4]
    41fa:	681b      	ldr	r3, [r3, #0]
    41fc:	429a      	cmp	r2, r3
    41fe:	d1e1      	bne.n	41c4 <Matrix_keyPositionDebug+0x1c>
    4200:	4805      	ldr	r0, [pc, #20]	; (4218 <Matrix_keyPositionDebug+0x70>)
    4202:	e7e2      	b.n	41ca <Matrix_keyPositionDebug+0x22>
    4204:	1fff89d0 	.word	0x1fff89d0
    4208:	0000fd9d 	.word	0x0000fd9d
    420c:	0000fda7 	.word	0x0000fda7
    4210:	0000fdb4 	.word	0x0000fdb4
    4214:	0000fdc1 	.word	0x0000fdc1
    4218:	0000fdce 	.word	0x0000fdce

0000421c <Matrix_single_scan>:
{
    421c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4220:	4e6a      	ldr	r6, [pc, #424]	; (43cc <Matrix_single_scan+0x1b0>)
	Latency_start_time( matrixLatencyResource );
    4222:	4d6b      	ldr	r5, [pc, #428]	; (43d0 <Matrix_single_scan+0x1b4>)
{
    4224:	6833      	ldr	r3, [r6, #0]
    4226:	b089      	sub	sp, #36	; 0x24
	uint8_t strobe = matrixCurrentStrobe;
    4228:	2400      	movs	r4, #0
{
    422a:	9307      	str	r3, [sp, #28]
	Latency_start_time( matrixLatencyResource );
    422c:	7828      	ldrb	r0, [r5, #0]
    422e:	f00b f8cd 	bl	f3cc <Latency_start_time>
	uint32_t currentTime = systick_millis_count;
    4232:	4b68      	ldr	r3, [pc, #416]	; (43d4 <Matrix_single_scan+0x1b8>)
    4234:	681b      	ldr	r3, [r3, #0]
    4236:	9301      	str	r3, [sp, #4]
	uint8_t strobe = matrixCurrentStrobe;
    4238:	4b67      	ldr	r3, [pc, #412]	; (43d8 <Matrix_single_scan+0x1bc>)
    423a:	9300      	str	r3, [sp, #0]
    423c:	781f      	ldrb	r7, [r3, #0]
    423e:	e9cd 6503 	strd	r6, r5, [sp, #12]
		GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_DriveSetup, Matrix_type );
    4242:	4e66      	ldr	r6, [pc, #408]	; (43dc <Matrix_single_scan+0x1c0>)
	uint8_t strobe = matrixCurrentStrobe;
    4244:	b2ff      	uxtb	r7, r7
		GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_DriveSetup, Matrix_type );
    4246:	eb06 0344 	add.w	r3, r6, r4, lsl #1
    424a:	f816 5014 	ldrb.w	r5, [r6, r4, lsl #1]
    424e:	785b      	ldrb	r3, [r3, #1]
    4250:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    4254:	2202      	movs	r2, #2
    4256:	2103      	movs	r1, #3
    4258:	4628      	mov	r0, r5
    425a:	f7fe fc55 	bl	2b08 <GPIO_Ctrl>
		GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_DriveLow, Matrix_type );
    425e:	2202      	movs	r2, #2
    4260:	2101      	movs	r1, #1
    4262:	4628      	mov	r0, r5
    4264:	f7fe fc50 	bl	2b08 <GPIO_Ctrl>
    4268:	3401      	adds	r4, #1
		GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_ReadSetup, Matrix_type );
    426a:	2202      	movs	r2, #2
    426c:	2105      	movs	r1, #5
    426e:	4628      	mov	r0, r5
    4270:	f7fe fc4a 	bl	2b08 <GPIO_Ctrl>
	for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
    4274:	2c05      	cmp	r4, #5
    4276:	d1e6      	bne.n	4246 <Matrix_single_scan+0x2a>
	GPIO_Ctrl( Matrix_cols[ strobe ], GPIO_Type_DriveHigh, Matrix_type );
    4278:	4b59      	ldr	r3, [pc, #356]	; (43e0 <Matrix_single_scan+0x1c4>)
    427a:	f813 0017 	ldrb.w	r0, [r3, r7, lsl #1]
    427e:	eb03 0347 	add.w	r3, r3, r7, lsl #1
    4282:	2202      	movs	r2, #2
    4284:	785b      	ldrb	r3, [r3, #1]
    4286:	2100      	movs	r1, #0
    4288:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    428c:	f7fe fc3c 	bl	2b08 <GPIO_Ctrl>
	if ( strobeDelayTime > 0 )
    4290:	4b54      	ldr	r3, [pc, #336]	; (43e4 <Matrix_single_scan+0x1c8>)
    4292:	781a      	ldrb	r2, [r3, #0]
    4294:	b112      	cbz	r2, 429c <Matrix_single_scan+0x80>
		delay_us( strobeDelayTime );
    4296:	7818      	ldrb	r0, [r3, #0]
    4298:	f7fe fad4 	bl	2844 <delay_us>
    429c:	4c52      	ldr	r4, [pc, #328]	; (43e8 <Matrix_single_scan+0x1cc>)
		if ( matrixDebugMode && state->curState != state->prevState )
    429e:	f8df a158 	ldr.w	sl, [pc, #344]	; 43f8 <Matrix_single_scan+0x1dc>
    42a2:	463d      	mov	r5, r7
	uint8_t strobe = matrixCurrentStrobe;
    42a4:	f04f 0800 	mov.w	r8, #0
    42a8:	b2ae      	uxth	r6, r5
		uint16_t key = Matrix_colsNum * sense + strobe;
    42aa:	fa1f f388 	uxth.w	r3, r8
		if ( key + 1 > MaxScanCode_KLL )
    42ae:	2e59      	cmp	r6, #89	; 0x59
		uint16_t key = Matrix_colsNum * sense + strobe;
    42b0:	9302      	str	r3, [sp, #8]
    42b2:	fa1f fb87 	uxth.w	fp, r7
		if ( key + 1 > MaxScanCode_KLL )
    42b6:	f200 80ad 	bhi.w	4414 <Matrix_single_scan+0x1f8>
		if ( GPIO_Ctrl( Matrix_rows[ sense ], GPIO_Type_Read, Matrix_type ) )
    42ba:	4b48      	ldr	r3, [pc, #288]	; (43dc <Matrix_single_scan+0x1c0>)
    42bc:	f813 0018 	ldrb.w	r0, [r3, r8, lsl #1]
    42c0:	eb03 0348 	add.w	r3, r3, r8, lsl #1
    42c4:	2202      	movs	r2, #2
    42c6:	785b      	ldrb	r3, [r3, #1]
    42c8:	2104      	movs	r1, #4
    42ca:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    42ce:	f7fe fc1b 	bl	2b08 <GPIO_Ctrl>
    42d2:	b318      	cbz	r0, 431c <Matrix_single_scan+0x100>
			if ( state->activeCount < DebounceDivThreshold ) state->activeCount += 1;
    42d4:	f814 3035 	ldrb.w	r3, [r4, r5, lsl #3]
    42d8:	2bff      	cmp	r3, #255	; 0xff
    42da:	bf1f      	itttt	ne
    42dc:	f814 3035 	ldrbne.w	r3, [r4, r5, lsl #3]
    42e0:	3301      	addne	r3, #1
    42e2:	b2db      	uxtbne	r3, r3
    42e4:	f804 3035 	strbne.w	r3, [r4, r5, lsl #3]
			state->inactiveCount >>= 1;
    42e8:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
    42ec:	7853      	ldrb	r3, [r2, #1]
    42ee:	085b      	lsrs	r3, r3, #1
    42f0:	7053      	strb	r3, [r2, #1]
		state->prevState = state->curState;
    42f2:	00eb      	lsls	r3, r5, #3
    42f4:	18e2      	adds	r2, r4, r3
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    42f6:	9801      	ldr	r0, [sp, #4]
		state->prevState = state->curState;
    42f8:	78d1      	ldrb	r1, [r2, #3]
    42fa:	b2c9      	uxtb	r1, r1
    42fc:	7091      	strb	r1, [r2, #2]
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    42fe:	6851      	ldr	r1, [r2, #4]
		switch ( state->prevState )
    4300:	7892      	ldrb	r2, [r2, #2]
    4302:	3601      	adds	r6, #1
    4304:	b2b6      	uxth	r6, r6
		uint32_t lastTransition = currentTime - state->prevDecisionTime;
    4306:	eba0 0901 	sub.w	r9, r0, r1
		switch ( state->prevState )
    430a:	2a03      	cmp	r2, #3
    430c:	f200 8138 	bhi.w	4580 <Matrix_single_scan+0x364>
    4310:	e8df f012 	tbh	[pc, r2, lsl #1]
    4314:	00130127 	.word	0x00130127
    4318:	01270013 	.word	0x01270013
			if ( state->inactiveCount < DebounceDivThreshold ) state->inactiveCount += 1;
    431c:	eb04 02c5 	add.w	r2, r4, r5, lsl #3
    4320:	7853      	ldrb	r3, [r2, #1]
    4322:	2bff      	cmp	r3, #255	; 0xff
    4324:	bf1f      	itttt	ne
    4326:	7853      	ldrbne	r3, [r2, #1]
    4328:	3301      	addne	r3, #1
    432a:	b2db      	uxtbne	r3, r3
    432c:	7053      	strbne	r3, [r2, #1]
			state->activeCount >>= 1;
    432e:	f814 3035 	ldrb.w	r3, [r4, r5, lsl #3]
    4332:	085b      	lsrs	r3, r3, #1
    4334:	f804 3035 	strb.w	r3, [r4, r5, lsl #3]
    4338:	e7db      	b.n	42f2 <Matrix_single_scan+0xd6>
			if ( state->activeCount > state->inactiveCount )
    433a:	4423      	add	r3, r4
    433c:	f814 1035 	ldrb.w	r1, [r4, r5, lsl #3]
    4340:	785a      	ldrb	r2, [r3, #1]
    4342:	4291      	cmp	r1, r2
    4344:	d95a      	bls.n	43fc <Matrix_single_scan+0x1e0>
				state->curState = KeyState_Hold;
    4346:	2202      	movs	r2, #2
				state->curState = KeyState_Press;
    4348:	70da      	strb	r2, [r3, #3]
		state->prevDecisionTime = currentTime;
    434a:	eb04 0bc5 	add.w	fp, r4, r5, lsl #3
    434e:	9b01      	ldr	r3, [sp, #4]
    4350:	f8cb 3004 	str.w	r3, [fp, #4]
		Macro_keyState( key_disp, state->curState );
    4354:	f89b 1003 	ldrb.w	r1, [fp, #3]
    4358:	4630      	mov	r0, r6
    435a:	f003 faa9 	bl	78b0 <Macro_keyState>
		if ( state->curState != KeyState_Off )
    435e:	f89b 3003 	ldrb.w	r3, [fp, #3]
    4362:	b123      	cbz	r3, 436e <Matrix_single_scan+0x152>
			matrixStateActiveCount++;
    4364:	4a21      	ldr	r2, [pc, #132]	; (43ec <Matrix_single_scan+0x1d0>)
    4366:	8813      	ldrh	r3, [r2, #0]
    4368:	3301      	adds	r3, #1
    436a:	b29b      	uxth	r3, r3
    436c:	8013      	strh	r3, [r2, #0]
		switch ( state->curState )
    436e:	ea4f 0bc5 	mov.w	fp, r5, lsl #3
    4372:	eb04 030b 	add.w	r3, r4, fp
    4376:	78db      	ldrb	r3, [r3, #3]
    4378:	b2db      	uxtb	r3, r3
    437a:	2b01      	cmp	r3, #1
    437c:	f000 8123 	beq.w	45c6 <Matrix_single_scan+0x3aa>
    4380:	2b03      	cmp	r3, #3
    4382:	f000 8126 	beq.w	45d2 <Matrix_single_scan+0x3b6>
		if ( matrixDebugMode && state->curState != state->prevState )
    4386:	f89a 3000 	ldrb.w	r3, [sl]
    438a:	2b00      	cmp	r3, #0
    438c:	d042      	beq.n	4414 <Matrix_single_scan+0x1f8>
    438e:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
    4392:	78d9      	ldrb	r1, [r3, #3]
    4394:	789a      	ldrb	r2, [r3, #2]
    4396:	4291      	cmp	r1, r2
    4398:	d03c      	beq.n	4414 <Matrix_single_scan+0x1f8>
			if ( matrixDebugMode == 1 && state->curState == KeyState_Press )
    439a:	f89a 2000 	ldrb.w	r2, [sl]
    439e:	2a01      	cmp	r2, #1
    43a0:	f040 8119 	bne.w	45d6 <Matrix_single_scan+0x3ba>
    43a4:	78d9      	ldrb	r1, [r3, #3]
    43a6:	b2c9      	uxtb	r1, r1
    43a8:	2901      	cmp	r1, #1
    43aa:	f040 8114 	bne.w	45d6 <Matrix_single_scan+0x3ba>
				printInt16( key_disp );
    43ae:	4630      	mov	r0, r6
    43b0:	9102      	str	r1, [sp, #8]
    43b2:	f00b f97d 	bl	f6b0 <printInt16>
				print(":");
    43b6:	480e      	ldr	r0, [pc, #56]	; (43f0 <Matrix_single_scan+0x1d4>)
    43b8:	f00b f8da 	bl	f570 <_print>
				printHex( key_disp );
    43bc:	9902      	ldr	r1, [sp, #8]
    43be:	4630      	mov	r0, r6
    43c0:	f00b f9fc 	bl	f7bc <printHex_op>
				print(" ");
    43c4:	480b      	ldr	r0, [pc, #44]	; (43f4 <Matrix_single_scan+0x1d8>)
				print( NL );
    43c6:	f00b f8d3 	bl	f570 <_print>
    43ca:	e023      	b.n	4414 <Matrix_single_scan+0x1f8>
    43cc:	1fff89d0 	.word	0x1fff89d0
    43d0:	1fff9498 	.word	0x1fff9498
    43d4:	1fff92d8 	.word	0x1fff92d8
    43d8:	1fff9494 	.word	0x1fff9494
    43dc:	0000fddb 	.word	0x0000fddb
    43e0:	0000fd8b 	.word	0x0000fd8b
    43e4:	1fff94a0 	.word	0x1fff94a0
    43e8:	1fff92e8 	.word	0x1fff92e8
    43ec:	1fff949a 	.word	0x1fff949a
    43f0:	00014d02 	.word	0x00014d02
    43f4:	00016f5e 	.word	0x00016f5e
    43f8:	1fff9495 	.word	0x1fff9495
				if ( lastTransition < debounceExpiryTime )
    43fc:	4a9b      	ldr	r2, [pc, #620]	; (466c <Matrix_single_scan+0x450>)
    43fe:	7812      	ldrb	r2, [r2, #0]
    4400:	454a      	cmp	r2, r9
    4402:	f240 80ac 	bls.w	455e <Matrix_single_scan+0x342>
					state->curState = state->prevState;
    4406:	789a      	ldrb	r2, [r3, #2]
    4408:	b2d2      	uxtb	r2, r2
    440a:	70da      	strb	r2, [r3, #3]
					Macro_keyState( key_disp, state->curState );
    440c:	78d9      	ldrb	r1, [r3, #3]
    440e:	4630      	mov	r0, r6
    4410:	f003 fa4e 	bl	78b0 <Macro_keyState>
    4414:	f108 0801 	add.w	r8, r8, #1
	for ( uint8_t sense = 0; sense < Matrix_rowsNum; sense++ )
    4418:	f1b8 0f05 	cmp.w	r8, #5
    441c:	f105 0509 	add.w	r5, r5, #9
    4420:	f47f af42 	bne.w	42a8 <Matrix_single_scan+0x8c>
	GPIO_Ctrl( Matrix_cols[ strobe ], GPIO_Type_DriveLow, Matrix_type );
    4424:	4b92      	ldr	r3, [pc, #584]	; (4670 <Matrix_single_scan+0x454>)
    4426:	f813 0017 	ldrb.w	r0, [r3, r7, lsl #1]
    442a:	eb03 0747 	add.w	r7, r3, r7, lsl #1
    442e:	2202      	movs	r2, #2
    4430:	787b      	ldrb	r3, [r7, #1]
    4432:	2101      	movs	r1, #1
    4434:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
    4438:	f7fe fb66 	bl	2b08 <GPIO_Ctrl>
	Latency_end_time( matrixLatencyResource );
    443c:	9b04      	ldr	r3, [sp, #16]
    443e:	7818      	ldrb	r0, [r3, #0]
    4440:	f00a ffe2 	bl	f408 <Latency_end_time>
	if ( matrixDebugStateCounter > 0 )
    4444:	4a8b      	ldr	r2, [pc, #556]	; (4674 <Matrix_single_scan+0x458>)
    4446:	8813      	ldrh	r3, [r2, #0]
    4448:	b29b      	uxth	r3, r3
    444a:	2b00      	cmp	r3, #0
    444c:	d04b      	beq.n	44e6 <Matrix_single_scan+0x2ca>
		matrixDebugStateCounter--;
    444e:	8813      	ldrh	r3, [r2, #0]
		print("<key>:<previous state><current state> <active count> <inactive count>");
    4450:	4889      	ldr	r0, [pc, #548]	; (4678 <Matrix_single_scan+0x45c>)
				print( NL );
    4452:	4f8a      	ldr	r7, [pc, #552]	; (467c <Matrix_single_scan+0x460>)
			print("\033[1m");
    4454:	4e8a      	ldr	r6, [pc, #552]	; (4680 <Matrix_single_scan+0x464>)
			print(" 0x");
    4456:	4d8b      	ldr	r5, [pc, #556]	; (4684 <Matrix_single_scan+0x468>)
		matrixDebugStateCounter--;
    4458:	3b01      	subs	r3, #1
    445a:	b29b      	uxth	r3, r3
    445c:	8013      	strh	r3, [r2, #0]
		print("<key>:<previous state><current state> <active count> <inactive count>");
    445e:	f00b f887 	bl	f570 <_print>
    4462:	2400      	movs	r4, #0
			if ( key % 5 == 0 )
    4464:	b2e2      	uxtb	r2, r4
    4466:	2305      	movs	r3, #5
    4468:	fbb2 f3f3 	udiv	r3, r2, r3
    446c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    4470:	1ad3      	subs	r3, r2, r3
    4472:	f013 0fff 	tst.w	r3, #255	; 0xff
    4476:	d102      	bne.n	447e <Matrix_single_scan+0x262>
				print( NL );
    4478:	4638      	mov	r0, r7
    447a:	f00b f879 	bl	f570 <_print>
			print("\033[1m");
    447e:	4630      	mov	r0, r6
			printInt16( key + 1 );
    4480:	f104 0901 	add.w	r9, r4, #1
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    4484:	f8df a230 	ldr.w	sl, [pc, #560]	; 46b8 <Matrix_single_scan+0x49c>
			print("\033[1m");
    4488:	f00b f872 	bl	f570 <_print>
			printInt16( key + 1 );
    448c:	fa1f f089 	uxth.w	r0, r9
    4490:	f00b f90e 	bl	f6b0 <printInt16>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    4494:	eb0a 08c4 	add.w	r8, sl, r4, lsl #3
			print("\033[0m");
    4498:	487b      	ldr	r0, [pc, #492]	; (4688 <Matrix_single_scan+0x46c>)
    449a:	f00b f869 	bl	f570 <_print>
			print(":");
    449e:	487b      	ldr	r0, [pc, #492]	; (468c <Matrix_single_scan+0x470>)
    44a0:	f00b f866 	bl	f570 <_print>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    44a4:	f898 0002 	ldrb.w	r0, [r8, #2]
    44a8:	f7ff fe7e 	bl	41a8 <Matrix_keyPositionDebug>
			Matrix_keyPositionDebug( Matrix_scanArray[ key ].curState );
    44ac:	f898 0003 	ldrb.w	r0, [r8, #3]
    44b0:	f7ff fe7a 	bl	41a8 <Matrix_keyPositionDebug>
			print(" 0x");
    44b4:	4628      	mov	r0, r5
    44b6:	f00b f85b 	bl	f570 <_print>
			printHex_op( Matrix_scanArray[ key ].activeCount, 2 );
    44ba:	f81a 0034 	ldrb.w	r0, [sl, r4, lsl #3]
    44be:	2102      	movs	r1, #2
    44c0:	f00b f97c 	bl	f7bc <printHex_op>
			print(" 0x");
    44c4:	4628      	mov	r0, r5
    44c6:	f00b f853 	bl	f570 <_print>
			printHex_op( Matrix_scanArray[ key ].inactiveCount, 2 );
    44ca:	f898 0001 	ldrb.w	r0, [r8, #1]
    44ce:	2102      	movs	r1, #2
    44d0:	f00b f974 	bl	f7bc <printHex_op>
    44d4:	464c      	mov	r4, r9
			print(" ");
    44d6:	486e      	ldr	r0, [pc, #440]	; (4690 <Matrix_single_scan+0x474>)
    44d8:	f00b f84a 	bl	f570 <_print>
		for ( uint8_t key = 0; key < Matrix_maxKeys; key++ )
    44dc:	2c2d      	cmp	r4, #45	; 0x2d
    44de:	d1c1      	bne.n	4464 <Matrix_single_scan+0x248>
		print( NL );
    44e0:	4866      	ldr	r0, [pc, #408]	; (467c <Matrix_single_scan+0x460>)
    44e2:	f00b f845 	bl	f570 <_print>
	if ( ++matrixCurrentStrobe >= Matrix_colsNum )
    44e6:	9b00      	ldr	r3, [sp, #0]
    44e8:	9a00      	ldr	r2, [sp, #0]
    44ea:	781b      	ldrb	r3, [r3, #0]
    44ec:	3301      	adds	r3, #1
    44ee:	b2db      	uxtb	r3, r3
    44f0:	2b08      	cmp	r3, #8
    44f2:	7013      	strb	r3, [r2, #0]
    44f4:	f04f 0000 	mov.w	r0, #0
    44f8:	d929      	bls.n	454e <Matrix_single_scan+0x332>
		if ( matrixStatePressCount > 0 && matrixStateReleaseCount == 0 )
    44fa:	4c66      	ldr	r4, [pc, #408]	; (4694 <Matrix_single_scan+0x478>)
		matrixCurrentStrobe = 0;
    44fc:	7010      	strb	r0, [r2, #0]
		if ( matrixStatePressCount > 0 && matrixStateReleaseCount == 0 )
    44fe:	8823      	ldrh	r3, [r4, #0]
    4500:	4d65      	ldr	r5, [pc, #404]	; (4698 <Matrix_single_scan+0x47c>)
    4502:	b29b      	uxth	r3, r3
    4504:	b12b      	cbz	r3, 4512 <Matrix_single_scan+0x2f6>
    4506:	882b      	ldrh	r3, [r5, #0]
    4508:	b29b      	uxth	r3, r3
    450a:	b913      	cbnz	r3, 4512 <Matrix_single_scan+0x2f6>
			Time_tick_reset( &inactivity_tickstore );
    450c:	4863      	ldr	r0, [pc, #396]	; (469c <Matrix_single_scan+0x480>)
    450e:	f7fe fdc9 	bl	30a4 <Time_tick_reset>
		if ( matrixStateReleaseCount > 0 && matrixStatePressCount == 0 )
    4512:	882b      	ldrh	r3, [r5, #0]
    4514:	b29b      	uxth	r3, r3
    4516:	b12b      	cbz	r3, 4524 <Matrix_single_scan+0x308>
    4518:	8823      	ldrh	r3, [r4, #0]
    451a:	b29b      	uxth	r3, r3
    451c:	b913      	cbnz	r3, 4524 <Matrix_single_scan+0x308>
			Time_tick_reset( &activity_tickstore );
    451e:	4860      	ldr	r0, [pc, #384]	; (46a0 <Matrix_single_scan+0x484>)
    4520:	f7fe fdc0 	bl	30a4 <Time_tick_reset>
		if ( matrixStateActiveCount > 0 )
    4524:	4e5f      	ldr	r6, [pc, #380]	; (46a4 <Matrix_single_scan+0x488>)
    4526:	8833      	ldrh	r3, [r6, #0]
    4528:	b29b      	uxth	r3, r3
    452a:	2b00      	cmp	r3, #0
    452c:	f000 8092 	beq.w	4654 <Matrix_single_scan+0x438>
			if ( activity_tickstore.fresh_store )
    4530:	4b5b      	ldr	r3, [pc, #364]	; (46a0 <Matrix_single_scan+0x484>)
    4532:	7e1b      	ldrb	r3, [r3, #24]
    4534:	b113      	cbz	r3, 453c <Matrix_single_scan+0x320>
				Time_tick_reset( &inactivity_tickstore );
    4536:	4859      	ldr	r0, [pc, #356]	; (469c <Matrix_single_scan+0x480>)
    4538:	f7fe fdb4 	bl	30a4 <Time_tick_reset>
			Macro_tick_update( &activity_tickstore, TriggerType_Active1 );
    453c:	4858      	ldr	r0, [pc, #352]	; (46a0 <Matrix_single_scan+0x484>)
    453e:	2114      	movs	r1, #20
			Macro_tick_update( &inactivity_tickstore, TriggerType_Inactive1 );
    4540:	f003 fba2 	bl	7c88 <Macro_tick_update>
		matrixStateActiveCount = 0;
    4544:	2300      	movs	r3, #0
    4546:	8033      	strh	r3, [r6, #0]
		return 1;
    4548:	2001      	movs	r0, #1
		matrixStatePressCount = 0;
    454a:	8023      	strh	r3, [r4, #0]
		matrixStateReleaseCount = 0;
    454c:	802b      	strh	r3, [r5, #0]
}
    454e:	9b03      	ldr	r3, [sp, #12]
    4550:	9a07      	ldr	r2, [sp, #28]
    4552:	681b      	ldr	r3, [r3, #0]
    4554:	429a      	cmp	r2, r3
    4556:	f000 8086 	beq.w	4666 <Matrix_single_scan+0x44a>
    455a:	f7fe f8e9 	bl	2730 <__stack_chk_fail>
				state->curState = KeyState_Release;
    455e:	2203      	movs	r2, #3
    4560:	e6f2      	b.n	4348 <Matrix_single_scan+0x12c>
			if ( state->activeCount > state->inactiveCount )
    4562:	4423      	add	r3, r4
    4564:	f814 1035 	ldrb.w	r1, [r4, r5, lsl #3]
    4568:	785a      	ldrb	r2, [r3, #1]
    456a:	4291      	cmp	r1, r2
    456c:	d906      	bls.n	457c <Matrix_single_scan+0x360>
				if ( lastTransition < debounceExpiryTime )
    456e:	4a3f      	ldr	r2, [pc, #252]	; (466c <Matrix_single_scan+0x450>)
    4570:	7812      	ldrb	r2, [r2, #0]
    4572:	454a      	cmp	r2, r9
    4574:	f63f af47 	bhi.w	4406 <Matrix_single_scan+0x1ea>
				state->curState = KeyState_Press;
    4578:	2201      	movs	r2, #1
    457a:	e6e5      	b.n	4348 <Matrix_single_scan+0x12c>
				state->curState = KeyState_Off;
    457c:	2200      	movs	r2, #0
    457e:	e6e3      	b.n	4348 <Matrix_single_scan+0x12c>
			erro_msg("Matrix scan bug!! Report me! - ");
    4580:	4849      	ldr	r0, [pc, #292]	; (46a8 <Matrix_single_scan+0x48c>)
    4582:	9305      	str	r3, [sp, #20]
    4584:	f00a fff4 	bl	f570 <_print>
			printHex( state->prevState );
    4588:	9b05      	ldr	r3, [sp, #20]
    458a:	4423      	add	r3, r4
    458c:	2101      	movs	r1, #1
    458e:	7898      	ldrb	r0, [r3, #2]
    4590:	f00b f914 	bl	f7bc <printHex_op>
			print(" Col: ");
    4594:	4845      	ldr	r0, [pc, #276]	; (46ac <Matrix_single_scan+0x490>)
    4596:	f00a ffeb 	bl	f570 <_print>
			printHex( strobe );
    459a:	2101      	movs	r1, #1
    459c:	4658      	mov	r0, fp
    459e:	f00b f90d 	bl	f7bc <printHex_op>
			print(" Row: ");
    45a2:	4843      	ldr	r0, [pc, #268]	; (46b0 <Matrix_single_scan+0x494>)
    45a4:	f00a ffe4 	bl	f570 <_print>
			printHex( sense );
    45a8:	2101      	movs	r1, #1
    45aa:	9802      	ldr	r0, [sp, #8]
    45ac:	f00b f906 	bl	f7bc <printHex_op>
			print(" Key: ");
    45b0:	4840      	ldr	r0, [pc, #256]	; (46b4 <Matrix_single_scan+0x498>)
    45b2:	f00a ffdd 	bl	f570 <_print>
			printHex( key_disp );
    45b6:	4630      	mov	r0, r6
    45b8:	2101      	movs	r1, #1
    45ba:	f00b f8ff 	bl	f7bc <printHex_op>
			print( NL );
    45be:	482f      	ldr	r0, [pc, #188]	; (467c <Matrix_single_scan+0x460>)
    45c0:	f00a ffd6 	bl	f570 <_print>
			break;
    45c4:	e6c1      	b.n	434a <Matrix_single_scan+0x12e>
			matrixStatePressCount++;
    45c6:	4a33      	ldr	r2, [pc, #204]	; (4694 <Matrix_single_scan+0x478>)
			matrixStateReleaseCount++;
    45c8:	8813      	ldrh	r3, [r2, #0]
    45ca:	3301      	adds	r3, #1
    45cc:	b29b      	uxth	r3, r3
    45ce:	8013      	strh	r3, [r2, #0]
			break;
    45d0:	e6d9      	b.n	4386 <Matrix_single_scan+0x16a>
			matrixStateReleaseCount++;
    45d2:	4a31      	ldr	r2, [pc, #196]	; (4698 <Matrix_single_scan+0x47c>)
    45d4:	e7f8      	b.n	45c8 <Matrix_single_scan+0x3ac>
			else if ( matrixDebugMode == 2 )
    45d6:	f89a 3000 	ldrb.w	r3, [sl]
    45da:	2b02      	cmp	r3, #2
    45dc:	d108      	bne.n	45f0 <Matrix_single_scan+0x3d4>
				printInt16( key_disp );
    45de:	4630      	mov	r0, r6
    45e0:	f00b f866 	bl	f6b0 <printInt16>
				Matrix_keyPositionDebug( state->curState );
    45e4:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
    45e8:	78d8      	ldrb	r0, [r3, #3]
    45ea:	f7ff fddd 	bl	41a8 <Matrix_keyPositionDebug>
    45ee:	e6e9      	b.n	43c4 <Matrix_single_scan+0x1a8>
			else if ( matrixDebugMode == 3 )
    45f0:	f89a 3000 	ldrb.w	r3, [sl]
    45f4:	2b03      	cmp	r3, #3
    45f6:	f47f af0d 	bne.w	4414 <Matrix_single_scan+0x1f8>
				print("\033[1m");
    45fa:	4821      	ldr	r0, [pc, #132]	; (4680 <Matrix_single_scan+0x464>)
    45fc:	f00a ffb8 	bl	f570 <_print>
				printInt16( key_disp );
    4600:	4630      	mov	r0, r6
    4602:	f00b f855 	bl	f6b0 <printInt16>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    4606:	44a3      	add	fp, r4
				print("\033[0m");
    4608:	481f      	ldr	r0, [pc, #124]	; (4688 <Matrix_single_scan+0x46c>)
    460a:	f00a ffb1 	bl	f570 <_print>
				print(":");
    460e:	481f      	ldr	r0, [pc, #124]	; (468c <Matrix_single_scan+0x470>)
    4610:	f00a ffae 	bl	f570 <_print>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].prevState );
    4614:	f89b 0002 	ldrb.w	r0, [fp, #2]
    4618:	f7ff fdc6 	bl	41a8 <Matrix_keyPositionDebug>
				Matrix_keyPositionDebug( Matrix_scanArray[ key ].curState );
    461c:	f89b 0003 	ldrb.w	r0, [fp, #3]
    4620:	f7ff fdc2 	bl	41a8 <Matrix_keyPositionDebug>
				print(" 0x");
    4624:	4817      	ldr	r0, [pc, #92]	; (4684 <Matrix_single_scan+0x468>)
    4626:	f00a ffa3 	bl	f570 <_print>
				printHex_op( state->activeCount, 2 );
    462a:	2102      	movs	r1, #2
    462c:	f814 0035 	ldrb.w	r0, [r4, r5, lsl #3]
    4630:	f00b f8c4 	bl	f7bc <printHex_op>
				print(" 0x");
    4634:	4813      	ldr	r0, [pc, #76]	; (4684 <Matrix_single_scan+0x468>)
    4636:	f00a ff9b 	bl	f570 <_print>
				printHex_op( state->inactiveCount, 2 );
    463a:	2102      	movs	r1, #2
    463c:	f89b 0001 	ldrb.w	r0, [fp, #1]
    4640:	f00b f8bc 	bl	f7bc <printHex_op>
				print(" ");
    4644:	4812      	ldr	r0, [pc, #72]	; (4690 <Matrix_single_scan+0x474>)
    4646:	f00a ff93 	bl	f570 <_print>
				printInt32( lastTransition );
    464a:	4648      	mov	r0, r9
    464c:	f00b f866 	bl	f71c <printInt32>
				print( NL );
    4650:	480a      	ldr	r0, [pc, #40]	; (467c <Matrix_single_scan+0x460>)
    4652:	e6b8      	b.n	43c6 <Matrix_single_scan+0x1aa>
			if ( inactivity_tickstore.fresh_store )
    4654:	4b11      	ldr	r3, [pc, #68]	; (469c <Matrix_single_scan+0x480>)
    4656:	7e1b      	ldrb	r3, [r3, #24]
    4658:	b113      	cbz	r3, 4660 <Matrix_single_scan+0x444>
				Time_tick_reset( &activity_tickstore );
    465a:	4811      	ldr	r0, [pc, #68]	; (46a0 <Matrix_single_scan+0x484>)
    465c:	f7fe fd22 	bl	30a4 <Time_tick_reset>
			Macro_tick_update( &inactivity_tickstore, TriggerType_Inactive1 );
    4660:	2113      	movs	r1, #19
    4662:	480e      	ldr	r0, [pc, #56]	; (469c <Matrix_single_scan+0x480>)
    4664:	e76c      	b.n	4540 <Matrix_single_scan+0x324>
}
    4666:	b009      	add	sp, #36	; 0x24
    4668:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    466c:	1fff9474 	.word	0x1fff9474
    4670:	0000fd8b 	.word	0x0000fd8b
    4674:	1fff9496 	.word	0x1fff9496
    4678:	0000fe46 	.word	0x0000fe46
    467c:	00015df4 	.word	0x00015df4
    4680:	0000fe3d 	.word	0x0000fe3d
    4684:	0000fe42 	.word	0x0000fe42
    4688:	0001205c 	.word	0x0001205c
    468c:	00014d02 	.word	0x00014d02
    4690:	00016f5e 	.word	0x00016f5e
    4694:	1fff949c 	.word	0x1fff949c
    4698:	1fff949e 	.word	0x1fff949e
    469c:	1fff9478 	.word	0x1fff9478
    46a0:	1fff9458 	.word	0x1fff9458
    46a4:	1fff949a 	.word	0x1fff949a
    46a8:	0000fdf3 	.word	0x0000fdf3
    46ac:	0000fe28 	.word	0x0000fe28
    46b0:	0000fe2f 	.word	0x0000fe2f
    46b4:	0000fe36 	.word	0x0000fe36
    46b8:	1fff92e8 	.word	0x1fff92e8

000046bc <Matrix_start>:
{
    46bc:	b507      	push	{r0, r1, r2, lr}
    46be:	4b08      	ldr	r3, [pc, #32]	; (46e0 <Matrix_start+0x24>)
    46c0:	681a      	ldr	r2, [r3, #0]
    46c2:	9201      	str	r2, [sp, #4]
	Periodic_init( PeriodicCycles_define );
    46c4:	9a01      	ldr	r2, [sp, #4]
    46c6:	681b      	ldr	r3, [r3, #0]
    46c8:	429a      	cmp	r2, r3
    46ca:	d001      	beq.n	46d0 <Matrix_start+0x14>
    46cc:	f7fe f830 	bl	2730 <__stack_chk_fail>
    46d0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
}
    46d4:	b003      	add	sp, #12
    46d6:	f85d eb04 	ldr.w	lr, [sp], #4
	Periodic_init( PeriodicCycles_define );
    46da:	f7fe ba81 	b.w	2be0 <Periodic_init>
    46de:	bf00      	nop
    46e0:	1fff89d0 	.word	0x1fff89d0

000046e4 <Matrix_currentChange>:
{
    46e4:	b507      	push	{r0, r1, r2, lr}
    46e6:	4b06      	ldr	r3, [pc, #24]	; (4700 <Matrix_currentChange+0x1c>)
    46e8:	681a      	ldr	r2, [r3, #0]
    46ea:	9201      	str	r2, [sp, #4]
}
    46ec:	9a01      	ldr	r2, [sp, #4]
    46ee:	681b      	ldr	r3, [r3, #0]
    46f0:	429a      	cmp	r2, r3
    46f2:	d001      	beq.n	46f8 <Matrix_currentChange+0x14>
    46f4:	f7fe f81c 	bl	2730 <__stack_chk_fail>
    46f8:	b003      	add	sp, #12
    46fa:	f85d fb04 	ldr.w	pc, [sp], #4
    46fe:	bf00      	nop
    4700:	1fff89d0 	.word	0x1fff89d0

00004704 <cliFunc_lcdColor>:
    }

}

void cliFunc_lcdColor( char* args )
{
    4704:	b5f0      	push	{r4, r5, r6, r7, lr}
    4706:	b087      	sub	sp, #28
    4708:	4e14      	ldr	r6, [pc, #80]	; (475c <cliFunc_lcdColor+0x58>)
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    470a:	ad06      	add	r5, sp, #24
{
    470c:	6832      	ldr	r2, [r6, #0]
	char* arg2Ptr = args;
    470e:	f845 0d10 	str.w	r0, [r5, #-16]!
{
    4712:	9205      	str	r2, [sp, #20]
	char* arg2Ptr = args;
    4714:	2400      	movs	r4, #0
		// Give up if not enough args given
		if ( *arg1Ptr == '\0' )
			return;

		// Convert argument to integer
		rgb[ color ] = numToInt( arg1Ptr );
    4716:	af03      	add	r7, sp, #12
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    4718:	9802      	ldr	r0, [sp, #8]
    471a:	462a      	mov	r2, r5
    471c:	a901      	add	r1, sp, #4
    471e:	f00a f9f9 	bl	eb14 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    4722:	9801      	ldr	r0, [sp, #4]
    4724:	7803      	ldrb	r3, [r0, #0]
    4726:	b183      	cbz	r3, 474a <cliFunc_lcdColor+0x46>
		rgb[ color ] = numToInt( arg1Ptr );
    4728:	f00b f8f2 	bl	f910 <numToInt>
    472c:	f827 0014 	strh.w	r0, [r7, r4, lsl #1]
    4730:	3401      	adds	r4, #1
	for ( uint8_t color = 0; color < 3; color++ )
    4732:	2c03      	cmp	r4, #3
    4734:	d1f0      	bne.n	4718 <cliFunc_lcdColor+0x14>
	}

	// Set PWM channels
#if defined(_kinetis_)
	FTM0_C0V = rgb[0];
    4736:	4b0a      	ldr	r3, [pc, #40]	; (4760 <cliFunc_lcdColor+0x5c>)
    4738:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    473c:	601a      	str	r2, [r3, #0]
	FTM0_C1V = rgb[1];
    473e:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    4742:	609a      	str	r2, [r3, #8]
	FTM0_C2V = rgb[2];
    4744:	f8bd 2010 	ldrh.w	r2, [sp, #16]
    4748:	611a      	str	r2, [r3, #16]
#elif defined(_sam_)
		//SAM TODO
#endif
}
    474a:	9a05      	ldr	r2, [sp, #20]
    474c:	6833      	ldr	r3, [r6, #0]
    474e:	429a      	cmp	r2, r3
    4750:	d001      	beq.n	4756 <cliFunc_lcdColor+0x52>
    4752:	f7fd ffed 	bl	2730 <__stack_chk_fail>
    4756:	b007      	add	sp, #28
    4758:	bdf0      	pop	{r4, r5, r6, r7, pc}
    475a:	bf00      	nop
    475c:	1fff89d0 	.word	0x1fff89d0
    4760:	40038010 	.word	0x40038010

00004764 <SPI_setup>:
{
    4764:	b507      	push	{r0, r1, r2, lr}
    4766:	4a10      	ldr	r2, [pc, #64]	; (47a8 <SPI_setup+0x44>)
	SIM_SCGC6 |= SIM_SCGC6_SPI0;
    4768:	4910      	ldr	r1, [pc, #64]	; (47ac <SPI_setup+0x48>)
{
    476a:	6813      	ldr	r3, [r2, #0]
    476c:	9301      	str	r3, [sp, #4]
	SIM_SCGC6 |= SIM_SCGC6_SPI0;
    476e:	680b      	ldr	r3, [r1, #0]
    4770:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    4774:	600b      	str	r3, [r1, #0]
	PORTC_PCR6 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    4776:	f501 513f 	add.w	r1, r1, #12224	; 0x2fc0
    477a:	311c      	adds	r1, #28
    477c:	f44f 7310 	mov.w	r3, #576	; 0x240
    4780:	600b      	str	r3, [r1, #0]
	PORTC_PCR5 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    4782:	f841 3c04 	str.w	r3, [r1, #-4]
	PORTC_PCR4 = PORT_PCR_DSE | PORT_PCR_MUX(2);
    4786:	f841 3c08 	str.w	r3, [r1, #-8]
	SPI0_MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(1);
    478a:	4b09      	ldr	r3, [pc, #36]	; (47b0 <SPI_setup+0x4c>)
    478c:	4909      	ldr	r1, [pc, #36]	; (47b4 <SPI_setup+0x50>)
    478e:	6019      	str	r1, [r3, #0]
	SPI0_CTAR0 = SPI_CTAR_FMSZ(7)
    4790:	4909      	ldr	r1, [pc, #36]	; (47b8 <SPI_setup+0x54>)
    4792:	60d9      	str	r1, [r3, #12]
}
    4794:	9901      	ldr	r1, [sp, #4]
    4796:	6813      	ldr	r3, [r2, #0]
    4798:	4299      	cmp	r1, r3
    479a:	d001      	beq.n	47a0 <SPI_setup+0x3c>
    479c:	f7fd ffc8 	bl	2730 <__stack_chk_fail>
    47a0:	b003      	add	sp, #12
    47a2:	f85d fb04 	ldr.w	pc, [sp], #4
    47a6:	bf00      	nop
    47a8:	1fff89d0 	.word	0x1fff89d0
    47ac:	4004803c 	.word	0x4004803c
    47b0:	4002c000 	.word	0x4002c000
    47b4:	80010000 	.word	0x80010000
    47b8:	38007777 	.word	0x38007777

000047bc <SPI_write>:
{
    47bc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    47c0:	4d13      	ldr	r5, [pc, #76]	; (4810 <SPI_write+0x54>)
		while ( !( SPI0_SR & SPI_SR_TFFF ) )
    47c2:	4c14      	ldr	r4, [pc, #80]	; (4814 <SPI_write+0x58>)
{
    47c4:	682a      	ldr	r2, [r5, #0]
		SPI0_PUSHR = ( buffer[ byte ] & 0xff ) | SPI_PUSHR_PCS(1);
    47c6:	f8df 8050 	ldr.w	r8, [pc, #80]	; 4818 <SPI_write+0x5c>
{
    47ca:	9201      	str	r2, [sp, #4]
    47cc:	1e46      	subs	r6, r0, #1
    47ce:	1877      	adds	r7, r6, r1
	for ( uint8_t byte = 0; byte < len; byte++ )
    47d0:	42be      	cmp	r6, r7
    47d2:	d108      	bne.n	47e6 <SPI_write+0x2a>
}
    47d4:	9a01      	ldr	r2, [sp, #4]
    47d6:	682b      	ldr	r3, [r5, #0]
    47d8:	429a      	cmp	r2, r3
    47da:	d015      	beq.n	4808 <SPI_write+0x4c>
    47dc:	f7fd ffa8 	bl	2730 <__stack_chk_fail>
			delay_us(10);
    47e0:	200a      	movs	r0, #10
    47e2:	f7fe f82f 	bl	2844 <delay_us>
		while ( !( SPI0_SR & SPI_SR_TFFF ) )
    47e6:	6823      	ldr	r3, [r4, #0]
    47e8:	019b      	lsls	r3, r3, #6
    47ea:	d5f9      	bpl.n	47e0 <SPI_write+0x24>
		SPI0_PUSHR = ( buffer[ byte ] & 0xff ) | SPI_PUSHR_PCS(1);
    47ec:	f816 3f01 	ldrb.w	r3, [r6, #1]!
    47f0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    47f4:	f8c8 3000 	str.w	r3, [r8]
		while ( !( SPI0_SR & SPI_SR_TCF ) );
    47f8:	6823      	ldr	r3, [r4, #0]
    47fa:	2b00      	cmp	r3, #0
    47fc:	dafc      	bge.n	47f8 <SPI_write+0x3c>
		SPI0_SR |= SPI_SR_TCF;
    47fe:	6823      	ldr	r3, [r4, #0]
    4800:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    4804:	6023      	str	r3, [r4, #0]
    4806:	e7e3      	b.n	47d0 <SPI_write+0x14>
}
    4808:	b002      	add	sp, #8
    480a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    480e:	bf00      	nop
    4810:	1fff89d0 	.word	0x1fff89d0
    4814:	4002c02c 	.word	0x4002c02c
    4818:	4002c034 	.word	0x4002c034

0000481c <LCD_writeControlReg>:
{
    481c:	b530      	push	{r4, r5, lr}
    481e:	4c15      	ldr	r4, [pc, #84]	; (4874 <LCD_writeControlReg+0x58>)
	while ( SPI0_TxFIFO_CNT != 0 );
    4820:	4b15      	ldr	r3, [pc, #84]	; (4878 <LCD_writeControlReg+0x5c>)
{
    4822:	6822      	ldr	r2, [r4, #0]
    4824:	b085      	sub	sp, #20
    4826:	461d      	mov	r5, r3
    4828:	f88d 0007 	strb.w	r0, [sp, #7]
    482c:	9203      	str	r2, [sp, #12]
	while ( SPI0_TxFIFO_CNT != 0 );
    482e:	681a      	ldr	r2, [r3, #0]
    4830:	f412 4f70 	tst.w	r2, #61440	; 0xf000
    4834:	d1fb      	bne.n	482e <LCD_writeControlReg+0x12>
	GPIOC_PCOR |= (1<<7);
    4836:	4a11      	ldr	r2, [pc, #68]	; (487c <LCD_writeControlReg+0x60>)
    4838:	6813      	ldr	r3, [r2, #0]
    483a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    483e:	6013      	str	r3, [r2, #0]
	SPI_write( &byte, 1 );
    4840:	2101      	movs	r1, #1
    4842:	f10d 0007 	add.w	r0, sp, #7
    4846:	f7ff ffb9 	bl	47bc <SPI_write>
	while ( SPI0_TxFIFO_CNT != 0 );
    484a:	682b      	ldr	r3, [r5, #0]
    484c:	f413 4f70 	tst.w	r3, #61440	; 0xf000
    4850:	d1fb      	bne.n	484a <LCD_writeControlReg+0x2e>
	delay_us(10); // XXX Adjust if SPI speed changes
    4852:	200a      	movs	r0, #10
    4854:	f7fd fff6 	bl	2844 <delay_us>
	GPIOC_PSOR |= (1<<7);
    4858:	4a09      	ldr	r2, [pc, #36]	; (4880 <LCD_writeControlReg+0x64>)
    485a:	6813      	ldr	r3, [r2, #0]
    485c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4860:	6013      	str	r3, [r2, #0]
}
    4862:	9a03      	ldr	r2, [sp, #12]
    4864:	6823      	ldr	r3, [r4, #0]
    4866:	429a      	cmp	r2, r3
    4868:	d001      	beq.n	486e <LCD_writeControlReg+0x52>
    486a:	f7fd ff61 	bl	2730 <__stack_chk_fail>
    486e:	b005      	add	sp, #20
    4870:	bd30      	pop	{r4, r5, pc}
    4872:	bf00      	nop
    4874:	1fff89d0 	.word	0x1fff89d0
    4878:	4002c02c 	.word	0x4002c02c
    487c:	400ff088 	.word	0x400ff088
    4880:	400ff084 	.word	0x400ff084

00004884 <cliFunc_lcdDisp>:

void cliFunc_lcdDisp( char* args )
{
    4884:	b5f0      	push	{r4, r5, r6, r7, lr}
    4886:	b085      	sub	sp, #20
	char* curArgs;
	char* arg1Ptr;
	char* arg2Ptr = args;
    4888:	ac04      	add	r4, sp, #16
{
    488a:	4f21      	ldr	r7, [pc, #132]	; (4910 <cliFunc_lcdDisp+0x8c>)
	char* arg2Ptr = args;
    488c:	f844 0d08 	str.w	r0, [r4, #-8]!
{
    4890:	683b      	ldr	r3, [r7, #0]
    4892:	9303      	str	r3, [sp, #12]

	// First process page and starting address
	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    4894:	4622      	mov	r2, r4
    4896:	a901      	add	r1, sp, #4
    4898:	f00a f93c 	bl	eb14 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    489c:	9801      	ldr	r0, [sp, #4]
    489e:	7803      	ldrb	r3, [r0, #0]
    48a0:	b373      	cbz	r3, 4900 <cliFunc_lcdDisp+0x7c>
		return;
	uint8_t page = numToInt( arg1Ptr );
    48a2:	f00b f835 	bl	f910 <numToInt>

	curArgs = arg2Ptr;
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    48a6:	4622      	mov	r2, r4
	uint8_t page = numToInt( arg1Ptr );
    48a8:	4605      	mov	r5, r0
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    48aa:	a901      	add	r1, sp, #4
    48ac:	9802      	ldr	r0, [sp, #8]
    48ae:	f00a f931 	bl	eb14 <CLI_argumentIsolation>

	// Stop processing args if no more are found
	if ( *arg1Ptr == '\0' )
    48b2:	9801      	ldr	r0, [sp, #4]
    48b4:	7803      	ldrb	r3, [r0, #0]
    48b6:	b31b      	cbz	r3, 4900 <cliFunc_lcdDisp+0x7c>
		return;
	uint8_t address = numToInt( arg1Ptr );
    48b8:	f00b f82a 	bl	f910 <numToInt>
    48bc:	b2c6      	uxtb	r6, r0

	// Set the register page
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    48be:	f005 000f 	and.w	r0, r5, #15
    48c2:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
    48c6:	f7ff ffa9 	bl	481c <LCD_writeControlReg>

	// Set starting address
	LCD_writeControlReg( 0x10 | ( ( 0xF0 & address ) >> 4 ) );
    48ca:	0930      	lsrs	r0, r6, #4
    48cc:	f040 0010 	orr.w	r0, r0, #16
    48d0:	f7ff ffa4 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 | ( 0x0F & address ));
    48d4:	f006 000f 	and.w	r0, r6, #15
    48d8:	f7ff ffa0 	bl	481c <LCD_writeControlReg>

	// Process all args
	for ( ;; )
	{
		curArgs = arg2Ptr;
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    48dc:	9802      	ldr	r0, [sp, #8]
    48de:	4622      	mov	r2, r4
    48e0:	a901      	add	r1, sp, #4
    48e2:	f00a f917 	bl	eb14 <CLI_argumentIsolation>

		// Stop processing args if no more are found
		if ( *arg1Ptr == '\0' )
    48e6:	9801      	ldr	r0, [sp, #4]
    48e8:	7803      	ldrb	r3, [r0, #0]
    48ea:	b14b      	cbz	r3, 4900 <cliFunc_lcdDisp+0x7c>
			break;

		uint8_t value = numToInt( arg1Ptr );
    48ec:	f00b f810 	bl	f910 <numToInt>
		// Write buffer to SPI
		SPI_write( &value, 1 );
    48f0:	2101      	movs	r1, #1
		uint8_t value = numToInt( arg1Ptr );
    48f2:	f88d 0003 	strb.w	r0, [sp, #3]
		SPI_write( &value, 1 );
    48f6:	f10d 0003 	add.w	r0, sp, #3
    48fa:	f7ff ff5f 	bl	47bc <SPI_write>
	{
    48fe:	e7ed      	b.n	48dc <cliFunc_lcdDisp+0x58>
	}
}
    4900:	9a03      	ldr	r2, [sp, #12]
    4902:	683b      	ldr	r3, [r7, #0]
    4904:	429a      	cmp	r2, r3
    4906:	d001      	beq.n	490c <cliFunc_lcdDisp+0x88>
    4908:	f7fd ff12 	bl	2730 <__stack_chk_fail>
    490c:	b005      	add	sp, #20
    490e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4910:	1fff89d0 	.word	0x1fff89d0

00004914 <LCD_writeDataReg>:
{
    4914:	b530      	push	{r4, r5, lr}
    4916:	4c12      	ldr	r4, [pc, #72]	; (4960 <LCD_writeDataReg+0x4c>)
	while ( SPI0_TxFIFO_CNT != 0 );
    4918:	4b12      	ldr	r3, [pc, #72]	; (4964 <LCD_writeDataReg+0x50>)
{
    491a:	6822      	ldr	r2, [r4, #0]
    491c:	b085      	sub	sp, #20
    491e:	461d      	mov	r5, r3
    4920:	f88d 0007 	strb.w	r0, [sp, #7]
    4924:	9203      	str	r2, [sp, #12]
	while ( SPI0_TxFIFO_CNT != 0 );
    4926:	681a      	ldr	r2, [r3, #0]
    4928:	f412 4f70 	tst.w	r2, #61440	; 0xf000
    492c:	d1fb      	bne.n	4926 <LCD_writeDataReg+0x12>
	GPIOC_PSOR |= (1<<7);
    492e:	4a0e      	ldr	r2, [pc, #56]	; (4968 <LCD_writeDataReg+0x54>)
    4930:	6813      	ldr	r3, [r2, #0]
    4932:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4936:	6013      	str	r3, [r2, #0]
	SPI_write( &byte, 1 );
    4938:	2101      	movs	r1, #1
    493a:	f10d 0007 	add.w	r0, sp, #7
    493e:	f7ff ff3d 	bl	47bc <SPI_write>
	while ( SPI0_TxFIFO_CNT != 0 );
    4942:	682b      	ldr	r3, [r5, #0]
    4944:	f413 4f70 	tst.w	r3, #61440	; 0xf000
    4948:	d1fb      	bne.n	4942 <LCD_writeDataReg+0x2e>
	delay_us(10); // XXX Adjust if SPI speed changes
    494a:	200a      	movs	r0, #10
    494c:	f7fd ff7a 	bl	2844 <delay_us>
}
    4950:	9a03      	ldr	r2, [sp, #12]
    4952:	6823      	ldr	r3, [r4, #0]
    4954:	429a      	cmp	r2, r3
    4956:	d001      	beq.n	495c <LCD_writeDataReg+0x48>
    4958:	f7fd feea 	bl	2730 <__stack_chk_fail>
    495c:	b005      	add	sp, #20
    495e:	bd30      	pop	{r4, r5, pc}
    4960:	1fff89d0 	.word	0x1fff89d0
    4964:	4002c02c 	.word	0x4002c02c
    4968:	400ff084 	.word	0x400ff084

0000496c <cliFunc_lcdCmd>:
{
    496c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	char* arg2Ptr = args;
    496e:	ad04      	add	r5, sp, #16
{
    4970:	4c20      	ldr	r4, [pc, #128]	; (49f4 <cliFunc_lcdCmd+0x88>)
	char* arg2Ptr = args;
    4972:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    4976:	6823      	ldr	r3, [r4, #0]
	print( NL ); // No \r\n by default after the command is entered
    4978:	481f      	ldr	r0, [pc, #124]	; (49f8 <cliFunc_lcdCmd+0x8c>)
{
    497a:	9303      	str	r3, [sp, #12]
	print( NL ); // No \r\n by default after the command is entered
    497c:	f00a fdf8 	bl	f570 <_print>
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    4980:	9802      	ldr	r0, [sp, #8]
    4982:	462a      	mov	r2, r5
    4984:	a901      	add	r1, sp, #4
    4986:	f00a f8c5 	bl	eb14 <CLI_argumentIsolation>
	if ( *arg1Ptr == '\0' )
    498a:	9801      	ldr	r0, [sp, #4]
    498c:	7803      	ldrb	r3, [r0, #0]
    498e:	b95b      	cbnz	r3, 49a8 <cliFunc_lcdCmd+0x3c>
		print("No args provided.");
    4990:	481a      	ldr	r0, [pc, #104]	; (49fc <cliFunc_lcdCmd+0x90>)
    4992:	f00a fded 	bl	f570 <_print>
		print( NL );
    4996:	4818      	ldr	r0, [pc, #96]	; (49f8 <cliFunc_lcdCmd+0x8c>)
    4998:	f00a fdea 	bl	f570 <_print>
}
    499c:	9a03      	ldr	r2, [sp, #12]
    499e:	6823      	ldr	r3, [r4, #0]
    49a0:	429a      	cmp	r2, r3
    49a2:	d024      	beq.n	49ee <cliFunc_lcdCmd+0x82>
    49a4:	f7fd fec4 	bl	2730 <__stack_chk_fail>
	uint8_t cmd = (uint8_t)numToInt( arg1Ptr );
    49a8:	f00a ffb2 	bl	f910 <numToInt>
	if ( *arg2Ptr == '\0' )
    49ac:	9b02      	ldr	r3, [sp, #8]
    49ae:	781b      	ldrb	r3, [r3, #0]
	uint8_t cmd = (uint8_t)numToInt( arg1Ptr );
    49b0:	b2c5      	uxtb	r5, r0
    49b2:	b2ae      	uxth	r6, r5
	if ( *arg2Ptr == '\0' )
    49b4:	b96b      	cbnz	r3, 49d2 <cliFunc_lcdCmd+0x66>
        info_msg("Sending- ");
    49b6:	4812      	ldr	r0, [pc, #72]	; (4a00 <cliFunc_lcdCmd+0x94>)
    49b8:	f00a fdda 	bl	f570 <_print>
		printHex( cmd );
    49bc:	2101      	movs	r1, #1
    49be:	4630      	mov	r0, r6
    49c0:	f00a fefc 	bl	f7bc <printHex_op>
		print( NL );
    49c4:	480c      	ldr	r0, [pc, #48]	; (49f8 <cliFunc_lcdCmd+0x8c>)
    49c6:	f00a fdd3 	bl	f570 <_print>
		LCD_writeControlReg( cmd );
    49ca:	4628      	mov	r0, r5
    49cc:	f7ff ff26 	bl	481c <LCD_writeControlReg>
		return;
    49d0:	e7e4      	b.n	499c <cliFunc_lcdCmd+0x30>
		info_msg("Sending WITH A0 FLAG SET- ");
    49d2:	480c      	ldr	r0, [pc, #48]	; (4a04 <cliFunc_lcdCmd+0x98>)
    49d4:	f00a fdcc 	bl	f570 <_print>
		printHex( cmd );
    49d8:	2101      	movs	r1, #1
    49da:	4630      	mov	r0, r6
    49dc:	f00a feee 	bl	f7bc <printHex_op>
		print( NL );
    49e0:	4805      	ldr	r0, [pc, #20]	; (49f8 <cliFunc_lcdCmd+0x8c>)
    49e2:	f00a fdc5 	bl	f570 <_print>
		LCD_writeDataReg( cmd );
    49e6:	4628      	mov	r0, r5
    49e8:	f7ff ff94 	bl	4914 <LCD_writeDataReg>
		return;
    49ec:	e7d6      	b.n	499c <cliFunc_lcdCmd+0x30>
}
    49ee:	b004      	add	sp, #16
    49f0:	bd70      	pop	{r4, r5, r6, pc}
    49f2:	bf00      	nop
    49f4:	1fff89d0 	.word	0x1fff89d0
    49f8:	00015df4 	.word	0x00015df4
    49fc:	00010942 	.word	0x00010942
    4a00:	00010954 	.word	0x00010954
    4a04:	00010970 	.word	0x00010970

00004a08 <LCD_writeDisplayReg>:
{
    4a08:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4a0a:	4c10      	ldr	r4, [pc, #64]	; (4a4c <LCD_writeDisplayReg+0x44>)
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    4a0c:	f000 000f 	and.w	r0, r0, #15
{
    4a10:	6823      	ldr	r3, [r4, #0]
    4a12:	9301      	str	r3, [sp, #4]
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    4a14:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
{
    4a18:	4616      	mov	r6, r2
    4a1a:	460d      	mov	r5, r1
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    4a1c:	f7ff fefe 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x40 );
    4a20:	2040      	movs	r0, #64	; 0x40
    4a22:	f7ff fefb 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x10 );
    4a26:	2010      	movs	r0, #16
    4a28:	f7ff fef8 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    4a2c:	2000      	movs	r0, #0
    4a2e:	f7ff fef5 	bl	481c <LCD_writeControlReg>
	SPI_write( buffer, len );
    4a32:	9a01      	ldr	r2, [sp, #4]
    4a34:	6823      	ldr	r3, [r4, #0]
    4a36:	429a      	cmp	r2, r3
    4a38:	d001      	beq.n	4a3e <LCD_writeDisplayReg+0x36>
    4a3a:	f7fd fe79 	bl	2730 <__stack_chk_fail>
    4a3e:	4631      	mov	r1, r6
    4a40:	4628      	mov	r0, r5
}
    4a42:	b002      	add	sp, #8
    4a44:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	SPI_write( buffer, len );
    4a48:	f7ff beb8 	b.w	47bc <SPI_write>
    4a4c:	1fff89d0 	.word	0x1fff89d0

00004a50 <cliFunc_lcdTest>:
{
    4a50:	b513      	push	{r0, r1, r4, lr}
    4a52:	4c10      	ldr	r4, [pc, #64]	; (4a94 <cliFunc_lcdTest+0x44>)
		LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    4a54:	4910      	ldr	r1, [pc, #64]	; (4a98 <cliFunc_lcdTest+0x48>)
{
    4a56:	6823      	ldr	r3, [r4, #0]
    4a58:	9301      	str	r3, [sp, #4]
		LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    4a5a:	2280      	movs	r2, #128	; 0x80
    4a5c:	2000      	movs	r0, #0
    4a5e:	f7ff ffd3 	bl	4a08 <LCD_writeDisplayReg>
    4a62:	2280      	movs	r2, #128	; 0x80
    4a64:	490d      	ldr	r1, [pc, #52]	; (4a9c <cliFunc_lcdTest+0x4c>)
    4a66:	2001      	movs	r0, #1
    4a68:	f7ff ffce 	bl	4a08 <LCD_writeDisplayReg>
    4a6c:	2280      	movs	r2, #128	; 0x80
    4a6e:	490c      	ldr	r1, [pc, #48]	; (4aa0 <cliFunc_lcdTest+0x50>)
    4a70:	2002      	movs	r0, #2
    4a72:	f7ff ffc9 	bl	4a08 <LCD_writeDisplayReg>
    4a76:	9a01      	ldr	r2, [sp, #4]
    4a78:	6823      	ldr	r3, [r4, #0]
    4a7a:	429a      	cmp	r2, r3
    4a7c:	d001      	beq.n	4a82 <cliFunc_lcdTest+0x32>
    4a7e:	f7fd fe57 	bl	2730 <__stack_chk_fail>
    4a82:	4908      	ldr	r1, [pc, #32]	; (4aa4 <cliFunc_lcdTest+0x54>)
    4a84:	2280      	movs	r2, #128	; 0x80
    4a86:	2003      	movs	r0, #3
}
    4a88:	b002      	add	sp, #8
    4a8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    4a8e:	f7ff bfbb 	b.w	4a08 <LCD_writeDisplayReg>
    4a92:	bf00      	nop
    4a94:	1fff89d0 	.word	0x1fff89d0
    4a98:	00010742 	.word	0x00010742
    4a9c:	000107c2 	.word	0x000107c2
    4aa0:	00010842 	.word	0x00010842
    4aa4:	000108c2 	.word	0x000108c2

00004aa8 <LCD_layerStackExact_capability.part.0>:
void LCD_layerStackExact_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
    4aa8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    4aac:	4f47      	ldr	r7, [pc, #284]	; (4bcc <LCD_layerStackExact_capability.part.0+0x124>)
	const uint8_t numbers[10][128] = {
    4aae:	4948      	ldr	r1, [pc, #288]	; (4bd0 <LCD_layerStackExact_capability.part.0+0x128>)
void LCD_layerStackExact_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
    4ab0:	683b      	ldr	r3, [r7, #0]
    4ab2:	f5ad 6da9 	sub.w	sp, sp, #1352	; 0x548
	const uint8_t numbers[10][128] = {
    4ab6:	f44f 62a0 	mov.w	r2, #1280	; 0x500
void LCD_layerStackExact_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
    4aba:	4605      	mov	r5, r0
	const uint8_t numbers[10][128] = {
    4abc:	a811      	add	r0, sp, #68	; 0x44
void LCD_layerStackExact_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
    4abe:	f8cd 3544 	str.w	r3, [sp, #1348]	; 0x544
	const uint8_t numbers[10][128] = {
    4ac2:	f7fd fe59 	bl	2778 <memcpy>
	const uint16_t colors[10][3] = {
    4ac6:	4b43      	ldr	r3, [pc, #268]	; (4bd4 <LCD_layerStackExact_capability.part.0+0x12c>)
    4ac8:	ae02      	add	r6, sp, #8
    4aca:	4632      	mov	r2, r6
    4acc:	f103 0c38 	add.w	ip, r3, #56	; 0x38
    4ad0:	6818      	ldr	r0, [r3, #0]
    4ad2:	6859      	ldr	r1, [r3, #4]
    4ad4:	4614      	mov	r4, r2
    4ad6:	c403      	stmia	r4!, {r0, r1}
    4ad8:	3308      	adds	r3, #8
    4ada:	4563      	cmp	r3, ip
    4adc:	4622      	mov	r2, r4
    4ade:	d1f7      	bne.n	4ad0 <LCD_layerStackExact_capability.part.0+0x28>
    4ae0:	6818      	ldr	r0, [r3, #0]
    4ae2:	6020      	str	r0, [r4, #0]
	if ( stack_args->numArgs > 0 )
    4ae4:	7828      	ldrb	r0, [r5, #0]
    4ae6:	4c3c      	ldr	r4, [pc, #240]	; (4bd8 <LCD_layerStackExact_capability.part.0+0x130>)
    4ae8:	493c      	ldr	r1, [pc, #240]	; (4bdc <LCD_layerStackExact_capability.part.0+0x134>)
    4aea:	4a3d      	ldr	r2, [pc, #244]	; (4be0 <LCD_layerStackExact_capability.part.0+0x138>)
    4aec:	2800      	cmp	r0, #0
    4aee:	d04f      	beq.n	4b90 <LCD_layerStackExact_capability.part.0+0xe8>
		FTM0_C0V = colors[ layerIndex ][0];
    4af0:	8868      	ldrh	r0, [r5, #2]
    4af2:	2306      	movs	r3, #6
    4af4:	4343      	muls	r3, r0
    4af6:	18f0      	adds	r0, r6, r3
    4af8:	5af3      	ldrh	r3, [r6, r3]
    4afa:	6023      	str	r3, [r4, #0]
		FTM0_C1V = colors[ layerIndex ][1];
    4afc:	8843      	ldrh	r3, [r0, #2]
    4afe:	600b      	str	r3, [r1, #0]
		FTM0_C2V = colors[ layerIndex ][2];
    4b00:	2400      	movs	r4, #0
    4b02:	8883      	ldrh	r3, [r0, #4]
    4b04:	6013      	str	r3, [r2, #0]
			LCD_writeControlReg( 0x00 );
    4b06:	46a0      	mov	r8, r4
			LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    4b08:	f064 004f 	orn	r0, r4, #79	; 0x4f
    4b0c:	b2c0      	uxtb	r0, r0
    4b0e:	f7ff fe85 	bl	481c <LCD_writeControlReg>
			LCD_writeControlReg( 0x10 );
    4b12:	2010      	movs	r0, #16
    4b14:	f7ff fe82 	bl	481c <LCD_writeControlReg>
			LCD_writeControlReg( 0x00 );
    4b18:	2000      	movs	r0, #0
    4b1a:	f7ff fe7f 	bl	481c <LCD_writeControlReg>
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
    4b1e:	ea4f 1a44 	mov.w	sl, r4, lsl #5
    4b22:	f105 0902 	add.w	r9, r5, #2
    4b26:	2600      	movs	r6, #0
			for ( uint16_t layer = 0; layer < stack_args->numArgs; layer++ )
    4b28:	782a      	ldrb	r2, [r5, #0]
    4b2a:	b2b3      	uxth	r3, r6
    4b2c:	429a      	cmp	r2, r3
    4b2e:	d814      	bhi.n	4b5a <LCD_layerStackExact_capability.part.0+0xb2>
			uint8_t data = 0;
    4b30:	f88d 8007 	strb.w	r8, [sp, #7]
    4b34:	f04f 0900 	mov.w	r9, #0
			for ( uint8_t c = 0; c < 4 - stack_args->numArgs; c++ )
    4b38:	782b      	ldrb	r3, [r5, #0]
    4b3a:	fa5f f289 	uxtb.w	r2, r9
    4b3e:	f1c3 0304 	rsb	r3, r3, #4
    4b42:	429a      	cmp	r2, r3
    4b44:	db17      	blt.n	4b76 <LCD_layerStackExact_capability.part.0+0xce>
    4b46:	3401      	adds	r4, #1
		for ( uint8_t page = 0; page < LCD_TOTAL_VISIBLE_PAGES; page++ )
    4b48:	2c04      	cmp	r4, #4
    4b4a:	d1dd      	bne.n	4b08 <LCD_layerStackExact_capability.part.0+0x60>
}
    4b4c:	f8dd 2544 	ldr.w	r2, [sp, #1348]	; 0x544
    4b50:	683b      	ldr	r3, [r7, #0]
    4b52:	429a      	cmp	r2, r3
    4b54:	d035      	beq.n	4bc2 <LCD_layerStackExact_capability.part.0+0x11a>
    4b56:	f7fd fdeb 	bl	2730 <__stack_chk_fail>
				layerIndex = stack_args->layers[ layer ];
    4b5a:	f839 0b02 	ldrh.w	r0, [r9], #2
					layerIndex = 0;
    4b5e:	280a      	cmp	r0, #10
    4b60:	bf28      	it	cs
    4b62:	2000      	movcs	r0, #0
				SPI_write( (uint8_t*)&numbers[ layerIndex ][ page * 32 ], 32 );
    4b64:	ab11      	add	r3, sp, #68	; 0x44
    4b66:	eb0a 10c0 	add.w	r0, sl, r0, lsl #7
    4b6a:	2120      	movs	r1, #32
    4b6c:	4418      	add	r0, r3
    4b6e:	f7ff fe25 	bl	47bc <SPI_write>
    4b72:	3601      	adds	r6, #1
    4b74:	e7d8      	b.n	4b28 <LCD_layerStackExact_capability.part.0+0x80>
			for ( uint8_t c = 0; c < 4 - stack_args->numArgs; c++ )
    4b76:	2620      	movs	r6, #32
					SPI_write( &data, 1 );
    4b78:	2101      	movs	r1, #1
    4b7a:	f10d 0007 	add.w	r0, sp, #7
    4b7e:	3e01      	subs	r6, #1
    4b80:	f7ff fe1c 	bl	47bc <SPI_write>
				for ( uint8_t byte = 0; byte < 32; byte++ )
    4b84:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
    4b88:	d1f6      	bne.n	4b78 <LCD_layerStackExact_capability.part.0+0xd0>
    4b8a:	f109 0901 	add.w	r9, r9, #1
    4b8e:	e7d3      	b.n	4b38 <LCD_layerStackExact_capability.part.0+0x90>
		FTM0_C0V = STLcdBacklightRed_define;
    4b90:	f640 73ff 	movw	r3, #4095	; 0xfff
    4b94:	6023      	str	r3, [r4, #0]
		FTM0_C1V = STLcdBacklightGreen_define;
    4b96:	600b      	str	r3, [r1, #0]
		FTM0_C2V = STLcdBacklightBlue_define;
    4b98:	6013      	str	r3, [r2, #0]
			LCD_writeDisplayReg( page, (uint8_t *)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    4b9a:	4912      	ldr	r1, [pc, #72]	; (4be4 <LCD_layerStackExact_capability.part.0+0x13c>)
    4b9c:	2280      	movs	r2, #128	; 0x80
    4b9e:	f7ff ff33 	bl	4a08 <LCD_writeDisplayReg>
    4ba2:	2280      	movs	r2, #128	; 0x80
    4ba4:	4910      	ldr	r1, [pc, #64]	; (4be8 <LCD_layerStackExact_capability.part.0+0x140>)
    4ba6:	2001      	movs	r0, #1
    4ba8:	f7ff ff2e 	bl	4a08 <LCD_writeDisplayReg>
    4bac:	2280      	movs	r2, #128	; 0x80
    4bae:	490f      	ldr	r1, [pc, #60]	; (4bec <LCD_layerStackExact_capability.part.0+0x144>)
    4bb0:	2002      	movs	r0, #2
    4bb2:	f7ff ff29 	bl	4a08 <LCD_writeDisplayReg>
    4bb6:	2280      	movs	r2, #128	; 0x80
    4bb8:	490d      	ldr	r1, [pc, #52]	; (4bf0 <LCD_layerStackExact_capability.part.0+0x148>)
    4bba:	2003      	movs	r0, #3
    4bbc:	f7ff ff24 	bl	4a08 <LCD_writeDisplayReg>
    4bc0:	e7c4      	b.n	4b4c <LCD_layerStackExact_capability.part.0+0xa4>
}
    4bc2:	f50d 6da9 	add.w	sp, sp, #1352	; 0x548
    4bc6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4bca:	bf00      	nop
    4bcc:	1fff89d0 	.word	0x1fff89d0
    4bd0:	000101a4 	.word	0x000101a4
    4bd4:	000106a4 	.word	0x000106a4
    4bd8:	40038010 	.word	0x40038010
    4bdc:	40038018 	.word	0x40038018
    4be0:	40038020 	.word	0x40038020
    4be4:	00010742 	.word	0x00010742
    4be8:	000107c2 	.word	0x000107c2
    4bec:	00010842 	.word	0x00010842
    4bf0:	000108c2 	.word	0x000108c2

00004bf4 <LCD_clearPage>:
{
    4bf4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4bf6:	4c15      	ldr	r4, [pc, #84]	; (4c4c <LCD_clearPage+0x58>)
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    4bf8:	f000 000f 	and.w	r0, r0, #15
{
    4bfc:	6823      	ldr	r3, [r4, #0]
    4bfe:	9301      	str	r3, [sp, #4]
	LCD_writeControlReg( 0xB0 | ( 0x0F & page ) );
    4c00:	f040 00b0 	orr.w	r0, r0, #176	; 0xb0
    4c04:	f7ff fe0a 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x40 );
    4c08:	2040      	movs	r0, #64	; 0x40
    4c0a:	f7ff fe07 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x10 );
    4c0e:	2010      	movs	r0, #16
    4c10:	f7ff fe04 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    4c14:	2000      	movs	r0, #0
    4c16:	f7ff fe01 	bl	481c <LCD_writeControlReg>
	for ( uint8_t page_reg = 0; page_reg < LCD_PAGE_LEN; page_reg++ )
    4c1a:	2581      	movs	r5, #129	; 0x81
		uint8_t byte = 0;
    4c1c:	2600      	movs	r6, #0
	for ( uint8_t page_reg = 0; page_reg < LCD_PAGE_LEN; page_reg++ )
    4c1e:	3d01      	subs	r5, #1
    4c20:	d10a      	bne.n	4c38 <LCD_clearPage+0x44>
	while ( SPI0_TxFIFO_CNT != 0 );
    4c22:	4a0b      	ldr	r2, [pc, #44]	; (4c50 <LCD_clearPage+0x5c>)
    4c24:	6813      	ldr	r3, [r2, #0]
    4c26:	f413 4f70 	tst.w	r3, #61440	; 0xf000
    4c2a:	d1fb      	bne.n	4c24 <LCD_clearPage+0x30>
}
    4c2c:	9a01      	ldr	r2, [sp, #4]
    4c2e:	6823      	ldr	r3, [r4, #0]
    4c30:	429a      	cmp	r2, r3
    4c32:	d009      	beq.n	4c48 <LCD_clearPage+0x54>
    4c34:	f7fd fd7c 	bl	2730 <__stack_chk_fail>
		SPI_write( &byte, 1 );
    4c38:	2101      	movs	r1, #1
    4c3a:	f10d 0003 	add.w	r0, sp, #3
		uint8_t byte = 0;
    4c3e:	f88d 6003 	strb.w	r6, [sp, #3]
		SPI_write( &byte, 1 );
    4c42:	f7ff fdbb 	bl	47bc <SPI_write>
    4c46:	e7ea      	b.n	4c1e <LCD_clearPage+0x2a>
}
    4c48:	b002      	add	sp, #8
    4c4a:	bd70      	pop	{r4, r5, r6, pc}
    4c4c:	1fff89d0 	.word	0x1fff89d0
    4c50:	4002c02c 	.word	0x4002c02c

00004c54 <LCD_clear>:
{
    4c54:	b537      	push	{r0, r1, r2, r4, r5, lr}
    4c56:	4c0f      	ldr	r4, [pc, #60]	; (4c94 <LCD_clear+0x40>)
    4c58:	6822      	ldr	r2, [r4, #0]
    4c5a:	9201      	str	r2, [sp, #4]
    4c5c:	2500      	movs	r5, #0
		LCD_clearPage( page );
    4c5e:	b2e8      	uxtb	r0, r5
    4c60:	3501      	adds	r5, #1
    4c62:	f7ff ffc7 	bl	4bf4 <LCD_clearPage>
	for ( uint8_t page = 0; page < LCD_TOTAL_PAGES; page++ )
    4c66:	2d09      	cmp	r5, #9
    4c68:	d1f9      	bne.n	4c5e <LCD_clear+0xa>
	LCD_writeControlReg( 0xB0 );
    4c6a:	20b0      	movs	r0, #176	; 0xb0
    4c6c:	f7ff fdd6 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x40 );
    4c70:	2040      	movs	r0, #64	; 0x40
    4c72:	f7ff fdd3 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x10 );
    4c76:	2010      	movs	r0, #16
    4c78:	f7ff fdd0 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    4c7c:	9a01      	ldr	r2, [sp, #4]
    4c7e:	6823      	ldr	r3, [r4, #0]
    4c80:	429a      	cmp	r2, r3
    4c82:	d001      	beq.n	4c88 <LCD_clear+0x34>
    4c84:	f7fd fd54 	bl	2730 <__stack_chk_fail>
    4c88:	2000      	movs	r0, #0
}
    4c8a:	b003      	add	sp, #12
    4c8c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LCD_writeControlReg( 0x00 );
    4c90:	f7ff bdc4 	b.w	481c <LCD_writeControlReg>
    4c94:	1fff89d0 	.word	0x1fff89d0

00004c98 <LCD_initialize>:
{
    4c98:	b513      	push	{r0, r1, r4, lr}
    4c9a:	4c16      	ldr	r4, [pc, #88]	; (4cf4 <LCD_initialize+0x5c>)
	LCD_writeControlReg( 0xA0 );
    4c9c:	20a0      	movs	r0, #160	; 0xa0
{
    4c9e:	6823      	ldr	r3, [r4, #0]
    4ca0:	9301      	str	r3, [sp, #4]
	LCD_writeControlReg( 0xA0 );
    4ca2:	f7ff fdbb 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0xAE );
    4ca6:	20ae      	movs	r0, #174	; 0xae
    4ca8:	f7ff fdb8 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0xC0 );
    4cac:	20c0      	movs	r0, #192	; 0xc0
    4cae:	f7ff fdb5 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0xA2 );
    4cb2:	20a2      	movs	r0, #162	; 0xa2
    4cb4:	f7ff fdb2 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x2F );
    4cb8:	202f      	movs	r0, #47	; 0x2f
    4cba:	f7ff fdaf 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x26 );
    4cbe:	2026      	movs	r0, #38	; 0x26
    4cc0:	f7ff fdac 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0xE2 );
    4cc4:	20e2      	movs	r0, #226	; 0xe2
    4cc6:	f7ff fda9 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x81 );
    4cca:	2081      	movs	r0, #129	; 0x81
    4ccc:	f7ff fda6 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0x00 );
    4cd0:	2000      	movs	r0, #0
    4cd2:	f7ff fda3 	bl	481c <LCD_writeControlReg>
	LCD_writeControlReg( 0xAF );
    4cd6:	20af      	movs	r0, #175	; 0xaf
    4cd8:	f7ff fda0 	bl	481c <LCD_writeControlReg>
	LCD_clear();
    4cdc:	9a01      	ldr	r2, [sp, #4]
    4cde:	6823      	ldr	r3, [r4, #0]
    4ce0:	429a      	cmp	r2, r3
    4ce2:	d001      	beq.n	4ce8 <LCD_initialize+0x50>
    4ce4:	f7fd fd24 	bl	2730 <__stack_chk_fail>
}
    4ce8:	b002      	add	sp, #8
    4cea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LCD_clear();
    4cee:	f7ff bfb1 	b.w	4c54 <LCD_clear>
    4cf2:	bf00      	nop
    4cf4:	1fff89d0 	.word	0x1fff89d0

00004cf8 <cliFunc_lcdInit>:
{
    4cf8:	b507      	push	{r0, r1, r2, lr}
    4cfa:	4b07      	ldr	r3, [pc, #28]	; (4d18 <cliFunc_lcdInit+0x20>)
    4cfc:	681a      	ldr	r2, [r3, #0]
    4cfe:	9201      	str	r2, [sp, #4]
	LCD_initialize();
    4d00:	9a01      	ldr	r2, [sp, #4]
    4d02:	681b      	ldr	r3, [r3, #0]
    4d04:	429a      	cmp	r2, r3
    4d06:	d001      	beq.n	4d0c <cliFunc_lcdInit+0x14>
    4d08:	f7fd fd12 	bl	2730 <__stack_chk_fail>
}
    4d0c:	b003      	add	sp, #12
    4d0e:	f85d eb04 	ldr.w	lr, [sp], #4
	LCD_initialize();
    4d12:	f7ff bfc1 	b.w	4c98 <LCD_initialize>
    4d16:	bf00      	nop
    4d18:	1fff89d0 	.word	0x1fff89d0

00004d1c <LCD_setup>:
{
    4d1c:	b513      	push	{r0, r1, r4, lr}
    4d1e:	4c39      	ldr	r4, [pc, #228]	; (4e04 <LCD_setup+0xe8>)
	CLI_registerDictionary( lcdCLIDict, lcdCLIDictName );
    4d20:	4939      	ldr	r1, [pc, #228]	; (4e08 <LCD_setup+0xec>)
{
    4d22:	6823      	ldr	r3, [r4, #0]
	CLI_registerDictionary( lcdCLIDict, lcdCLIDictName );
    4d24:	4839      	ldr	r0, [pc, #228]	; (4e0c <LCD_setup+0xf0>)
{
    4d26:	9301      	str	r3, [sp, #4]
	CLI_registerDictionary( lcdCLIDict, lcdCLIDictName );
    4d28:	f009 ffb2 	bl	ec90 <CLI_registerDictionary>
	SPI_setup();
    4d2c:	f7ff fd1a 	bl	4764 <SPI_setup>
	GPIOC_PDDR |= (1<<7);
    4d30:	4a37      	ldr	r2, [pc, #220]	; (4e10 <LCD_setup+0xf4>)
    4d32:	6813      	ldr	r3, [r2, #0]
    4d34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    4d38:	6013      	str	r3, [r2, #0]
	PORTC_PCR7 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4d3a:	4b36      	ldr	r3, [pc, #216]	; (4e14 <LCD_setup+0xf8>)
    4d3c:	f44f 70a2 	mov.w	r0, #324	; 0x144
    4d40:	6018      	str	r0, [r3, #0]
	GPIOC_PSOR |= (1<<7);
    4d42:	f503 2334 	add.w	r3, r3, #737280	; 0xb4000
    4d46:	3368      	adds	r3, #104	; 0x68
    4d48:	6819      	ldr	r1, [r3, #0]
    4d4a:	f041 0180 	orr.w	r1, r1, #128	; 0x80
    4d4e:	6019      	str	r1, [r3, #0]
	GPIOC_PDDR |= (1<<8);
    4d50:	6811      	ldr	r1, [r2, #0]
    4d52:	f441 7180 	orr.w	r1, r1, #256	; 0x100
    4d56:	6011      	str	r1, [r2, #0]
	PORTC_PCR8 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    4d58:	f5a2 2234 	sub.w	r2, r2, #737280	; 0xb4000
    4d5c:	3a74      	subs	r2, #116	; 0x74
    4d5e:	6010      	str	r0, [r2, #0]
	GPIOC_PSOR |= (1<<8);
    4d60:	681a      	ldr	r2, [r3, #0]
    4d62:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    4d66:	601a      	str	r2, [r3, #0]
	LCD_initialize();
    4d68:	f7ff ff96 	bl	4c98 <LCD_initialize>
		LCD_writeDisplayReg( page, (uint8_t*)&STLcdDefaultImage[page * LCD_PAGE_LEN], LCD_PAGE_LEN );
    4d6c:	2280      	movs	r2, #128	; 0x80
    4d6e:	492a      	ldr	r1, [pc, #168]	; (4e18 <LCD_setup+0xfc>)
    4d70:	2000      	movs	r0, #0
    4d72:	f7ff fe49 	bl	4a08 <LCD_writeDisplayReg>
    4d76:	2280      	movs	r2, #128	; 0x80
    4d78:	4928      	ldr	r1, [pc, #160]	; (4e1c <LCD_setup+0x100>)
    4d7a:	2001      	movs	r0, #1
    4d7c:	f7ff fe44 	bl	4a08 <LCD_writeDisplayReg>
    4d80:	2280      	movs	r2, #128	; 0x80
    4d82:	4927      	ldr	r1, [pc, #156]	; (4e20 <LCD_setup+0x104>)
    4d84:	2002      	movs	r0, #2
    4d86:	f7ff fe3f 	bl	4a08 <LCD_writeDisplayReg>
    4d8a:	2280      	movs	r2, #128	; 0x80
    4d8c:	4925      	ldr	r1, [pc, #148]	; (4e24 <LCD_setup+0x108>)
    4d8e:	2003      	movs	r0, #3
    4d90:	f7ff fe3a 	bl	4a08 <LCD_writeDisplayReg>
	SIM_SCGC6 |= SIM_SCGC6_FTM0;
    4d94:	4a24      	ldr	r2, [pc, #144]	; (4e28 <LCD_setup+0x10c>)
	PORTC_PCR1 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    4d96:	4825      	ldr	r0, [pc, #148]	; (4e2c <LCD_setup+0x110>)
	SIM_SCGC6 |= SIM_SCGC6_FTM0;
    4d98:	6813      	ldr	r3, [r2, #0]
    4d9a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    4d9e:	6013      	str	r3, [r2, #0]
	FTM0_CNT = 0; // Reset counter
    4da0:	4b23      	ldr	r3, [pc, #140]	; (4e30 <LCD_setup+0x114>)
    4da2:	2100      	movs	r1, #0
	FTM0_MOD = 0xFFFF;
    4da4:	f64f 72ff 	movw	r2, #65535	; 0xffff
	FTM0_CNT = 0; // Reset counter
    4da8:	6019      	str	r1, [r3, #0]
	FTM0_MOD = 0xFFFF;
    4daa:	605a      	str	r2, [r3, #4]
	FTM0_C0SC = 0x24; // MSnB:MSnA = 10, ELSnB:ELSnA = 01
    4dac:	4a21      	ldr	r2, [pc, #132]	; (4e34 <LCD_setup+0x118>)
    4dae:	2324      	movs	r3, #36	; 0x24
    4db0:	6013      	str	r3, [r2, #0]
	FTM0_C1SC = 0x24;
    4db2:	6093      	str	r3, [r2, #8]
	FTM0_C2SC = 0x24;
    4db4:	6113      	str	r3, [r2, #16]
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS( STLcdBacklightPrescalar_define );
    4db6:	4b20      	ldr	r3, [pc, #128]	; (4e38 <LCD_setup+0x11c>)
    4db8:	2208      	movs	r2, #8
    4dba:	601a      	str	r2, [r3, #0]
	FTM0_C0V = STLcdBacklightRed_define;
    4dbc:	f640 72ff 	movw	r2, #4095	; 0xfff
    4dc0:	611a      	str	r2, [r3, #16]
	PORTC_PCR1 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    4dc2:	f240 4344 	movw	r3, #1092	; 0x444
    4dc6:	6003      	str	r3, [r0, #0]
	FTM0_C1V = STLcdBacklightGreen_define;
    4dc8:	f5a0 3097 	sub.w	r0, r0, #77312	; 0x12e00
    4dcc:	f5a0 70f6 	sub.w	r0, r0, #492	; 0x1ec
    4dd0:	6002      	str	r2, [r0, #0]
	PORTC_PCR2 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    4dd2:	f500 3097 	add.w	r0, r0, #77312	; 0x12e00
    4dd6:	f500 70f8 	add.w	r0, r0, #496	; 0x1f0
    4dda:	6003      	str	r3, [r0, #0]
	FTM0_C2V = STLcdBacklightBlue_define;
    4ddc:	f5a0 3097 	sub.w	r0, r0, #77312	; 0x12e00
    4de0:	f5a0 70f4 	sub.w	r0, r0, #488	; 0x1e8
    4de4:	6002      	str	r2, [r0, #0]
	PORTC_PCR3 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    4de6:	4a15      	ldr	r2, [pc, #84]	; (4e3c <LCD_setup+0x120>)
	stlcdLatencyResource = Latency_add_resource("STLcd", LatencyOption_Ticks);
    4de8:	4815      	ldr	r0, [pc, #84]	; (4e40 <LCD_setup+0x124>)
	PORTC_PCR3 = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(4);
    4dea:	6013      	str	r3, [r2, #0]
	stlcdLatencyResource = Latency_add_resource("STLcd", LatencyOption_Ticks);
    4dec:	f00a fa76 	bl	f2dc <Latency_add_resource>
    4df0:	4b14      	ldr	r3, [pc, #80]	; (4e44 <LCD_setup+0x128>)
}
    4df2:	9a01      	ldr	r2, [sp, #4]
	stlcdLatencyResource = Latency_add_resource("STLcd", LatencyOption_Ticks);
    4df4:	7018      	strb	r0, [r3, #0]
}
    4df6:	6823      	ldr	r3, [r4, #0]
    4df8:	429a      	cmp	r2, r3
    4dfa:	d001      	beq.n	4e00 <LCD_setup+0xe4>
    4dfc:	f7fd fc98 	bl	2730 <__stack_chk_fail>
    4e00:	b002      	add	sp, #8
    4e02:	bd10      	pop	{r4, pc}
    4e04:	1fff89d0 	.word	0x1fff89d0
    4e08:	000109e8 	.word	0x000109e8
    4e0c:	000109a0 	.word	0x000109a0
    4e10:	400ff094 	.word	0x400ff094
    4e14:	4004b01c 	.word	0x4004b01c
    4e18:	00010742 	.word	0x00010742
    4e1c:	000107c2 	.word	0x000107c2
    4e20:	00010842 	.word	0x00010842
    4e24:	000108c2 	.word	0x000108c2
    4e28:	4004803c 	.word	0x4004803c
    4e2c:	4004b004 	.word	0x4004b004
    4e30:	40038004 	.word	0x40038004
    4e34:	4003800c 	.word	0x4003800c
    4e38:	40038000 	.word	0x40038000
    4e3c:	4004b00c 	.word	0x4004b00c
    4e40:	0001073c 	.word	0x0001073c
    4e44:	1fff94ac 	.word	0x1fff94ac

00004e48 <LCD_scan>:
{
    4e48:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4e4a:	4d1f      	ldr	r5, [pc, #124]	; (4ec8 <LCD_scan+0x80>)
	Latency_start_time( stlcdLatencyResource );
    4e4c:	4c1f      	ldr	r4, [pc, #124]	; (4ecc <LCD_scan+0x84>)
{
    4e4e:	682b      	ldr	r3, [r5, #0]
	Latency_start_time( stlcdLatencyResource );
    4e50:	7820      	ldrb	r0, [r4, #0]
{
    4e52:	9301      	str	r3, [sp, #4]
	Latency_start_time( stlcdLatencyResource );
    4e54:	f00a faba 	bl	f3cc <Latency_start_time>
	uint16_t is_capslock = USBKeys_LEDs & 2;
    4e58:	4b1d      	ldr	r3, [pc, #116]	; (4ed0 <LCD_scan+0x88>)
    4e5a:	781b      	ldrb	r3, [r3, #0]
	if ( is_capslock && !was_capslock )
    4e5c:	f013 0202 	ands.w	r2, r3, #2
    4e60:	4b1c      	ldr	r3, [pc, #112]	; (4ed4 <LCD_scan+0x8c>)
    4e62:	d017      	beq.n	4e94 <LCD_scan+0x4c>
    4e64:	781e      	ldrb	r6, [r3, #0]
    4e66:	481c      	ldr	r0, [pc, #112]	; (4ed8 <LCD_scan+0x90>)
    4e68:	491c      	ldr	r1, [pc, #112]	; (4edc <LCD_scan+0x94>)
    4e6a:	4a1d      	ldr	r2, [pc, #116]	; (4ee0 <LCD_scan+0x98>)
    4e6c:	b946      	cbnz	r6, 4e80 <LCD_scan+0x38>
		was_capslock = 1;
    4e6e:	2601      	movs	r6, #1
    4e70:	701e      	strb	r6, [r3, #0]
		hold_color[0] = FTM0_C0V;
    4e72:	4b1c      	ldr	r3, [pc, #112]	; (4ee4 <LCD_scan+0x9c>)
    4e74:	6806      	ldr	r6, [r0, #0]
    4e76:	801e      	strh	r6, [r3, #0]
		hold_color[1] = FTM0_C1V;
    4e78:	680e      	ldr	r6, [r1, #0]
    4e7a:	805e      	strh	r6, [r3, #2]
		hold_color[2] = FTM0_C2V;
    4e7c:	6816      	ldr	r6, [r2, #0]
    4e7e:	809e      	strh	r6, [r3, #4]
		FTM0_C0V = 0x8303;
    4e80:	f248 3303 	movw	r3, #33539	; 0x8303
    4e84:	6003      	str	r3, [r0, #0]
		FTM0_C1V = 0x1394;
    4e86:	f241 3394 	movw	r3, #5012	; 0x1394
    4e8a:	600b      	str	r3, [r1, #0]
		FTM0_C2V = 0xb9f9;
    4e8c:	f64b 13f9 	movw	r3, #47609	; 0xb9f9
    4e90:	6013      	str	r3, [r2, #0]
    4e92:	e00b      	b.n	4eac <LCD_scan+0x64>
	else if ( !is_capslock && was_capslock )
    4e94:	7819      	ldrb	r1, [r3, #0]
    4e96:	b149      	cbz	r1, 4eac <LCD_scan+0x64>
		was_capslock = 0;
    4e98:	701a      	strb	r2, [r3, #0]
		FTM0_C0V = hold_color[0];
    4e9a:	4b12      	ldr	r3, [pc, #72]	; (4ee4 <LCD_scan+0x9c>)
    4e9c:	4a0e      	ldr	r2, [pc, #56]	; (4ed8 <LCD_scan+0x90>)
    4e9e:	8819      	ldrh	r1, [r3, #0]
    4ea0:	6011      	str	r1, [r2, #0]
		FTM0_C1V = hold_color[1];
    4ea2:	8859      	ldrh	r1, [r3, #2]
    4ea4:	6091      	str	r1, [r2, #8]
		FTM0_C2V = hold_color[2];
    4ea6:	889a      	ldrh	r2, [r3, #4]
    4ea8:	4b0d      	ldr	r3, [pc, #52]	; (4ee0 <LCD_scan+0x98>)
    4eaa:	601a      	str	r2, [r3, #0]
	Latency_end_time( stlcdLatencyResource );
    4eac:	7820      	ldrb	r0, [r4, #0]
    4eae:	f00a faab 	bl	f408 <Latency_end_time>
}
    4eb2:	9a01      	ldr	r2, [sp, #4]
    4eb4:	682b      	ldr	r3, [r5, #0]
    4eb6:	429a      	cmp	r2, r3
    4eb8:	f04f 0000 	mov.w	r0, #0
    4ebc:	d001      	beq.n	4ec2 <LCD_scan+0x7a>
    4ebe:	f7fd fc37 	bl	2730 <__stack_chk_fail>
    4ec2:	b002      	add	sp, #8
    4ec4:	bd70      	pop	{r4, r5, r6, pc}
    4ec6:	bf00      	nop
    4ec8:	1fff89d0 	.word	0x1fff89d0
    4ecc:	1fff94ac 	.word	0x1fff94ac
    4ed0:	1fffb32b 	.word	0x1fffb32b
    4ed4:	1fff94ad 	.word	0x1fff94ad
    4ed8:	40038010 	.word	0x40038010
    4edc:	40038018 	.word	0x40038018
    4ee0:	40038020 	.word	0x40038020
    4ee4:	1fff94a6 	.word	0x1fff94a6

00004ee8 <LCD_currentChange>:
{
    4ee8:	b507      	push	{r0, r1, r2, lr}
    4eea:	4b0a      	ldr	r3, [pc, #40]	; (4f14 <LCD_currentChange+0x2c>)
    4eec:	681a      	ldr	r2, [r3, #0]
    4eee:	9201      	str	r2, [sp, #4]
    4ef0:	4a09      	ldr	r2, [pc, #36]	; (4f18 <LCD_currentChange+0x30>)
		SIM_SCGC6 &= ~(SIM_SCGC6_FTM0);
    4ef2:	6811      	ldr	r1, [r2, #0]
	if ( current < 150 )
    4ef4:	2895      	cmp	r0, #149	; 0x95
		SIM_SCGC6 &= ~(SIM_SCGC6_FTM0);
    4ef6:	bf94      	ite	ls
    4ef8:	f021 7180 	bicls.w	r1, r1, #16777216	; 0x1000000
		SIM_SCGC6 |= SIM_SCGC6_FTM0;
    4efc:	f041 7180 	orrhi.w	r1, r1, #16777216	; 0x1000000
    4f00:	6011      	str	r1, [r2, #0]
}
    4f02:	9a01      	ldr	r2, [sp, #4]
    4f04:	681b      	ldr	r3, [r3, #0]
    4f06:	429a      	cmp	r2, r3
    4f08:	d001      	beq.n	4f0e <LCD_currentChange+0x26>
    4f0a:	f7fd fc11 	bl	2730 <__stack_chk_fail>
    4f0e:	b003      	add	sp, #12
    4f10:	f85d fb04 	ldr.w	pc, [sp], #4
    4f14:	1fff89d0 	.word	0x1fff89d0
    4f18:	4004803c 	.word	0x4004803c

00004f1c <LCD_layerStackExact_capability>:
{
    4f1c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    4f1e:	4c15      	ldr	r4, [pc, #84]	; (4f74 <LCD_layerStackExact_capability+0x58>)
    4f20:	4608      	mov	r0, r1
    4f22:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    4f24:	4611      	mov	r1, r2
{
    4f26:	6823      	ldr	r3, [r4, #0]
    4f28:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    4f2a:	f001 fc09 	bl	6740 <KLL_CapabilityState>
    4f2e:	4621      	mov	r1, r4
	switch ( cstate )
    4f30:	b1c8      	cbz	r0, 4f66 <LCD_layerStackExact_capability+0x4a>
    4f32:	2803      	cmp	r0, #3
    4f34:	d90d      	bls.n	4f52 <LCD_layerStackExact_capability+0x36>
    4f36:	28ff      	cmp	r0, #255	; 0xff
    4f38:	d115      	bne.n	4f66 <LCD_layerStackExact_capability+0x4a>
		print("LCD_layerStackExact_capability(num,layer1,layer2,layer3,layer4)");
    4f3a:	9a01      	ldr	r2, [sp, #4]
    4f3c:	6823      	ldr	r3, [r4, #0]
    4f3e:	429a      	cmp	r2, r3
    4f40:	d001      	beq.n	4f46 <LCD_layerStackExact_capability+0x2a>
}
    4f42:	f7fd fbf5 	bl	2730 <__stack_chk_fail>
		print("LCD_layerStackExact_capability(num,layer1,layer2,layer3,layer4)");
    4f46:	480c      	ldr	r0, [pc, #48]	; (4f78 <LCD_layerStackExact_capability+0x5c>)
}
    4f48:	b003      	add	sp, #12
    4f4a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		print("LCD_layerStackExact_capability(num,layer1,layer2,layer3,layer4)");
    4f4e:	f00a bb0f 	b.w	f570 <_print>
    4f52:	9a01      	ldr	r2, [sp, #4]
    4f54:	6823      	ldr	r3, [r4, #0]
    4f56:	429a      	cmp	r2, r3
    4f58:	d1f3      	bne.n	4f42 <LCD_layerStackExact_capability+0x26>
    4f5a:	4628      	mov	r0, r5
}
    4f5c:	b003      	add	sp, #12
    4f5e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    4f62:	f7ff bda1 	b.w	4aa8 <LCD_layerStackExact_capability.part.0>
    4f66:	9a01      	ldr	r2, [sp, #4]
    4f68:	680b      	ldr	r3, [r1, #0]
    4f6a:	429a      	cmp	r2, r3
    4f6c:	d1e9      	bne.n	4f42 <LCD_layerStackExact_capability+0x26>
    4f6e:	b003      	add	sp, #12
    4f70:	bd30      	pop	{r4, r5, pc}
    4f72:	bf00      	nop
    4f74:	1fff89d0 	.word	0x1fff89d0
    4f78:	000106e0 	.word	0x000106e0

00004f7c <LCD_layerStack_capability>:
{
    4f7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4f80:	4c2c      	ldr	r4, [pc, #176]	; (5034 <LCD_layerStack_capability+0xb8>)
    4f82:	b087      	sub	sp, #28
    4f84:	460f      	mov	r7, r1
    4f86:	4681      	mov	r9, r0
    4f88:	6823      	ldr	r3, [r4, #0]
    4f8a:	9305      	str	r3, [sp, #20]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    4f8c:	4611      	mov	r1, r2
    4f8e:	4638      	mov	r0, r7
{
    4f90:	4690      	mov	r8, r2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    4f92:	f001 fbd5 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    4f96:	b130      	cbz	r0, 4fa6 <LCD_layerStack_capability+0x2a>
    4f98:	2803      	cmp	r0, #3
    4f9a:	d90a      	bls.n	4fb2 <LCD_layerStack_capability+0x36>
    4f9c:	28ff      	cmp	r0, #255	; 0xff
    4f9e:	d102      	bne.n	4fa6 <LCD_layerStack_capability+0x2a>
		print("LCD_layerStack_capability()");
    4fa0:	4825      	ldr	r0, [pc, #148]	; (5038 <LCD_layerStack_capability+0xbc>)
    4fa2:	f00a fae5 	bl	f570 <_print>
}
    4fa6:	9a05      	ldr	r2, [sp, #20]
    4fa8:	6823      	ldr	r3, [r4, #0]
    4faa:	429a      	cmp	r2, r3
    4fac:	d03e      	beq.n	502c <LCD_layerStack_capability+0xb0>
    4fae:	f7fd fbbf 	bl	2730 <__stack_chk_fail>
	if ( macroLayerIndexStackSize == LCD_layerStack_prevSize
    4fb2:	4e22      	ldr	r6, [pc, #136]	; (503c <LCD_layerStack_capability+0xc0>)
    4fb4:	4d22      	ldr	r5, [pc, #136]	; (5040 <LCD_layerStack_capability+0xc4>)
    4fb6:	8832      	ldrh	r2, [r6, #0]
    4fb8:	1e53      	subs	r3, r2, #1
    4fba:	f835 0013 	ldrh.w	r0, [r5, r3, lsl #1]
    4fbe:	4b21      	ldr	r3, [pc, #132]	; (5044 <LCD_layerStack_capability+0xc8>)
    4fc0:	8819      	ldrh	r1, [r3, #0]
    4fc2:	4291      	cmp	r1, r2
    4fc4:	4920      	ldr	r1, [pc, #128]	; (5048 <LCD_layerStack_capability+0xcc>)
    4fc6:	d103      	bne.n	4fd0 <LCD_layerStack_capability+0x54>
		&& macroLayerIndexStack[macroLayerIndexStackSize - 1] == LCD_layerStack_prevTop )
    4fc8:	f8b1 c000 	ldrh.w	ip, [r1]
    4fcc:	4584      	cmp	ip, r0
    4fce:	d0ea      	beq.n	4fa6 <LCD_layerStack_capability+0x2a>
	LCD_layerStack_prevSize = macroLayerIndexStackSize;
    4fd0:	801a      	strh	r2, [r3, #0]
	LCD_layerStack_prevTop  = macroLayerIndexStack[macroLayerIndexStackSize - 1];
    4fd2:	8008      	strh	r0, [r1, #0]
	memset( stack_args.layers, 0, sizeof( stack_args.layers ) );
    4fd4:	2208      	movs	r2, #8
    4fd6:	2100      	movs	r1, #0
    4fd8:	f10d 000a 	add.w	r0, sp, #10
    4fdc:	f7fd fbb6 	bl	274c <memset>
	stack_args.numArgs = macroLayerIndexStackSize;
    4fe0:	8832      	ldrh	r2, [r6, #0]
    4fe2:	f88d 2008 	strb.w	r2, [sp, #8]
	for ( uint16_t layer = 1; layer <= macroLayerIndexStackSize; layer++ )
    4fe6:	2301      	movs	r3, #1
    4fe8:	429a      	cmp	r2, r3
    4fea:	d214      	bcs.n	5016 <LCD_layerStack_capability+0x9a>
	if ( Connect_master )
    4fec:	4b17      	ldr	r3, [pc, #92]	; (504c <LCD_layerStack_capability+0xd0>)
    4fee:	781b      	ldrb	r3, [r3, #0]
    4ff0:	ad02      	add	r5, sp, #8
    4ff2:	b14b      	cbz	r3, 5008 <LCD_layerStack_capability+0x8c>
		Connect_send_RemoteCapability(
    4ff4:	4b16      	ldr	r3, [pc, #88]	; (5050 <LCD_layerStack_capability+0xd4>)
    4ff6:	9501      	str	r5, [sp, #4]
    4ff8:	791b      	ldrb	r3, [r3, #4]
    4ffa:	9300      	str	r3, [sp, #0]
    4ffc:	463a      	mov	r2, r7
    4ffe:	4643      	mov	r3, r8
    5000:	2100      	movs	r1, #0
    5002:	20ff      	movs	r0, #255	; 0xff
    5004:	f000 fdfc 	bl	5c00 <Connect_send_RemoteCapability>
	LCD_layerStackExact_capability( trigger, state, stateType, (uint8_t*)&stack_args );
    5008:	462b      	mov	r3, r5
    500a:	4642      	mov	r2, r8
    500c:	4639      	mov	r1, r7
    500e:	4648      	mov	r0, r9
    5010:	f7ff ff84 	bl	4f1c <LCD_layerStackExact_capability>
    5014:	e7c7      	b.n	4fa6 <LCD_layerStack_capability+0x2a>
		stack_args.layers[ layer - 1 ] = macroLayerIndexStack[ macroLayerIndexStackSize - layer ];
    5016:	1ad0      	subs	r0, r2, r3
    5018:	a906      	add	r1, sp, #24
    501a:	eb01 0143 	add.w	r1, r1, r3, lsl #1
    501e:	f835 0010 	ldrh.w	r0, [r5, r0, lsl #1]
    5022:	f821 0c10 	strh.w	r0, [r1, #-16]
	for ( uint16_t layer = 1; layer <= macroLayerIndexStackSize; layer++ )
    5026:	3301      	adds	r3, #1
    5028:	b29b      	uxth	r3, r3
    502a:	e7dd      	b.n	4fe8 <LCD_layerStack_capability+0x6c>
}
    502c:	b007      	add	sp, #28
    502e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5032:	bf00      	nop
    5034:	1fff89d0 	.word	0x1fff89d0
    5038:	00010720 	.word	0x00010720
    503c:	1fff94e0 	.word	0x1fff94e0
    5040:	1fff94da 	.word	0x1fff94da
    5044:	1fff94a2 	.word	0x1fff94a2
    5048:	1fff94a4 	.word	0x1fff94a4
    504c:	1fff94cc 	.word	0x1fff94cc
    5050:	00011460 	.word	0x00011460

00005054 <Connect_receive_RemoteOutput>:
	return *pending_bytes == 0 ? 1 : 0;
}


uint8_t Connect_receive_RemoteOutput( uint8_t byte, uint16_t *pending_bytes, uint8_t uart_num )
{
    5054:	b507      	push	{r0, r1, r2, lr}
    5056:	4b08      	ldr	r3, [pc, #32]	; (5078 <Connect_receive_RemoteOutput+0x24>)
    5058:	681a      	ldr	r2, [r3, #0]
    505a:	9201      	str	r2, [sp, #4]
	// TODO
	(*pending_bytes)--;
	*pending_bytes = 0;
    505c:	2200      	movs	r2, #0
    505e:	800a      	strh	r2, [r1, #0]

	// Check whether the scan codes have finished sending
	return *pending_bytes == 0 ? 1 : 0;
}
    5060:	9a01      	ldr	r2, [sp, #4]
    5062:	681b      	ldr	r3, [r3, #0]
    5064:	429a      	cmp	r2, r3
    5066:	f04f 0001 	mov.w	r0, #1
    506a:	d001      	beq.n	5070 <Connect_receive_RemoteOutput+0x1c>
    506c:	f7fd fb60 	bl	2730 <__stack_chk_fail>
    5070:	b003      	add	sp, #12
    5072:	f85d fb04 	ldr.w	pc, [sp], #4
    5076:	bf00      	nop
    5078:	1fff89d0 	.word	0x1fff89d0

0000507c <Connect_receive_Animation>:
{
    507c:	b513      	push	{r0, r1, r4, lr}
    507e:	4c08      	ldr	r4, [pc, #32]	; (50a0 <Connect_receive_Animation+0x24>)
	dbug_print("Animation");
    5080:	4808      	ldr	r0, [pc, #32]	; (50a4 <Connect_receive_Animation+0x28>)
{
    5082:	6823      	ldr	r3, [r4, #0]
    5084:	9301      	str	r3, [sp, #4]
	dbug_print("Animation");
    5086:	f00a fa73 	bl	f570 <_print>
}
    508a:	9a01      	ldr	r2, [sp, #4]
    508c:	6823      	ldr	r3, [r4, #0]
    508e:	429a      	cmp	r2, r3
    5090:	f04f 0001 	mov.w	r0, #1
    5094:	d001      	beq.n	509a <Connect_receive_Animation+0x1e>
    5096:	f7fd fb4b 	bl	2730 <__stack_chk_fail>
    509a:	b002      	add	sp, #8
    509c:	bd10      	pop	{r4, pc}
    509e:	bf00      	nop
    50a0:	1fff89d0 	.word	0x1fff89d0
    50a4:	00010c28 	.word	0x00010c28

000050a8 <cliFunc_connectDbg>:
		break;
	}
}

void cliFunc_connectDbg( char* args )
{
    50a8:	b513      	push	{r0, r1, r4, lr}
    50aa:	4c0b      	ldr	r4, [pc, #44]	; (50d8 <cliFunc_connectDbg+0x30>)
	print( NL );
    50ac:	480b      	ldr	r0, [pc, #44]	; (50dc <cliFunc_connectDbg+0x34>)
{
    50ae:	6823      	ldr	r3, [r4, #0]
    50b0:	9301      	str	r3, [sp, #4]
	print( NL );
    50b2:	f00a fa5d 	bl	f570 <_print>
	info_msg("Connect Debug Mode Toggle");
    50b6:	480a      	ldr	r0, [pc, #40]	; (50e0 <cliFunc_connectDbg+0x38>)
    50b8:	f00a fa5a 	bl	f570 <_print>
	Connect_debug = !Connect_debug;
    50bc:	4a09      	ldr	r2, [pc, #36]	; (50e4 <cliFunc_connectDbg+0x3c>)
    50be:	7813      	ldrb	r3, [r2, #0]
    50c0:	fab3 f383 	clz	r3, r3
    50c4:	095b      	lsrs	r3, r3, #5
    50c6:	7013      	strb	r3, [r2, #0]
}
    50c8:	9a01      	ldr	r2, [sp, #4]
    50ca:	6823      	ldr	r3, [r4, #0]
    50cc:	429a      	cmp	r2, r3
    50ce:	d001      	beq.n	50d4 <cliFunc_connectDbg+0x2c>
    50d0:	f7fd fb2e 	bl	2730 <__stack_chk_fail>
    50d4:	b002      	add	sp, #8
    50d6:	bd10      	pop	{r4, pc}
    50d8:	1fff89d0 	.word	0x1fff89d0
    50dc:	00015df4 	.word	0x00015df4
    50e0:	00010f1a 	.word	0x00010f1a
    50e4:	1fff94c6 	.word	0x1fff94c6

000050e8 <Connect_receive_CurrentEvent>:
{
    50e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    50ea:	4e16      	ldr	r6, [pc, #88]	; (5144 <Connect_receive_CurrentEvent+0x5c>)
    50ec:	460c      	mov	r4, r1
    50ee:	6831      	ldr	r1, [r6, #0]
    50f0:	9101      	str	r1, [sp, #4]
    50f2:	4605      	mov	r5, r0
	if ( uart_num == UART_Slave )
    50f4:	b912      	cbnz	r2, 50fc <Connect_receive_CurrentEvent+0x14>
		erro_print("Invalid CurrentEvent direction...");
    50f6:	4814      	ldr	r0, [pc, #80]	; (5148 <Connect_receive_CurrentEvent+0x60>)
    50f8:	f00a fa3a 	bl	f570 <_print>
	switch ( (*pending_bytes)-- )
    50fc:	8823      	ldrh	r3, [r4, #0]
    50fe:	1e5a      	subs	r2, r3, #1
    5100:	8022      	strh	r2, [r4, #0]
    5102:	f64f 72fe 	movw	r2, #65534	; 0xfffe
    5106:	4293      	cmp	r3, r2
    5108:	d010      	beq.n	512c <Connect_receive_CurrentEvent+0x44>
    510a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    510e:	4293      	cmp	r3, r2
    5110:	d101      	bne.n	5116 <Connect_receive_CurrentEvent+0x2e>
		Connect_receive_CurrentEvent_current = byte;
    5112:	4b0e      	ldr	r3, [pc, #56]	; (514c <Connect_receive_CurrentEvent+0x64>)
    5114:	801d      	strh	r5, [r3, #0]
}
    5116:	9a01      	ldr	r2, [sp, #4]
	return *pending_bytes == 0 ? 1 : 0;
    5118:	8820      	ldrh	r0, [r4, #0]
}
    511a:	6833      	ldr	r3, [r6, #0]
    511c:	fab0 f080 	clz	r0, r0
    5120:	429a      	cmp	r2, r3
    5122:	ea4f 1050 	mov.w	r0, r0, lsr #5
    5126:	d00b      	beq.n	5140 <Connect_receive_CurrentEvent+0x58>
    5128:	f7fd fb02 	bl	2730 <__stack_chk_fail>
		Connect_receive_CurrentEvent_current |= (byte << 8);
    512c:	4b07      	ldr	r3, [pc, #28]	; (514c <Connect_receive_CurrentEvent+0x64>)
    512e:	8818      	ldrh	r0, [r3, #0]
    5130:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
    5134:	8018      	strh	r0, [r3, #0]
		Output_update_external_current( Connect_receive_CurrentEvent_current );
    5136:	f006 fdb5 	bl	bca4 <Output_update_external_current>
		*pending_bytes = 0;
    513a:	2300      	movs	r3, #0
    513c:	8023      	strh	r3, [r4, #0]
		break;
    513e:	e7ea      	b.n	5116 <Connect_receive_CurrentEvent+0x2e>
}
    5140:	b002      	add	sp, #8
    5142:	bd70      	pop	{r4, r5, r6, pc}
    5144:	1fff89d0 	.word	0x1fff89d0
    5148:	00010cc8 	.word	0x00010cc8
    514c:	1fff94d0 	.word	0x1fff94d0

00005150 <Connect_receive_CableCheck>:
{
    5150:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    5154:	4d43      	ldr	r5, [pc, #268]	; (5264 <Connect_receive_CableCheck+0x114>)
    5156:	682b      	ldr	r3, [r5, #0]
    5158:	9301      	str	r3, [sp, #4]
	if ( *pending_bytes == BYTE_COUNT_START )
    515a:	880b      	ldrh	r3, [r1, #0]
{
    515c:	4617      	mov	r7, r2
	if ( *pending_bytes == BYTE_COUNT_START )
    515e:	f64f 72ff 	movw	r2, #65535	; 0xffff
    5162:	4293      	cmp	r3, r2
{
    5164:	4606      	mov	r6, r0
    5166:	460c      	mov	r4, r1
	if ( *pending_bytes == BYTE_COUNT_START )
    5168:	d137      	bne.n	51da <Connect_receive_CableCheck+0x8a>
		*pending_bytes = byte;
    516a:	fa1f f880 	uxth.w	r8, r0
		if ( Connect_debug )
    516e:	4b3e      	ldr	r3, [pc, #248]	; (5268 <Connect_receive_CableCheck+0x118>)
		*pending_bytes = byte;
    5170:	f8a1 8000 	strh.w	r8, [r1]
		if ( Connect_debug )
    5174:	781b      	ldrb	r3, [r3, #0]
    5176:	b183      	cbz	r3, 519a <Connect_receive_CableCheck+0x4a>
			dbug_msg("PENDING SET -> ");
    5178:	483c      	ldr	r0, [pc, #240]	; (526c <Connect_receive_CableCheck+0x11c>)
    517a:	f00a f9f9 	bl	f570 <_print>
			printHex( byte );
    517e:	2101      	movs	r1, #1
    5180:	4640      	mov	r0, r8
    5182:	f00a fb1b 	bl	f7bc <printHex_op>
			print(" ");
    5186:	483a      	ldr	r0, [pc, #232]	; (5270 <Connect_receive_CableCheck+0x120>)
    5188:	f00a f9f2 	bl	f570 <_print>
			printHex( *pending_bytes );
    518c:	8820      	ldrh	r0, [r4, #0]
    518e:	2101      	movs	r1, #1
    5190:	f00a fb14 	bl	f7bc <printHex_op>
			print( NL );
    5194:	4837      	ldr	r0, [pc, #220]	; (5274 <Connect_receive_CableCheck+0x124>)
    5196:	f00a f9eb 	bl	f570 <_print>
	if ( *pending_bytes == 0 )
    519a:	8823      	ldrh	r3, [r4, #0]
    519c:	b923      	cbnz	r3, 51a8 <Connect_receive_CableCheck+0x58>
    519e:	2301      	movs	r3, #1
		if ( uart_num == UART_Slave )
    51a0:	2f00      	cmp	r7, #0
    51a2:	d15a      	bne.n	525a <Connect_receive_CableCheck+0x10a>
			Connect_cableOkSlave = 1;
    51a4:	4a34      	ldr	r2, [pc, #208]	; (5278 <Connect_receive_CableCheck+0x128>)
			Connect_cableOkMaster = 1;
    51a6:	7013      	strb	r3, [r2, #0]
	if ( Connect_debug )
    51a8:	4b2f      	ldr	r3, [pc, #188]	; (5268 <Connect_receive_CableCheck+0x118>)
    51aa:	781b      	ldrb	r3, [r3, #0]
    51ac:	b183      	cbz	r3, 51d0 <Connect_receive_CableCheck+0x80>
		dbug_msg("CABLECHECK RECEIVE - ");
    51ae:	4833      	ldr	r0, [pc, #204]	; (527c <Connect_receive_CableCheck+0x12c>)
    51b0:	f00a f9de 	bl	f570 <_print>
		printHex( byte );
    51b4:	2101      	movs	r1, #1
    51b6:	4630      	mov	r0, r6
    51b8:	f00a fb00 	bl	f7bc <printHex_op>
		print(" ");
    51bc:	482c      	ldr	r0, [pc, #176]	; (5270 <Connect_receive_CableCheck+0x120>)
    51be:	f00a f9d7 	bl	f570 <_print>
		printHex( *pending_bytes );
    51c2:	8820      	ldrh	r0, [r4, #0]
    51c4:	2101      	movs	r1, #1
    51c6:	f00a faf9 	bl	f7bc <printHex_op>
		print( NL );
    51ca:	482a      	ldr	r0, [pc, #168]	; (5274 <Connect_receive_CableCheck+0x124>)
    51cc:	f00a f9d0 	bl	f570 <_print>
	return *pending_bytes == 0 ? 1 : 0;
    51d0:	8820      	ldrh	r0, [r4, #0]
    51d2:	fab0 f080 	clz	r0, r0
    51d6:	0940      	lsrs	r0, r0, #5
    51d8:	e018      	b.n	520c <Connect_receive_CableCheck+0xbc>
		(*pending_bytes)--;
    51da:	3b01      	subs	r3, #1
		if ( byte != CABLE_CHECK_ARG )
    51dc:	28d2      	cmp	r0, #210	; 0xd2
		(*pending_bytes)--;
    51de:	800b      	strh	r3, [r1, #0]
		if ( byte != CABLE_CHECK_ARG )
    51e0:	d029      	beq.n	5236 <Connect_receive_CableCheck+0xe6>
			warn_print("Cable Fault!");
    51e2:	4827      	ldr	r0, [pc, #156]	; (5280 <Connect_receive_CableCheck+0x130>)
    51e4:	f00a f9c4 	bl	f570 <_print>
			if ( uart_num == UART_Slave )
    51e8:	b9b7      	cbnz	r7, 5218 <Connect_receive_CableCheck+0xc8>
				Connect_cableFaultsSlave++;
    51ea:	4a26      	ldr	r2, [pc, #152]	; (5284 <Connect_receive_CableCheck+0x134>)
				print(" Slave ");
    51ec:	4826      	ldr	r0, [pc, #152]	; (5288 <Connect_receive_CableCheck+0x138>)
				Connect_cableFaultsSlave++;
    51ee:	6813      	ldr	r3, [r2, #0]
    51f0:	3301      	adds	r3, #1
    51f2:	6013      	str	r3, [r2, #0]
				Connect_cableOkSlave = 0;
    51f4:	4b20      	ldr	r3, [pc, #128]	; (5278 <Connect_receive_CableCheck+0x128>)
    51f6:	701f      	strb	r7, [r3, #0]
				print(" Master ");
    51f8:	f00a f9ba 	bl	f570 <_print>
			printHex( byte );
    51fc:	2101      	movs	r1, #1
    51fe:	4630      	mov	r0, r6
    5200:	f00a fadc 	bl	f7bc <printHex_op>
			print( NL );
    5204:	481b      	ldr	r0, [pc, #108]	; (5274 <Connect_receive_CableCheck+0x124>)
    5206:	f00a f9b3 	bl	f570 <_print>
			return 1;
    520a:	2001      	movs	r0, #1
}
    520c:	9a01      	ldr	r2, [sp, #4]
    520e:	682b      	ldr	r3, [r5, #0]
    5210:	429a      	cmp	r2, r3
    5212:	d024      	beq.n	525e <Connect_receive_CableCheck+0x10e>
    5214:	f7fd fa8c 	bl	2730 <__stack_chk_fail>
				if ( Connect_id != 0 )
    5218:	4b1c      	ldr	r3, [pc, #112]	; (528c <Connect_receive_CableCheck+0x13c>)
    521a:	781b      	ldrb	r3, [r3, #0]
    521c:	b113      	cbz	r3, 5224 <Connect_receive_CableCheck+0xd4>
					Output_update_external_current( 50 );
    521e:	2032      	movs	r0, #50	; 0x32
    5220:	f006 fd40 	bl	bca4 <Output_update_external_current>
				Connect_cableFaultsMaster++;
    5224:	4a1a      	ldr	r2, [pc, #104]	; (5290 <Connect_receive_CableCheck+0x140>)
				print(" Master ");
    5226:	481b      	ldr	r0, [pc, #108]	; (5294 <Connect_receive_CableCheck+0x144>)
				Connect_cableFaultsMaster++;
    5228:	6813      	ldr	r3, [r2, #0]
    522a:	3301      	adds	r3, #1
    522c:	6013      	str	r3, [r2, #0]
				Connect_cableOkMaster = 0;
    522e:	4b1a      	ldr	r3, [pc, #104]	; (5298 <Connect_receive_CableCheck+0x148>)
    5230:	2200      	movs	r2, #0
    5232:	701a      	strb	r2, [r3, #0]
    5234:	e7e0      	b.n	51f8 <Connect_receive_CableCheck+0xa8>
			if ( uart_num == UART_Slave )
    5236:	b927      	cbnz	r7, 5242 <Connect_receive_CableCheck+0xf2>
				Connect_cableChecksSlave++;
    5238:	4a18      	ldr	r2, [pc, #96]	; (529c <Connect_receive_CableCheck+0x14c>)
				Connect_cableChecksMaster++;
    523a:	6813      	ldr	r3, [r2, #0]
    523c:	3301      	adds	r3, #1
    523e:	6013      	str	r3, [r2, #0]
    5240:	e7ab      	b.n	519a <Connect_receive_CableCheck+0x4a>
				if ( Connect_id != 255 && Connect_id != 0 )
    5242:	4b12      	ldr	r3, [pc, #72]	; (528c <Connect_receive_CableCheck+0x13c>)
    5244:	781b      	ldrb	r3, [r3, #0]
    5246:	3b01      	subs	r3, #1
    5248:	b2db      	uxtb	r3, r3
    524a:	2bfd      	cmp	r3, #253	; 0xfd
    524c:	d803      	bhi.n	5256 <Connect_receive_CableCheck+0x106>
					Output_update_external_current( Output_current_available() );
    524e:	f006 fcef 	bl	bc30 <Output_current_available>
    5252:	f006 fd27 	bl	bca4 <Output_update_external_current>
				Connect_cableChecksMaster++;
    5256:	4a12      	ldr	r2, [pc, #72]	; (52a0 <Connect_receive_CableCheck+0x150>)
    5258:	e7ef      	b.n	523a <Connect_receive_CableCheck+0xea>
			Connect_cableOkMaster = 1;
    525a:	4a0f      	ldr	r2, [pc, #60]	; (5298 <Connect_receive_CableCheck+0x148>)
    525c:	e7a3      	b.n	51a6 <Connect_receive_CableCheck+0x56>
}
    525e:	b002      	add	sp, #8
    5260:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5264:	1fff89d0 	.word	0x1fff89d0
    5268:	1fff94c6 	.word	0x1fff94c6
    526c:	00010c47 	.word	0x00010c47
    5270:	00016f5e 	.word	0x00016f5e
    5274:	00015df4 	.word	0x00015df4
    5278:	1fff94c5 	.word	0x1fff94c5
    527c:	00010c9f 	.word	0x00010c9f
    5280:	00010c6a 	.word	0x00010c6a
    5284:	1fff94c0 	.word	0x1fff94c0
    5288:	00010c8e 	.word	0x00010c8e
    528c:	1fff89e2 	.word	0x1fff89e2
    5290:	1fff94bc 	.word	0x1fff94bc
    5294:	00010c96 	.word	0x00010c96
    5298:	1fff94c4 	.word	0x1fff94c4
    529c:	1fff94b8 	.word	0x1fff94b8
    52a0:	1fff94b4 	.word	0x1fff94b4

000052a4 <cliFunc_connectLst>:

	Connect_send_Idle( count );
}

void cliFunc_connectLst( char* args )
{
    52a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    52a8:	4e18      	ldr	r6, [pc, #96]	; (530c <cliFunc_connectLst+0x68>)
	const char *Command_strs[] = {
    52aa:	4d19      	ldr	r5, [pc, #100]	; (5310 <cliFunc_connectLst+0x6c>)
{
    52ac:	6833      	ldr	r3, [r6, #0]

	print( NL );
	info_msg("List of UARTConnect commands");
	for ( uint8_t cmd = 0; cmd < Command_TOP; cmd++ )
	{
		print( NL );
    52ae:	f8df 8068 	ldr.w	r8, [pc, #104]	; 5318 <cliFunc_connectLst+0x74>
		printInt8( cmd );
		print(" - ");
    52b2:	4f18      	ldr	r7, [pc, #96]	; (5314 <cliFunc_connectLst+0x70>)
{
    52b4:	b08c      	sub	sp, #48	; 0x30
	const char *Command_strs[] = {
    52b6:	ac01      	add	r4, sp, #4
{
    52b8:	930b      	str	r3, [sp, #44]	; 0x2c
	const char *Command_strs[] = {
    52ba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    52bc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    52be:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    52c0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    52c2:	e895 0003 	ldmia.w	r5, {r0, r1}
    52c6:	e884 0003 	stmia.w	r4, {r0, r1}
	print( NL );
    52ca:	4813      	ldr	r0, [pc, #76]	; (5318 <cliFunc_connectLst+0x74>)
    52cc:	f00a f950 	bl	f570 <_print>
	info_msg("List of UARTConnect commands");
    52d0:	4812      	ldr	r0, [pc, #72]	; (531c <cliFunc_connectLst+0x78>)
    52d2:	f00a f94d 	bl	f570 <_print>
    52d6:	2400      	movs	r4, #0
    52d8:	ad01      	add	r5, sp, #4
		print( NL );
    52da:	4640      	mov	r0, r8
    52dc:	f00a f948 	bl	f570 <_print>
		printInt8( cmd );
    52e0:	b2e0      	uxtb	r0, r4
    52e2:	f00a f9af 	bl	f644 <printInt8>
		print(" - ");
    52e6:	4638      	mov	r0, r7
    52e8:	f00a f942 	bl	f570 <_print>
		dPrint( (char*)Command_strs[ cmd ] );
    52ec:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
    52f0:	3401      	adds	r4, #1
    52f2:	f006 fdb5 	bl	be60 <Output_putstr>
	for ( uint8_t cmd = 0; cmd < Command_TOP; cmd++ )
    52f6:	2c0a      	cmp	r4, #10
    52f8:	d1ef      	bne.n	52da <cliFunc_connectLst+0x36>
	}
}
    52fa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    52fc:	6833      	ldr	r3, [r6, #0]
    52fe:	429a      	cmp	r2, r3
    5300:	d001      	beq.n	5306 <cliFunc_connectLst+0x62>
    5302:	f7fd fa15 	bl	2730 <__stack_chk_fail>
    5306:	b00c      	add	sp, #48	; 0x30
    5308:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    530c:	1fff89d0 	.word	0x1fff89d0
    5310:	00010b38 	.word	0x00010b38
    5314:	00016378 	.word	0x00016378
    5318:	00015df4 	.word	0x00015df4
    531c:	00010f6e 	.word	0x00010f6e

00005320 <cliFunc_connectSts>:
	// Reset node id
	Connect_id = DEFAULT_SLAVE_ID;
}

void cliFunc_connectSts( char* args )
{
    5320:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5322:	4d3e      	ldr	r5, [pc, #248]	; (541c <cliFunc_connectSts+0xfc>)
	print( NL );
    5324:	483e      	ldr	r0, [pc, #248]	; (5420 <cliFunc_connectSts+0x100>)
{
    5326:	682b      	ldr	r3, [r5, #0]
    5328:	9301      	str	r3, [sp, #4]
	print( NL );
    532a:	f00a f921 	bl	f570 <_print>
	info_msg("UARTConnect Status");
    532e:	483d      	ldr	r0, [pc, #244]	; (5424 <cliFunc_connectSts+0x104>)
	print( NL "\tFaults:\t");
	printHex32( Connect_cableFaultsMaster );
	print("/");
	printHex32( Connect_cableChecksMaster );
	print( NL "\tRx:\t");
	printHex( uart_rx_status[UART_Master].status );
    5330:	4e3d      	ldr	r6, [pc, #244]	; (5428 <cliFunc_connectSts+0x108>)
	print( NL "\tTx:\t");
	printHex( uart_tx_status[UART_Master].status );
    5332:	4c3e      	ldr	r4, [pc, #248]	; (542c <cliFunc_connectSts+0x10c>)
	info_msg("UARTConnect Status");
    5334:	f00a f91c 	bl	f570 <_print>
	print( NL "Device Type:\t" );
    5338:	483d      	ldr	r0, [pc, #244]	; (5430 <cliFunc_connectSts+0x110>)
    533a:	f00a f919 	bl	f570 <_print>
	print( Connect_master ? "Master" : "Slave" );
    533e:	4b3d      	ldr	r3, [pc, #244]	; (5434 <cliFunc_connectSts+0x114>)
    5340:	4a3d      	ldr	r2, [pc, #244]	; (5438 <cliFunc_connectSts+0x118>)
    5342:	7818      	ldrb	r0, [r3, #0]
    5344:	4b3d      	ldr	r3, [pc, #244]	; (543c <cliFunc_connectSts+0x11c>)
    5346:	2800      	cmp	r0, #0
    5348:	bf14      	ite	ne
    534a:	4610      	movne	r0, r2
    534c:	4618      	moveq	r0, r3
    534e:	f00a f90f 	bl	f570 <_print>
	print( NL "Device Id:\t" );
    5352:	483b      	ldr	r0, [pc, #236]	; (5440 <cliFunc_connectSts+0x120>)
    5354:	f00a f90c 	bl	f570 <_print>
	printHex( Connect_id );
    5358:	4b3a      	ldr	r3, [pc, #232]	; (5444 <cliFunc_connectSts+0x124>)
    535a:	2101      	movs	r1, #1
    535c:	7818      	ldrb	r0, [r3, #0]
    535e:	f00a fa2d 	bl	f7bc <printHex_op>
	print( NL "Max Id:\t" );
    5362:	4839      	ldr	r0, [pc, #228]	; (5448 <cliFunc_connectSts+0x128>)
    5364:	f00a f904 	bl	f570 <_print>
	printHex( Connect_maxId );
    5368:	4b38      	ldr	r3, [pc, #224]	; (544c <cliFunc_connectSts+0x12c>)
    536a:	2101      	movs	r1, #1
    536c:	7818      	ldrb	r0, [r3, #0]
    536e:	f00a fa25 	bl	f7bc <printHex_op>
	print( NL "Master <=" NL "\tStatus:\t");
    5372:	4837      	ldr	r0, [pc, #220]	; (5450 <cliFunc_connectSts+0x130>)
    5374:	f00a f8fc 	bl	f570 <_print>
	printHex( Connect_cableOkMaster );
    5378:	4b36      	ldr	r3, [pc, #216]	; (5454 <cliFunc_connectSts+0x134>)
    537a:	2101      	movs	r1, #1
    537c:	7818      	ldrb	r0, [r3, #0]
    537e:	f00a fa1d 	bl	f7bc <printHex_op>
	print( NL "\tFaults:\t");
    5382:	4835      	ldr	r0, [pc, #212]	; (5458 <cliFunc_connectSts+0x138>)
    5384:	f00a f8f4 	bl	f570 <_print>
	printHex32( Connect_cableFaultsMaster );
    5388:	4b34      	ldr	r3, [pc, #208]	; (545c <cliFunc_connectSts+0x13c>)
    538a:	2101      	movs	r1, #1
    538c:	6818      	ldr	r0, [r3, #0]
    538e:	f00a fa67 	bl	f860 <printHex32_op>
	print("/");
    5392:	4833      	ldr	r0, [pc, #204]	; (5460 <cliFunc_connectSts+0x140>)
    5394:	f00a f8ec 	bl	f570 <_print>
	printHex32( Connect_cableChecksMaster );
    5398:	4b32      	ldr	r3, [pc, #200]	; (5464 <cliFunc_connectSts+0x144>)
    539a:	2101      	movs	r1, #1
    539c:	6818      	ldr	r0, [r3, #0]
    539e:	f00a fa5f 	bl	f860 <printHex32_op>
	print( NL "\tRx:\t");
    53a2:	4831      	ldr	r0, [pc, #196]	; (5468 <cliFunc_connectSts+0x148>)
    53a4:	f00a f8e4 	bl	f570 <_print>
	printHex( uart_rx_status[UART_Master].status );
    53a8:	2101      	movs	r1, #1
    53aa:	7930      	ldrb	r0, [r6, #4]
    53ac:	f00a fa06 	bl	f7bc <printHex_op>
	print( NL "\tTx:\t");
    53b0:	482e      	ldr	r0, [pc, #184]	; (546c <cliFunc_connectSts+0x14c>)
    53b2:	f00a f8dd 	bl	f570 <_print>
	printHex( uart_tx_status[UART_Master].status );
    53b6:	2101      	movs	r1, #1
    53b8:	78a0      	ldrb	r0, [r4, #2]
    53ba:	f00a f9ff 	bl	f7bc <printHex_op>
	print( NL "Slave <=" NL "\tStatus:\t");
    53be:	482c      	ldr	r0, [pc, #176]	; (5470 <cliFunc_connectSts+0x150>)
    53c0:	f00a f8d6 	bl	f570 <_print>
	printHex( Connect_cableOkSlave );
    53c4:	4b2b      	ldr	r3, [pc, #172]	; (5474 <cliFunc_connectSts+0x154>)
    53c6:	2101      	movs	r1, #1
    53c8:	7818      	ldrb	r0, [r3, #0]
    53ca:	f00a f9f7 	bl	f7bc <printHex_op>
	print( NL "\tFaults:\t");
    53ce:	4822      	ldr	r0, [pc, #136]	; (5458 <cliFunc_connectSts+0x138>)
    53d0:	f00a f8ce 	bl	f570 <_print>
	printHex32( Connect_cableFaultsSlave );
    53d4:	4b28      	ldr	r3, [pc, #160]	; (5478 <cliFunc_connectSts+0x158>)
    53d6:	2101      	movs	r1, #1
    53d8:	6818      	ldr	r0, [r3, #0]
    53da:	f00a fa41 	bl	f860 <printHex32_op>
	print("/");
    53de:	4820      	ldr	r0, [pc, #128]	; (5460 <cliFunc_connectSts+0x140>)
    53e0:	f00a f8c6 	bl	f570 <_print>
	printHex32( Connect_cableChecksSlave );
    53e4:	4b25      	ldr	r3, [pc, #148]	; (547c <cliFunc_connectSts+0x15c>)
    53e6:	2101      	movs	r1, #1
    53e8:	6818      	ldr	r0, [r3, #0]
    53ea:	f00a fa39 	bl	f860 <printHex32_op>
	print( NL "\tRx:\t");
    53ee:	481e      	ldr	r0, [pc, #120]	; (5468 <cliFunc_connectSts+0x148>)
    53f0:	f00a f8be 	bl	f570 <_print>
	printHex( uart_rx_status[UART_Slave].status );
    53f4:	7830      	ldrb	r0, [r6, #0]
    53f6:	2101      	movs	r1, #1
    53f8:	f00a f9e0 	bl	f7bc <printHex_op>
	print( NL "\tTx:\t");
    53fc:	481b      	ldr	r0, [pc, #108]	; (546c <cliFunc_connectSts+0x14c>)
    53fe:	f00a f8b7 	bl	f570 <_print>
	printHex( uart_tx_status[UART_Slave].status );
    5402:	9a01      	ldr	r2, [sp, #4]
    5404:	682b      	ldr	r3, [r5, #0]
    5406:	429a      	cmp	r2, r3
    5408:	d001      	beq.n	540e <cliFunc_connectSts+0xee>
    540a:	f7fd f991 	bl	2730 <__stack_chk_fail>
    540e:	7820      	ldrb	r0, [r4, #0]
    5410:	2101      	movs	r1, #1
}
    5412:	b002      	add	sp, #8
    5414:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	printHex( uart_tx_status[UART_Slave].status );
    5418:	f00a b9d0 	b.w	f7bc <printHex_op>
    541c:	1fff89d0 	.word	0x1fff89d0
    5420:	00015df4 	.word	0x00015df4
    5424:	00011032 	.word	0x00011032
    5428:	1fffa178 	.word	0x1fffa178
    542c:	1fffa15a 	.word	0x1fffa15a
    5430:	00011057 	.word	0x00011057
    5434:	1fff94cc 	.word	0x1fff94cc
    5438:	00011025 	.word	0x00011025
    543c:	0001102c 	.word	0x0001102c
    5440:	00011067 	.word	0x00011067
    5444:	1fff89e2 	.word	0x1fff89e2
    5448:	00011075 	.word	0x00011075
    544c:	1fff94cd 	.word	0x1fff94cd
    5450:	00011080 	.word	0x00011080
    5454:	1fff94c4 	.word	0x1fff94c4
    5458:	00011097 	.word	0x00011097
    545c:	1fff94bc 	.word	0x1fff94bc
    5460:	0000fb89 	.word	0x0000fb89
    5464:	1fff94b4 	.word	0x1fff94b4
    5468:	000110a3 	.word	0x000110a3
    546c:	000110ab 	.word	0x000110ab
    5470:	000110b3 	.word	0x000110b3
    5474:	1fff94c5 	.word	0x1fff94c5
    5478:	1fff94c0 	.word	0x1fff94c0
    547c:	1fff94b8 	.word	0x1fff94b8

00005480 <cliFunc_connectMst>:
{
    5480:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    5482:	4e19      	ldr	r6, [pc, #100]	; (54e8 <cliFunc_connectMst+0x68>)
    5484:	4d19      	ldr	r5, [pc, #100]	; (54ec <cliFunc_connectMst+0x6c>)
    5486:	6833      	ldr	r3, [r6, #0]
    5488:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    548a:	aa02      	add	r2, sp, #8
    548c:	a901      	add	r1, sp, #4
    548e:	f009 fb41 	bl	eb14 <CLI_argumentIsolation>
	print( NL );
    5492:	4817      	ldr	r0, [pc, #92]	; (54f0 <cliFunc_connectMst+0x70>)
    5494:	4c17      	ldr	r4, [pc, #92]	; (54f4 <cliFunc_connectMst+0x74>)
    5496:	f00a f86b 	bl	f570 <_print>
	Connect_override = 1;
    549a:	4b17      	ldr	r3, [pc, #92]	; (54f8 <cliFunc_connectMst+0x78>)
    549c:	2201      	movs	r2, #1
    549e:	701a      	strb	r2, [r3, #0]
	switch ( arg1Ptr[0] )
    54a0:	9a01      	ldr	r2, [sp, #4]
    54a2:	7812      	ldrb	r2, [r2, #0]
    54a4:	2a53      	cmp	r2, #83	; 0x53
    54a6:	d00d      	beq.n	54c4 <cliFunc_connectMst+0x44>
    54a8:	d808      	bhi.n	54bc <cliFunc_connectMst+0x3c>
    54aa:	2a44      	cmp	r2, #68	; 0x44
    54ac:	d017      	beq.n	54de <cliFunc_connectMst+0x5e>
		info_msg("Setting device as master.");
    54ae:	4813      	ldr	r0, [pc, #76]	; (54fc <cliFunc_connectMst+0x7c>)
    54b0:	f00a f85e 	bl	f570 <_print>
		Connect_master = 1;
    54b4:	2301      	movs	r3, #1
    54b6:	702b      	strb	r3, [r5, #0]
		Connect_id = 0;
    54b8:	2300      	movs	r3, #0
    54ba:	e009      	b.n	54d0 <cliFunc_connectMst+0x50>
	switch ( arg1Ptr[0] )
    54bc:	2a64      	cmp	r2, #100	; 0x64
    54be:	d00e      	beq.n	54de <cliFunc_connectMst+0x5e>
    54c0:	2a73      	cmp	r2, #115	; 0x73
    54c2:	d1f4      	bne.n	54ae <cliFunc_connectMst+0x2e>
		info_msg("Setting device as slave.");
    54c4:	480e      	ldr	r0, [pc, #56]	; (5500 <cliFunc_connectMst+0x80>)
    54c6:	f00a f853 	bl	f570 <_print>
		Connect_master = 0;
    54ca:	2300      	movs	r3, #0
    54cc:	702b      	strb	r3, [r5, #0]
		Connect_id = DEFAULT_SLAVE_ID;
    54ce:	23ff      	movs	r3, #255	; 0xff
}
    54d0:	9a03      	ldr	r2, [sp, #12]
		Connect_id = 0;
    54d2:	7023      	strb	r3, [r4, #0]
}
    54d4:	6833      	ldr	r3, [r6, #0]
    54d6:	429a      	cmp	r2, r3
    54d8:	d004      	beq.n	54e4 <cliFunc_connectMst+0x64>
    54da:	f7fd f929 	bl	2730 <__stack_chk_fail>
		Connect_override = 0;
    54de:	2200      	movs	r2, #0
    54e0:	701a      	strb	r2, [r3, #0]
    54e2:	e7ef      	b.n	54c4 <cliFunc_connectMst+0x44>
}
    54e4:	b004      	add	sp, #16
    54e6:	bd70      	pop	{r4, r5, r6, pc}
    54e8:	1fff89d0 	.word	0x1fff89d0
    54ec:	1fff94cc 	.word	0x1fff94cc
    54f0:	00015df4 	.word	0x00015df4
    54f4:	1fff89e2 	.word	0x1fff89e2
    54f8:	1fff94ce 	.word	0x1fff94ce
    54fc:	00010fc8 	.word	0x00010fc8
    5500:	00010f9d 	.word	0x00010f9d

00005504 <Connect_addBytes.part.1>:
void Connect_addBytes( uint8_t *buffer, uint8_t count, uint8_t uart )
    5504:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    5508:	4b2e      	ldr	r3, [pc, #184]	; (55c4 <Connect_addBytes.part.1+0xc0>)
	while ( uart_tx_buf[ uart ].items + count > UART_Buffer_Size )
    550a:	4f2f      	ldr	r7, [pc, #188]	; (55c8 <Connect_addBytes.part.1+0xc4>)
void Connect_addBytes( uint8_t *buffer, uint8_t count, uint8_t uart )
    550c:	4616      	mov	r6, r2
	while ( uart_tx_buf[ uart ].items + count > UART_Buffer_Size )
    550e:	2483      	movs	r4, #131	; 0x83
void Connect_addBytes( uint8_t *buffer, uint8_t count, uint8_t uart )
    5510:	681a      	ldr	r2, [r3, #0]
    5512:	9201      	str	r2, [sp, #4]
    5514:	4605      	mov	r5, r0
    5516:	4689      	mov	r9, r1
    5518:	4698      	mov	r8, r3
	while ( uart_tx_buf[ uart ].items + count > UART_Buffer_Size )
    551a:	fb04 7406 	mla	r4, r4, r6, r7
    551e:	78a3      	ldrb	r3, [r4, #2]
    5520:	444b      	add	r3, r9
    5522:	2b80      	cmp	r3, #128	; 0x80
    5524:	dc0d      	bgt.n	5542 <Connect_addBytes.part.1+0x3e>
		uart_tx_buf[ uart ].buffer[ uart_tx_buf[ uart ].tail++ ] = buffer[ c ];
    5526:	f04f 0a83 	mov.w	sl, #131	; 0x83
    552a:	44a9      	add	r9, r5
    552c:	fb0a 7406 	mla	r4, sl, r6, r7
	for ( uint8_t c = 0; c < count; c++ )
    5530:	45a9      	cmp	r9, r5
    5532:	d113      	bne.n	555c <Connect_addBytes.part.1+0x58>
}
    5534:	9a01      	ldr	r2, [sp, #4]
    5536:	f8d8 3000 	ldr.w	r3, [r8]
    553a:	429a      	cmp	r2, r3
    553c:	d03f      	beq.n	55be <Connect_addBytes.part.1+0xba>
    553e:	f7fd f8f7 	bl	2730 <__stack_chk_fail>
		warn_msg("Too much data to send on UART");
    5542:	4822      	ldr	r0, [pc, #136]	; (55cc <Connect_addBytes.part.1+0xc8>)
    5544:	f00a f814 	bl	f570 <_print>
		printInt8( uart );
    5548:	4630      	mov	r0, r6
    554a:	f00a f87b 	bl	f644 <printInt8>
		print( ", waiting..." NL );
    554e:	4820      	ldr	r0, [pc, #128]	; (55d0 <Connect_addBytes.part.1+0xcc>)
    5550:	f00a f80e 	bl	f570 <_print>
		delay_ms( 1 );
    5554:	2001      	movs	r0, #1
    5556:	f7fd f98f 	bl	2878 <delay_ms>
    555a:	e7e0      	b.n	551e <Connect_addBytes.part.1+0x1a>
		if ( Connect_debug )
    555c:	4b1d      	ldr	r3, [pc, #116]	; (55d4 <Connect_addBytes.part.1+0xd0>)
    555e:	781b      	ldrb	r3, [r3, #0]
    5560:	b163      	cbz	r3, 557c <Connect_addBytes.part.1+0x78>
			printHex( buffer[ c ] );
    5562:	2101      	movs	r1, #1
    5564:	7828      	ldrb	r0, [r5, #0]
    5566:	f00a f929 	bl	f7bc <printHex_op>
			print(" +");
    556a:	481b      	ldr	r0, [pc, #108]	; (55d8 <Connect_addBytes.part.1+0xd4>)
    556c:	f00a f800 	bl	f570 <_print>
			printInt8( uart );
    5570:	4630      	mov	r0, r6
    5572:	f00a f867 	bl	f644 <printInt8>
			print( NL );
    5576:	4819      	ldr	r0, [pc, #100]	; (55dc <Connect_addBytes.part.1+0xd8>)
    5578:	f009 fffa 	bl	f570 <_print>
		uart_tx_buf[ uart ].buffer[ uart_tx_buf[ uart ].tail++ ] = buffer[ c ];
    557c:	7862      	ldrb	r2, [r4, #1]
    557e:	1c53      	adds	r3, r2, #1
    5580:	b2db      	uxtb	r3, r3
    5582:	7063      	strb	r3, [r4, #1]
    5584:	4422      	add	r2, r4
    5586:	f815 1b01 	ldrb.w	r1, [r5], #1
    558a:	70d1      	strb	r1, [r2, #3]
		uart_tx_buf[ uart ].items++;
    558c:	78a2      	ldrb	r2, [r4, #2]
		if ( uart_tx_buf[ uart ].tail >= UART_Buffer_Size )
    558e:	061b      	lsls	r3, r3, #24
		uart_tx_buf[ uart ].items++;
    5590:	f102 0201 	add.w	r2, r2, #1
			uart_tx_buf[ uart ].tail = 0;
    5594:	bf48      	it	mi
    5596:	2300      	movmi	r3, #0
		uart_tx_buf[ uart ].items++;
    5598:	70a2      	strb	r2, [r4, #2]
		if ( uart_tx_buf[ uart ].head == uart_tx_buf[ uart ].tail )
    559a:	fb0a f206 	mul.w	r2, sl, r6
			uart_tx_buf[ uart ].tail = 0;
    559e:	bf48      	it	mi
    55a0:	7063      	strbmi	r3, [r4, #1]
		if ( uart_tx_buf[ uart ].head == uart_tx_buf[ uart ].tail )
    55a2:	18bb      	adds	r3, r7, r2
    55a4:	5cb9      	ldrb	r1, [r7, r2]
    55a6:	785b      	ldrb	r3, [r3, #1]
    55a8:	428b      	cmp	r3, r1
			uart_tx_buf[ uart ].head++;
    55aa:	bf04      	itt	eq
    55ac:	3301      	addeq	r3, #1
    55ae:	54bb      	strbeq	r3, [r7, r2]
		if ( uart_tx_buf[ uart ].head >= UART_Buffer_Size )
    55b0:	f994 3000 	ldrsb.w	r3, [r4]
    55b4:	2b00      	cmp	r3, #0
			uart_tx_buf[ uart ].head = 0;
    55b6:	bfbc      	itt	lt
    55b8:	2300      	movlt	r3, #0
    55ba:	7023      	strblt	r3, [r4, #0]
    55bc:	e7b8      	b.n	5530 <Connect_addBytes.part.1+0x2c>
}
    55be:	b002      	add	sp, #8
    55c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    55c4:	1fff89d0 	.word	0x1fff89d0
    55c8:	1fffa04e 	.word	0x1fffa04e
    55cc:	00010b6b 	.word	0x00010b6b
    55d0:	00010b9e 	.word	0x00010b9e
    55d4:	1fff94c6 	.word	0x1fff94c6
    55d8:	00010bad 	.word	0x00010bad
    55dc:	00015df4 	.word	0x00015df4

000055e0 <Connect_receive_ScanCode>:
{
    55e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    55e2:	4e58      	ldr	r6, [pc, #352]	; (5744 <Connect_receive_ScanCode+0x164>)
    55e4:	b085      	sub	sp, #20
    55e6:	6833      	ldr	r3, [r6, #0]
    55e8:	f88d 0007 	strb.w	r0, [sp, #7]
	if ( uart_num == UART_Master )
    55ec:	2a01      	cmp	r2, #1
{
    55ee:	460d      	mov	r5, r1
    55f0:	9303      	str	r3, [sp, #12]
	if ( uart_num == UART_Master )
    55f2:	d102      	bne.n	55fa <Connect_receive_ScanCode+0x1a>
		erro_print("Invalid ScanCode direction...");
    55f4:	4854      	ldr	r0, [pc, #336]	; (5748 <Connect_receive_ScanCode+0x168>)
    55f6:	f009 ffbb 	bl	f570 <_print>
    55fa:	882a      	ldrh	r2, [r5, #0]
	if ( Connect_master ) switch ( (*pending_bytes)-- )
    55fc:	4953      	ldr	r1, [pc, #332]	; (574c <Connect_receive_ScanCode+0x16c>)
    55fe:	1e53      	subs	r3, r2, #1
    5600:	7809      	ldrb	r1, [r1, #0]
    5602:	b29b      	uxth	r3, r3
    5604:	f64f 70fe 	movw	r0, #65534	; 0xfffe
    5608:	802b      	strh	r3, [r5, #0]
    560a:	2900      	cmp	r1, #0
    560c:	d05b      	beq.n	56c6 <Connect_receive_ScanCode+0xe6>
    560e:	4282      	cmp	r2, r0
    5610:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5614:	d011      	beq.n	563a <Connect_receive_ScanCode+0x5a>
    5616:	f64f 71ff 	movw	r1, #65535	; 0xffff
    561a:	428a      	cmp	r2, r1
    561c:	d114      	bne.n	5648 <Connect_receive_ScanCode+0x68>
		Connect_receive_ScanCodeDeviceId = byte;
    561e:	4a4c      	ldr	r2, [pc, #304]	; (5750 <Connect_receive_ScanCode+0x170>)
    5620:	7013      	strb	r3, [r2, #0]
}
    5622:	9a03      	ldr	r2, [sp, #12]
	return *pending_bytes == 0 ? 1 : 0;
    5624:	8828      	ldrh	r0, [r5, #0]
}
    5626:	6833      	ldr	r3, [r6, #0]
    5628:	fab0 f080 	clz	r0, r0
    562c:	429a      	cmp	r2, r3
    562e:	ea4f 1050 	mov.w	r0, r0, lsr #5
    5632:	f000 8084 	beq.w	573e <Connect_receive_ScanCode+0x15e>
    5636:	f7fd f87b 	bl	2730 <__stack_chk_fail>
		*pending_bytes = byte * sizeof( TriggerGuide );
    563a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    563e:	802b      	strh	r3, [r5, #0]
		Connect_receive_ScanCodeBufferPos = 0;
    5640:	4b44      	ldr	r3, [pc, #272]	; (5754 <Connect_receive_ScanCode+0x174>)
    5642:	2200      	movs	r2, #0
    5644:	701a      	strb	r2, [r3, #0]
		break;
    5646:	e7ec      	b.n	5622 <Connect_receive_ScanCode+0x42>
		((uint8_t*)&Connect_receive_ScanCodeBuffer)[ Connect_receive_ScanCodeBufferPos++ ] = byte;
    5648:	4942      	ldr	r1, [pc, #264]	; (5754 <Connect_receive_ScanCode+0x174>)
    564a:	4c43      	ldr	r4, [pc, #268]	; (5758 <Connect_receive_ScanCode+0x178>)
    564c:	7808      	ldrb	r0, [r1, #0]
    564e:	1c42      	adds	r2, r0, #1
    5650:	b2d2      	uxtb	r2, r2
		if ( Connect_receive_ScanCodeBufferPos >= sizeof( TriggerGuide ) )
    5652:	2a02      	cmp	r2, #2
		((uint8_t*)&Connect_receive_ScanCodeBuffer)[ Connect_receive_ScanCodeBufferPos++ ] = byte;
    5654:	700a      	strb	r2, [r1, #0]
    5656:	5423      	strb	r3, [r4, r0]
		if ( Connect_receive_ScanCodeBufferPos >= sizeof( TriggerGuide ) )
    5658:	d9e3      	bls.n	5622 <Connect_receive_ScanCode+0x42>
			if ( Connect_receive_ScanCodeDeviceId > 0 )
    565a:	4f3d      	ldr	r7, [pc, #244]	; (5750 <Connect_receive_ScanCode+0x170>)
    565c:	783a      	ldrb	r2, [r7, #0]
			Connect_receive_ScanCodeBufferPos = 0;
    565e:	2300      	movs	r3, #0
    5660:	700b      	strb	r3, [r1, #0]
			if ( Connect_receive_ScanCodeDeviceId > 0 )
    5662:	b18a      	cbz	r2, 5688 <Connect_receive_ScanCode+0xa8>
				if ( Connect_receive_ScanCodeDeviceId >= InterconnectNodeMax )
    5664:	2a02      	cmp	r2, #2
    5666:	d90a      	bls.n	567e <Connect_receive_ScanCode+0x9e>
					warn_msg("Not enough interconnect layout nodes configured: ");
    5668:	483c      	ldr	r0, [pc, #240]	; (575c <Connect_receive_ScanCode+0x17c>)
    566a:	f009 ff81 	bl	f570 <_print>
					printHex( Connect_receive_ScanCodeDeviceId );
    566e:	7838      	ldrb	r0, [r7, #0]
    5670:	2101      	movs	r1, #1
    5672:	f00a f8a3 	bl	f7bc <printHex_op>
					print( NL );
    5676:	483a      	ldr	r0, [pc, #232]	; (5760 <Connect_receive_ScanCode+0x180>)
    5678:	f009 ff7a 	bl	f570 <_print>
					break;
    567c:	e7d1      	b.n	5622 <Connect_receive_ScanCode+0x42>
				Connect_receive_ScanCodeBuffer.scanCode = Connect_receive_ScanCodeBuffer.scanCode + InterconnectOffsetList[ Connect_receive_ScanCodeDeviceId ];
    567e:	4939      	ldr	r1, [pc, #228]	; (5764 <Connect_receive_ScanCode+0x184>)
    5680:	78a3      	ldrb	r3, [r4, #2]
    5682:	5c8a      	ldrb	r2, [r1, r2]
    5684:	4413      	add	r3, r2
    5686:	70a3      	strb	r3, [r4, #2]
			if ( Connect_debug )
    5688:	4b37      	ldr	r3, [pc, #220]	; (5768 <Connect_receive_ScanCode+0x188>)
    568a:	781b      	ldrb	r3, [r3, #0]
    568c:	b1bb      	cbz	r3, 56be <Connect_receive_ScanCode+0xde>
				dbug_msg("");
    568e:	4837      	ldr	r0, [pc, #220]	; (576c <Connect_receive_ScanCode+0x18c>)
    5690:	f009 ff6e 	bl	f570 <_print>
				printHex( Connect_receive_ScanCodeBuffer.type );
    5694:	2101      	movs	r1, #1
    5696:	7820      	ldrb	r0, [r4, #0]
    5698:	f00a f890 	bl	f7bc <printHex_op>
				print(" ");
    569c:	4834      	ldr	r0, [pc, #208]	; (5770 <Connect_receive_ScanCode+0x190>)
    569e:	f009 ff67 	bl	f570 <_print>
				printHex( Connect_receive_ScanCodeBuffer.state );
    56a2:	2101      	movs	r1, #1
    56a4:	7860      	ldrb	r0, [r4, #1]
    56a6:	f00a f889 	bl	f7bc <printHex_op>
				print(" ");
    56aa:	4831      	ldr	r0, [pc, #196]	; (5770 <Connect_receive_ScanCode+0x190>)
    56ac:	f009 ff60 	bl	f570 <_print>
				printHex( Connect_receive_ScanCodeBuffer.scanCode );
    56b0:	78a0      	ldrb	r0, [r4, #2]
    56b2:	2101      	movs	r1, #1
    56b4:	f00a f882 	bl	f7bc <printHex_op>
				print( NL );
    56b8:	4829      	ldr	r0, [pc, #164]	; (5760 <Connect_receive_ScanCode+0x180>)
    56ba:	f009 ff59 	bl	f570 <_print>
			Macro_pressReleaseAdd( &Connect_receive_ScanCodeBuffer );
    56be:	4826      	ldr	r0, [pc, #152]	; (5758 <Connect_receive_ScanCode+0x178>)
    56c0:	f002 f87a 	bl	77b8 <Macro_pressReleaseAdd>
    56c4:	e7ad      	b.n	5622 <Connect_receive_ScanCode+0x42>
	else switch ( (*pending_bytes)-- )
    56c6:	4282      	cmp	r2, r0
    56c8:	d01f      	beq.n	570a <Connect_receive_ScanCode+0x12a>
    56ca:	f64f 73ff 	movw	r3, #65535	; 0xffff
    56ce:	429a      	cmp	r2, r3
    56d0:	d126      	bne.n	5720 <Connect_receive_ScanCode+0x140>
		Connect_receive_ScanCodeDeviceId = byte;
    56d2:	4b1f      	ldr	r3, [pc, #124]	; (5750 <Connect_receive_ScanCode+0x170>)
    56d4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    56d8:	701a      	strb	r2, [r3, #0]
		uart_lockTx( UART_Master );
    56da:	4b26      	ldr	r3, [pc, #152]	; (5774 <Connect_receive_ScanCode+0x194>)
    56dc:	78d9      	ldrb	r1, [r3, #3]
    56de:	2900      	cmp	r1, #0
    56e0:	d1fd      	bne.n	56de <Connect_receive_ScanCode+0xfe>
    56e2:	2101      	movs	r1, #1
    56e4:	70d9      	strb	r1, [r3, #3]
    56e6:	7899      	ldrb	r1, [r3, #2]
    56e8:	2904      	cmp	r1, #4
    56ea:	d1fd      	bne.n	56e8 <Connect_receive_ScanCode+0x108>
    56ec:	2000      	movs	r0, #0
    56ee:	7098      	strb	r0, [r3, #2]
		uint8_t header[] = { Command_SYN, SOH, ScanCode, byte };
    56f0:	f44f 738b 	mov.w	r3, #278	; 0x116
    56f4:	f88d 200b 	strb.w	r2, [sp, #11]
    56f8:	f8ad 3008 	strh.w	r3, [sp, #8]
    56fc:	f88d 100a 	strb.w	r1, [sp, #10]
    5700:	2201      	movs	r2, #1
    5702:	a802      	add	r0, sp, #8
    5704:	f7ff fefe 	bl	5504 <Connect_addBytes.part.1>
    5708:	e78b      	b.n	5622 <Connect_receive_ScanCode+0x42>
		*pending_bytes = byte * sizeof( TriggerGuide );
    570a:	a804      	add	r0, sp, #16
    570c:	2201      	movs	r2, #1
    570e:	f810 3d09 	ldrb.w	r3, [r0, #-9]!
    5712:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5716:	802b      	strh	r3, [r5, #0]
		Connect_receive_ScanCodeBufferPos = 0;
    5718:	4b0e      	ldr	r3, [pc, #56]	; (5754 <Connect_receive_ScanCode+0x174>)
    571a:	7019      	strb	r1, [r3, #0]
    571c:	4611      	mov	r1, r2
    571e:	e7f1      	b.n	5704 <Connect_receive_ScanCode+0x124>
    5720:	2201      	movs	r2, #1
    5722:	4611      	mov	r1, r2
    5724:	f10d 0007 	add.w	r0, sp, #7
    5728:	f7ff feec 	bl	5504 <Connect_addBytes.part.1>
		if ( *pending_bytes == 0 )
    572c:	882a      	ldrh	r2, [r5, #0]
    572e:	2a00      	cmp	r2, #0
    5730:	f47f af77 	bne.w	5622 <Connect_receive_ScanCode+0x42>
			uart_unlockTx( UART_Master );
    5734:	4b0f      	ldr	r3, [pc, #60]	; (5774 <Connect_receive_ScanCode+0x194>)
    5736:	2104      	movs	r1, #4
    5738:	7099      	strb	r1, [r3, #2]
    573a:	70da      	strb	r2, [r3, #3]
    573c:	e771      	b.n	5622 <Connect_receive_ScanCode+0x42>
}
    573e:	b005      	add	sp, #20
    5740:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5742:	bf00      	nop
    5744:	1fff89d0 	.word	0x1fff89d0
    5748:	00010df1 	.word	0x00010df1
    574c:	1fff94cc 	.word	0x1fff94cc
    5750:	1fff94d6 	.word	0x1fff94d6
    5754:	1fff94d5 	.word	0x1fff94d5
    5758:	1fff94d2 	.word	0x1fff94d2
    575c:	00010e26 	.word	0x00010e26
    5760:	00015df4 	.word	0x00015df4
    5764:	00011540 	.word	0x00011540
    5768:	1fff94c6 	.word	0x1fff94c6
    576c:	00010e6d 	.word	0x00010e6d
    5770:	00016f5e 	.word	0x00016f5e
    5774:	1fffa15a 	.word	0x1fffa15a

00005778 <Connect_receive_RemoteInput>:
    5778:	b507      	push	{r0, r1, r2, lr}
    577a:	4b08      	ldr	r3, [pc, #32]	; (579c <Connect_receive_RemoteInput+0x24>)
    577c:	681a      	ldr	r2, [r3, #0]
    577e:	9201      	str	r2, [sp, #4]
    5780:	2200      	movs	r2, #0
    5782:	800a      	strh	r2, [r1, #0]
    5784:	9a01      	ldr	r2, [sp, #4]
    5786:	681b      	ldr	r3, [r3, #0]
    5788:	429a      	cmp	r2, r3
    578a:	f04f 0001 	mov.w	r0, #1
    578e:	d001      	beq.n	5794 <Connect_receive_RemoteInput+0x1c>
    5790:	f7fc ffce 	bl	2730 <__stack_chk_fail>
    5794:	b003      	add	sp, #12
    5796:	f85d fb04 	ldr.w	pc, [sp], #4
    579a:	bf00      	nop
    579c:	1fff89d0 	.word	0x1fff89d0

000057a0 <Connect_addBytes>:
{
    57a0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    57a2:	4b11      	ldr	r3, [pc, #68]	; (57e8 <Connect_addBytes+0x48>)
	if ( count > UART_Buffer_Size )
    57a4:	2980      	cmp	r1, #128	; 0x80
{
    57a6:	681d      	ldr	r5, [r3, #0]
    57a8:	9501      	str	r5, [sp, #4]
	if ( count > UART_Buffer_Size )
    57aa:	d90b      	bls.n	57c4 <Connect_addBytes+0x24>
		erro_msg("Too big of a command to fit into the buffer...");
    57ac:	9a01      	ldr	r2, [sp, #4]
    57ae:	681b      	ldr	r3, [r3, #0]
    57b0:	429a      	cmp	r2, r3
    57b2:	d001      	beq.n	57b8 <Connect_addBytes+0x18>
		erro_print("Invalid UART to send from...");
    57b4:	f7fc ffbc 	bl	2730 <__stack_chk_fail>
		erro_msg("Too big of a command to fit into the buffer...");
    57b8:	480c      	ldr	r0, [pc, #48]	; (57ec <Connect_addBytes+0x4c>)
}
    57ba:	b003      	add	sp, #12
    57bc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		erro_print("Invalid UART to send from...");
    57c0:	f009 bed6 	b.w	f570 <_print>
	if ( uart >= UART_Num_Interfaces )
    57c4:	2a01      	cmp	r2, #1
    57c6:	d808      	bhi.n	57da <Connect_addBytes+0x3a>
    57c8:	9c01      	ldr	r4, [sp, #4]
    57ca:	681b      	ldr	r3, [r3, #0]
    57cc:	429c      	cmp	r4, r3
    57ce:	d1f1      	bne.n	57b4 <Connect_addBytes+0x14>
}
    57d0:	b003      	add	sp, #12
    57d2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    57d6:	f7ff be95 	b.w	5504 <Connect_addBytes.part.1>
		erro_print("Invalid UART to send from...");
    57da:	9a01      	ldr	r2, [sp, #4]
    57dc:	681b      	ldr	r3, [r3, #0]
    57de:	429a      	cmp	r2, r3
    57e0:	d1e8      	bne.n	57b4 <Connect_addBytes+0x14>
    57e2:	4803      	ldr	r0, [pc, #12]	; (57f0 <Connect_addBytes+0x50>)
    57e4:	e7e9      	b.n	57ba <Connect_addBytes+0x1a>
    57e6:	bf00      	nop
    57e8:	1fff89d0 	.word	0x1fff89d0
    57ec:	00010bb0 	.word	0x00010bb0
    57f0:	00010bf4 	.word	0x00010bf4

000057f4 <Connect_receive_RemoteCapability>:
{
    57f4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    57f8:	460f      	mov	r7, r1
    57fa:	4943      	ldr	r1, [pc, #268]	; (5908 <Connect_receive_RemoteCapability+0x114>)
    57fc:	4c43      	ldr	r4, [pc, #268]	; (590c <Connect_receive_RemoteCapability+0x118>)
    57fe:	680b      	ldr	r3, [r1, #0]
    5800:	9301      	str	r3, [sp, #4]
	switch ( (*pending_bytes)-- )
    5802:	883b      	ldrh	r3, [r7, #0]
{
    5804:	4616      	mov	r6, r2
	switch ( (*pending_bytes)-- )
    5806:	1e5a      	subs	r2, r3, #1
    5808:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
    580c:	b292      	uxth	r2, r2
    580e:	3bfb      	subs	r3, #251	; 0xfb
    5810:	803a      	strh	r2, [r7, #0]
    5812:	4688      	mov	r8, r1
    5814:	2b04      	cmp	r3, #4
    5816:	d81a      	bhi.n	584e <Connect_receive_RemoteCapability+0x5a>
    5818:	e8df f003 	tbb	[pc, r3]
    581c:	10121416 	.word	0x10121416
    5820:	03          	.byte	0x03
    5821:	00          	.byte	0x00
		Connect_receive_RemoteCapabilityBuffer.id = byte;
    5822:	7060      	strb	r0, [r4, #1]
}
    5824:	9a01      	ldr	r2, [sp, #4]
	return *pending_bytes == 0 ? 1 : 0;
    5826:	8838      	ldrh	r0, [r7, #0]
}
    5828:	f8d8 3000 	ldr.w	r3, [r8]
    582c:	fab0 f080 	clz	r0, r0
    5830:	429a      	cmp	r2, r3
    5832:	ea4f 1050 	mov.w	r0, r0, lsr #5
    5836:	d063      	beq.n	5900 <Connect_receive_RemoteCapability+0x10c>
    5838:	f7fc ff7a 	bl	2730 <__stack_chk_fail>
		Connect_receive_RemoteCapabilityBuffer.capabilityIndex = byte;
    583c:	70a0      	strb	r0, [r4, #2]
		break;
    583e:	e7f1      	b.n	5824 <Connect_receive_RemoteCapability+0x30>
		Connect_receive_RemoteCapabilityBuffer.state = byte;
    5840:	70e0      	strb	r0, [r4, #3]
		break;
    5842:	e7ef      	b.n	5824 <Connect_receive_RemoteCapability+0x30>
		Connect_receive_RemoteCapabilityBuffer.stateType = byte;
    5844:	7120      	strb	r0, [r4, #4]
		break;
    5846:	e7ed      	b.n	5824 <Connect_receive_RemoteCapability+0x30>
		Connect_receive_RemoteCapabilityBuffer.numArgs = byte;
    5848:	7160      	strb	r0, [r4, #5]
		*pending_bytes = byte;
    584a:	8038      	strh	r0, [r7, #0]
		break;
    584c:	e7ea      	b.n	5824 <Connect_receive_RemoteCapability+0x30>
			Connect_receive_RemoteCapabilityBuffer.numArgs - *pending_bytes + 1
    584e:	7963      	ldrb	r3, [r4, #5]
    5850:	1a9b      	subs	r3, r3, r2
		] = byte;
    5852:	4a2f      	ldr	r2, [pc, #188]	; (5910 <Connect_receive_RemoteCapability+0x11c>)
    5854:	441a      	add	r2, r3
    5856:	7050      	strb	r0, [r2, #1]
		if ( *pending_bytes == 0 )
    5858:	883b      	ldrh	r3, [r7, #0]
    585a:	2b00      	cmp	r3, #0
    585c:	d1e2      	bne.n	5824 <Connect_receive_RemoteCapability+0x30>
			if ( Connect_receive_RemoteCapabilityBuffer.id == BROADCAST_ID
    585e:	7863      	ldrb	r3, [r4, #1]
    5860:	2bff      	cmp	r3, #255	; 0xff
    5862:	d003      	beq.n	586c <Connect_receive_RemoteCapability+0x78>
				|| Connect_receive_RemoteCapabilityBuffer.id == Connect_id )
    5864:	4a2b      	ldr	r2, [pc, #172]	; (5914 <Connect_receive_RemoteCapability+0x120>)
    5866:	7812      	ldrb	r2, [r2, #0]
    5868:	429a      	cmp	r2, r3
    586a:	d108      	bne.n	587e <Connect_receive_RemoteCapability+0x8a>
							Connect_receive_RemoteCapabilityBuffer.capabilityIndex
    586c:	78a2      	ldrb	r2, [r4, #2]
				capability(
    586e:	4b2a      	ldr	r3, [pc, #168]	; (5918 <Connect_receive_RemoteCapability+0x124>)
    5870:	78e1      	ldrb	r1, [r4, #3]
    5872:	f853 5032 	ldr.w	r5, [r3, r2, lsl #3]
    5876:	4b29      	ldr	r3, [pc, #164]	; (591c <Connect_receive_RemoteCapability+0x128>)
    5878:	7922      	ldrb	r2, [r4, #4]
    587a:	2000      	movs	r0, #0
    587c:	47a8      	blx	r5
			if ( Connect_receive_RemoteCapabilityBuffer.id == BROADCAST_ID
    587e:	7863      	ldrb	r3, [r4, #1]
    5880:	2bff      	cmp	r3, #255	; 0xff
    5882:	d003      	beq.n	588c <Connect_receive_RemoteCapability+0x98>
				|| Connect_receive_RemoteCapabilityBuffer.id != Connect_id )
    5884:	4a23      	ldr	r2, [pc, #140]	; (5914 <Connect_receive_RemoteCapability+0x120>)
    5886:	7812      	ldrb	r2, [r2, #0]
    5888:	429a      	cmp	r2, r3
    588a:	d0cb      	beq.n	5824 <Connect_receive_RemoteCapability+0x30>
				uint8_t uart_direction = uart_num == UART_Master ? UART_Slave : UART_Master;
    588c:	f116 36ff 	adds.w	r6, r6, #4294967295	; 0xffffffff
				Connect_receive_RemoteCapabilityBuffer.command = RemoteCapability;
    5890:	f04f 0306 	mov.w	r3, #6
				uint8_t uart_direction = uart_num == UART_Master ? UART_Slave : UART_Master;
    5894:	bf18      	it	ne
    5896:	2601      	movne	r6, #1
				Connect_receive_RemoteCapabilityBuffer.command = RemoteCapability;
    5898:	7023      	strb	r3, [r4, #0]
    589a:	4d21      	ldr	r5, [pc, #132]	; (5920 <Connect_receive_RemoteCapability+0x12c>)
				switch ( uart_direction )
    589c:	b316      	cbz	r6, 58e4 <Connect_receive_RemoteCapability+0xf0>
				case UART_Master: uart_lockTx( UART_Master ); break;
    589e:	78eb      	ldrb	r3, [r5, #3]
    58a0:	2b00      	cmp	r3, #0
    58a2:	d1fd      	bne.n	58a0 <Connect_receive_RemoteCapability+0xac>
    58a4:	2301      	movs	r3, #1
    58a6:	70eb      	strb	r3, [r5, #3]
    58a8:	78ab      	ldrb	r3, [r5, #2]
    58aa:	2b04      	cmp	r3, #4
    58ac:	d1fd      	bne.n	58aa <Connect_receive_RemoteCapability+0xb6>
    58ae:	2300      	movs	r3, #0
    58b0:	70ab      	strb	r3, [r5, #2]
				uint8_t header[] = { Command_SYN, SOH };
    58b2:	4b1c      	ldr	r3, [pc, #112]	; (5924 <Connect_receive_RemoteCapability+0x130>)
				Connect_addBytes( header, sizeof( header ), uart_direction );
    58b4:	4632      	mov	r2, r6
				uint8_t header[] = { Command_SYN, SOH };
    58b6:	881b      	ldrh	r3, [r3, #0]
    58b8:	f8ad 3000 	strh.w	r3, [sp]
				Connect_addBytes( header, sizeof( header ), uart_direction );
    58bc:	2102      	movs	r1, #2
    58be:	4668      	mov	r0, sp
    58c0:	f7ff ff6e 	bl	57a0 <Connect_addBytes>
				Connect_addBytes( (uint8_t*)&Connect_receive_RemoteCapabilityBuffer, sizeof( RemoteCapabilityCommand ), uart_direction );
    58c4:	4632      	mov	r2, r6
    58c6:	2106      	movs	r1, #6
    58c8:	4810      	ldr	r0, [pc, #64]	; (590c <Connect_receive_RemoteCapability+0x118>)
    58ca:	f7ff ff69 	bl	57a0 <Connect_addBytes>
				Connect_addBytes( Connect_receive_RemoteCapabilityArgs, Connect_receive_RemoteCapabilityBuffer.numArgs, uart_direction );
    58ce:	4632      	mov	r2, r6
    58d0:	7961      	ldrb	r1, [r4, #5]
    58d2:	480f      	ldr	r0, [pc, #60]	; (5910 <Connect_receive_RemoteCapability+0x11c>)
    58d4:	f7ff ff64 	bl	57a0 <Connect_addBytes>
    58d8:	2300      	movs	r3, #0
    58da:	2204      	movs	r2, #4
				switch ( uart_direction )
    58dc:	b16e      	cbz	r6, 58fa <Connect_receive_RemoteCapability+0x106>
				case UART_Master: uart_unlockTx( UART_Master ); break;
    58de:	70aa      	strb	r2, [r5, #2]
    58e0:	70eb      	strb	r3, [r5, #3]
    58e2:	e79f      	b.n	5824 <Connect_receive_RemoteCapability+0x30>
				case UART_Slave:  uart_lockTx( UART_Slave );  break;
    58e4:	786b      	ldrb	r3, [r5, #1]
    58e6:	2b00      	cmp	r3, #0
    58e8:	d1fd      	bne.n	58e6 <Connect_receive_RemoteCapability+0xf2>
    58ea:	2301      	movs	r3, #1
    58ec:	706b      	strb	r3, [r5, #1]
    58ee:	782b      	ldrb	r3, [r5, #0]
    58f0:	2b04      	cmp	r3, #4
    58f2:	d1fd      	bne.n	58f0 <Connect_receive_RemoteCapability+0xfc>
    58f4:	2300      	movs	r3, #0
    58f6:	702b      	strb	r3, [r5, #0]
    58f8:	e7db      	b.n	58b2 <Connect_receive_RemoteCapability+0xbe>
				case UART_Slave:  uart_unlockTx( UART_Slave );  break;
    58fa:	702a      	strb	r2, [r5, #0]
    58fc:	706b      	strb	r3, [r5, #1]
    58fe:	e791      	b.n	5824 <Connect_receive_RemoteCapability+0x30>
}
    5900:	b002      	add	sp, #8
    5902:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5906:	bf00      	nop
    5908:	1fff89d0 	.word	0x1fff89d0
    590c:	1fffa154 	.word	0x1fffa154
    5910:	1fffa15e 	.word	0x1fffa15e
    5914:	1fff89e2 	.word	0x1fff89e2
    5918:	00011460 	.word	0x00011460
    591c:	1fffa160 	.word	0x1fffa160
    5920:	1fffa15a 	.word	0x1fffa15a
    5924:	00010b60 	.word	0x00010b60

00005928 <Connect_send_CableCheck>:
{
    5928:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    592c:	4f24      	ldr	r7, [pc, #144]	; (59c0 <Connect_send_CableCheck+0x98>)
	uart_lockBothTx( UART_Master, UART_Slave );
    592e:	4c25      	ldr	r4, [pc, #148]	; (59c4 <Connect_send_CableCheck+0x9c>)
{
    5930:	683b      	ldr	r3, [r7, #0]
    5932:	9303      	str	r3, [sp, #12]
	uart_lockBothTx( UART_Master, UART_Slave );
    5934:	78e2      	ldrb	r2, [r4, #3]
    5936:	7863      	ldrb	r3, [r4, #1]
{
    5938:	4680      	mov	r8, r0
	uart_lockBothTx( UART_Master, UART_Slave );
    593a:	2a00      	cmp	r2, #0
    593c:	d1fd      	bne.n	593a <Connect_send_CableCheck+0x12>
    593e:	2b00      	cmp	r3, #0
    5940:	d1fd      	bne.n	593e <Connect_send_CableCheck+0x16>
    5942:	2301      	movs	r3, #1
    5944:	70e3      	strb	r3, [r4, #3]
    5946:	7063      	strb	r3, [r4, #1]
    5948:	7826      	ldrb	r6, [r4, #0]
    594a:	78a3      	ldrb	r3, [r4, #2]
    594c:	2b04      	cmp	r3, #4
    594e:	d1fd      	bne.n	594c <Connect_send_CableCheck+0x24>
    5950:	2e04      	cmp	r6, #4
    5952:	d1fd      	bne.n	5950 <Connect_send_CableCheck+0x28>
    5954:	2500      	movs	r5, #0
	uint8_t header[] = { Command_SYN, SOH, CableCheck, patternLen };
    5956:	f44f 738b 	mov.w	r3, #278	; 0x116
    595a:	4631      	mov	r1, r6
    595c:	2201      	movs	r2, #1
    595e:	a802      	add	r0, sp, #8
    5960:	f8ad 3008 	strh.w	r3, [sp, #8]
	uart_lockBothTx( UART_Master, UART_Slave );
    5964:	70a5      	strb	r5, [r4, #2]
    5966:	7025      	strb	r5, [r4, #0]
	uint8_t header[] = { Command_SYN, SOH, CableCheck, patternLen };
    5968:	f88d 500a 	strb.w	r5, [sp, #10]
    596c:	f88d 800b 	strb.w	r8, [sp, #11]
    5970:	f7ff fdc8 	bl	5504 <Connect_addBytes.part.1>
    5974:	4631      	mov	r1, r6
    5976:	462a      	mov	r2, r5
    5978:	a802      	add	r0, sp, #8
	uint8_t value = CABLE_CHECK_ARG;
    597a:	ae04      	add	r6, sp, #16
    597c:	f7ff fdc2 	bl	5504 <Connect_addBytes.part.1>
    5980:	23d2      	movs	r3, #210	; 0xd2
    5982:	f806 3d09 	strb.w	r3, [r6, #-9]!
	for ( uint8_t c = 0; c < patternLen; c++ )
    5986:	4545      	cmp	r5, r8
    5988:	d10b      	bne.n	59a2 <Connect_send_CableCheck+0x7a>
	uart_unlockTx( UART_Master );
    598a:	2204      	movs	r2, #4
    598c:	2300      	movs	r3, #0
    598e:	70a2      	strb	r2, [r4, #2]
    5990:	70e3      	strb	r3, [r4, #3]
	uart_unlockTx( UART_Slave );
    5992:	7022      	strb	r2, [r4, #0]
    5994:	7063      	strb	r3, [r4, #1]
}
    5996:	9a03      	ldr	r2, [sp, #12]
    5998:	683b      	ldr	r3, [r7, #0]
    599a:	429a      	cmp	r2, r3
    599c:	d00d      	beq.n	59ba <Connect_send_CableCheck+0x92>
    599e:	f7fc fec7 	bl	2730 <__stack_chk_fail>
    59a2:	2201      	movs	r2, #1
    59a4:	4611      	mov	r1, r2
    59a6:	4630      	mov	r0, r6
    59a8:	f7ff fdac 	bl	5504 <Connect_addBytes.part.1>
    59ac:	2200      	movs	r2, #0
    59ae:	2101      	movs	r1, #1
    59b0:	4630      	mov	r0, r6
    59b2:	f7ff fda7 	bl	5504 <Connect_addBytes.part.1>
    59b6:	3501      	adds	r5, #1
    59b8:	e7e5      	b.n	5986 <Connect_send_CableCheck+0x5e>
    59ba:	b004      	add	sp, #16
    59bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    59c0:	1fff89d0 	.word	0x1fff89d0
    59c4:	1fffa15a 	.word	0x1fffa15a

000059c8 <Connect_send_IdRequest>:
{
    59c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    59ca:	4f12      	ldr	r7, [pc, #72]	; (5a14 <Connect_send_IdRequest+0x4c>)
	uart_lockTx( UART_Master );
    59cc:	4c12      	ldr	r4, [pc, #72]	; (5a18 <Connect_send_IdRequest+0x50>)
{
    59ce:	683a      	ldr	r2, [r7, #0]
    59d0:	9201      	str	r2, [sp, #4]
	uart_lockTx( UART_Master );
    59d2:	78e2      	ldrb	r2, [r4, #3]
    59d4:	2a00      	cmp	r2, #0
    59d6:	d1fd      	bne.n	59d4 <Connect_send_IdRequest+0xc>
    59d8:	2301      	movs	r3, #1
    59da:	78a6      	ldrb	r6, [r4, #2]
    59dc:	70e3      	strb	r3, [r4, #3]
    59de:	2e04      	cmp	r6, #4
    59e0:	d1fd      	bne.n	59de <Connect_send_IdRequest+0x16>
	uint8_t header[] = { Command_SYN, SOH, IdRequest };
    59e2:	4b0e      	ldr	r3, [pc, #56]	; (5a1c <Connect_send_IdRequest+0x54>)
    59e4:	881a      	ldrh	r2, [r3, #0]
    59e6:	f8ad 2000 	strh.w	r2, [sp]
    59ea:	789b      	ldrb	r3, [r3, #2]
    59ec:	f88d 3002 	strb.w	r3, [sp, #2]
	uart_lockTx( UART_Master );
    59f0:	2500      	movs	r5, #0
    59f2:	2201      	movs	r2, #1
    59f4:	2103      	movs	r1, #3
    59f6:	4668      	mov	r0, sp
    59f8:	70a5      	strb	r5, [r4, #2]
    59fa:	f7ff fd83 	bl	5504 <Connect_addBytes.part.1>
}
    59fe:	9a01      	ldr	r2, [sp, #4]
    5a00:	683b      	ldr	r3, [r7, #0]
	uart_unlockTx( UART_Master );
    5a02:	70a6      	strb	r6, [r4, #2]
}
    5a04:	429a      	cmp	r2, r3
	uart_unlockTx( UART_Master );
    5a06:	70e5      	strb	r5, [r4, #3]
}
    5a08:	d001      	beq.n	5a0e <Connect_send_IdRequest+0x46>
    5a0a:	f7fc fe91 	bl	2730 <__stack_chk_fail>
    5a0e:	b003      	add	sp, #12
    5a10:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5a12:	bf00      	nop
    5a14:	1fff89d0 	.word	0x1fff89d0
    5a18:	1fffa15a 	.word	0x1fffa15a
    5a1c:	00010b62 	.word	0x00010b62

00005a20 <Connect_send_IdEnumeration>:
{
    5a20:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5a22:	4f13      	ldr	r7, [pc, #76]	; (5a70 <Connect_send_IdEnumeration+0x50>)
	uart_lockTx( UART_Slave );
    5a24:	4c13      	ldr	r4, [pc, #76]	; (5a74 <Connect_send_IdEnumeration+0x54>)
{
    5a26:	683a      	ldr	r2, [r7, #0]
    5a28:	9201      	str	r2, [sp, #4]
	uart_lockTx( UART_Slave );
    5a2a:	7862      	ldrb	r2, [r4, #1]
    5a2c:	2a00      	cmp	r2, #0
    5a2e:	d1fd      	bne.n	5a2c <Connect_send_IdEnumeration+0xc>
    5a30:	2301      	movs	r3, #1
    5a32:	7826      	ldrb	r6, [r4, #0]
    5a34:	7063      	strb	r3, [r4, #1]
    5a36:	2e04      	cmp	r6, #4
    5a38:	d1fd      	bne.n	5a36 <Connect_send_IdEnumeration+0x16>
    5a3a:	2500      	movs	r5, #0
	uint8_t header[] = { Command_SYN, SOH, IdEnumeration, id };
    5a3c:	f44f 738b 	mov.w	r3, #278	; 0x116
    5a40:	f8ad 3000 	strh.w	r3, [sp]
    5a44:	f88d 0003 	strb.w	r0, [sp, #3]
    5a48:	2302      	movs	r3, #2
    5a4a:	462a      	mov	r2, r5
    5a4c:	4631      	mov	r1, r6
    5a4e:	4668      	mov	r0, sp
    5a50:	f88d 3002 	strb.w	r3, [sp, #2]
	uart_lockTx( UART_Slave );
    5a54:	7025      	strb	r5, [r4, #0]
    5a56:	f7ff fd55 	bl	5504 <Connect_addBytes.part.1>
}
    5a5a:	9a01      	ldr	r2, [sp, #4]
    5a5c:	683b      	ldr	r3, [r7, #0]
	uart_unlockTx( UART_Slave );
    5a5e:	7026      	strb	r6, [r4, #0]
}
    5a60:	429a      	cmp	r2, r3
	uart_unlockTx( UART_Slave );
    5a62:	7065      	strb	r5, [r4, #1]
}
    5a64:	d001      	beq.n	5a6a <Connect_send_IdEnumeration+0x4a>
    5a66:	f7fc fe63 	bl	2730 <__stack_chk_fail>
    5a6a:	b003      	add	sp, #12
    5a6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5a6e:	bf00      	nop
    5a70:	1fff89d0 	.word	0x1fff89d0
    5a74:	1fffa15a 	.word	0x1fffa15a

00005a78 <Connect_receive_IdRequest>:
{
    5a78:	b537      	push	{r0, r1, r2, r4, r5, lr}
    5a7a:	4c0f      	ldr	r4, [pc, #60]	; (5ab8 <Connect_receive_IdRequest+0x40>)
	dbug_print("IdRequest");
    5a7c:	480f      	ldr	r0, [pc, #60]	; (5abc <Connect_receive_IdRequest+0x44>)
{
    5a7e:	6823      	ldr	r3, [r4, #0]
    5a80:	9301      	str	r3, [sp, #4]
    5a82:	4615      	mov	r5, r2
	dbug_print("IdRequest");
    5a84:	f009 fd74 	bl	f570 <_print>
	if ( uart_num == UART_Master )
    5a88:	2d01      	cmp	r5, #1
    5a8a:	d102      	bne.n	5a92 <Connect_receive_IdRequest+0x1a>
		erro_print("Invalid IdRequest direction...");
    5a8c:	480c      	ldr	r0, [pc, #48]	; (5ac0 <Connect_receive_IdRequest+0x48>)
    5a8e:	f009 fd6f 	bl	f570 <_print>
	if ( Connect_master )
    5a92:	4b0c      	ldr	r3, [pc, #48]	; (5ac4 <Connect_receive_IdRequest+0x4c>)
    5a94:	781b      	ldrb	r3, [r3, #0]
    5a96:	b153      	cbz	r3, 5aae <Connect_receive_IdRequest+0x36>
		Connect_send_IdEnumeration( 1 );
    5a98:	2001      	movs	r0, #1
    5a9a:	f7ff ffc1 	bl	5a20 <Connect_send_IdEnumeration>
}
    5a9e:	9a01      	ldr	r2, [sp, #4]
    5aa0:	6823      	ldr	r3, [r4, #0]
    5aa2:	429a      	cmp	r2, r3
    5aa4:	f04f 0001 	mov.w	r0, #1
    5aa8:	d004      	beq.n	5ab4 <Connect_receive_IdRequest+0x3c>
    5aaa:	f7fc fe41 	bl	2730 <__stack_chk_fail>
		Connect_send_IdRequest();
    5aae:	f7ff ff8b 	bl	59c8 <Connect_send_IdRequest>
    5ab2:	e7f4      	b.n	5a9e <Connect_receive_IdRequest+0x26>
}
    5ab4:	b003      	add	sp, #12
    5ab6:	bd30      	pop	{r4, r5, pc}
    5ab8:	1fff89d0 	.word	0x1fff89d0
    5abc:	00010d9c 	.word	0x00010d9c
    5ac0:	00010dbb 	.word	0x00010dbb
    5ac4:	1fff94cc 	.word	0x1fff94cc

00005ac8 <Connect_send_IdReport>:
{
    5ac8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5aca:	4f13      	ldr	r7, [pc, #76]	; (5b18 <Connect_send_IdReport+0x50>)
	uart_lockTx( UART_Master );
    5acc:	4c13      	ldr	r4, [pc, #76]	; (5b1c <Connect_send_IdReport+0x54>)
{
    5ace:	683a      	ldr	r2, [r7, #0]
    5ad0:	9201      	str	r2, [sp, #4]
	uart_lockTx( UART_Master );
    5ad2:	78e2      	ldrb	r2, [r4, #3]
    5ad4:	2a00      	cmp	r2, #0
    5ad6:	d1fd      	bne.n	5ad4 <Connect_send_IdReport+0xc>
    5ad8:	2301      	movs	r3, #1
    5ada:	78a5      	ldrb	r5, [r4, #2]
    5adc:	70e3      	strb	r3, [r4, #3]
    5ade:	2d04      	cmp	r5, #4
    5ae0:	d1fd      	bne.n	5ade <Connect_send_IdReport+0x16>
	uint8_t header[] = { Command_SYN, SOH, IdReport, id };
    5ae2:	f44f 738b 	mov.w	r3, #278	; 0x116
	uart_lockTx( UART_Master );
    5ae6:	2600      	movs	r6, #0
	uint8_t header[] = { Command_SYN, SOH, IdReport, id };
    5ae8:	f8ad 3000 	strh.w	r3, [sp]
    5aec:	f88d 0003 	strb.w	r0, [sp, #3]
    5af0:	2303      	movs	r3, #3
    5af2:	2201      	movs	r2, #1
    5af4:	4629      	mov	r1, r5
    5af6:	4668      	mov	r0, sp
    5af8:	f88d 3002 	strb.w	r3, [sp, #2]
	uart_lockTx( UART_Master );
    5afc:	70a6      	strb	r6, [r4, #2]
    5afe:	f7ff fd01 	bl	5504 <Connect_addBytes.part.1>
}
    5b02:	9a01      	ldr	r2, [sp, #4]
    5b04:	683b      	ldr	r3, [r7, #0]
	uart_unlockTx( UART_Master );
    5b06:	70a5      	strb	r5, [r4, #2]
}
    5b08:	429a      	cmp	r2, r3
	uart_unlockTx( UART_Master );
    5b0a:	70e6      	strb	r6, [r4, #3]
}
    5b0c:	d001      	beq.n	5b12 <Connect_send_IdReport+0x4a>
    5b0e:	f7fc fe0f 	bl	2730 <__stack_chk_fail>
    5b12:	b003      	add	sp, #12
    5b14:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5b16:	bf00      	nop
    5b18:	1fff89d0 	.word	0x1fff89d0
    5b1c:	1fffa15a 	.word	0x1fffa15a

00005b20 <Connect_receive_IdEnumeration>:
{
    5b20:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5b22:	4e14      	ldr	r6, [pc, #80]	; (5b74 <Connect_receive_IdEnumeration+0x54>)
    5b24:	4604      	mov	r4, r0
    5b26:	4617      	mov	r7, r2
    5b28:	6833      	ldr	r3, [r6, #0]
	dbug_print("IdEnumeration");
    5b2a:	4813      	ldr	r0, [pc, #76]	; (5b78 <Connect_receive_IdEnumeration+0x58>)
{
    5b2c:	9301      	str	r3, [sp, #4]
	dbug_print("IdEnumeration");
    5b2e:	f009 fd1f 	bl	f570 <_print>
	if ( uart_num == UART_Slave )
    5b32:	b917      	cbnz	r7, 5b3a <Connect_receive_IdEnumeration+0x1a>
		erro_print("Invalid IdEnumeration direction...");
    5b34:	4811      	ldr	r0, [pc, #68]	; (5b7c <Connect_receive_IdEnumeration+0x5c>)
    5b36:	f009 fd1b 	bl	f570 <_print>
	Connect_id = id;
    5b3a:	4d11      	ldr	r5, [pc, #68]	; (5b80 <Connect_receive_IdEnumeration+0x60>)
	Connect_send_IdReport( id );
    5b3c:	4620      	mov	r0, r4
	Connect_id = id;
    5b3e:	702c      	strb	r4, [r5, #0]
	Connect_send_IdReport( id );
    5b40:	f7ff ffc2 	bl	5ac8 <Connect_send_IdReport>
	if ( Connect_id != 0 )
    5b44:	782b      	ldrb	r3, [r5, #0]
    5b46:	b11b      	cbz	r3, 5b50 <Connect_receive_IdEnumeration+0x30>
		Output_update_external_current( Connect_LastCurrentValue );
    5b48:	4b0e      	ldr	r3, [pc, #56]	; (5b84 <Connect_receive_IdEnumeration+0x64>)
    5b4a:	8818      	ldrh	r0, [r3, #0]
    5b4c:	f006 f8aa 	bl	bca4 <Output_update_external_current>
	if ( Connect_cableOkSlave )
    5b50:	4b0d      	ldr	r3, [pc, #52]	; (5b88 <Connect_receive_IdEnumeration+0x68>)
    5b52:	781b      	ldrb	r3, [r3, #0]
    5b54:	b11b      	cbz	r3, 5b5e <Connect_receive_IdEnumeration+0x3e>
		Connect_send_IdEnumeration( id + 1 );
    5b56:	1c60      	adds	r0, r4, #1
    5b58:	b2c0      	uxtb	r0, r0
    5b5a:	f7ff ff61 	bl	5a20 <Connect_send_IdEnumeration>
}
    5b5e:	9a01      	ldr	r2, [sp, #4]
    5b60:	6833      	ldr	r3, [r6, #0]
    5b62:	429a      	cmp	r2, r3
    5b64:	f04f 0001 	mov.w	r0, #1
    5b68:	d001      	beq.n	5b6e <Connect_receive_IdEnumeration+0x4e>
    5b6a:	f7fc fde1 	bl	2730 <__stack_chk_fail>
    5b6e:	b003      	add	sp, #12
    5b70:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5b72:	bf00      	nop
    5b74:	1fff89d0 	.word	0x1fff89d0
    5b78:	00010d01 	.word	0x00010d01
    5b7c:	00010d24 	.word	0x00010d24
    5b80:	1fff89e2 	.word	0x1fff89e2
    5b84:	1fff94ae 	.word	0x1fff94ae
    5b88:	1fff94c5 	.word	0x1fff94c5

00005b8c <Connect_send_ScanCode>:
{
    5b8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5b90:	4b19      	ldr	r3, [pc, #100]	; (5bf8 <Connect_send_ScanCode+0x6c>)
	uart_lockTx( UART_Master );
    5b92:	4c1a      	ldr	r4, [pc, #104]	; (5bfc <Connect_send_ScanCode+0x70>)
{
    5b94:	b085      	sub	sp, #20
    5b96:	4617      	mov	r7, r2
    5b98:	681a      	ldr	r2, [r3, #0]
    5b9a:	9203      	str	r2, [sp, #12]
	uart_lockTx( UART_Master );
    5b9c:	78e2      	ldrb	r2, [r4, #3]
{
    5b9e:	4689      	mov	r9, r1
    5ba0:	4698      	mov	r8, r3
	uart_lockTx( UART_Master );
    5ba2:	2a00      	cmp	r2, #0
    5ba4:	d1fd      	bne.n	5ba2 <Connect_send_ScanCode+0x16>
    5ba6:	2301      	movs	r3, #1
    5ba8:	78a5      	ldrb	r5, [r4, #2]
    5baa:	70e3      	strb	r3, [r4, #3]
    5bac:	2d04      	cmp	r5, #4
    5bae:	d1fd      	bne.n	5bac <Connect_send_ScanCode+0x20>
	uint8_t header[] = { Command_SYN, SOH, ScanCode, id, numScanCodes };
    5bb0:	f44f 738b 	mov.w	r3, #278	; 0x116
	uart_lockTx( UART_Master );
    5bb4:	2600      	movs	r6, #0
	uint8_t header[] = { Command_SYN, SOH, ScanCode, id, numScanCodes };
    5bb6:	f88d 0007 	strb.w	r0, [sp, #7]
    5bba:	f88d 7008 	strb.w	r7, [sp, #8]
    5bbe:	2201      	movs	r2, #1
    5bc0:	2105      	movs	r1, #5
    5bc2:	a801      	add	r0, sp, #4
	Connect_addBytes( (uint8_t*)scanCodeStateList, numScanCodes * TriggerGuideSize, UART_Master );
    5bc4:	eb07 0747 	add.w	r7, r7, r7, lsl #1
	uint8_t header[] = { Command_SYN, SOH, ScanCode, id, numScanCodes };
    5bc8:	f8ad 3004 	strh.w	r3, [sp, #4]
	uart_lockTx( UART_Master );
    5bcc:	70a6      	strb	r6, [r4, #2]
	uint8_t header[] = { Command_SYN, SOH, ScanCode, id, numScanCodes };
    5bce:	f88d 5006 	strb.w	r5, [sp, #6]
    5bd2:	f7ff fc97 	bl	5504 <Connect_addBytes.part.1>
	Connect_addBytes( (uint8_t*)scanCodeStateList, numScanCodes * TriggerGuideSize, UART_Master );
    5bd6:	2201      	movs	r2, #1
    5bd8:	b2f9      	uxtb	r1, r7
    5bda:	4648      	mov	r0, r9
    5bdc:	f7ff fde0 	bl	57a0 <Connect_addBytes>
}
    5be0:	9a03      	ldr	r2, [sp, #12]
    5be2:	f8d8 3000 	ldr.w	r3, [r8]
	uart_unlockTx( UART_Master );
    5be6:	70a5      	strb	r5, [r4, #2]
}
    5be8:	429a      	cmp	r2, r3
	uart_unlockTx( UART_Master );
    5bea:	70e6      	strb	r6, [r4, #3]
}
    5bec:	d001      	beq.n	5bf2 <Connect_send_ScanCode+0x66>
    5bee:	f7fc fd9f 	bl	2730 <__stack_chk_fail>
    5bf2:	b005      	add	sp, #20
    5bf4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    5bf8:	1fff89d0 	.word	0x1fff89d0
    5bfc:	1fffa15a 	.word	0x1fffa15a

00005c00 <Connect_send_RemoteCapability>:
{
    5c00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5c04:	b085      	sub	sp, #20
    5c06:	4d32      	ldr	r5, [pc, #200]	; (5cd0 <Connect_send_RemoteCapability+0xd0>)
	uint8_t header[] = { Command_SYN, SOH, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    5c08:	f88d 300a 	strb.w	r3, [sp, #10]
	if ( id == Connect_id )
    5c0c:	4b31      	ldr	r3, [pc, #196]	; (5cd4 <Connect_send_RemoteCapability+0xd4>)
	uint8_t header[] = { Command_SYN, SOH, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    5c0e:	f88d 2009 	strb.w	r2, [sp, #9]
{
    5c12:	4682      	mov	sl, r0
	if ( id == Connect_id )
    5c14:	781a      	ldrb	r2, [r3, #0]
{
    5c16:	6828      	ldr	r0, [r5, #0]
    5c18:	9003      	str	r0, [sp, #12]
	uint8_t header[] = { Command_SYN, SOH, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    5c1a:	f44f 708b 	mov.w	r0, #278	; 0x116
{
    5c1e:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	uint8_t header[] = { Command_SYN, SOH, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    5c22:	f8ad 0004 	strh.w	r0, [sp, #4]
	if ( id == Connect_id )
    5c26:	4552      	cmp	r2, sl
	uint8_t header[] = { Command_SYN, SOH, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    5c28:	f04f 0006 	mov.w	r0, #6
{
    5c2c:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
	uint8_t header[] = { Command_SYN, SOH, RemoteCapability, id, capabilityIndex, state, stateType, numArgs };
    5c30:	f88d 0006 	strb.w	r0, [sp, #6]
    5c34:	f88d a007 	strb.w	sl, [sp, #7]
    5c38:	f88d 1008 	strb.w	r1, [sp, #8]
    5c3c:	f88d 700b 	strb.w	r7, [sp, #11]
    5c40:	469b      	mov	fp, r3
	if ( id == Connect_id )
    5c42:	d03b      	beq.n	5cbc <Connect_send_RemoteCapability+0xbc>
	if ( id > Connect_id )
    5c44:	d219      	bcs.n	5c7a <Connect_send_RemoteCapability+0x7a>
		uart_lockTx( UART_Slave );
    5c46:	4c24      	ldr	r4, [pc, #144]	; (5cd8 <Connect_send_RemoteCapability+0xd8>)
    5c48:	7863      	ldrb	r3, [r4, #1]
    5c4a:	2b00      	cmp	r3, #0
    5c4c:	d1fd      	bne.n	5c4a <Connect_send_RemoteCapability+0x4a>
    5c4e:	2301      	movs	r3, #1
    5c50:	f894 9000 	ldrb.w	r9, [r4]
    5c54:	7063      	strb	r3, [r4, #1]
    5c56:	f1b9 0f04 	cmp.w	r9, #4
    5c5a:	d1fc      	bne.n	5c56 <Connect_send_RemoteCapability+0x56>
    5c5c:	2600      	movs	r6, #0
    5c5e:	4632      	mov	r2, r6
    5c60:	2108      	movs	r1, #8
    5c62:	a801      	add	r0, sp, #4
    5c64:	7026      	strb	r6, [r4, #0]
    5c66:	f7ff fc4d 	bl	5504 <Connect_addBytes.part.1>
		Connect_addBytes( args, numArgs, UART_Slave );
    5c6a:	4632      	mov	r2, r6
    5c6c:	4639      	mov	r1, r7
    5c6e:	4640      	mov	r0, r8
    5c70:	f7ff fd96 	bl	57a0 <Connect_addBytes>
		uart_unlockTx( UART_Slave );
    5c74:	f884 9000 	strb.w	r9, [r4]
    5c78:	7066      	strb	r6, [r4, #1]
	if ( id < Connect_id || id == 255 )
    5c7a:	f89b 3000 	ldrb.w	r3, [fp]
    5c7e:	4553      	cmp	r3, sl
    5c80:	d802      	bhi.n	5c88 <Connect_send_RemoteCapability+0x88>
    5c82:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
    5c86:	d119      	bne.n	5cbc <Connect_send_RemoteCapability+0xbc>
		uart_lockTx( UART_Master );
    5c88:	4c13      	ldr	r4, [pc, #76]	; (5cd8 <Connect_send_RemoteCapability+0xd8>)
    5c8a:	78e3      	ldrb	r3, [r4, #3]
    5c8c:	2b00      	cmp	r3, #0
    5c8e:	d1fd      	bne.n	5c8c <Connect_send_RemoteCapability+0x8c>
    5c90:	2301      	movs	r3, #1
    5c92:	f894 9002 	ldrb.w	r9, [r4, #2]
    5c96:	70e3      	strb	r3, [r4, #3]
    5c98:	f1b9 0f04 	cmp.w	r9, #4
    5c9c:	d1fc      	bne.n	5c98 <Connect_send_RemoteCapability+0x98>
    5c9e:	2600      	movs	r6, #0
    5ca0:	2201      	movs	r2, #1
    5ca2:	2108      	movs	r1, #8
    5ca4:	a801      	add	r0, sp, #4
    5ca6:	70a6      	strb	r6, [r4, #2]
    5ca8:	f7ff fc2c 	bl	5504 <Connect_addBytes.part.1>
		Connect_addBytes( args, numArgs, UART_Master );
    5cac:	2201      	movs	r2, #1
    5cae:	4639      	mov	r1, r7
    5cb0:	4640      	mov	r0, r8
    5cb2:	f7ff fd75 	bl	57a0 <Connect_addBytes>
		uart_unlockTx( UART_Master );
    5cb6:	f884 9002 	strb.w	r9, [r4, #2]
    5cba:	70e6      	strb	r6, [r4, #3]
}
    5cbc:	9a03      	ldr	r2, [sp, #12]
    5cbe:	682b      	ldr	r3, [r5, #0]
    5cc0:	429a      	cmp	r2, r3
    5cc2:	d001      	beq.n	5cc8 <Connect_send_RemoteCapability+0xc8>
    5cc4:	f7fc fd34 	bl	2730 <__stack_chk_fail>
    5cc8:	b005      	add	sp, #20
    5cca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5cce:	bf00      	nop
    5cd0:	1fff89d0 	.word	0x1fff89d0
    5cd4:	1fff89e2 	.word	0x1fff89e2
    5cd8:	1fffa15a 	.word	0x1fffa15a

00005cdc <Connect_send_Idle>:
{
    5cdc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    5ce0:	4f1b      	ldr	r7, [pc, #108]	; (5d50 <Connect_send_Idle+0x74>)
	uart_lockBothTx( UART_Slave, UART_Master );
    5ce2:	4c1c      	ldr	r4, [pc, #112]	; (5d54 <Connect_send_Idle+0x78>)
{
    5ce4:	683a      	ldr	r2, [r7, #0]
    5ce6:	9201      	str	r2, [sp, #4]
	uart_lockBothTx( UART_Slave, UART_Master );
    5ce8:	7861      	ldrb	r1, [r4, #1]
    5cea:	78e2      	ldrb	r2, [r4, #3]
{
    5cec:	4680      	mov	r8, r0
	uart_lockBothTx( UART_Slave, UART_Master );
    5cee:	2900      	cmp	r1, #0
    5cf0:	d1fd      	bne.n	5cee <Connect_send_Idle+0x12>
    5cf2:	2a00      	cmp	r2, #0
    5cf4:	d1fd      	bne.n	5cf2 <Connect_send_Idle+0x16>
    5cf6:	2301      	movs	r3, #1
    5cf8:	7063      	strb	r3, [r4, #1]
    5cfa:	70e3      	strb	r3, [r4, #3]
    5cfc:	7822      	ldrb	r2, [r4, #0]
    5cfe:	78a3      	ldrb	r3, [r4, #2]
    5d00:	2a04      	cmp	r2, #4
    5d02:	d1fd      	bne.n	5d00 <Connect_send_Idle+0x24>
    5d04:	2b04      	cmp	r3, #4
    5d06:	d1fd      	bne.n	5d04 <Connect_send_Idle+0x28>
	uint8_t value = Command_SYN;
    5d08:	ae02      	add	r6, sp, #8
    5d0a:	2316      	movs	r3, #22
	uart_lockBothTx( UART_Slave, UART_Master );
    5d0c:	2500      	movs	r5, #0
	uint8_t value = Command_SYN;
    5d0e:	f806 3d05 	strb.w	r3, [r6, #-5]!
	uart_lockBothTx( UART_Slave, UART_Master );
    5d12:	7025      	strb	r5, [r4, #0]
    5d14:	70a5      	strb	r5, [r4, #2]
	for ( uint8_t c = 0; c < num; c++ )
    5d16:	4545      	cmp	r5, r8
    5d18:	d10b      	bne.n	5d32 <Connect_send_Idle+0x56>
	uart_unlockTx( UART_Master );
    5d1a:	2204      	movs	r2, #4
    5d1c:	2300      	movs	r3, #0
    5d1e:	70a2      	strb	r2, [r4, #2]
    5d20:	70e3      	strb	r3, [r4, #3]
	uart_unlockTx( UART_Slave );
    5d22:	7022      	strb	r2, [r4, #0]
    5d24:	7063      	strb	r3, [r4, #1]
}
    5d26:	9a01      	ldr	r2, [sp, #4]
    5d28:	683b      	ldr	r3, [r7, #0]
    5d2a:	429a      	cmp	r2, r3
    5d2c:	d00d      	beq.n	5d4a <Connect_send_Idle+0x6e>
    5d2e:	f7fc fcff 	bl	2730 <__stack_chk_fail>
    5d32:	2201      	movs	r2, #1
    5d34:	4611      	mov	r1, r2
    5d36:	4630      	mov	r0, r6
    5d38:	f7ff fbe4 	bl	5504 <Connect_addBytes.part.1>
    5d3c:	2200      	movs	r2, #0
    5d3e:	2101      	movs	r1, #1
    5d40:	4630      	mov	r0, r6
    5d42:	f7ff fbdf 	bl	5504 <Connect_addBytes.part.1>
    5d46:	3501      	adds	r5, #1
    5d48:	e7e5      	b.n	5d16 <Connect_send_Idle+0x3a>
    5d4a:	b002      	add	sp, #8
    5d4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5d50:	1fff89d0 	.word	0x1fff89d0
    5d54:	1fffa15a 	.word	0x1fffa15a

00005d58 <cliFunc_connectIdl>:
{
    5d58:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    5d5a:	4c0f      	ldr	r4, [pc, #60]	; (5d98 <cliFunc_connectIdl+0x40>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5d5c:	aa02      	add	r2, sp, #8
{
    5d5e:	6823      	ldr	r3, [r4, #0]
    5d60:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5d62:	a901      	add	r1, sp, #4
    5d64:	f008 fed6 	bl	eb14 <CLI_argumentIsolation>
	print( NL );
    5d68:	480c      	ldr	r0, [pc, #48]	; (5d9c <cliFunc_connectIdl+0x44>)
    5d6a:	f009 fc01 	bl	f570 <_print>
	info_msg("Sending Sync Idles...");
    5d6e:	480c      	ldr	r0, [pc, #48]	; (5da0 <cliFunc_connectIdl+0x48>)
    5d70:	f009 fbfe 	bl	f570 <_print>
	uint8_t count = numToInt( &arg1Ptr[0] );
    5d74:	9801      	ldr	r0, [sp, #4]
    5d76:	f009 fdcb 	bl	f910 <numToInt>
    5d7a:	b2c0      	uxtb	r0, r0
		count = 2;
    5d7c:	2800      	cmp	r0, #0
	Connect_send_Idle( count );
    5d7e:	bf08      	it	eq
    5d80:	2002      	moveq	r0, #2
    5d82:	f7ff ffab 	bl	5cdc <Connect_send_Idle>
}
    5d86:	9a03      	ldr	r2, [sp, #12]
    5d88:	6823      	ldr	r3, [r4, #0]
    5d8a:	429a      	cmp	r2, r3
    5d8c:	d001      	beq.n	5d92 <cliFunc_connectIdl+0x3a>
    5d8e:	f7fc fccf 	bl	2730 <__stack_chk_fail>
    5d92:	b004      	add	sp, #16
    5d94:	bd10      	pop	{r4, pc}
    5d96:	bf00      	nop
    5d98:	1fff89d0 	.word	0x1fff89d0
    5d9c:	00015df4 	.word	0x00015df4
    5da0:	00010f46 	.word	0x00010f46

00005da4 <Connect_send_CurrentEvent>:
{
    5da4:	b5f0      	push	{r4, r5, r6, r7, lr}
    5da6:	4f15      	ldr	r7, [pc, #84]	; (5dfc <Connect_send_CurrentEvent+0x58>)
	uart_lockTx( UART_Slave );
    5da8:	4c15      	ldr	r4, [pc, #84]	; (5e00 <Connect_send_CurrentEvent+0x5c>)
{
    5daa:	683a      	ldr	r2, [r7, #0]
    5dac:	b085      	sub	sp, #20
    5dae:	9203      	str	r2, [sp, #12]
	uart_lockTx( UART_Slave );
    5db0:	7862      	ldrb	r2, [r4, #1]
    5db2:	2a00      	cmp	r2, #0
    5db4:	d1fd      	bne.n	5db2 <Connect_send_CurrentEvent+0xe>
    5db6:	2301      	movs	r3, #1
    5db8:	7826      	ldrb	r6, [r4, #0]
    5dba:	7063      	strb	r3, [r4, #1]
    5dbc:	2e04      	cmp	r6, #4
    5dbe:	d1fd      	bne.n	5dbc <Connect_send_CurrentEvent+0x18>
    5dc0:	2500      	movs	r5, #0
	uint8_t header[] = { 0x16, 0x01, CurrentEvent, current & 0xFF, (current >> 8) & 0xFF };
    5dc2:	f44f 738b 	mov.w	r3, #278	; 0x116
    5dc6:	f88d 0007 	strb.w	r0, [sp, #7]
    5dca:	0a00      	lsrs	r0, r0, #8
    5dcc:	f8ad 3004 	strh.w	r3, [sp, #4]
    5dd0:	f88d 0008 	strb.w	r0, [sp, #8]
    5dd4:	2309      	movs	r3, #9
    5dd6:	462a      	mov	r2, r5
    5dd8:	2105      	movs	r1, #5
    5dda:	a801      	add	r0, sp, #4
    5ddc:	f88d 3006 	strb.w	r3, [sp, #6]
	uart_lockTx( UART_Slave );
    5de0:	7025      	strb	r5, [r4, #0]
    5de2:	f7ff fb8f 	bl	5504 <Connect_addBytes.part.1>
}
    5de6:	9a03      	ldr	r2, [sp, #12]
    5de8:	683b      	ldr	r3, [r7, #0]
	uart_unlockTx( UART_Slave );
    5dea:	7026      	strb	r6, [r4, #0]
}
    5dec:	429a      	cmp	r2, r3
	uart_unlockTx( UART_Slave );
    5dee:	7065      	strb	r5, [r4, #1]
}
    5df0:	d001      	beq.n	5df6 <Connect_send_CurrentEvent+0x52>
    5df2:	f7fc fc9d 	bl	2730 <__stack_chk_fail>
    5df6:	b005      	add	sp, #20
    5df8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5dfa:	bf00      	nop
    5dfc:	1fff89d0 	.word	0x1fff89d0
    5e00:	1fffa15a 	.word	0x1fffa15a

00005e04 <cliFunc_connectCmd>:
{
    5e04:	b510      	push	{r4, lr}
    5e06:	4c20      	ldr	r4, [pc, #128]	; (5e88 <cliFunc_connectCmd+0x84>)
    5e08:	b086      	sub	sp, #24
    5e0a:	6823      	ldr	r3, [r4, #0]
    5e0c:	9305      	str	r3, [sp, #20]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    5e0e:	aa02      	add	r2, sp, #8
    5e10:	a901      	add	r1, sp, #4
    5e12:	f008 fe7f 	bl	eb14 <CLI_argumentIsolation>
	print( NL );
    5e16:	481d      	ldr	r0, [pc, #116]	; (5e8c <cliFunc_connectCmd+0x88>)
    5e18:	f009 fbaa 	bl	f570 <_print>
	switch ( numToInt( &arg1Ptr[0] ) )
    5e1c:	9801      	ldr	r0, [sp, #4]
    5e1e:	f009 fd77 	bl	f910 <numToInt>
    5e22:	2809      	cmp	r0, #9
    5e24:	d809      	bhi.n	5e3a <cliFunc_connectCmd+0x36>
    5e26:	e8df f000 	tbb	[pc, r0]
    5e2a:	0e05      	.short	0x0e05
    5e2c:	08191511 	.word	0x08191511
    5e30:	25080808 	.word	0x25080808
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    5e34:	2002      	movs	r0, #2
    5e36:	f7ff fd77 	bl	5928 <Connect_send_CableCheck>
}
    5e3a:	9a05      	ldr	r2, [sp, #20]
    5e3c:	6823      	ldr	r3, [r4, #0]
    5e3e:	429a      	cmp	r2, r3
    5e40:	d01f      	beq.n	5e82 <cliFunc_connectCmd+0x7e>
    5e42:	f7fc fc75 	bl	2730 <__stack_chk_fail>
		Connect_send_IdRequest();
    5e46:	f7ff fdbf 	bl	59c8 <Connect_send_IdRequest>
		break;
    5e4a:	e7f6      	b.n	5e3a <cliFunc_connectCmd+0x36>
		Connect_send_IdEnumeration( 5 );
    5e4c:	2005      	movs	r0, #5
    5e4e:	f7ff fde7 	bl	5a20 <Connect_send_IdEnumeration>
		break;
    5e52:	e7f2      	b.n	5e3a <cliFunc_connectCmd+0x36>
		Connect_send_IdReport( 8 );
    5e54:	2008      	movs	r0, #8
    5e56:	f7ff fe37 	bl	5ac8 <Connect_send_IdReport>
		break;
    5e5a:	e7ee      	b.n	5e3a <cliFunc_connectCmd+0x36>
		TriggerEvent scanCodes[] = { { 0x00, 0x01, 0x05 }, { 0x00, 0x03, 0x16 } };
    5e5c:	4b0c      	ldr	r3, [pc, #48]	; (5e90 <cliFunc_connectCmd+0x8c>)
    5e5e:	6818      	ldr	r0, [r3, #0]
    5e60:	9003      	str	r0, [sp, #12]
    5e62:	889b      	ldrh	r3, [r3, #4]
    5e64:	f8ad 3010 	strh.w	r3, [sp, #16]
		Connect_send_ScanCode( 10, scanCodes, 2 );
    5e68:	2202      	movs	r2, #2
    5e6a:	a903      	add	r1, sp, #12
    5e6c:	200a      	movs	r0, #10
    5e6e:	f7ff fe8d 	bl	5b8c <Connect_send_ScanCode>
    5e72:	e7e2      	b.n	5e3a <cliFunc_connectCmd+0x36>
		dbug_print("Sending current event");
    5e74:	4807      	ldr	r0, [pc, #28]	; (5e94 <cliFunc_connectCmd+0x90>)
    5e76:	f009 fb7b 	bl	f570 <_print>
		Connect_send_CurrentEvent( 250 );
    5e7a:	20fa      	movs	r0, #250	; 0xfa
    5e7c:	f7ff ff92 	bl	5da4 <Connect_send_CurrentEvent>
}
    5e80:	e7db      	b.n	5e3a <cliFunc_connectCmd+0x36>
    5e82:	b006      	add	sp, #24
    5e84:	bd10      	pop	{r4, pc}
    5e86:	bf00      	nop
    5e88:	1fff89d0 	.word	0x1fff89d0
    5e8c:	00015df4 	.word	0x00015df4
    5e90:	00010b65 	.word	0x00010b65
    5e94:	00010eef 	.word	0x00010eef

00005e98 <Connect_reset>:
{
    5e98:	b537      	push	{r0, r1, r2, r4, r5, lr}
    5e9a:	4d12      	ldr	r5, [pc, #72]	; (5ee4 <Connect_reset+0x4c>)
	memset( (void*)uart_tx_status, 0, sizeof( UARTStatusTx ) * UART_Num_Interfaces );
    5e9c:	4c12      	ldr	r4, [pc, #72]	; (5ee8 <Connect_reset+0x50>)
{
    5e9e:	682b      	ldr	r3, [r5, #0]
	memset( (void*)uart_rx_status, 0, sizeof( UARTStatusRx ) * UART_Num_Interfaces );
    5ea0:	4812      	ldr	r0, [pc, #72]	; (5eec <Connect_reset+0x54>)
{
    5ea2:	9301      	str	r3, [sp, #4]
	memset( (void*)uart_rx_status, 0, sizeof( UARTStatusRx ) * UART_Num_Interfaces );
    5ea4:	2208      	movs	r2, #8
    5ea6:	2100      	movs	r1, #0
    5ea8:	f7fc fc50 	bl	274c <memset>
	memset( (void*)uart_tx_buf,    0, sizeof( UARTRingBuf )  * UART_Num_Interfaces );
    5eac:	f44f 7283 	mov.w	r2, #262	; 0x106
    5eb0:	2100      	movs	r1, #0
    5eb2:	480f      	ldr	r0, [pc, #60]	; (5ef0 <Connect_reset+0x58>)
    5eb4:	f7fc fc4a 	bl	274c <memset>
	memset( (void*)uart_tx_status, 0, sizeof( UARTStatusTx ) * UART_Num_Interfaces );
    5eb8:	2204      	movs	r2, #4
    5eba:	2100      	movs	r1, #0
    5ebc:	4620      	mov	r0, r4
    5ebe:	f7fc fc45 	bl	274c <memset>
		uart_rx_buf[ inter ].last_read = UART_Buffer_Size;
    5ec2:	4b0c      	ldr	r3, [pc, #48]	; (5ef4 <Connect_reset+0x5c>)
    5ec4:	2280      	movs	r2, #128	; 0x80
    5ec6:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
    5eca:	f8a3 2102 	strh.w	r2, [r3, #258]	; 0x102
}
    5ece:	9a01      	ldr	r2, [sp, #4]
    5ed0:	682b      	ldr	r3, [r5, #0]
		uart_tx_status[ inter ].status = UARTStatus_Ready;
    5ed2:	2104      	movs	r1, #4
}
    5ed4:	429a      	cmp	r2, r3
		uart_tx_status[ inter ].status = UARTStatus_Ready;
    5ed6:	7021      	strb	r1, [r4, #0]
    5ed8:	70a1      	strb	r1, [r4, #2]
}
    5eda:	d001      	beq.n	5ee0 <Connect_reset+0x48>
    5edc:	f7fc fc28 	bl	2730 <__stack_chk_fail>
    5ee0:	b003      	add	sp, #12
    5ee2:	bd30      	pop	{r4, r5, pc}
    5ee4:	1fff89d0 	.word	0x1fff89d0
    5ee8:	1fffa15a 	.word	0x1fffa15a
    5eec:	1fffa178 	.word	0x1fffa178
    5ef0:	1fffa04e 	.word	0x1fffa04e
    5ef4:	1fffa180 	.word	0x1fffa180

00005ef8 <cliFunc_connectRst>:
{
    5ef8:	b513      	push	{r0, r1, r4, lr}
    5efa:	4c0b      	ldr	r4, [pc, #44]	; (5f28 <cliFunc_connectRst+0x30>)
	print( NL );
    5efc:	480b      	ldr	r0, [pc, #44]	; (5f2c <cliFunc_connectRst+0x34>)
{
    5efe:	6823      	ldr	r3, [r4, #0]
    5f00:	9301      	str	r3, [sp, #4]
	print( NL );
    5f02:	f009 fb35 	bl	f570 <_print>
	info_msg("Resetting UARTConnect state...");
    5f06:	480a      	ldr	r0, [pc, #40]	; (5f30 <cliFunc_connectRst+0x38>)
    5f08:	f009 fb32 	bl	f570 <_print>
	Connect_reset();
    5f0c:	f7ff ffc4 	bl	5e98 <Connect_reset>
	Connect_id = DEFAULT_SLAVE_ID;
    5f10:	4b08      	ldr	r3, [pc, #32]	; (5f34 <cliFunc_connectRst+0x3c>)
    5f12:	22ff      	movs	r2, #255	; 0xff
    5f14:	701a      	strb	r2, [r3, #0]
}
    5f16:	9a01      	ldr	r2, [sp, #4]
    5f18:	6823      	ldr	r3, [r4, #0]
    5f1a:	429a      	cmp	r2, r3
    5f1c:	d001      	beq.n	5f22 <cliFunc_connectRst+0x2a>
    5f1e:	f7fc fc07 	bl	2730 <__stack_chk_fail>
    5f22:	b002      	add	sp, #8
    5f24:	bd10      	pop	{r4, pc}
    5f26:	bf00      	nop
    5f28:	1fff89d0 	.word	0x1fff89d0
    5f2c:	00015df4 	.word	0x00015df4
    5f30:	00010ff4 	.word	0x00010ff4
    5f34:	1fff89e2 	.word	0x1fff89e2

00005f38 <Connect_setup>:
{
    5f38:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    5f3a:	4d64      	ldr	r5, [pc, #400]	; (60cc <Connect_setup+0x194>)
	uarts_configured = 0;
    5f3c:	4e64      	ldr	r6, [pc, #400]	; (60d0 <Connect_setup+0x198>)
{
    5f3e:	682b      	ldr	r3, [r5, #0]
    5f40:	9301      	str	r3, [sp, #4]
	uarts_configured = 0;
    5f42:	2300      	movs	r3, #0
{
    5f44:	4604      	mov	r4, r0
	uarts_configured = 0;
    5f46:	7033      	strb	r3, [r6, #0]
	if ( first )
    5f48:	b119      	cbz	r1, 5f52 <Connect_setup+0x1a>
		CLI_registerDictionary( uartConnectCLIDict, uartConnectCLIDictName );
    5f4a:	4962      	ldr	r1, [pc, #392]	; (60d4 <Connect_setup+0x19c>)
    5f4c:	4862      	ldr	r0, [pc, #392]	; (60d8 <Connect_setup+0x1a0>)
    5f4e:	f008 fe9f 	bl	ec90 <CLI_registerDictionary>
	Connect_master = master;
    5f52:	4b62      	ldr	r3, [pc, #392]	; (60dc <Connect_setup+0x1a4>)
    5f54:	701c      	strb	r4, [r3, #0]
	if ( Connect_master )
    5f56:	b114      	cbz	r4, 5f5e <Connect_setup+0x26>
		Connect_id = MASTER_ID; // 0x00 is always the master Id
    5f58:	4b61      	ldr	r3, [pc, #388]	; (60e0 <Connect_setup+0x1a8>)
    5f5a:	2200      	movs	r2, #0
    5f5c:	701a      	strb	r2, [r3, #0]
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    5f5e:	4b61      	ldr	r3, [pc, #388]	; (60e4 <Connect_setup+0x1ac>)
	UART0_BDH = (uint8_t)(Connect_baud >> 8);
    5f60:	4961      	ldr	r1, [pc, #388]	; (60e8 <Connect_setup+0x1b0>)
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    5f62:	681a      	ldr	r2, [r3, #0]
	DMAMUX0_CHCFG0 = 0;
    5f64:	4f61      	ldr	r7, [pc, #388]	; (60ec <Connect_setup+0x1b4>)
	DMA_TCD0_SADDR = (uint32_t*)&UART0_D;
    5f66:	f8df c1cc 	ldr.w	ip, [pc, #460]	; 6134 <Connect_setup+0x1fc>
	SIM_SCGC4 |= SIM_SCGC4_UART0; // Disable clock gating
    5f6a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    5f6e:	601a      	str	r2, [r3, #0]
	SIM_SCGC4 |= SIM_SCGC4_UART1; // Disable clock gating
    5f70:	681a      	ldr	r2, [r3, #0]
    5f72:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    5f76:	601a      	str	r2, [r3, #0]
	PORTA_PCR1 = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(2); // RX Pin
    5f78:	f240 2213 	movw	r2, #531	; 0x213
    5f7c:	f8c3 2fd0 	str.w	r2, [r3, #4048]	; 0xfd0
	PORTA_PCR2 = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(2); // TX Pin
    5f80:	f44f 7211 	mov.w	r2, #580	; 0x244
    5f84:	f8c3 2fd4 	str.w	r2, [r3, #4052]	; 0xfd4
	PORTE_PCR0 = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); // RX Pin
    5f88:	4b59      	ldr	r3, [pc, #356]	; (60f0 <Connect_setup+0x1b8>)
    5f8a:	f240 3213 	movw	r2, #787	; 0x313
    5f8e:	601a      	str	r2, [r3, #0]
	PORTE_PCR1 = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); // TX Pin
    5f90:	f44f 7251 	mov.w	r2, #836	; 0x344
    5f94:	605a      	str	r2, [r3, #4]
	UART0_BDH = (uint8_t)(Connect_baud >> 8);
    5f96:	4b57      	ldr	r3, [pc, #348]	; (60f4 <Connect_setup+0x1bc>)
    5f98:	881a      	ldrh	r2, [r3, #0]
    5f9a:	0a12      	lsrs	r2, r2, #8
    5f9c:	700a      	strb	r2, [r1, #0]
	UART0_BDL = (uint8_t)Connect_baud;
    5f9e:	4a56      	ldr	r2, [pc, #344]	; (60f8 <Connect_setup+0x1c0>)
    5fa0:	7819      	ldrb	r1, [r3, #0]
    5fa2:	7011      	strb	r1, [r2, #0]
	UART0_C4  = Connect_baudFine;
    5fa4:	4955      	ldr	r1, [pc, #340]	; (60fc <Connect_setup+0x1c4>)
    5fa6:	7808      	ldrb	r0, [r1, #0]
    5fa8:	7250      	strb	r0, [r2, #9]
	UART1_BDH = (uint8_t)(Connect_baud >> 8);
    5faa:	881a      	ldrh	r2, [r3, #0]
    5fac:	4854      	ldr	r0, [pc, #336]	; (6100 <Connect_setup+0x1c8>)
    5fae:	0a12      	lsrs	r2, r2, #8
    5fb0:	7002      	strb	r2, [r0, #0]
	UART1_BDL = (uint8_t)Connect_baud;
    5fb2:	781a      	ldrb	r2, [r3, #0]
    5fb4:	4b53      	ldr	r3, [pc, #332]	; (6104 <Connect_setup+0x1cc>)
    5fb6:	701a      	strb	r2, [r3, #0]
	UART1_C4  = Connect_baudFine;
    5fb8:	780a      	ldrb	r2, [r1, #0]
    5fba:	725a      	strb	r2, [r3, #9]
	UART0_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    5fbc:	4a52      	ldr	r2, [pc, #328]	; (6108 <Connect_setup+0x1d0>)
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    5fbe:	4953      	ldr	r1, [pc, #332]	; (610c <Connect_setup+0x1d4>)
	UART0_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    5fc0:	2316      	movs	r3, #22
    5fc2:	7013      	strb	r3, [r2, #0]
	UART1_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    5fc4:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
	DMAMUX0_CHCFG1 = 0;
    5fc8:	f5a0 2093 	sub.w	r0, r0, #301056	; 0x49800
	UART1_C1 = UART_C1_M | UART_C1_PE | UART_C1_ILT;
    5fcc:	7013      	strb	r3, [r2, #0]
	UART0_PFIFO = UART_PFIFO_TXFE;
    5fce:	4b50      	ldr	r3, [pc, #320]	; (6110 <Connect_setup+0x1d8>)
    5fd0:	2280      	movs	r2, #128	; 0x80
    5fd2:	701a      	strb	r2, [r3, #0]
	UART1_PFIFO = UART_PFIFO_TXFE;
    5fd4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
	DMAMUX0_CHCFG1 = 0;
    5fd8:	f2a0 70ff 	subw	r0, r0, #2047	; 0x7ff
	UART1_PFIFO = UART_PFIFO_TXFE;
    5fdc:	701a      	strb	r2, [r3, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    5fde:	680b      	ldr	r3, [r1, #0]
    5fe0:	f043 0302 	orr.w	r3, r3, #2
    5fe4:	600b      	str	r3, [r1, #0]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    5fe6:	684b      	ldr	r3, [r1, #4]
    5fe8:	f043 0302 	orr.w	r3, r3, #2
    5fec:	604b      	str	r3, [r1, #4]
	DMA_TCD0_CSR = 0;
    5fee:	4b49      	ldr	r3, [pc, #292]	; (6114 <Connect_setup+0x1dc>)
	DMAMUX0_CHCFG0 = 0;
    5ff0:	2400      	movs	r4, #0
    5ff2:	703c      	strb	r4, [r7, #0]
	DMA_DCHPRI1 = 1; // ch 1, priority 1
    5ff4:	f5a1 317f 	sub.w	r1, r1, #261120	; 0x3fc00
	DMAMUX0_CHCFG1 = 0;
    5ff8:	7004      	strb	r4, [r0, #0]
	DMA_TCD0_CSR = 0;
    5ffa:	801c      	strh	r4, [r3, #0]
	DMA_TCD1_CSR = 0;
    5ffc:	841c      	strh	r4, [r3, #32]
	DMA_CR = 0;
    5ffe:	4b46      	ldr	r3, [pc, #280]	; (6118 <Connect_setup+0x1e0>)
	DMA_DCHPRI1 = 1; // ch 1, priority 1
    6000:	f2a1 313a 	subw	r1, r1, #826	; 0x33a
	DMA_CR = 0;
    6004:	601c      	str	r4, [r3, #0]
	DMA_DCHPRI0 = 0; // Ch 0, priority 0
    6006:	f883 4103 	strb.w	r4, [r3, #259]	; 0x103
	DMA_DCHPRI1 = 1; // ch 1, priority 1
    600a:	2301      	movs	r3, #1
    600c:	700b      	strb	r3, [r1, #0]
	DMA_EEI = 0;
    600e:	f841 4cee 	str.w	r4, [r1, #-238]
	DMA_TCD0_SADDR = (uint32_t*)&UART0_D;
    6012:	f8c1 cefe 	str.w	ip, [r1, #3838]	; 0xefe
    6016:	f601 61fe 	addw	r1, r1, #3838	; 0xefe
	DMA_TCD1_SADDR = (uint32_t*)&UART1_D;
    601a:	f50c 5c80 	add.w	ip, ip, #4096	; 0x1000
    601e:	f8c1 c020 	str.w	ip, [r1, #32]
	DMA_TCD0_DADDR = (uint32_t*)uart_rx_buf[0].buffer;
    6022:	f5ac 2cc3 	sub.w	ip, ip, #399360	; 0x61800
	DMA_TCD0_SOFF = 0;
    6026:	808c      	strh	r4, [r1, #4]
	DMA_TCD0_DADDR = (uint32_t*)uart_rx_buf[0].buffer;
    6028:	f2ac 7cf7 	subw	ip, ip, #2039	; 0x7f7
	DMA_TCD1_SOFF = 0;
    602c:	848c      	strh	r4, [r1, #36]	; 0x24
	DMA_TCD0_ATTR = DMA_TCD_ATTR_SMOD(0) | DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DMOD(0) | DMA_TCD_ATTR_DSIZE(0);
    602e:	80cc      	strh	r4, [r1, #6]
	DMA_TCD1_ATTR = DMA_TCD_ATTR_SMOD(0) | DMA_TCD_ATTR_SSIZE(0) | DMA_TCD_ATTR_DMOD(0) | DMA_TCD_ATTR_DSIZE(0);
    6030:	84cc      	strh	r4, [r1, #38]	; 0x26
	DMA_TCD0_NBYTES_MLNO = 1;
    6032:	608b      	str	r3, [r1, #8]
	DMA_TCD1_NBYTES_MLNO = 1;
    6034:	628b      	str	r3, [r1, #40]	; 0x28
	DMA_TCD0_SLAST = 0;
    6036:	60cc      	str	r4, [r1, #12]
	DMA_TCD1_SLAST = 0;
    6038:	62cc      	str	r4, [r1, #44]	; 0x2c
	DMA_TCD0_DADDR = (uint32_t*)uart_rx_buf[0].buffer;
    603a:	4938      	ldr	r1, [pc, #224]	; (611c <Connect_setup+0x1e4>)
    603c:	f8cc 1000 	str.w	r1, [ip]
	DMA_TCD1_DADDR = (uint32_t*)uart_rx_buf[1].buffer;
    6040:	3182      	adds	r1, #130	; 0x82
    6042:	f8cc 1020 	str.w	r1, [ip, #32]
	DMA_TCD0_DOFF = 1;
    6046:	4936      	ldr	r1, [pc, #216]	; (6120 <Connect_setup+0x1e8>)
    6048:	800b      	strh	r3, [r1, #0]
	DMA_TCD1_DOFF = 1;
    604a:	840b      	strh	r3, [r1, #32]
	DMA_TCD0_CITER_ELINKNO = UART_Buffer_Size;
    604c:	804a      	strh	r2, [r1, #2]
	DMA_TCD1_CITER_ELINKNO = UART_Buffer_Size;
    604e:	844a      	strh	r2, [r1, #34]	; 0x22
	DMA_TCD0_BITER_ELINKNO = UART_Buffer_Size;
    6050:	814a      	strh	r2, [r1, #10]
	DMA_TCD1_BITER_ELINKNO = UART_Buffer_Size;
    6052:	854a      	strh	r2, [r1, #42]	; 0x2a
	DMA_TCD0_DLASTSGA = -( UART_Buffer_Size );
    6054:	f06f 027f 	mvn.w	r2, #127	; 0x7f
    6058:	604a      	str	r2, [r1, #4]
	DMA_TCD1_DLASTSGA = -( UART_Buffer_Size );
    605a:	624a      	str	r2, [r1, #36]	; 0x24
	DMA_ERQ |= DMA_ERQ_ERQ0 | DMA_ERQ_ERQ1;
    605c:	f5a1 5180 	sub.w	r1, r1, #4096	; 0x1000
    6060:	3908      	subs	r1, #8
    6062:	680a      	ldr	r2, [r1, #0]
    6064:	f042 0203 	orr.w	r2, r2, #3
    6068:	600a      	str	r2, [r1, #0]
	DMAMUX0_CHCFG0 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART0_RX;
    606a:	2282      	movs	r2, #130	; 0x82
	UART0_C5 = UART_C5_RDMAS;
    606c:	f501 21c3 	add.w	r1, r1, #399360	; 0x61800
	DMAMUX0_CHCFG0 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART0_RX;
    6070:	703a      	strb	r2, [r7, #0]
	UART0_C5 = UART_C5_RDMAS;
    6072:	f201 71ff 	addw	r1, r1, #2047	; 0x7ff
	DMAMUX0_CHCFG1 = DMAMUX_ENABLE | DMAMUX_SOURCE_UART1_RX;
    6076:	2284      	movs	r2, #132	; 0x84
    6078:	7002      	strb	r2, [r0, #0]
	UART0_C5 = UART_C5_RDMAS;
    607a:	2220      	movs	r2, #32
    607c:	700a      	strb	r2, [r1, #0]
	UART1_C5 = UART_C5_RDMAS;
    607e:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    6082:	700a      	strb	r2, [r1, #0]
	UART0_C2 = UART_C2_TE | UART_C2_RE | UART_C2_RIE;
    6084:	4927      	ldr	r1, [pc, #156]	; (6124 <Connect_setup+0x1ec>)
    6086:	222c      	movs	r2, #44	; 0x2c
    6088:	700a      	strb	r2, [r1, #0]
	UART1_C2 = UART_C2_TE | UART_C2_RE | UART_C2_RIE;
    608a:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
    608e:	700a      	strb	r2, [r1, #0]
	NVIC_ENABLE_IRQ( IRQ_UART0_STATUS );
    6090:	f102 22e0 	add.w	r2, r2, #3758153728	; 0xe000e000
    6094:	32d8      	adds	r2, #216	; 0xd8
    6096:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    609a:	6011      	str	r1, [r2, #0]
	NVIC_ENABLE_IRQ( IRQ_UART1_STATUS );
    609c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    60a0:	6011      	str	r1, [r2, #0]
	Connect_LastCurrentValue = 50; // Default to 50 mA
    60a2:	4a21      	ldr	r2, [pc, #132]	; (6128 <Connect_setup+0x1f0>)
	uarts_configured = 1;
    60a4:	7033      	strb	r3, [r6, #0]
	Connect_LastCurrentValue = 50; // Default to 50 mA
    60a6:	2132      	movs	r1, #50	; 0x32
    60a8:	8011      	strh	r1, [r2, #0]
	Connect_reset();
    60aa:	f7ff fef5 	bl	5e98 <Connect_reset>
	connectLatencyResource = Latency_add_resource("UARTConnect", LatencyOption_Ticks);
    60ae:	4621      	mov	r1, r4
    60b0:	481e      	ldr	r0, [pc, #120]	; (612c <Connect_setup+0x1f4>)
    60b2:	f009 f913 	bl	f2dc <Latency_add_resource>
    60b6:	4b1e      	ldr	r3, [pc, #120]	; (6130 <Connect_setup+0x1f8>)
}
    60b8:	9a01      	ldr	r2, [sp, #4]
	connectLatencyResource = Latency_add_resource("UARTConnect", LatencyOption_Ticks);
    60ba:	7018      	strb	r0, [r3, #0]
}
    60bc:	682b      	ldr	r3, [r5, #0]
    60be:	429a      	cmp	r2, r3
    60c0:	d001      	beq.n	60c6 <Connect_setup+0x18e>
    60c2:	f7fc fb35 	bl	2730 <__stack_chk_fail>
    60c6:	b003      	add	sp, #12
    60c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    60ca:	bf00      	nop
    60cc:	1fff89d0 	.word	0x1fff89d0
    60d0:	1fff94d8 	.word	0x1fff94d8
    60d4:	00011398 	.word	0x00011398
    60d8:	00011338 	.word	0x00011338
    60dc:	1fff94cc 	.word	0x1fff94cc
    60e0:	1fff89e2 	.word	0x1fff89e2
    60e4:	40048034 	.word	0x40048034
    60e8:	4006a000 	.word	0x4006a000
    60ec:	40021000 	.word	0x40021000
    60f0:	4004d000 	.word	0x4004d000
    60f4:	1fff89e0 	.word	0x1fff89e0
    60f8:	4006a001 	.word	0x4006a001
    60fc:	1fff94b0 	.word	0x1fff94b0
    6100:	4006b000 	.word	0x4006b000
    6104:	4006b001 	.word	0x4006b001
    6108:	4006a002 	.word	0x4006a002
    610c:	4004803c 	.word	0x4004803c
    6110:	4006a010 	.word	0x4006a010
    6114:	4000901c 	.word	0x4000901c
    6118:	40008000 	.word	0x40008000
    611c:	1fffa180 	.word	0x1fffa180
    6120:	40009014 	.word	0x40009014
    6124:	4006a003 	.word	0x4006a003
    6128:	1fff94ae 	.word	0x1fff94ae
    612c:	00010ee3 	.word	0x00010ee3
    6130:	1fff94d7 	.word	0x1fff94d7
    6134:	4006a007 	.word	0x4006a007

00006138 <Connect_rx_process>:
{
    6138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    613c:	4b67      	ldr	r3, [pc, #412]	; (62dc <Connect_rx_process+0x1a4>)
    613e:	b085      	sub	sp, #20
    6140:	681a      	ldr	r2, [r3, #0]
    6142:	9203      	str	r2, [sp, #12]
	switch ( uartNum )
    6144:	4604      	mov	r4, r0
    6146:	9301      	str	r3, [sp, #4]
    6148:	b118      	cbz	r0, 6152 <Connect_rx_process+0x1a>
    614a:	2801      	cmp	r0, #1
    614c:	d011      	beq.n	6172 <Connect_rx_process+0x3a>
	uint16_t bufpos = 0;
    614e:	2700      	movs	r7, #0
    6150:	e002      	b.n	6158 <Connect_rx_process+0x20>
	DMA_BUF_POS( 0, bufpos );
    6152:	4b63      	ldr	r3, [pc, #396]	; (62e0 <Connect_rx_process+0x1a8>)
	DMA_BUF_POS( 1, bufpos );
    6154:	881f      	ldrh	r7, [r3, #0]
    6156:	b2bf      	uxth	r7, r7
	while ( bufpos != uart_rx_buf[ uartNum ].last_read )
    6158:	2382      	movs	r3, #130	; 0x82
    615a:	fb03 fb04 	mul.w	fp, r3, r4
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    615e:	f04f 0902 	mov.w	r9, #2
    6162:	4d60      	ldr	r5, [pc, #384]	; (62e4 <Connect_rx_process+0x1ac>)
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    6164:	4b60      	ldr	r3, [pc, #384]	; (62e8 <Connect_rx_process+0x1b0>)
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    6166:	eb09 0984 	add.w	r9, r9, r4, lsl #2
    616a:	44a9      	add	r9, r5
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    616c:	eb03 0a0b 	add.w	sl, r3, fp
    6170:	e07c      	b.n	626c <Connect_rx_process+0x134>
	DMA_BUF_POS( 1, bufpos );
    6172:	4b5e      	ldr	r3, [pc, #376]	; (62ec <Connect_rx_process+0x1b4>)
    6174:	e7ee      	b.n	6154 <Connect_rx_process+0x1c>
			uart_rx_buf[ uartNum ].last_read = UART_Buffer_Size;
    6176:	2280      	movs	r2, #128	; 0x80
			if ( bufpos == UART_Buffer_Size )
    6178:	4297      	cmp	r7, r2
			uart_rx_buf[ uartNum ].last_read = UART_Buffer_Size;
    617a:	f8a3 2080 	strh.w	r2, [r3, #128]	; 0x80
			if ( bufpos == UART_Buffer_Size )
    617e:	f040 8081 	bne.w	6284 <Connect_rx_process+0x14c>
}
    6182:	9b01      	ldr	r3, [sp, #4]
    6184:	9a03      	ldr	r2, [sp, #12]
    6186:	681b      	ldr	r3, [r3, #0]
    6188:	429a      	cmp	r2, r3
    618a:	f000 80a3 	beq.w	62d4 <Connect_rx_process+0x19c>
    618e:	f7fc facf 	bl	2730 <__stack_chk_fail>
			if ( Connect_debug )
    6192:	f898 3000 	ldrb.w	r3, [r8]
    6196:	b113      	cbz	r3, 619e <Connect_rx_process+0x66>
				print(" Wait ");
    6198:	4855      	ldr	r0, [pc, #340]	; (62f0 <Connect_rx_process+0x1b8>)
    619a:	f009 f9e9 	bl	f570 <_print>
			uart_rx_status[ uartNum ].status = byte == Command_SYN ? UARTStatus_SYN : UARTStatus_Wait;
    619e:	f1a6 0316 	sub.w	r3, r6, #22
    61a2:	425e      	negs	r6, r3
    61a4:	415e      	adcs	r6, r3
    61a6:	f805 6024 	strb.w	r6, [r5, r4, lsl #2]
		if ( Connect_debug )
    61aa:	f898 3000 	ldrb.w	r3, [r8]
    61ae:	2b00      	cmp	r3, #0
    61b0:	d05c      	beq.n	626c <Connect_rx_process+0x134>
			print( NL );
    61b2:	4850      	ldr	r0, [pc, #320]	; (62f4 <Connect_rx_process+0x1bc>)
    61b4:	f009 f9dc 	bl	f570 <_print>
    61b8:	e058      	b.n	626c <Connect_rx_process+0x134>
			if ( Connect_debug )
    61ba:	f898 3000 	ldrb.w	r3, [r8]
    61be:	b113      	cbz	r3, 61c6 <Connect_rx_process+0x8e>
				print(" SYN ");
    61c0:	484d      	ldr	r0, [pc, #308]	; (62f8 <Connect_rx_process+0x1c0>)
    61c2:	f009 f9d5 	bl	f570 <_print>
			uart_rx_status[ uartNum ].status = byte == SOH ? UARTStatus_SOH : UARTStatus_Wait;
    61c6:	2e01      	cmp	r6, #1
    61c8:	bf14      	ite	ne
    61ca:	2300      	movne	r3, #0
    61cc:	2302      	moveq	r3, #2
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    61ce:	f805 3024 	strb.w	r3, [r5, r4, lsl #2]
				break;
    61d2:	e7ea      	b.n	61aa <Connect_rx_process+0x72>
			if ( Connect_debug )
    61d4:	f898 3000 	ldrb.w	r3, [r8]
    61d8:	b113      	cbz	r3, 61e0 <Connect_rx_process+0xa8>
				print(" SOH ");
    61da:	4848      	ldr	r0, [pc, #288]	; (62fc <Connect_rx_process+0x1c4>)
    61dc:	f009 f9c8 	bl	f570 <_print>
			if ( byte == Command_SYN )
    61e0:	2e16      	cmp	r6, #22
    61e2:	d101      	bne.n	61e8 <Connect_rx_process+0xb0>
				uart_rx_status[ uartNum ].status = UARTStatus_SYN;
    61e4:	2301      	movs	r3, #1
    61e6:	e7f2      	b.n	61ce <Connect_rx_process+0x96>
			if ( byte < Command_TOP )
    61e8:	2e09      	cmp	r6, #9
				uart_rx_status[ uartNum ].status = UARTStatus_Command;
    61ea:	bf98      	it	ls
    61ec:	2203      	movls	r2, #3
    61ee:	ea4f 0384 	mov.w	r3, r4, lsl #2
    61f2:	bf9b      	ittet	ls
    61f4:	f805 2024 	strbls.w	r2, [r5, r4, lsl #2]
				uart_rx_status[ uartNum ].command = byte;
    61f8:	18ea      	addls	r2, r5, r3
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    61fa:	2200      	movhi	r2, #0
				uart_rx_status[ uartNum ].command = byte;
    61fc:	7056      	strbls	r6, [r2, #1]
				uart_rx_status[ uartNum ].bytes_waiting = BYTE_COUNT_START;
    61fe:	bf94      	ite	ls
    6200:	f64f 71ff 	movwls	r1, #65535	; 0xffff
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    6204:	f805 2024 	strbhi.w	r2, [r5, r4, lsl #2]
			switch ( uart_rx_status[ uartNum ].command )
    6208:	eb05 0603 	add.w	r6, r5, r3
				uart_rx_status[ uartNum ].bytes_waiting = BYTE_COUNT_START;
    620c:	bf98      	it	ls
    620e:	8051      	strhls	r1, [r2, #2]
			switch ( uart_rx_status[ uartNum ].command )
    6210:	7873      	ldrb	r3, [r6, #1]
    6212:	2b01      	cmp	r3, #1
    6214:	d106      	bne.n	6224 <Connect_rx_process+0xec>
				Connect_receive_IdRequest( 0, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum );
    6216:	4622      	mov	r2, r4
    6218:	4649      	mov	r1, r9
    621a:	2000      	movs	r0, #0
    621c:	f7ff fc2c 	bl	5a78 <Connect_receive_IdRequest>
				uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    6220:	2300      	movs	r3, #0
    6222:	e7d4      	b.n	61ce <Connect_rx_process+0x96>
				if ( Connect_debug )
    6224:	f898 3000 	ldrb.w	r3, [r8]
    6228:	b303      	cbz	r3, 626c <Connect_rx_process+0x134>
					print(" ### ");
    622a:	4835      	ldr	r0, [pc, #212]	; (6300 <Connect_rx_process+0x1c8>)
    622c:	f009 f9a0 	bl	f570 <_print>
					printHex( uart_rx_status[ uartNum ].command );
    6230:	7870      	ldrb	r0, [r6, #1]
    6232:	2101      	movs	r1, #1
    6234:	f009 fac2 	bl	f7bc <printHex_op>
    6238:	e7b7      	b.n	61aa <Connect_rx_process+0x72>
			if ( Connect_debug )
    623a:	f898 3000 	ldrb.w	r3, [r8]
    623e:	b113      	cbz	r3, 6246 <Connect_rx_process+0x10e>
				print(" CMD ");
    6240:	4830      	ldr	r0, [pc, #192]	; (6304 <Connect_rx_process+0x1cc>)
    6242:	f009 f995 	bl	f570 <_print>
			uint8_t (*rcvFunc)(uint8_t, uint16_t(*), uint8_t) = (uint8_t(*)(uint8_t, uint16_t(*), uint8_t))(Connect_receiveFunctions[ uart_rx_status[ uartNum ].command ]);
    6246:	eb05 0384 	add.w	r3, r5, r4, lsl #2
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    624a:	4649      	mov	r1, r9
			uint8_t (*rcvFunc)(uint8_t, uint16_t(*), uint8_t) = (uint8_t(*)(uint8_t, uint16_t(*), uint8_t))(Connect_receiveFunctions[ uart_rx_status[ uartNum ].command ]);
    624c:	785a      	ldrb	r2, [r3, #1]
    624e:	4b2e      	ldr	r3, [pc, #184]	; (6308 <Connect_rx_process+0x1d0>)
			if ( rcvFunc( byte, (uint16_t*)&uart_rx_status[ uartNum ].bytes_waiting, uartNum ) )
    6250:	4630      	mov	r0, r6
    6252:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6256:	4622      	mov	r2, r4
    6258:	4798      	blx	r3
    625a:	2800      	cmp	r0, #0
    625c:	d0a5      	beq.n	61aa <Connect_rx_process+0x72>
    625e:	e7df      	b.n	6220 <Connect_rx_process+0xe8>
			erro_msg("Invalid UARTStatus...");
    6260:	482a      	ldr	r0, [pc, #168]	; (630c <Connect_rx_process+0x1d4>)
    6262:	f009 f985 	bl	f570 <_print>
			uart_rx_status[ uartNum ].status = UARTStatus_Wait;
    6266:	2300      	movs	r3, #0
    6268:	f805 3024 	strb.w	r3, [r5, r4, lsl #2]
	while ( bufpos != uart_rx_buf[ uartNum ].last_read )
    626c:	4b1e      	ldr	r3, [pc, #120]	; (62e8 <Connect_rx_process+0x1b0>)
    626e:	445b      	add	r3, fp
    6270:	f8b3 2080 	ldrh.w	r2, [r3, #128]	; 0x80
    6274:	4297      	cmp	r7, r2
    6276:	d084      	beq.n	6182 <Connect_rx_process+0x4a>
		if ( uart_rx_buf[ uartNum ].last_read == 0 )
    6278:	f8b3 2080 	ldrh.w	r2, [r3, #128]	; 0x80
    627c:	b292      	uxth	r2, r2
    627e:	2a00      	cmp	r2, #0
    6280:	f43f af79 	beq.w	6176 <Connect_rx_process+0x3e>
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    6284:	f8ba 3080 	ldrh.w	r3, [sl, #128]	; 0x80
		if ( Connect_debug )
    6288:	f8df 8088 	ldr.w	r8, [pc, #136]	; 6314 <Connect_rx_process+0x1dc>
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    628c:	b29b      	uxth	r3, r3
    628e:	1e5a      	subs	r2, r3, #1
    6290:	b292      	uxth	r2, r2
    6292:	f1c3 0380 	rsb	r3, r3, #128	; 0x80
    6296:	f8aa 2080 	strh.w	r2, [sl, #128]	; 0x80
    629a:	f81a 6003 	ldrb.w	r6, [sl, r3]
		if ( Connect_debug )
    629e:	f898 3000 	ldrb.w	r3, [r8]
		uint8_t byte = uart_rx_buf[ uartNum ].buffer[ UART_Buffer_Size - uart_rx_buf[ uartNum ].last_read-- ];
    62a2:	b2f6      	uxtb	r6, r6
		if ( Connect_debug )
    62a4:	b133      	cbz	r3, 62b4 <Connect_rx_process+0x17c>
			printHex( byte );
    62a6:	4630      	mov	r0, r6
    62a8:	2101      	movs	r1, #1
    62aa:	f009 fa87 	bl	f7bc <printHex_op>
			print(" ");
    62ae:	4818      	ldr	r0, [pc, #96]	; (6310 <Connect_rx_process+0x1d8>)
    62b0:	f009 f95e 	bl	f570 <_print>
		switch ( uart_rx_status[ uartNum ].status )
    62b4:	f815 3024 	ldrb.w	r3, [r5, r4, lsl #2]
    62b8:	2b03      	cmp	r3, #3
    62ba:	d8d1      	bhi.n	6260 <Connect_rx_process+0x128>
    62bc:	a201      	add	r2, pc, #4	; (adr r2, 62c4 <Connect_rx_process+0x18c>)
    62be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    62c2:	bf00      	nop
    62c4:	00006193 	.word	0x00006193
    62c8:	000061bb 	.word	0x000061bb
    62cc:	000061d5 	.word	0x000061d5
    62d0:	0000623b 	.word	0x0000623b
}
    62d4:	b005      	add	sp, #20
    62d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    62da:	bf00      	nop
    62dc:	1fff89d0 	.word	0x1fff89d0
    62e0:	40009016 	.word	0x40009016
    62e4:	1fffa178 	.word	0x1fffa178
    62e8:	1fffa180 	.word	0x1fffa180
    62ec:	40009036 	.word	0x40009036
    62f0:	00010e81 	.word	0x00010e81
    62f4:	00015df4 	.word	0x00015df4
    62f8:	00010e88 	.word	0x00010e88
    62fc:	00010e8e 	.word	0x00010e8e
    6300:	00010e94 	.word	0x00010e94
    6304:	00010e9a 	.word	0x00010e9a
    6308:	1fff89e4 	.word	0x1fff89e4
    630c:	00010ea0 	.word	0x00010ea0
    6310:	00016f5e 	.word	0x00016f5e
    6314:	1fff94c6 	.word	0x1fff94c6

00006318 <Connect_scan>:
{
    6318:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    631c:	4f6d      	ldr	r7, [pc, #436]	; (64d4 <Connect_scan+0x1bc>)
	Latency_start_time( connectLatencyResource );
    631e:	4e6e      	ldr	r6, [pc, #440]	; (64d8 <Connect_scan+0x1c0>)
	if ( !Connect_master && Output_Available && !Connect_override )
    6320:	4c6e      	ldr	r4, [pc, #440]	; (64dc <Connect_scan+0x1c4>)
{
    6322:	683b      	ldr	r3, [r7, #0]
	Latency_start_time( connectLatencyResource );
    6324:	7830      	ldrb	r0, [r6, #0]
{
    6326:	9301      	str	r3, [sp, #4]
	Latency_start_time( connectLatencyResource );
    6328:	f009 f850 	bl	f3cc <Latency_start_time>
	if ( !Connect_master && Output_Available && !Connect_override )
    632c:	7822      	ldrb	r2, [r4, #0]
    632e:	b942      	cbnz	r2, 6342 <Connect_scan+0x2a>
    6330:	4b6b      	ldr	r3, [pc, #428]	; (64e0 <Connect_scan+0x1c8>)
    6332:	781a      	ldrb	r2, [r3, #0]
    6334:	b12a      	cbz	r2, 6342 <Connect_scan+0x2a>
    6336:	4a6b      	ldr	r2, [pc, #428]	; (64e4 <Connect_scan+0x1cc>)
    6338:	7811      	ldrb	r1, [r2, #0]
    633a:	b911      	cbnz	r1, 6342 <Connect_scan+0x2a>
		Connect_setup( Output_Available, 0 );
    633c:	7818      	ldrb	r0, [r3, #0]
    633e:	f7ff fdfb 	bl	5f38 <Connect_setup>
	uint32_t current_time = systick_millis_count;
    6342:	4b69      	ldr	r3, [pc, #420]	; (64e8 <Connect_scan+0x1d0>)
	if ( Connect_lastCheck != current_time
    6344:	4a69      	ldr	r2, [pc, #420]	; (64ec <Connect_scan+0x1d4>)
	uint32_t current_time = systick_millis_count;
    6346:	681b      	ldr	r3, [r3, #0]
	if ( Connect_lastCheck != current_time
    6348:	6811      	ldr	r1, [r2, #0]
    634a:	4299      	cmp	r1, r3
    634c:	d014      	beq.n	6378 <Connect_scan+0x60>
		&& ( current_time & time_compare ) == time_compare
    634e:	f3c3 000a 	ubfx	r0, r3, #0, #11
    6352:	f240 71ff 	movw	r1, #2047	; 0x7ff
    6356:	4288      	cmp	r0, r1
    6358:	d10e      	bne.n	6378 <Connect_scan+0x60>
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    635a:	2002      	movs	r0, #2
		Connect_lastCheck = current_time;
    635c:	6013      	str	r3, [r2, #0]
		Connect_send_CableCheck( UARTConnectCableCheckLength_define );
    635e:	f7ff fae3 	bl	5928 <Connect_send_CableCheck>
		if ( !Connect_master && Connect_id == DEFAULT_SLAVE_ID && Connect_cableOkMaster )
    6362:	7823      	ldrb	r3, [r4, #0]
    6364:	b943      	cbnz	r3, 6378 <Connect_scan+0x60>
    6366:	4b62      	ldr	r3, [pc, #392]	; (64f0 <Connect_scan+0x1d8>)
    6368:	781b      	ldrb	r3, [r3, #0]
    636a:	2bff      	cmp	r3, #255	; 0xff
    636c:	d104      	bne.n	6378 <Connect_scan+0x60>
    636e:	4b61      	ldr	r3, [pc, #388]	; (64f4 <Connect_scan+0x1dc>)
    6370:	781b      	ldrb	r3, [r3, #0]
    6372:	b10b      	cbz	r3, 6378 <Connect_scan+0x60>
			Connect_send_IdRequest();
    6374:	f7ff fb28 	bl	59c8 <Connect_send_IdRequest>
	if ( uarts_configured )
    6378:	4b5f      	ldr	r3, [pc, #380]	; (64f8 <Connect_scan+0x1e0>)
    637a:	781b      	ldrb	r3, [r3, #0]
    637c:	b163      	cbz	r3, 6398 <Connect_scan+0x80>
		if ( uart_tx_buf[ 0 ].items > 0 && UART0_TCFIFO == 0 )
    637e:	4c5f      	ldr	r4, [pc, #380]	; (64fc <Connect_scan+0x1e4>)
    6380:	78a3      	ldrb	r3, [r4, #2]
    6382:	b983      	cbnz	r3, 63a6 <Connect_scan+0x8e>
		if ( uart_tx_buf[ 1 ].items > 0 && UART1_TCFIFO == 0 )
    6384:	f894 3085 	ldrb.w	r3, [r4, #133]	; 0x85
    6388:	2b00      	cmp	r3, #0
    638a:	d151      	bne.n	6430 <Connect_scan+0x118>
		Connect_rx_process( 0 );
    638c:	2000      	movs	r0, #0
    638e:	f7ff fed3 	bl	6138 <Connect_rx_process>
		Connect_rx_process( 1 );
    6392:	2001      	movs	r0, #1
    6394:	f7ff fed0 	bl	6138 <Connect_rx_process>
	Latency_end_time( connectLatencyResource );
    6398:	9a01      	ldr	r2, [sp, #4]
    639a:	683b      	ldr	r3, [r7, #0]
    639c:	429a      	cmp	r2, r3
    639e:	f000 8092 	beq.w	64c6 <Connect_scan+0x1ae>
    63a2:	f7fc f9c5 	bl	2730 <__stack_chk_fail>
		if ( uart_tx_buf[ 0 ].items > 0 && UART0_TCFIFO == 0 )
    63a6:	4b56      	ldr	r3, [pc, #344]	; (6500 <Connect_scan+0x1e8>)
    63a8:	781a      	ldrb	r2, [r3, #0]
    63aa:	4698      	mov	r8, r3
    63ac:	2a00      	cmp	r2, #0
    63ae:	d1e9      	bne.n	6384 <Connect_scan+0x6c>
			uart_fillTxFifo( 0 );
    63b0:	f813 5c04 	ldrb.w	r5, [r3, #-4]
    63b4:	4b53      	ldr	r3, [pc, #332]	; (6504 <Connect_scan+0x1ec>)
    63b6:	08ad      	lsrs	r5, r5, #2
    63b8:	781b      	ldrb	r3, [r3, #0]
    63ba:	f015 051c 	ands.w	r5, r5, #28
    63be:	bf08      	it	eq
    63c0:	2501      	moveq	r5, #1
    63c2:	b1c3      	cbz	r3, 63f6 <Connect_scan+0xde>
    63c4:	4850      	ldr	r0, [pc, #320]	; (6508 <Connect_scan+0x1f0>)
    63c6:	f009 f8d3 	bl	f570 <_print>
    63ca:	2101      	movs	r1, #1
    63cc:	4628      	mov	r0, r5
    63ce:	f009 f9f5 	bl	f7bc <printHex_op>
    63d2:	484e      	ldr	r0, [pc, #312]	; (650c <Connect_scan+0x1f4>)
    63d4:	f009 f8cc 	bl	f570 <_print>
    63d8:	2101      	movs	r1, #1
    63da:	f898 0000 	ldrb.w	r0, [r8]
    63de:	f009 f9ed 	bl	f7bc <printHex_op>
    63e2:	484a      	ldr	r0, [pc, #296]	; (650c <Connect_scan+0x1f4>)
    63e4:	f009 f8c4 	bl	f570 <_print>
    63e8:	78a0      	ldrb	r0, [r4, #2]
    63ea:	2101      	movs	r1, #1
    63ec:	f009 f9e6 	bl	f7bc <printHex_op>
    63f0:	4847      	ldr	r0, [pc, #284]	; (6510 <Connect_scan+0x1f8>)
    63f2:	f009 f8bd 	bl	f570 <_print>
    63f6:	f898 3000 	ldrb.w	r3, [r8]
    63fa:	4946      	ldr	r1, [pc, #280]	; (6514 <Connect_scan+0x1fc>)
    63fc:	1aed      	subs	r5, r5, r3
    63fe:	b2ed      	uxtb	r5, r5
    6400:	2000      	movs	r0, #0
    6402:	2d00      	cmp	r5, #0
    6404:	d0be      	beq.n	6384 <Connect_scan+0x6c>
    6406:	78a3      	ldrb	r3, [r4, #2]
    6408:	2b00      	cmp	r3, #0
    640a:	d0bb      	beq.n	6384 <Connect_scan+0x6c>
    640c:	7822      	ldrb	r2, [r4, #0]
    640e:	f102 0c01 	add.w	ip, r2, #1
    6412:	4422      	add	r2, r4
    6414:	f884 c000 	strb.w	ip, [r4]
    6418:	78d2      	ldrb	r2, [r2, #3]
    641a:	700a      	strb	r2, [r1, #0]
    641c:	3b01      	subs	r3, #1
    641e:	70a3      	strb	r3, [r4, #2]
    6420:	f994 3000 	ldrsb.w	r3, [r4]
    6424:	3d01      	subs	r5, #1
    6426:	2b00      	cmp	r3, #0
    6428:	bfb8      	it	lt
    642a:	7020      	strblt	r0, [r4, #0]
    642c:	b2ed      	uxtb	r5, r5
    642e:	e7e8      	b.n	6402 <Connect_scan+0xea>
		if ( uart_tx_buf[ 1 ].items > 0 && UART1_TCFIFO == 0 )
    6430:	4b39      	ldr	r3, [pc, #228]	; (6518 <Connect_scan+0x200>)
    6432:	781a      	ldrb	r2, [r3, #0]
    6434:	4698      	mov	r8, r3
    6436:	2a00      	cmp	r2, #0
    6438:	d1a8      	bne.n	638c <Connect_scan+0x74>
			uart_fillTxFifo( 1 );
    643a:	f813 5c04 	ldrb.w	r5, [r3, #-4]
    643e:	4b31      	ldr	r3, [pc, #196]	; (6504 <Connect_scan+0x1ec>)
    6440:	08ad      	lsrs	r5, r5, #2
    6442:	781b      	ldrb	r3, [r3, #0]
    6444:	f015 051c 	ands.w	r5, r5, #28
    6448:	bf08      	it	eq
    644a:	2501      	moveq	r5, #1
    644c:	b1cb      	cbz	r3, 6482 <Connect_scan+0x16a>
    644e:	4833      	ldr	r0, [pc, #204]	; (651c <Connect_scan+0x204>)
    6450:	f009 f88e 	bl	f570 <_print>
    6454:	2101      	movs	r1, #1
    6456:	4628      	mov	r0, r5
    6458:	f009 f9b0 	bl	f7bc <printHex_op>
    645c:	482b      	ldr	r0, [pc, #172]	; (650c <Connect_scan+0x1f4>)
    645e:	f009 f887 	bl	f570 <_print>
    6462:	2101      	movs	r1, #1
    6464:	f898 0000 	ldrb.w	r0, [r8]
    6468:	f009 f9a8 	bl	f7bc <printHex_op>
    646c:	4827      	ldr	r0, [pc, #156]	; (650c <Connect_scan+0x1f4>)
    646e:	f009 f87f 	bl	f570 <_print>
    6472:	f894 0085 	ldrb.w	r0, [r4, #133]	; 0x85
    6476:	2101      	movs	r1, #1
    6478:	f009 f9a0 	bl	f7bc <printHex_op>
    647c:	4824      	ldr	r0, [pc, #144]	; (6510 <Connect_scan+0x1f8>)
    647e:	f009 f877 	bl	f570 <_print>
    6482:	f898 3000 	ldrb.w	r3, [r8]
    6486:	4826      	ldr	r0, [pc, #152]	; (6520 <Connect_scan+0x208>)
    6488:	1aed      	subs	r5, r5, r3
    648a:	b2ed      	uxtb	r5, r5
    648c:	f04f 0c00 	mov.w	ip, #0
    6490:	2d00      	cmp	r5, #0
    6492:	f43f af7b 	beq.w	638c <Connect_scan+0x74>
    6496:	f894 3085 	ldrb.w	r3, [r4, #133]	; 0x85
    649a:	2b00      	cmp	r3, #0
    649c:	f43f af76 	beq.w	638c <Connect_scan+0x74>
    64a0:	f894 2083 	ldrb.w	r2, [r4, #131]	; 0x83
    64a4:	1c51      	adds	r1, r2, #1
    64a6:	4422      	add	r2, r4
    64a8:	3b01      	subs	r3, #1
    64aa:	f892 2086 	ldrb.w	r2, [r2, #134]	; 0x86
    64ae:	f884 1083 	strb.w	r1, [r4, #131]	; 0x83
    64b2:	3d01      	subs	r5, #1
    64b4:	7002      	strb	r2, [r0, #0]
    64b6:	f884 3085 	strb.w	r3, [r4, #133]	; 0x85
    64ba:	060b      	lsls	r3, r1, #24
    64bc:	bf48      	it	mi
    64be:	f884 c083 	strbmi.w	ip, [r4, #131]	; 0x83
    64c2:	b2ed      	uxtb	r5, r5
    64c4:	e7e4      	b.n	6490 <Connect_scan+0x178>
	Latency_end_time( connectLatencyResource );
    64c6:	7830      	ldrb	r0, [r6, #0]
}
    64c8:	b002      	add	sp, #8
    64ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	Latency_end_time( connectLatencyResource );
    64ce:	f008 bf9b 	b.w	f408 <Latency_end_time>
    64d2:	bf00      	nop
    64d4:	1fff89d0 	.word	0x1fff89d0
    64d8:	1fff94d7 	.word	0x1fff94d7
    64dc:	1fff94cc 	.word	0x1fff94cc
    64e0:	1fffb2ca 	.word	0x1fffb2ca
    64e4:	1fff94ce 	.word	0x1fff94ce
    64e8:	1fff92d8 	.word	0x1fff92d8
    64ec:	1fff94c8 	.word	0x1fff94c8
    64f0:	1fff89e2 	.word	0x1fff89e2
    64f4:	1fff94c4 	.word	0x1fff94c4
    64f8:	1fff94d8 	.word	0x1fff94d8
    64fc:	1fffa04e 	.word	0x1fffa04e
    6500:	4006a014 	.word	0x4006a014
    6504:	1fff94c6 	.word	0x1fff94c6
    6508:	00010ecb 	.word	0x00010ecb
    650c:	0000fb89 	.word	0x0000fb89
    6510:	00015df4 	.word	0x00015df4
    6514:	4006a007 	.word	0x4006a007
    6518:	4006b014 	.word	0x4006b014
    651c:	00010ed7 	.word	0x00010ed7
    6520:	4006b007 	.word	0x4006b007

00006524 <Connect_currentChange>:
{
    6524:	b507      	push	{r0, r1, r2, lr}
    6526:	4a0b      	ldr	r2, [pc, #44]	; (6554 <Connect_currentChange+0x30>)
	Connect_LastCurrentValue = current;
    6528:	490b      	ldr	r1, [pc, #44]	; (6558 <Connect_currentChange+0x34>)
{
    652a:	6813      	ldr	r3, [r2, #0]
    652c:	9301      	str	r3, [sp, #4]
	if ( current >= 250 )
    652e:	28f9      	cmp	r0, #249	; 0xf9
	uint16_t current_left = current;
    6530:	b283      	uxth	r3, r0
	Connect_LastCurrentValue = current;
    6532:	800b      	strh	r3, [r1, #0]
		current_left -= 125; // mA
    6534:	bf8c      	ite	hi
    6536:	3b7d      	subhi	r3, #125	; 0x7d
		current_left -= 50; // mA
    6538:	3b32      	subls	r3, #50	; 0x32
	Connect_send_CurrentEvent( current_left );
    653a:	9901      	ldr	r1, [sp, #4]
		current_left -= 50; // mA
    653c:	b298      	uxth	r0, r3
	Connect_send_CurrentEvent( current_left );
    653e:	6813      	ldr	r3, [r2, #0]
    6540:	4299      	cmp	r1, r3
    6542:	d001      	beq.n	6548 <Connect_currentChange+0x24>
    6544:	f7fc f8f4 	bl	2730 <__stack_chk_fail>
}
    6548:	b003      	add	sp, #12
    654a:	f85d eb04 	ldr.w	lr, [sp], #4
	Connect_send_CurrentEvent( current_left );
    654e:	f7ff bc29 	b.w	5da4 <Connect_send_CurrentEvent>
    6552:	bf00      	nop
    6554:	1fff89d0 	.word	0x1fff89d0
    6558:	1fff94ae 	.word	0x1fff94ae

0000655c <Connect_receive_IdReport>:
{
    655c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    655e:	4c18      	ldr	r4, [pc, #96]	; (65c0 <Connect_receive_IdReport+0x64>)
    6560:	4616      	mov	r6, r2
    6562:	6823      	ldr	r3, [r4, #0]
    6564:	9301      	str	r3, [sp, #4]
    6566:	4605      	mov	r5, r0
	dbug_print("IdReport");
    6568:	4816      	ldr	r0, [pc, #88]	; (65c4 <Connect_receive_IdReport+0x68>)
    656a:	f009 f801 	bl	f570 <_print>
	if ( uart_num == UART_Master )
    656e:	2e01      	cmp	r6, #1
    6570:	d102      	bne.n	6578 <Connect_receive_IdReport+0x1c>
		erro_print("Invalid IdRequest direction...");
    6572:	4815      	ldr	r0, [pc, #84]	; (65c8 <Connect_receive_IdReport+0x6c>)
    6574:	f008 fffc 	bl	f570 <_print>
	if ( Connect_master )
    6578:	4b14      	ldr	r3, [pc, #80]	; (65cc <Connect_receive_IdReport+0x70>)
    657a:	781b      	ldrb	r3, [r3, #0]
    657c:	b1d3      	cbz	r3, 65b4 <Connect_receive_IdReport+0x58>
		info_msg("Id Reported: ");
    657e:	4814      	ldr	r0, [pc, #80]	; (65d0 <Connect_receive_IdReport+0x74>)
    6580:	f008 fff6 	bl	f570 <_print>
		printHex( id );
    6584:	2101      	movs	r1, #1
    6586:	4628      	mov	r0, r5
    6588:	f009 f918 	bl	f7bc <printHex_op>
		print( NL );
    658c:	4811      	ldr	r0, [pc, #68]	; (65d4 <Connect_receive_IdReport+0x78>)
    658e:	f008 ffef 	bl	f570 <_print>
		if ( id > Connect_maxId )
    6592:	4b11      	ldr	r3, [pc, #68]	; (65d8 <Connect_receive_IdReport+0x7c>)
    6594:	781a      	ldrb	r2, [r3, #0]
    6596:	42aa      	cmp	r2, r5
			Connect_maxId = id;
    6598:	bf38      	it	cc
    659a:	701d      	strbcc	r5, [r3, #0]
		Connect_currentChange( Output_current_available() );
    659c:	f005 fb48 	bl	bc30 <Output_current_available>
    65a0:	f7ff ffc0 	bl	6524 <Connect_currentChange>
}
    65a4:	9a01      	ldr	r2, [sp, #4]
    65a6:	6823      	ldr	r3, [r4, #0]
    65a8:	429a      	cmp	r2, r3
    65aa:	f04f 0001 	mov.w	r0, #1
    65ae:	d005      	beq.n	65bc <Connect_receive_IdReport+0x60>
    65b0:	f7fc f8be 	bl	2730 <__stack_chk_fail>
		Connect_send_IdReport( id );
    65b4:	4628      	mov	r0, r5
    65b6:	f7ff fa87 	bl	5ac8 <Connect_send_IdReport>
	return 1;
    65ba:	e7f3      	b.n	65a4 <Connect_receive_IdReport+0x48>
}
    65bc:	b002      	add	sp, #8
    65be:	bd70      	pop	{r4, r5, r6, pc}
    65c0:	1fff89d0 	.word	0x1fff89d0
    65c4:	00010d5e 	.word	0x00010d5e
    65c8:	00010dbb 	.word	0x00010dbb
    65cc:	1fff94cc 	.word	0x1fff94cc
    65d0:	00010d7c 	.word	0x00010d7c
    65d4:	00015df4 	.word	0x00015df4
    65d8:	1fff94cd 	.word	0x1fff94cd

000065dc <Scan_setup>:

// ----- Functions -----

// Setup
inline void Scan_setup()
{
    65dc:	b513      	push	{r0, r1, r4, lr}
    65de:	4c0d      	ldr	r4, [pc, #52]	; (6614 <Scan_setup+0x38>)
    65e0:	6823      	ldr	r3, [r4, #0]
    65e2:	9301      	str	r3, [sp, #4]
	// Setup UART Connect, if Output_Available, this is the master node
	Connect_setup( Output_Available, 1 );
    65e4:	4b0c      	ldr	r3, [pc, #48]	; (6618 <Scan_setup+0x3c>)
    65e6:	2101      	movs	r1, #1
    65e8:	7818      	ldrb	r0, [r3, #0]
    65ea:	f7ff fca5 	bl	5f38 <Connect_setup>

	// Setup GPIO pins for matrix scanning
	Matrix_setup();
    65ee:	f7fd fd45 	bl	407c <Matrix_setup>

	// Setup ISSI chip to control the leds
	LED_setup();
    65f2:	f7fd fa45 	bl	3a80 <LED_setup>

	// Setup the ST/NHD lcd display
	LCD_setup();
    65f6:	f7fe fb91 	bl	4d1c <LCD_setup>

	// Setup Pixel Map
	Pixel_setup();
    65fa:	f004 fc49 	bl	ae90 <Pixel_setup>

	// Start Matrix Scanner
	Matrix_start();
    65fe:	9a01      	ldr	r2, [sp, #4]
    6600:	6823      	ldr	r3, [r4, #0]
    6602:	429a      	cmp	r2, r3
    6604:	d001      	beq.n	660a <Scan_setup+0x2e>
    6606:	f7fc f893 	bl	2730 <__stack_chk_fail>
}
    660a:	b002      	add	sp, #8
    660c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Matrix_start();
    6610:	f7fe b854 	b.w	46bc <Matrix_start>
    6614:	1fff89d0 	.word	0x1fff89d0
    6618:	1fffb2ca 	.word	0x1fffb2ca

0000661c <Scan_poll>:

// Main Poll Loop
// This is for operations that need to be run as often as possible
// Usually reserved for LED update routines and other things that need quick update rates
void Scan_poll()
{
    661c:	b513      	push	{r0, r1, r4, lr}
    661e:	4c09      	ldr	r4, [pc, #36]	; (6644 <Scan_poll+0x28>)
    6620:	6823      	ldr	r3, [r4, #0]
    6622:	9301      	str	r3, [sp, #4]
	// Prepare any LED events
	Pixel_process();
    6624:	f004 faca 	bl	abbc <Pixel_process>

	// Process any LED events
	LED_scan();
    6628:	f7fd fa9c 	bl	3b64 <LED_scan>

	// Process any LCD events
	LCD_scan();
    662c:	9a01      	ldr	r2, [sp, #4]
    662e:	6823      	ldr	r3, [r4, #0]
    6630:	429a      	cmp	r2, r3
    6632:	d001      	beq.n	6638 <Scan_poll+0x1c>
    6634:	f7fc f87c 	bl	2730 <__stack_chk_fail>
}
    6638:	b002      	add	sp, #8
    663a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LCD_scan();
    663e:	f7fe bc03 	b.w	4e48 <LCD_scan>
    6642:	bf00      	nop
    6644:	1fff89d0 	.word	0x1fff89d0

00006648 <Scan_periodic>:

// Main Periodic Scan
// This function is called periodically at a constant rate
// Useful for matrix scanning and anything that requires consistent attention
uint8_t Scan_periodic()
{
    6648:	b513      	push	{r0, r1, r4, lr}
    664a:	4c08      	ldr	r4, [pc, #32]	; (666c <Scan_periodic+0x24>)
    664c:	6823      	ldr	r3, [r4, #0]
    664e:	9301      	str	r3, [sp, #4]
	// Process any interconnect commands
	Connect_scan();
    6650:	f7ff fe62 	bl	6318 <Connect_scan>

	// Scan Matrix
	return Matrix_single_scan();
    6654:	9a01      	ldr	r2, [sp, #4]
    6656:	6823      	ldr	r3, [r4, #0]
    6658:	429a      	cmp	r2, r3
    665a:	d001      	beq.n	6660 <Scan_periodic+0x18>
    665c:	f7fc f868 	bl	2730 <__stack_chk_fail>
}
    6660:	b002      	add	sp, #8
    6662:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return Matrix_single_scan();
    6666:	f7fd bdd9 	b.w	421c <Matrix_single_scan>
    666a:	bf00      	nop
    666c:	1fff89d0 	.word	0x1fff89d0

00006670 <Scan_finishedWithMacro>:


// Signal from Macro Module that all keys have been processed (that it knows about)
inline void Scan_finishedWithMacro( uint8_t sentKeys )
{
    6670:	b507      	push	{r0, r1, r2, lr}
    6672:	4b06      	ldr	r3, [pc, #24]	; (668c <Scan_finishedWithMacro+0x1c>)
    6674:	681a      	ldr	r2, [r3, #0]
    6676:	9201      	str	r2, [sp, #4]
}
    6678:	9a01      	ldr	r2, [sp, #4]
    667a:	681b      	ldr	r3, [r3, #0]
    667c:	429a      	cmp	r2, r3
    667e:	d001      	beq.n	6684 <Scan_finishedWithMacro+0x14>
    6680:	f7fc f856 	bl	2730 <__stack_chk_fail>
    6684:	b003      	add	sp, #12
    6686:	f85d fb04 	ldr.w	pc, [sp], #4
    668a:	bf00      	nop
    668c:	1fff89d0 	.word	0x1fff89d0

00006690 <Scan_finishedWithOutput>:
    6690:	b507      	push	{r0, r1, r2, lr}
    6692:	4b06      	ldr	r3, [pc, #24]	; (66ac <Scan_finishedWithOutput+0x1c>)
    6694:	681a      	ldr	r2, [r3, #0]
    6696:	9201      	str	r2, [sp, #4]
    6698:	9a01      	ldr	r2, [sp, #4]
    669a:	681b      	ldr	r3, [r3, #0]
    669c:	429a      	cmp	r2, r3
    669e:	d001      	beq.n	66a4 <Scan_finishedWithOutput+0x14>
    66a0:	f7fc f846 	bl	2730 <__stack_chk_fail>
    66a4:	b003      	add	sp, #12
    66a6:	f85d fb04 	ldr.w	pc, [sp], #4
    66aa:	bf00      	nop
    66ac:	1fff89d0 	.word	0x1fff89d0

000066b0 <Scan_currentChange>:


// Signal from the Output Module that the available current has changed
// current - mA
void Scan_currentChange( unsigned int current )
{
    66b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    66b2:	4d0c      	ldr	r5, [pc, #48]	; (66e4 <Scan_currentChange+0x34>)
    66b4:	4604      	mov	r4, r0
    66b6:	682b      	ldr	r3, [r5, #0]
    66b8:	9301      	str	r3, [sp, #4]
	// Indicate to all submodules current change
	Connect_currentChange( current );
    66ba:	f7ff ff33 	bl	6524 <Connect_currentChange>
	Matrix_currentChange( current );
    66be:	4620      	mov	r0, r4
    66c0:	f7fe f810 	bl	46e4 <Matrix_currentChange>
	LED_currentChange( current );
    66c4:	4620      	mov	r0, r4
    66c6:	f7fd fb31 	bl	3d2c <LED_currentChange>
	LCD_currentChange( current );
    66ca:	9a01      	ldr	r2, [sp, #4]
    66cc:	682b      	ldr	r3, [r5, #0]
    66ce:	429a      	cmp	r2, r3
    66d0:	d001      	beq.n	66d6 <Scan_currentChange+0x26>
    66d2:	f7fc f82d 	bl	2730 <__stack_chk_fail>
    66d6:	4620      	mov	r0, r4
}
    66d8:	b003      	add	sp, #12
    66da:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LCD_currentChange( current );
    66de:	f7fe bc03 	b.w	4ee8 <LCD_currentChange>
    66e2:	bf00      	nop
    66e4:	1fff89d0 	.word	0x1fff89d0

000066e8 <KLL_TriggerIndex_loopkup>:

// ----- Functions -----

// Based on the type and index, lookup the full index
var_uint_t KLL_TriggerIndex_loopkup( TriggerType type, uint8_t index )
{
    66e8:	b507      	push	{r0, r1, r2, lr}
    66ea:	4b13      	ldr	r3, [pc, #76]	; (6738 <KLL_TriggerIndex_loopkup+0x50>)
    66ec:	2810      	cmp	r0, #16
    66ee:	681a      	ldr	r2, [r3, #0]
    66f0:	9201      	str	r2, [sp, #4]
    66f2:	461a      	mov	r2, r3
    66f4:	d80e      	bhi.n	6714 <KLL_TriggerIndex_loopkup+0x2c>
    66f6:	2301      	movs	r3, #1
    66f8:	fa03 f000 	lsl.w	r0, r3, r0
    66fc:	4b0f      	ldr	r3, [pc, #60]	; (673c <KLL_TriggerIndex_loopkup+0x54>)
    66fe:	4218      	tst	r0, r3
    6700:	d113      	bne.n	672a <KLL_TriggerIndex_loopkup+0x42>
    6702:	f648 0384 	movw	r3, #34948	; 0x8884
    6706:	4218      	tst	r0, r3
    6708:	d10b      	bne.n	6722 <KLL_TriggerIndex_loopkup+0x3a>
    670a:	f244 4342 	movw	r3, #17474	; 0x4442
    670e:	4218      	tst	r0, r3
    6710:	d000      	beq.n	6714 <KLL_TriggerIndex_loopkup+0x2c>
	{
	case TriggerType_Switch2:
	case TriggerType_Analog2:
	case TriggerType_Layer2:
	case TriggerType_Animation2:
		fullindex += 255;
    6712:	31ff      	adds	r1, #255	; 0xff
	default:
		break;
	}

	return fullindex;
}
    6714:	4608      	mov	r0, r1
    6716:	9901      	ldr	r1, [sp, #4]
    6718:	6813      	ldr	r3, [r2, #0]
    671a:	4299      	cmp	r1, r3
    671c:	d008      	beq.n	6730 <KLL_TriggerIndex_loopkup+0x48>
    671e:	f7fc f807 	bl	2730 <__stack_chk_fail>
		fullindex += 511;
    6722:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
		fullindex += 767;
    6726:	b289      	uxth	r1, r1
		break;
    6728:	e7f4      	b.n	6714 <KLL_TriggerIndex_loopkup+0x2c>
		fullindex += 767;
    672a:	f201 21ff 	addw	r1, r1, #767	; 0x2ff
    672e:	e7fa      	b.n	6726 <KLL_TriggerIndex_loopkup+0x3e>
}
    6730:	b003      	add	sp, #12
    6732:	f85d fb04 	ldr.w	pc, [sp], #4
    6736:	bf00      	nop
    6738:	1fff89d0 	.word	0x1fff89d0
    673c:	00011108 	.word	0x00011108

00006740 <KLL_CapabilityState>:


// Given a state and state type determine a CapabilityState
CapabilityState KLL_CapabilityState( ScheduleState state, TriggerType type )
{
    6740:	b507      	push	{r0, r1, r2, lr}
    6742:	4b1e      	ldr	r3, [pc, #120]	; (67bc <KLL_CapabilityState+0x7c>)
	// Lookup trigger type
	switch ( type )
    6744:	290c      	cmp	r1, #12
{
    6746:	681a      	ldr	r2, [r3, #0]
    6748:	9201      	str	r2, [sp, #4]
	switch ( type )
    674a:	d811      	bhi.n	6770 <KLL_CapabilityState+0x30>
    674c:	2909      	cmp	r1, #9
    674e:	d21d      	bcs.n	678c <KLL_CapabilityState+0x4c>
    6750:	2904      	cmp	r1, #4
    6752:	d01b      	beq.n	678c <KLL_CapabilityState+0x4c>
    6754:	d91a      	bls.n	678c <KLL_CapabilityState+0x4c>
		// XXX There is no "Press" state per say
		//     0x02 is reserved for Press
		//     0x01 is reserved for Release
		//     However these are reserved for working with state scheduling events
		//     By default, all analog values have to be handled manually (unless state scheduled)
		switch ( state )
    6756:	2801      	cmp	r0, #1
    6758:	d02a      	beq.n	67b0 <KLL_CapabilityState+0x70>
    675a:	d30e      	bcc.n	677a <KLL_CapabilityState+0x3a>
			return CapabilityState_Any;
    675c:	2802      	cmp	r0, #2
    675e:	bf0c      	ite	eq
    6760:	2001      	moveq	r0, #1
    6762:	2003      	movne	r0, #3
		break;
	}

	// Ignore otherwise
	return CapabilityState_None;
}
    6764:	9a01      	ldr	r2, [sp, #4]
    6766:	681b      	ldr	r3, [r3, #0]
    6768:	429a      	cmp	r2, r3
    676a:	d023      	beq.n	67b4 <KLL_CapabilityState+0x74>
    676c:	f7fb ffe0 	bl	2730 <__stack_chk_fail>
	switch ( type )
    6770:	2915      	cmp	r1, #21
    6772:	d01b      	beq.n	67ac <KLL_CapabilityState+0x6c>
    6774:	d803      	bhi.n	677e <KLL_CapabilityState+0x3e>
    6776:	2910      	cmp	r1, #16
    6778:	d912      	bls.n	67a0 <KLL_CapabilityState+0x60>
	return CapabilityState_None;
    677a:	2000      	movs	r0, #0
    677c:	e7f2      	b.n	6764 <KLL_CapabilityState+0x24>
	switch ( type )
    677e:	29ff      	cmp	r1, #255	; 0xff
    6780:	d1fb      	bne.n	677a <KLL_CapabilityState+0x3a>
		if ( state == ScheduleType_Debug )
    6782:	28ff      	cmp	r0, #255	; 0xff
    6784:	bf0c      	ite	eq
    6786:	20ff      	moveq	r0, #255	; 0xff
    6788:	2000      	movne	r0, #0
    678a:	e7eb      	b.n	6764 <KLL_CapabilityState+0x24>
		switch ( state )
    678c:	2802      	cmp	r0, #2
    678e:	d005      	beq.n	679c <KLL_CapabilityState+0x5c>
    6790:	2803      	cmp	r0, #3
    6792:	d00d      	beq.n	67b0 <KLL_CapabilityState+0x70>
	return CapabilityState_None;
    6794:	1e42      	subs	r2, r0, #1
    6796:	4250      	negs	r0, r2
    6798:	4150      	adcs	r0, r2
    679a:	e7e3      	b.n	6764 <KLL_CapabilityState+0x24>
			return CapabilityState_Any;
    679c:	2003      	movs	r0, #3
    679e:	e7e1      	b.n	6764 <KLL_CapabilityState+0x24>
		switch ( state )
    67a0:	3806      	subs	r0, #6
			return CapabilityState_Any;
    67a2:	2801      	cmp	r0, #1
    67a4:	bf8c      	ite	hi
    67a6:	2000      	movhi	r0, #0
    67a8:	2003      	movls	r0, #3
    67aa:	e7db      	b.n	6764 <KLL_CapabilityState+0x24>
			return CapabilityState_Initial;
    67ac:	2001      	movs	r0, #1
    67ae:	e7d9      	b.n	6764 <KLL_CapabilityState+0x24>
			return CapabilityState_Last;
    67b0:	2002      	movs	r0, #2
    67b2:	e7d7      	b.n	6764 <KLL_CapabilityState+0x24>
}
    67b4:	b003      	add	sp, #12
    67b6:	f85d fb04 	ldr.w	pc, [sp], #4
    67ba:	bf00      	nop
    67bc:	1fff89d0 	.word	0x1fff89d0

000067c0 <Layer_layerStateSet.part.0>:


// ----- Capabilities -----

// Sets the given layer with the specified layerState
void Layer_layerStateSet( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
    67c0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    67c4:	4e4d      	ldr	r6, [pc, #308]	; (68fc <Layer_layerStateSet.part.0+0x13c>)
	// Ignore if layer does not exist or trying to manipulate layer 0/Default layer
	if ( layer >= LayerNum || layer == 0 )
		return;

	// Check current layer state
	uint8_t oldState = LayerState[ layer ];
    67c6:	4c4e      	ldr	r4, [pc, #312]	; (6900 <Layer_layerStateSet.part.0+0x140>)

	// Is layer in the LayerIndexStack?
	uint8_t inLayerIndexStack = 0;
	uint16_t stackItem = 0;
	while ( stackItem < macroLayerIndexStackSize )
    67c8:	4d4e      	ldr	r5, [pc, #312]	; (6904 <Layer_layerStateSet.part.0+0x144>)
void Layer_layerStateSet( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint16_t layer, uint8_t layerState )
    67ca:	6833      	ldr	r3, [r6, #0]
    67cc:	9301      	str	r3, [sp, #4]
	uint8_t oldState = LayerState[ layer ];
    67ce:	f814 e000 	ldrb.w	lr, [r4, r0]
	while ( stackItem < macroLayerIndexStackSize )
    67d2:	882b      	ldrh	r3, [r5, #0]
	{
		// Flag if layer is already in the LayerIndexStack
		if ( macroLayerIndexStack[ stackItem ] == layer )
    67d4:	f8df c130 	ldr.w	ip, [pc, #304]	; 6908 <Layer_layerStateSet.part.0+0x148>
	while ( stackItem < macroLayerIndexStackSize )
    67d8:	2700      	movs	r7, #0
    67da:	b2ba      	uxth	r2, r7
    67dc:	429a      	cmp	r2, r3
    67de:	d34b      	bcc.n	6878 <Layer_layerStateSet.part.0+0xb8>
	uint8_t inLayerIndexStack = 0;
    67e0:	f04f 0c00 	mov.w	ip, #0
		// Increment to next item
		stackItem++;
	}

	// Toggle Layer State Byte
	if ( LayerState[ layer ] & layerState )
    67e4:	ea1e 0f01 	tst.w	lr, r1
	{
		// Unset
		LayerState[ layer ] &= ~layerState;
    67e8:	bf14      	ite	ne
    67ea:	ea2e 0801 	bicne.w	r8, lr, r1
	}
	else
	{
		// Set
		LayerState[ layer ] |= layerState;
    67ee:	ea4e 0801 	orreq.w	r8, lr, r1
    67f2:	f804 8000 	strb.w	r8, [r4, r0]
	}

	// If the layer was not in the LayerIndexStack add it
	if ( !inLayerIndexStack )
    67f6:	f1bc 0f00 	cmp.w	ip, #0
    67fa:	d107      	bne.n	680c <Layer_layerStateSet.part.0+0x4c>
	{
		macroLayerIndexStack[ macroLayerIndexStackSize++ ] = layer;
    67fc:	f103 0801 	add.w	r8, r3, #1
    6800:	f8a5 8000 	strh.w	r8, [r5]
    6804:	f8df 8100 	ldr.w	r8, [pc, #256]	; 6908 <Layer_layerStateSet.part.0+0x148>
    6808:	f828 0013 	strh.w	r0, [r8, r3, lsl #1]
	}

	// If the layer is in the LayerIndexStack and the state is 0x00, remove
	uint8_t newState = LayerState[ layer ];
    680c:	5c23      	ldrb	r3, [r4, r0]
	if ( newState == LayerStateType_Off && inLayerIndexStack )
    680e:	2b00      	cmp	r3, #0
    6810:	d163      	bne.n	68da <Layer_layerStateSet.part.0+0x11a>
    6812:	f1bc 0f00 	cmp.w	ip, #0
    6816:	d00a      	beq.n	682e <Layer_layerStateSet.part.0+0x6e>
    6818:	4b3b      	ldr	r3, [pc, #236]	; (6908 <Layer_layerStateSet.part.0+0x148>)
	{
		// Remove the layer from the LayerIndexStack
		// Using the already positioned stackItem variable from the loop above
		while ( stackItem < macroLayerIndexStackSize )
    681a:	f8b5 c000 	ldrh.w	ip, [r5]
    681e:	eb03 0347 	add.w	r3, r3, r7, lsl #1
    6822:	4562      	cmp	r2, ip
    6824:	d333      	bcc.n	688e <Layer_layerStateSet.part.0+0xce>
			macroLayerIndexStack[ stackItem ] = macroLayerIndexStack[ stackItem + 1 ];
			stackItem++;
		}

		// Reduce LayerIndexStack size
		macroLayerIndexStackSize--;
    6826:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    682a:	f8a5 c000 	strh.w	ip, [r5]
	}

	// Determine what signal to send about layer
	if ( oldState && newState )
    682e:	f1be 0f00 	cmp.w	lr, #0
    6832:	d13b      	bne.n	68ac <Layer_layerStateSet.part.0+0xec>
		// Send layer state that deactivated
		Macro_layerState( layer, ScheduleType_D | (layerState << 4) );
	}

	// Layer Debug Mode
	if ( layerDebugMode )
    6834:	4b35      	ldr	r3, [pc, #212]	; (690c <Layer_layerStateSet.part.0+0x14c>)
    6836:	781b      	ldrb	r3, [r3, #0]
    6838:	2b00      	cmp	r3, #0
    683a:	d057      	beq.n	68ec <Layer_layerStateSet.part.0+0x12c>
	{
		print("\033[1;36mL\033[0m ");
    683c:	4834      	ldr	r0, [pc, #208]	; (6910 <Layer_layerStateSet.part.0+0x150>)
		print(" 0");

		// Iterate over the layer stack starting from the bottom of the stack
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
		{
			print(":");
    683e:	4f35      	ldr	r7, [pc, #212]	; (6914 <Layer_layerStateSet.part.0+0x154>)
		print("\033[1;36mL\033[0m ");
    6840:	f008 fe96 	bl	f570 <_print>
			printHex_op( LayerState[ index ], 0 );
    6844:	7820      	ldrb	r0, [r4, #0]
    6846:	2100      	movs	r1, #0
    6848:	f008 ffb8 	bl	f7bc <printHex_op>
    684c:	7860      	ldrb	r0, [r4, #1]
    684e:	2100      	movs	r1, #0
    6850:	f008 ffb4 	bl	f7bc <printHex_op>
    6854:	78a0      	ldrb	r0, [r4, #2]
    6856:	2100      	movs	r1, #0
    6858:	f008 ffb0 	bl	f7bc <printHex_op>
		print(" 0");
    685c:	482e      	ldr	r0, [pc, #184]	; (6918 <Layer_layerStateSet.part.0+0x158>)
    685e:	f008 fe87 	bl	f570 <_print>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    6862:	882c      	ldrh	r4, [r5, #0]
    6864:	4d28      	ldr	r5, [pc, #160]	; (6908 <Layer_layerStateSet.part.0+0x148>)
    6866:	eb05 0544 	add.w	r5, r5, r4, lsl #1
    686a:	bb2c      	cbnz	r4, 68b8 <Layer_layerStateSet.part.0+0xf8>
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
		}

		print( NL );
    686c:	9a01      	ldr	r2, [sp, #4]
    686e:	6833      	ldr	r3, [r6, #0]
    6870:	429a      	cmp	r2, r3
    6872:	d02c      	beq.n	68ce <Layer_layerStateSet.part.0+0x10e>
	}
}
    6874:	f7fb ff5c 	bl	2730 <__stack_chk_fail>
		if ( macroLayerIndexStack[ stackItem ] == layer )
    6878:	f83c 9017 	ldrh.w	r9, [ip, r7, lsl #1]
    687c:	4581      	cmp	r9, r0
    687e:	f107 0801 	add.w	r8, r7, #1
    6882:	d001      	beq.n	6888 <Layer_layerStateSet.part.0+0xc8>
    6884:	4647      	mov	r7, r8
    6886:	e7a8      	b.n	67da <Layer_layerStateSet.part.0+0x1a>
			inLayerIndexStack = 1;
    6888:	f04f 0c01 	mov.w	ip, #1
    688c:	e7aa      	b.n	67e4 <Layer_layerStateSet.part.0+0x24>
			macroLayerIndexStack[ stackItem ] = macroLayerIndexStack[ stackItem + 1 ];
    688e:	f833 7f02 	ldrh.w	r7, [r3, #2]!
    6892:	f823 7c02 	strh.w	r7, [r3, #-2]
			stackItem++;
    6896:	3201      	adds	r2, #1
    6898:	b292      	uxth	r2, r2
    689a:	e7c2      	b.n	6822 <Layer_layerStateSet.part.0+0x62>
		Macro_layerState( layer, ScheduleType_On | (LayerState[ layer ] << 4) );
    689c:	0119      	lsls	r1, r3, #4
    689e:	f041 0102 	orr.w	r1, r1, #2
    68a2:	f001 01f2 	and.w	r1, r1, #242	; 0xf2
		Macro_layerState( layer, ScheduleType_D | (layerState << 4) );
    68a6:	f001 f90b 	bl	7ac0 <Macro_layerState>
    68aa:	e7c3      	b.n	6834 <Layer_layerStateSet.part.0+0x74>
    68ac:	0109      	lsls	r1, r1, #4
    68ae:	f041 0103 	orr.w	r1, r1, #3
    68b2:	f001 01f3 	and.w	r1, r1, #243	; 0xf3
    68b6:	e7f6      	b.n	68a6 <Layer_layerStateSet.part.0+0xe6>
			print(":");
    68b8:	4638      	mov	r0, r7
    68ba:	f008 fe59 	bl	f570 <_print>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    68be:	3c01      	subs	r4, #1
			printHex_op( macroLayerIndexStack[ index - 1 ], 0 );
    68c0:	2100      	movs	r1, #0
    68c2:	f835 0d02 	ldrh.w	r0, [r5, #-2]!
    68c6:	f008 ff79 	bl	f7bc <printHex_op>
		for ( index_uint_t index = macroLayerIndexStackSize; index > 0; index-- )
    68ca:	b2a4      	uxth	r4, r4
    68cc:	e7cd      	b.n	686a <Layer_layerStateSet.part.0+0xaa>
		print( NL );
    68ce:	4813      	ldr	r0, [pc, #76]	; (691c <Layer_layerStateSet.part.0+0x15c>)
}
    68d0:	b003      	add	sp, #12
    68d2:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		print( NL );
    68d6:	f008 be4b 	b.w	f570 <_print>
	if ( oldState && newState )
    68da:	f1be 0f00 	cmp.w	lr, #0
    68de:	d1dd      	bne.n	689c <Layer_layerStateSet.part.0+0xdc>
		Macro_layerState( layer, ScheduleType_A | (layerState << 4) );
    68e0:	0109      	lsls	r1, r1, #4
    68e2:	f041 0101 	orr.w	r1, r1, #1
    68e6:	f001 01f1 	and.w	r1, r1, #241	; 0xf1
    68ea:	e7dc      	b.n	68a6 <Layer_layerStateSet.part.0+0xe6>
}
    68ec:	9a01      	ldr	r2, [sp, #4]
    68ee:	6833      	ldr	r3, [r6, #0]
    68f0:	429a      	cmp	r2, r3
    68f2:	d1bf      	bne.n	6874 <Layer_layerStateSet.part.0+0xb4>
    68f4:	b003      	add	sp, #12
    68f6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    68fa:	bf00      	nop
    68fc:	1fff89d0 	.word	0x1fff89d0
    6900:	1fffa343 	.word	0x1fffa343
    6904:	1fff94e0 	.word	0x1fff94e0
    6908:	1fff94da 	.word	0x1fff94da
    690c:	1fffa286 	.word	0x1fffa286
    6910:	00011426 	.word	0x00011426
    6914:	00014d02 	.word	0x00014d02
    6918:	00011434 	.word	0x00011434
    691c:	00015df4 	.word	0x00015df4

00006920 <Layer_layerState_capability>:

// Modifies the specified Layer control byte
// Argument #1: Layer Index -> uint16_t
// Argument #2: Layer State -> uint8_t
void Layer_layerState_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    6920:	b573      	push	{r0, r1, r4, r5, r6, lr}
    6922:	4d1b      	ldr	r5, [pc, #108]	; (6990 <Layer_layerState_capability+0x70>)
    6924:	4608      	mov	r0, r1
    6926:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6928:	4611      	mov	r1, r2
{
    692a:	682b      	ldr	r3, [r5, #0]
    692c:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    692e:	f7ff ff07 	bl	6740 <KLL_CapabilityState>
    6932:	462e      	mov	r6, r5

	switch ( cstate )
    6934:	b328      	cbz	r0, 6982 <Layer_layerState_capability+0x62>
    6936:	2802      	cmp	r0, #2
    6938:	d915      	bls.n	6966 <Layer_layerState_capability+0x46>
    693a:	28ff      	cmp	r0, #255	; 0xff
    693c:	d121      	bne.n	6982 <Layer_layerState_capability+0x62>
	case CapabilityState_Last:
		// Only use capability on press or release
		break;
	case CapabilityState_Debug:
		// Display capability name
		print("Layer_layerState(layerIndex,layerState)");
    693e:	4815      	ldr	r0, [pc, #84]	; (6994 <Layer_layerState_capability+0x74>)
    6940:	f008 fe16 	bl	f570 <_print>

		// Read arg if not set to 0
		if ( args != 0 )
    6944:	b1ec      	cbz	r4, 6982 <Layer_layerState_capability+0x62>
		{
			uint16_t key = *(uint16_t*)(&args[0]);
			print(" -> ");
    6946:	4814      	ldr	r0, [pc, #80]	; (6998 <Layer_layerState_capability+0x78>)
			uint16_t key = *(uint16_t*)(&args[0]);
    6948:	8824      	ldrh	r4, [r4, #0]
			print(" -> ");
    694a:	f008 fe11 	bl	f570 <_print>
			printInt16( key );
    694e:	9a01      	ldr	r2, [sp, #4]
    6950:	682b      	ldr	r3, [r5, #0]
    6952:	429a      	cmp	r2, r3
    6954:	d001      	beq.n	695a <Layer_layerState_capability+0x3a>

	// Get layer toggle byte
	uint8_t layerState = args[ sizeof(uint16_t) ];

	Layer_layerStateSet( trigger, state, stateType, layer, layerState );
}
    6956:	f7fb feeb 	bl	2730 <__stack_chk_fail>
			printInt16( key );
    695a:	4620      	mov	r0, r4
}
    695c:	b002      	add	sp, #8
    695e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    6962:	f008 bea5 	b.w	f6b0 <printInt16>
	uint16_t layer = *(uint16_t*)(&args[0]);
    6966:	8820      	ldrh	r0, [r4, #0]
	if ( layer >= LayerNum || layer == 0 )
    6968:	1e43      	subs	r3, r0, #1
    696a:	2b01      	cmp	r3, #1
    696c:	d809      	bhi.n	6982 <Layer_layerState_capability+0x62>
    696e:	9a01      	ldr	r2, [sp, #4]
    6970:	682b      	ldr	r3, [r5, #0]
    6972:	429a      	cmp	r2, r3
    6974:	d1ef      	bne.n	6956 <Layer_layerState_capability+0x36>
    6976:	78a1      	ldrb	r1, [r4, #2]
}
    6978:	b002      	add	sp, #8
    697a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    697e:	f7ff bf1f 	b.w	67c0 <Layer_layerStateSet.part.0>
    6982:	9a01      	ldr	r2, [sp, #4]
    6984:	6833      	ldr	r3, [r6, #0]
    6986:	429a      	cmp	r2, r3
    6988:	d1e5      	bne.n	6956 <Layer_layerState_capability+0x36>
    698a:	b002      	add	sp, #8
    698c:	bd70      	pop	{r4, r5, r6, pc}
    698e:	bf00      	nop
    6990:	1fff89d0 	.word	0x1fff89d0
    6994:	00011437 	.word	0x00011437
    6998:	00010c65 	.word	0x00010c65

0000699c <Layer_layerLatch_capability>:


// Latches given layer
// Argument #1: Layer Index -> uint16_t
void Layer_layerLatch_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    699c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    699e:	4c1a      	ldr	r4, [pc, #104]	; (6a08 <Layer_layerLatch_capability+0x6c>)
    69a0:	4608      	mov	r0, r1
    69a2:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    69a4:	4611      	mov	r1, r2
{
    69a6:	6823      	ldr	r3, [r4, #0]
    69a8:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    69aa:	f7ff fec9 	bl	6740 <KLL_CapabilityState>

	switch ( cstate )
    69ae:	2802      	cmp	r0, #2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    69b0:	4601      	mov	r1, r0
    69b2:	4626      	mov	r6, r4
	switch ( cstate )
    69b4:	d015      	beq.n	69e2 <Layer_layerLatch_capability+0x46>
    69b6:	28ff      	cmp	r0, #255	; 0xff
    69b8:	d120      	bne.n	69fc <Layer_layerLatch_capability+0x60>
	case CapabilityState_Last:
		// Only use capability on release
		break;
	case CapabilityState_Debug:
		// Display capability name
		print("Layer_layerLatch(layerIndex)");
    69ba:	4814      	ldr	r0, [pc, #80]	; (6a0c <Layer_layerLatch_capability+0x70>)
    69bc:	f008 fdd8 	bl	f570 <_print>

		// Read arg if not set to 0
		if ( args != 0 )
    69c0:	b1e5      	cbz	r5, 69fc <Layer_layerLatch_capability+0x60>
		{
			uint16_t key = *(uint16_t*)(&args[0]);
			print(" -> ");
    69c2:	4813      	ldr	r0, [pc, #76]	; (6a10 <Layer_layerLatch_capability+0x74>)
			uint16_t key = *(uint16_t*)(&args[0]);
    69c4:	882d      	ldrh	r5, [r5, #0]
			print(" -> ");
    69c6:	f008 fdd3 	bl	f570 <_print>
			printInt16( key );
    69ca:	9a01      	ldr	r2, [sp, #4]
    69cc:	6823      	ldr	r3, [r4, #0]
    69ce:	429a      	cmp	r2, r3
    69d0:	d001      	beq.n	69d6 <Layer_layerLatch_capability+0x3a>
	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	Layer_layerStateSet( trigger, state, stateType, layer, LayerStateType_Latch );
}
    69d2:	f7fb fead 	bl	2730 <__stack_chk_fail>
			printInt16( key );
    69d6:	4628      	mov	r0, r5
}
    69d8:	b002      	add	sp, #8
    69da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    69de:	f008 be67 	b.w	f6b0 <printInt16>
	uint16_t layer = *(uint16_t*)(&args[0]);
    69e2:	8828      	ldrh	r0, [r5, #0]
	if ( layer >= LayerNum || layer == 0 )
    69e4:	1e43      	subs	r3, r0, #1
    69e6:	2b01      	cmp	r3, #1
    69e8:	d808      	bhi.n	69fc <Layer_layerLatch_capability+0x60>
    69ea:	9a01      	ldr	r2, [sp, #4]
    69ec:	6823      	ldr	r3, [r4, #0]
    69ee:	429a      	cmp	r2, r3
    69f0:	d1ef      	bne.n	69d2 <Layer_layerLatch_capability+0x36>
}
    69f2:	b002      	add	sp, #8
    69f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    69f8:	f7ff bee2 	b.w	67c0 <Layer_layerStateSet.part.0>
    69fc:	9a01      	ldr	r2, [sp, #4]
    69fe:	6833      	ldr	r3, [r6, #0]
    6a00:	429a      	cmp	r2, r3
    6a02:	d1e6      	bne.n	69d2 <Layer_layerLatch_capability+0x36>
    6a04:	b002      	add	sp, #8
    6a06:	bd70      	pop	{r4, r5, r6, pc}
    6a08:	1fff89d0 	.word	0x1fff89d0
    6a0c:	000113b4 	.word	0x000113b4
    6a10:	00010c65 	.word	0x00010c65

00006a14 <Layer_layerLock_capability>:


// Locks given layer
// Argument #1: Layer Index -> uint16_t
void Layer_layerLock_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    6a14:	b573      	push	{r0, r1, r4, r5, r6, lr}
    6a16:	4c1a      	ldr	r4, [pc, #104]	; (6a80 <Layer_layerLock_capability+0x6c>)
    6a18:	4608      	mov	r0, r1
    6a1a:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6a1c:	4611      	mov	r1, r2
{
    6a1e:	6823      	ldr	r3, [r4, #0]
    6a20:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6a22:	f7ff fe8d 	bl	6740 <KLL_CapabilityState>

	switch ( cstate )
    6a26:	2801      	cmp	r0, #1
    6a28:	4626      	mov	r6, r4
    6a2a:	d015      	beq.n	6a58 <Layer_layerLock_capability+0x44>
    6a2c:	28ff      	cmp	r0, #255	; 0xff
    6a2e:	d121      	bne.n	6a74 <Layer_layerLock_capability+0x60>
	case CapabilityState_Initial:
		// Only use capability on press
		break;
	case CapabilityState_Debug:
		// Display capability name
		print("Layer_layerLock(layerIndex)");
    6a30:	4814      	ldr	r0, [pc, #80]	; (6a84 <Layer_layerLock_capability+0x70>)
    6a32:	f008 fd9d 	bl	f570 <_print>

		// Read arg if not set to 0
		if ( args != 0 )
    6a36:	b1ed      	cbz	r5, 6a74 <Layer_layerLock_capability+0x60>
		{
			uint16_t key = *(uint16_t*)(&args[0]);
			print(" -> ");
    6a38:	4813      	ldr	r0, [pc, #76]	; (6a88 <Layer_layerLock_capability+0x74>)
			uint16_t key = *(uint16_t*)(&args[0]);
    6a3a:	882d      	ldrh	r5, [r5, #0]
			print(" -> ");
    6a3c:	f008 fd98 	bl	f570 <_print>
			printInt16( key );
    6a40:	9a01      	ldr	r2, [sp, #4]
    6a42:	6823      	ldr	r3, [r4, #0]
    6a44:	429a      	cmp	r2, r3
    6a46:	d001      	beq.n	6a4c <Layer_layerLock_capability+0x38>
	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	Layer_layerStateSet( trigger, state, stateType, layer, LayerStateType_Lock );
}
    6a48:	f7fb fe72 	bl	2730 <__stack_chk_fail>
			printInt16( key );
    6a4c:	4628      	mov	r0, r5
}
    6a4e:	b002      	add	sp, #8
    6a50:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    6a54:	f008 be2c 	b.w	f6b0 <printInt16>
	uint16_t layer = *(uint16_t*)(&args[0]);
    6a58:	8828      	ldrh	r0, [r5, #0]
	if ( layer >= LayerNum || layer == 0 )
    6a5a:	1e43      	subs	r3, r0, #1
    6a5c:	2b01      	cmp	r3, #1
    6a5e:	d809      	bhi.n	6a74 <Layer_layerLock_capability+0x60>
    6a60:	9a01      	ldr	r2, [sp, #4]
    6a62:	6823      	ldr	r3, [r4, #0]
    6a64:	429a      	cmp	r2, r3
    6a66:	d1ef      	bne.n	6a48 <Layer_layerLock_capability+0x34>
    6a68:	2104      	movs	r1, #4
}
    6a6a:	b002      	add	sp, #8
    6a6c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    6a70:	f7ff bea6 	b.w	67c0 <Layer_layerStateSet.part.0>
    6a74:	9a01      	ldr	r2, [sp, #4]
    6a76:	6833      	ldr	r3, [r6, #0]
    6a78:	429a      	cmp	r2, r3
    6a7a:	d1e5      	bne.n	6a48 <Layer_layerLock_capability+0x34>
    6a7c:	b002      	add	sp, #8
    6a7e:	bd70      	pop	{r4, r5, r6, pc}
    6a80:	1fff89d0 	.word	0x1fff89d0
    6a84:	000113d1 	.word	0x000113d1
    6a88:	00010c65 	.word	0x00010c65

00006a8c <Layer_layerShift_capability>:


// Shifts given layer
// Argument #1: Layer Index -> uint16_t
void Layer_layerShift_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    6a8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    6a8e:	4d28      	ldr	r5, [pc, #160]	; (6b30 <Layer_layerShift_capability+0xa4>)
    6a90:	461e      	mov	r6, r3
    6a92:	4608      	mov	r0, r1
    6a94:	682b      	ldr	r3, [r5, #0]
    6a96:	9301      	str	r3, [sp, #4]
	// Get layer index from arguments
	// Cast pointer to uint8_t to uint16_t then access that memory location
	uint16_t layer = *(uint16_t*)(&args[0]);

	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6a98:	4611      	mov	r1, r2
	uint16_t layer = *(uint16_t*)(&args[0]);
    6a9a:	8834      	ldrh	r4, [r6, #0]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6a9c:	f7ff fe50 	bl	6740 <KLL_CapabilityState>

	switch ( cstate )
    6aa0:	2802      	cmp	r0, #2
    6aa2:	462b      	mov	r3, r5
    6aa4:	d017      	beq.n	6ad6 <Layer_layerShift_capability+0x4a>
    6aa6:	28ff      	cmp	r0, #255	; 0xff
    6aa8:	d022      	beq.n	6af0 <Layer_layerShift_capability+0x64>
    6aaa:	2801      	cmp	r0, #1
    6aac:	d13a      	bne.n	6b24 <Layer_layerShift_capability+0x98>
	{
	case CapabilityState_Initial:
		// Press
		// Only set the layer if it is disabled
		if ( (LayerState[ layer ] & LayerStateType_Shift) != LayerStateType_Off )
    6aae:	4a21      	ldr	r2, [pc, #132]	; (6b34 <Layer_layerShift_capability+0xa8>)
    6ab0:	5d12      	ldrb	r2, [r2, r4]
    6ab2:	07d2      	lsls	r2, r2, #31
    6ab4:	d52d      	bpl.n	6b12 <Layer_layerShift_capability+0x86>
	if ( layer >= LayerNum || layer == 0 )
    6ab6:	1e62      	subs	r2, r4, #1
    6ab8:	2a01      	cmp	r2, #1
    6aba:	d833      	bhi.n	6b24 <Layer_layerShift_capability+0x98>
    6abc:	9a01      	ldr	r2, [sp, #4]
    6abe:	682b      	ldr	r3, [r5, #0]
    6ac0:	429a      	cmp	r2, r3
    6ac2:	d001      	beq.n	6ac8 <Layer_layerShift_capability+0x3c>
	default:
		return;
	}

	Layer_layerStateSet( trigger, state, stateType, layer, LayerStateType_Shift );
}
    6ac4:	f7fb fe34 	bl	2730 <__stack_chk_fail>
    6ac8:	2100      	movs	r1, #0
    6aca:	4620      	mov	r0, r4
    6acc:	b002      	add	sp, #8
    6ace:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    6ad2:	f7ff be75 	b.w	67c0 <Layer_layerStateSet.part.0>
		if ( (LayerState[ layer ] & LayerStateType_Shift) == LayerStateType_Off )
    6ad6:	4a17      	ldr	r2, [pc, #92]	; (6b34 <Layer_layerShift_capability+0xa8>)
    6ad8:	5d11      	ldrb	r1, [r2, r4]
    6ada:	f011 0101 	ands.w	r1, r1, #1
    6ade:	d118      	bne.n	6b12 <Layer_layerShift_capability+0x86>
	if ( layer >= LayerNum || layer == 0 )
    6ae0:	1e62      	subs	r2, r4, #1
    6ae2:	2a01      	cmp	r2, #1
    6ae4:	d81e      	bhi.n	6b24 <Layer_layerShift_capability+0x98>
    6ae6:	9a01      	ldr	r2, [sp, #4]
    6ae8:	682b      	ldr	r3, [r5, #0]
    6aea:	429a      	cmp	r2, r3
    6aec:	d0ed      	beq.n	6aca <Layer_layerShift_capability+0x3e>
    6aee:	e7e9      	b.n	6ac4 <Layer_layerShift_capability+0x38>
		print("Layer_layerShift(layerIndex)");
    6af0:	4811      	ldr	r0, [pc, #68]	; (6b38 <Layer_layerShift_capability+0xac>)
    6af2:	f008 fd3d 	bl	f570 <_print>
			print(" -> ");
    6af6:	4811      	ldr	r0, [pc, #68]	; (6b3c <Layer_layerShift_capability+0xb0>)
			uint16_t key = *(uint16_t*)(&args[0]);
    6af8:	8834      	ldrh	r4, [r6, #0]
			print(" -> ");
    6afa:	f008 fd39 	bl	f570 <_print>
			printInt16( key );
    6afe:	9a01      	ldr	r2, [sp, #4]
    6b00:	682b      	ldr	r3, [r5, #0]
    6b02:	429a      	cmp	r2, r3
    6b04:	d1de      	bne.n	6ac4 <Layer_layerShift_capability+0x38>
    6b06:	4620      	mov	r0, r4
}
    6b08:	b002      	add	sp, #8
    6b0a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    6b0e:	f008 bdcf 	b.w	f6b0 <printInt16>
	if ( layer >= LayerNum || layer == 0 )
    6b12:	1e62      	subs	r2, r4, #1
    6b14:	2a01      	cmp	r2, #1
    6b16:	d805      	bhi.n	6b24 <Layer_layerShift_capability+0x98>
    6b18:	9a01      	ldr	r2, [sp, #4]
    6b1a:	681b      	ldr	r3, [r3, #0]
    6b1c:	429a      	cmp	r2, r3
    6b1e:	d1d1      	bne.n	6ac4 <Layer_layerShift_capability+0x38>
    6b20:	2101      	movs	r1, #1
    6b22:	e7d2      	b.n	6aca <Layer_layerShift_capability+0x3e>
}
    6b24:	9a01      	ldr	r2, [sp, #4]
    6b26:	681b      	ldr	r3, [r3, #0]
    6b28:	429a      	cmp	r2, r3
    6b2a:	d1cb      	bne.n	6ac4 <Layer_layerShift_capability+0x38>
    6b2c:	b002      	add	sp, #8
    6b2e:	bd70      	pop	{r4, r5, r6, pc}
    6b30:	1fff89d0 	.word	0x1fff89d0
    6b34:	1fffa343 	.word	0x1fffa343
    6b38:	00011409 	.word	0x00011409
    6b3c:	00010c65 	.word	0x00010c65

00006b40 <Layer_layerRotate_capability>:

// Rotate layer to next/previous
// Uses state variable to keep track of the current layer position
// Layers are still evaluated using the layer stack
void Layer_layerRotate_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    6b40:	b573      	push	{r0, r1, r4, r5, r6, lr}
    6b42:	4c27      	ldr	r4, [pc, #156]	; (6be0 <Layer_layerRotate_capability+0xa0>)
    6b44:	4608      	mov	r0, r1
    6b46:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6b48:	4611      	mov	r1, r2
{
    6b4a:	6823      	ldr	r3, [r4, #0]
    6b4c:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6b4e:	f7ff fdf7 	bl	6740 <KLL_CapabilityState>

	switch ( cstate )
    6b52:	2801      	cmp	r0, #1
    6b54:	4626      	mov	r6, r4
    6b56:	d016      	beq.n	6b86 <Layer_layerRotate_capability+0x46>
    6b58:	28ff      	cmp	r0, #255	; 0xff
    6b5a:	d13a      	bne.n	6bd2 <Layer_layerRotate_capability+0x92>
	case CapabilityState_Initial:
		// Only use capability on press
		break;
	case CapabilityState_Debug:
		// Display capability name
		print("Layer_layerRotate(previous)");
    6b5c:	4821      	ldr	r0, [pc, #132]	; (6be4 <Layer_layerRotate_capability+0xa4>)
    6b5e:	f008 fd07 	bl	f570 <_print>

		// Read arg if not set to 0
		if ( args != 0 )
    6b62:	2d00      	cmp	r5, #0
    6b64:	d035      	beq.n	6bd2 <Layer_layerRotate_capability+0x92>
		{
			uint8_t key = args[0];
			print(" -> ");
    6b66:	4820      	ldr	r0, [pc, #128]	; (6be8 <Layer_layerRotate_capability+0xa8>)
			uint8_t key = args[0];
    6b68:	782d      	ldrb	r5, [r5, #0]
			print(" -> ");
    6b6a:	f008 fd01 	bl	f570 <_print>
			printInt8( key );
    6b6e:	9a01      	ldr	r2, [sp, #4]
    6b70:	6823      	ldr	r3, [r4, #0]
    6b72:	429a      	cmp	r2, r3
    6b74:	d001      	beq.n	6b7a <Layer_layerRotate_capability+0x3a>
			Layer_rotationLayer = LayerNum - 1;
	}

	// Toggle the computed layer rotation
	Layer_layerStateSet( trigger, state, stateType, Layer_rotationLayer, LayerStateType_Lock );
}
    6b76:	f7fb fddb 	bl	2730 <__stack_chk_fail>
			printInt8( key );
    6b7a:	4628      	mov	r0, r5
}
    6b7c:	b002      	add	sp, #8
    6b7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt8( key );
    6b82:	f008 bd5f 	b.w	f644 <printInt8>
	if ( Layer_rotationLayer != 0 )
    6b86:	4c19      	ldr	r4, [pc, #100]	; (6bec <Layer_layerRotate_capability+0xac>)
    6b88:	8820      	ldrh	r0, [r4, #0]
    6b8a:	1e43      	subs	r3, r0, #1
    6b8c:	2b01      	cmp	r3, #1
    6b8e:	d802      	bhi.n	6b96 <Layer_layerRotate_capability+0x56>
    6b90:	2104      	movs	r1, #4
    6b92:	f7ff fe15 	bl	67c0 <Layer_layerStateSet.part.0>
	if ( !direction )
    6b96:	782a      	ldrb	r2, [r5, #0]
    6b98:	8823      	ldrh	r3, [r4, #0]
    6b9a:	b9a2      	cbnz	r2, 6bc6 <Layer_layerRotate_capability+0x86>
		Layer_rotationLayer++;
    6b9c:	3301      	adds	r3, #1
    6b9e:	b29b      	uxth	r3, r3
		if ( Layer_rotationLayer >= LayerNum )
    6ba0:	2b02      	cmp	r3, #2
    6ba2:	d801      	bhi.n	6ba8 <Layer_layerRotate_capability+0x68>
			Layer_rotationLayer = LayerNum - 1;
    6ba4:	8023      	strh	r3, [r4, #0]
    6ba6:	e000      	b.n	6baa <Layer_layerRotate_capability+0x6a>
			Layer_rotationLayer = 0;
    6ba8:	8022      	strh	r2, [r4, #0]
	Layer_layerStateSet( trigger, state, stateType, Layer_rotationLayer, LayerStateType_Lock );
    6baa:	8820      	ldrh	r0, [r4, #0]
	if ( layer >= LayerNum || layer == 0 )
    6bac:	1e43      	subs	r3, r0, #1
    6bae:	2b01      	cmp	r3, #1
    6bb0:	d80f      	bhi.n	6bd2 <Layer_layerRotate_capability+0x92>
    6bb2:	9a01      	ldr	r2, [sp, #4]
    6bb4:	6833      	ldr	r3, [r6, #0]
    6bb6:	429a      	cmp	r2, r3
    6bb8:	d1dd      	bne.n	6b76 <Layer_layerRotate_capability+0x36>
    6bba:	2104      	movs	r1, #4
}
    6bbc:	b002      	add	sp, #8
    6bbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    6bc2:	f7ff bdfd 	b.w	67c0 <Layer_layerStateSet.part.0>
		Layer_rotationLayer--;
    6bc6:	3b01      	subs	r3, #1
    6bc8:	b29b      	uxth	r3, r3
		if ( Layer_rotationLayer >= LayerNum )
    6bca:	2b02      	cmp	r3, #2
			Layer_rotationLayer = LayerNum - 1;
    6bcc:	bf88      	it	hi
    6bce:	2302      	movhi	r3, #2
    6bd0:	e7e8      	b.n	6ba4 <Layer_layerRotate_capability+0x64>
}
    6bd2:	9a01      	ldr	r2, [sp, #4]
    6bd4:	6833      	ldr	r3, [r6, #0]
    6bd6:	429a      	cmp	r2, r3
    6bd8:	d1cd      	bne.n	6b76 <Layer_layerRotate_capability+0x36>
    6bda:	b002      	add	sp, #8
    6bdc:	bd70      	pop	{r4, r5, r6, pc}
    6bde:	bf00      	nop
    6be0:	1fff89d0 	.word	0x1fff89d0
    6be4:	000113ed 	.word	0x000113ed
    6be8:	00010c65 	.word	0x00010c65
    6bec:	1fffa284 	.word	0x1fffa284

00006bf0 <Layer_clearLayers>:

// ----- Functions -----

// Clears the current layer state
void Layer_clearLayers()
{
    6bf0:	b507      	push	{r0, r1, r2, lr}
    6bf2:	4b09      	ldr	r3, [pc, #36]	; (6c18 <Layer_clearLayers+0x28>)
    6bf4:	681a      	ldr	r2, [r3, #0]
    6bf6:	9201      	str	r2, [sp, #4]
	// Clear layer stack
	macroLayerIndexStackSize = 0;
    6bf8:	4a08      	ldr	r2, [pc, #32]	; (6c1c <Layer_clearLayers+0x2c>)
    6bfa:	2100      	movs	r1, #0
    6bfc:	8011      	strh	r1, [r2, #0]

	// Clear layer states
	memset( &LayerState, 0, sizeof(LayerStateType) * LayerNum );
    6bfe:	9a01      	ldr	r2, [sp, #4]
    6c00:	681b      	ldr	r3, [r3, #0]
    6c02:	429a      	cmp	r2, r3
    6c04:	d001      	beq.n	6c0a <Layer_clearLayers+0x1a>
    6c06:	f7fb fd93 	bl	2730 <__stack_chk_fail>
    6c0a:	4805      	ldr	r0, [pc, #20]	; (6c20 <Layer_clearLayers+0x30>)
    6c0c:	2203      	movs	r2, #3
}
    6c0e:	b003      	add	sp, #12
    6c10:	f85d eb04 	ldr.w	lr, [sp], #4
	memset( &LayerState, 0, sizeof(LayerStateType) * LayerNum );
    6c14:	f7fb bd9a 	b.w	274c <memset>
    6c18:	1fff89d0 	.word	0x1fff89d0
    6c1c:	1fff94e0 	.word	0x1fff94e0
    6c20:	1fffa343 	.word	0x1fffa343

00006c24 <Layer_setup>:


// Setup layers
void Layer_setup()
{
    6c24:	b513      	push	{r0, r1, r4, lr}
    6c26:	4c09      	ldr	r4, [pc, #36]	; (6c4c <Layer_setup+0x28>)
    6c28:	6823      	ldr	r3, [r4, #0]
    6c2a:	9301      	str	r3, [sp, #4]
	// Cleanup layers
	Layer_clearLayers();
    6c2c:	f7ff ffe0 	bl	6bf0 <Layer_clearLayers>

	// Set the current rotated layer to 0
	Layer_rotationLayer = 0;
    6c30:	4a07      	ldr	r2, [pc, #28]	; (6c50 <Layer_setup+0x2c>)
    6c32:	2300      	movs	r3, #0
    6c34:	8013      	strh	r3, [r2, #0]

	// Layer debug mode
	layerDebugMode = 0;
    6c36:	4a07      	ldr	r2, [pc, #28]	; (6c54 <Layer_setup+0x30>)
    6c38:	7013      	strb	r3, [r2, #0]
}
    6c3a:	9a01      	ldr	r2, [sp, #4]
    6c3c:	6823      	ldr	r3, [r4, #0]
    6c3e:	429a      	cmp	r2, r3
    6c40:	d001      	beq.n	6c46 <Layer_setup+0x22>
    6c42:	f7fb fd75 	bl	2730 <__stack_chk_fail>
    6c46:	b002      	add	sp, #8
    6c48:	bd10      	pop	{r4, pc}
    6c4a:	bf00      	nop
    6c4c:	1fff89d0 	.word	0x1fff89d0
    6c50:	1fffa284 	.word	0x1fffa284
    6c54:	1fffa286 	.word	0x1fffa286

00006c58 <Layer_layerLookup>:


// Looks up the trigger list for the given scan code (from the active layer)
// NOTE: Calling function must handle the NULL pointer case
nat_ptr_t *Layer_layerLookup( TriggerEvent *event, uint8_t latch_expire )
{
    6c58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6c5c:	4d4c      	ldr	r5, [pc, #304]	; (6d90 <Layer_layerLookup+0x138>)
	uint8_t index = event->index;
    6c5e:	7884      	ldrb	r4, [r0, #2]
{
    6c60:	682b      	ldr	r3, [r5, #0]
    6c62:	b087      	sub	sp, #28
    6c64:	4607      	mov	r7, r0
    6c66:	468a      	mov	sl, r1

	// Cached Lookup (for handling layer latches)
	uint8_t cache_lookup = 0;
	CapabilityState cstate = KLL_CapabilityState( event->state, event->type );
    6c68:	7801      	ldrb	r1, [r0, #0]
    6c6a:	7840      	ldrb	r0, [r0, #1]
{
    6c6c:	9305      	str	r3, [sp, #20]
	CapabilityState cstate = KLL_CapabilityState( event->state, event->type );
    6c6e:	f7ff fd67 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    6c72:	3802      	subs	r0, #2
    6c74:	2801      	cmp	r0, #1
    6c76:	9501      	str	r5, [sp, #4]
    6c78:	d817      	bhi.n	6caa <Layer_layerLookup+0x52>

	// Do a cached lookup if necessary
	if ( cache_lookup )
	{
		// Cached layer
		var_uint_t cachedLayer = macroTriggerEventLayerCache[ index ];
    6c7a:	4b46      	ldr	r3, [pc, #280]	; (6d94 <Layer_layerLookup+0x13c>)

		// Lookup map, then layer
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    6c7c:	4946      	ldr	r1, [pc, #280]	; (6d98 <Layer_layerLookup+0x140>)
		var_uint_t cachedLayer = macroTriggerEventLayerCache[ index ];
    6c7e:	f833 0014 	ldrh.w	r0, [r3, r4, lsl #1]
		nat_ptr_t **map = (nat_ptr_t**)LayerIndex[ cachedLayer ].triggerMap;
    6c82:	230c      	movs	r3, #12
    6c84:	4343      	muls	r3, r0
    6c86:	18ca      	adds	r2, r1, r3
		const Layer *layer = &LayerIndex[ cachedLayer ];

		// Cache trigger list before attempting to expire latch
		nat_ptr_t *trigger_list = map[ index - layer->first ];
    6c88:	58cb      	ldr	r3, [r1, r3]
    6c8a:	7a12      	ldrb	r2, [r2, #8]
    6c8c:	1aa4      	subs	r4, r4, r2
    6c8e:	f853 6024 	ldr.w	r6, [r3, r4, lsl #2]

		// Check if latch has been pressed for this layer
		uint8_t latch = LayerState[ cachedLayer ] & LayerStateType_Latch;
    6c92:	4b42      	ldr	r3, [pc, #264]	; (6d9c <Layer_layerLookup+0x144>)
    6c94:	5c1b      	ldrb	r3, [r3, r0]
		if ( latch && latch_expire )
    6c96:	079b      	lsls	r3, r3, #30
    6c98:	d423      	bmi.n	6ce2 <Layer_layerLookup+0x8a>
	}

	// Otherwise no defined Trigger Macro
	// Just ignore it
	return 0;
}
    6c9a:	9b01      	ldr	r3, [sp, #4]
    6c9c:	9a05      	ldr	r2, [sp, #20]
    6c9e:	681b      	ldr	r3, [r3, #0]
    6ca0:	429a      	cmp	r2, r3
    6ca2:	4630      	mov	r0, r6
    6ca4:	d071      	beq.n	6d8a <Layer_layerLookup+0x132>
    6ca6:	f7fb fd43 	bl	2730 <__stack_chk_fail>
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    6caa:	4b3d      	ldr	r3, [pc, #244]	; (6da0 <Layer_layerLookup+0x148>)
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    6cac:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 6da4 <Layer_layerLookup+0x14c>
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    6cb0:	881d      	ldrh	r5, [r3, #0]
		uint8_t shift = LayerState[ macroLayerIndexStack[ layerIndex ] ] & LayerStateType_Shift;
    6cb2:	4b3a      	ldr	r3, [pc, #232]	; (6d9c <Layer_layerLookup+0x144>)
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    6cb4:	f64f 72ff 	movw	r2, #65535	; 0xffff
    6cb8:	4295      	cmp	r5, r2
    6cba:	d122      	bne.n	6d02 <Layer_layerLookup+0xaa>
	nat_ptr_t **map = (nat_ptr_t**)LayerIndex[0].triggerMap;
    6cbc:	4b36      	ldr	r3, [pc, #216]	; (6d98 <Layer_layerLookup+0x140>)
    6cbe:	681e      	ldr	r6, [r3, #0]
	if ( map != 0
    6cc0:	2e00      	cmp	r6, #0
    6cc2:	d0ea      	beq.n	6c9a <Layer_layerLookup+0x42>
		&& index <= layer->last
    6cc4:	7a5a      	ldrb	r2, [r3, #9]
    6cc6:	42a2      	cmp	r2, r4
    6cc8:	d35b      	bcc.n	6d82 <Layer_layerLookup+0x12a>
		&& index >= layer->first
    6cca:	7a1b      	ldrb	r3, [r3, #8]
    6ccc:	42a3      	cmp	r3, r4
    6cce:	d858      	bhi.n	6d82 <Layer_layerLookup+0x12a>
		&& *map[ index - layer->first ] != 0 )
    6cd0:	1ae3      	subs	r3, r4, r3
    6cd2:	f856 6023 	ldr.w	r6, [r6, r3, lsl #2]
    6cd6:	6833      	ldr	r3, [r6, #0]
    6cd8:	2b00      	cmp	r3, #0
    6cda:	d054      	beq.n	6d86 <Layer_layerLookup+0x12e>
		macroTriggerEventLayerCache[ index ] = 0;
    6cdc:	4b2d      	ldr	r3, [pc, #180]	; (6d94 <Layer_layerLookup+0x13c>)
    6cde:	2200      	movs	r2, #0
    6ce0:	e048      	b.n	6d74 <Layer_layerLookup+0x11c>
		if ( latch && latch_expire )
    6ce2:	f1ba 0f00 	cmp.w	sl, #0
    6ce6:	d0d8      	beq.n	6c9a <Layer_layerLookup+0x42>
	if ( layer >= LayerNum || layer == 0 )
    6ce8:	1e43      	subs	r3, r0, #1
    6cea:	2b01      	cmp	r3, #1
    6cec:	d802      	bhi.n	6cf4 <Layer_layerLookup+0x9c>
    6cee:	2102      	movs	r1, #2
    6cf0:	f7ff fd66 	bl	67c0 <Layer_layerStateSet.part.0>
			LCD_layerStack_capability( 0, 0, 0, 0 );
    6cf4:	2300      	movs	r3, #0
    6cf6:	461a      	mov	r2, r3
    6cf8:	4619      	mov	r1, r3
    6cfa:	4618      	mov	r0, r3
    6cfc:	f7fe f93e 	bl	4f7c <LCD_layerStack_capability>
    6d00:	e7cb      	b.n	6c9a <Layer_layerLookup+0x42>
		switch ( event->type )
    6d02:	783a      	ldrb	r2, [r7, #0]
    6d04:	3a09      	subs	r2, #9
    6d06:	2a03      	cmp	r2, #3
    6d08:	d937      	bls.n	6d7a <Layer_layerLookup+0x122>
		const Layer *layer = &LayerIndex[ macroLayerIndexStack[ layerIndex ] ];
    6d0a:	f83b 8015 	ldrh.w	r8, [fp, r5, lsl #1]
		uint8_t shift = LayerState[ macroLayerIndexStack[ layerIndex ] ] & LayerStateType_Shift;
    6d0e:	f813 6008 	ldrb.w	r6, [r3, r8]
		if ( latch && latch_expire )
    6d12:	f016 0202 	ands.w	r2, r6, #2
		uint8_t shift = LayerState[ macroLayerIndexStack[ layerIndex ] ] & LayerStateType_Shift;
    6d16:	f006 0901 	and.w	r9, r6, #1
		if ( latch && latch_expire )
    6d1a:	d00e      	beq.n	6d3a <Layer_layerLookup+0xe2>
    6d1c:	f1ba 0f00 	cmp.w	sl, #0
    6d20:	d00b      	beq.n	6d3a <Layer_layerLookup+0xe2>
	if ( layer >= LayerNum || layer == 0 )
    6d22:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
    6d26:	2901      	cmp	r1, #1
    6d28:	d807      	bhi.n	6d3a <Layer_layerLookup+0xe2>
    6d2a:	2102      	movs	r1, #2
    6d2c:	4640      	mov	r0, r8
    6d2e:	e9cd 2302 	strd	r2, r3, [sp, #8]
    6d32:	f7ff fd45 	bl	67c0 <Layer_layerStateSet.part.0>
    6d36:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
		if ( (shift) ^ (latch>>1) ^ (lock>>2) )
    6d3a:	ea89 0952 	eor.w	r9, r9, r2, lsr #1
    6d3e:	f3c6 0680 	ubfx	r6, r6, #2, #1
    6d42:	45b1      	cmp	r9, r6
    6d44:	d01a      	beq.n	6d7c <Layer_layerLookup+0x124>
			nat_ptr_t **map = (nat_ptr_t**)layer->triggerMap;
    6d46:	220c      	movs	r2, #12
    6d48:	4913      	ldr	r1, [pc, #76]	; (6d98 <Layer_layerLookup+0x140>)
    6d4a:	fb02 f808 	mul.w	r8, r2, r8
    6d4e:	eb01 0208 	add.w	r2, r1, r8
    6d52:	f851 1008 	ldr.w	r1, [r1, r8]
			if ( map != 0
    6d56:	b189      	cbz	r1, 6d7c <Layer_layerLookup+0x124>
				&& index <= layer->last
    6d58:	7a50      	ldrb	r0, [r2, #9]
    6d5a:	42a0      	cmp	r0, r4
    6d5c:	d30e      	bcc.n	6d7c <Layer_layerLookup+0x124>
				&& index >= layer->first
    6d5e:	7a12      	ldrb	r2, [r2, #8]
    6d60:	42a2      	cmp	r2, r4
    6d62:	d80b      	bhi.n	6d7c <Layer_layerLookup+0x124>
				&& *map[ index - layer->first ] != 0 )
    6d64:	1aa2      	subs	r2, r4, r2
    6d66:	f851 6022 	ldr.w	r6, [r1, r2, lsl #2]
    6d6a:	6832      	ldr	r2, [r6, #0]
    6d6c:	b132      	cbz	r2, 6d7c <Layer_layerLookup+0x124>
				macroTriggerEventLayerCache[ index ] = macroLayerIndexStack[ layerIndex ];
    6d6e:	f83b 2015 	ldrh.w	r2, [fp, r5, lsl #1]
    6d72:	4b08      	ldr	r3, [pc, #32]	; (6d94 <Layer_layerLookup+0x13c>)
		macroTriggerEventLayerCache[ index ] = 0;
    6d74:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
		return map[ index - layer->first ];
    6d78:	e78f      	b.n	6c9a <Layer_layerLookup+0x42>
			layerIndex = 0;
    6d7a:	2500      	movs	r5, #0
	for ( uint16_t layerIndex = macroLayerIndexStackSize; layerIndex != 0xFFFF; layerIndex-- )
    6d7c:	3d01      	subs	r5, #1
    6d7e:	b2ad      	uxth	r5, r5
    6d80:	e798      	b.n	6cb4 <Layer_layerLookup+0x5c>
	return 0;
    6d82:	2600      	movs	r6, #0
    6d84:	e789      	b.n	6c9a <Layer_layerLookup+0x42>
    6d86:	461e      	mov	r6, r3
    6d88:	e787      	b.n	6c9a <Layer_layerLookup+0x42>
}
    6d8a:	b007      	add	sp, #28
    6d8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6d90:	1fff89d0 	.word	0x1fff89d0
    6d94:	1fffa288 	.word	0x1fffa288
    6d98:	00011544 	.word	0x00011544
    6d9c:	1fffa343 	.word	0x1fffa343
    6da0:	1fff94e0 	.word	0x1fff94e0
    6da4:	1fff94da 	.word	0x1fff94da

00006da8 <Macro_none_capability>:
	Macro_rotationState( index, increment );
}

// No-op capability (None)
void Macro_none_capability( TriggerMacro *trigger, uint8_t state, uint8_t stateType, uint8_t *args )
{
    6da8:	b513      	push	{r0, r1, r4, lr}
    6daa:	4c0c      	ldr	r4, [pc, #48]	; (6ddc <Macro_none_capability+0x34>)
    6dac:	4608      	mov	r0, r1
    6dae:	6823      	ldr	r3, [r4, #0]
    6db0:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    6db2:	4611      	mov	r1, r2
    6db4:	f7ff fcc4 	bl	6740 <KLL_CapabilityState>

	switch ( cstate )
    6db8:	28ff      	cmp	r0, #255	; 0xff
	{
	case CapabilityState_Debug:
		// Display capability name
		print("Macro_none()");
    6dba:	9a01      	ldr	r2, [sp, #4]
    6dbc:	6823      	ldr	r3, [r4, #0]
	switch ( cstate )
    6dbe:	d109      	bne.n	6dd4 <Macro_none_capability+0x2c>
		print("Macro_none()");
    6dc0:	429a      	cmp	r2, r3
    6dc2:	d001      	beq.n	6dc8 <Macro_none_capability+0x20>
		return;
	default:
		break;
	}

}
    6dc4:	f7fb fcb4 	bl	2730 <__stack_chk_fail>
		print("Macro_none()");
    6dc8:	4805      	ldr	r0, [pc, #20]	; (6de0 <Macro_none_capability+0x38>)
}
    6dca:	b002      	add	sp, #8
    6dcc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		print("Macro_none()");
    6dd0:	f008 bbce 	b.w	f570 <_print>
}
    6dd4:	429a      	cmp	r2, r3
    6dd6:	d1f5      	bne.n	6dc4 <Macro_none_capability+0x1c>
    6dd8:	b002      	add	sp, #8
    6dda:	bd10      	pop	{r4, pc}
    6ddc:	1fff89d0 	.word	0x1fff89d0
    6de0:	00011624 	.word	0x00011624

00006de4 <cliFunc_posList>:
	printInt16( Key_Position[ key ].name.i ); \
	print("."); \
	printInt16( Key_Position[ key ].name.f )

void cliFunc_posList( char* args )
{
    6de4:	b507      	push	{r0, r1, r2, lr}
    6de6:	4b07      	ldr	r3, [pc, #28]	; (6e04 <cliFunc_posList+0x20>)
    6de8:	681a      	ldr	r2, [r3, #0]
    6dea:	9201      	str	r2, [sp, #4]
	print( NL );
    6dec:	9a01      	ldr	r2, [sp, #4]
    6dee:	681b      	ldr	r3, [r3, #0]
    6df0:	429a      	cmp	r2, r3
    6df2:	d001      	beq.n	6df8 <cliFunc_posList+0x14>
    6df4:	f7fb fc9c 	bl	2730 <__stack_chk_fail>
    6df8:	4803      	ldr	r0, [pc, #12]	; (6e08 <cliFunc_posList+0x24>)
		Key_PositionPrint( key, rz );
		print("]");
		print( NL );
	}
	*/
}
    6dfa:	b003      	add	sp, #12
    6dfc:	f85d eb04 	ldr.w	lr, [sp], #4
	print( NL );
    6e00:	f008 bbb6 	b.w	f570 <_print>
    6e04:	1fff89d0 	.word	0x1fff89d0
    6e08:	00015df4 	.word	0x00015df4

00006e0c <cliFunc_capDebug>:
{
    6e0c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6e0e:	4d0d      	ldr	r5, [pc, #52]	; (6e44 <cliFunc_capDebug+0x38>)
	capDebugMode = capDebugMode ? 0 : 1;
    6e10:	4c0d      	ldr	r4, [pc, #52]	; (6e48 <cliFunc_capDebug+0x3c>)
{
    6e12:	682b      	ldr	r3, [r5, #0]
    6e14:	9301      	str	r3, [sp, #4]
	capDebugMode = capDebugMode ? 0 : 1;
    6e16:	7823      	ldrb	r3, [r4, #0]
	print( NL );
    6e18:	480c      	ldr	r0, [pc, #48]	; (6e4c <cliFunc_capDebug+0x40>)
	capDebugMode = capDebugMode ? 0 : 1;
    6e1a:	fab3 f383 	clz	r3, r3
    6e1e:	095b      	lsrs	r3, r3, #5
    6e20:	7023      	strb	r3, [r4, #0]
	print( NL );
    6e22:	f008 fba5 	bl	f570 <_print>
	info_msg("Capability Debug Mode: ");
    6e26:	480a      	ldr	r0, [pc, #40]	; (6e50 <cliFunc_capDebug+0x44>)
    6e28:	f008 fba2 	bl	f570 <_print>
	printInt8( capDebugMode );
    6e2c:	9a01      	ldr	r2, [sp, #4]
    6e2e:	682b      	ldr	r3, [r5, #0]
    6e30:	429a      	cmp	r2, r3
    6e32:	d001      	beq.n	6e38 <cliFunc_capDebug+0x2c>
    6e34:	f7fb fc7c 	bl	2730 <__stack_chk_fail>
    6e38:	7820      	ldrb	r0, [r4, #0]
}
    6e3a:	b003      	add	sp, #12
    6e3c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt8( capDebugMode );
    6e40:	f008 bc00 	b.w	f644 <printInt8>
    6e44:	1fff89d0 	.word	0x1fff89d0
    6e48:	1fffa8a0 	.word	0x1fffa8a0
    6e4c:	00015df4 	.word	0x00015df4
    6e50:	00011f0f 	.word	0x00011f0f

00006e54 <cliFunc_layerDebug>:
{
    6e54:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6e56:	4d0d      	ldr	r5, [pc, #52]	; (6e8c <cliFunc_layerDebug+0x38>)
	layerDebugMode = layerDebugMode ? 0 : 1;
    6e58:	4c0d      	ldr	r4, [pc, #52]	; (6e90 <cliFunc_layerDebug+0x3c>)
{
    6e5a:	682b      	ldr	r3, [r5, #0]
    6e5c:	9301      	str	r3, [sp, #4]
	layerDebugMode = layerDebugMode ? 0 : 1;
    6e5e:	7823      	ldrb	r3, [r4, #0]
	print( NL );
    6e60:	480c      	ldr	r0, [pc, #48]	; (6e94 <cliFunc_layerDebug+0x40>)
	layerDebugMode = layerDebugMode ? 0 : 1;
    6e62:	fab3 f383 	clz	r3, r3
    6e66:	095b      	lsrs	r3, r3, #5
    6e68:	7023      	strb	r3, [r4, #0]
	print( NL );
    6e6a:	f008 fb81 	bl	f570 <_print>
	info_msg("Layer Debug Mode: ");
    6e6e:	480a      	ldr	r0, [pc, #40]	; (6e98 <cliFunc_layerDebug+0x44>)
    6e70:	f008 fb7e 	bl	f570 <_print>
	printInt8( layerDebugMode );
    6e74:	9a01      	ldr	r2, [sp, #4]
    6e76:	682b      	ldr	r3, [r5, #0]
    6e78:	429a      	cmp	r2, r3
    6e7a:	d001      	beq.n	6e80 <cliFunc_layerDebug+0x2c>
    6e7c:	f7fb fc58 	bl	2730 <__stack_chk_fail>
    6e80:	7820      	ldrb	r0, [r4, #0]
}
    6e82:	b003      	add	sp, #12
    6e84:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt8( layerDebugMode );
    6e88:	f008 bbdc 	b.w	f644 <printInt8>
    6e8c:	1fff89d0 	.word	0x1fff89d0
    6e90:	1fffa286 	.word	0x1fffa286
    6e94:	00015df4 	.word	0x00015df4
    6e98:	0001200c 	.word	0x0001200c

00006e9c <cliFunc_macroProc>:
{
    6e9c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    6e9e:	4d0d      	ldr	r5, [pc, #52]	; (6ed4 <cliFunc_macroProc+0x38>)
	macroPauseMode = macroPauseMode ? 0 : 1;
    6ea0:	4c0d      	ldr	r4, [pc, #52]	; (6ed8 <cliFunc_macroProc+0x3c>)
{
    6ea2:	682b      	ldr	r3, [r5, #0]
    6ea4:	9301      	str	r3, [sp, #4]
	macroPauseMode = macroPauseMode ? 0 : 1;
    6ea6:	7823      	ldrb	r3, [r4, #0]
	print( NL );
    6ea8:	480c      	ldr	r0, [pc, #48]	; (6edc <cliFunc_macroProc+0x40>)
	macroPauseMode = macroPauseMode ? 0 : 1;
    6eaa:	fab3 f383 	clz	r3, r3
    6eae:	095b      	lsrs	r3, r3, #5
    6eb0:	7023      	strb	r3, [r4, #0]
	print( NL );
    6eb2:	f008 fb5d 	bl	f570 <_print>
	info_msg("Macro Processing Mode: ");
    6eb6:	480a      	ldr	r0, [pc, #40]	; (6ee0 <cliFunc_macroProc+0x44>)
    6eb8:	f008 fb5a 	bl	f570 <_print>
	printInt8( macroPauseMode );
    6ebc:	9a01      	ldr	r2, [sp, #4]
    6ebe:	682b      	ldr	r3, [r5, #0]
    6ec0:	429a      	cmp	r2, r3
    6ec2:	d001      	beq.n	6ec8 <cliFunc_macroProc+0x2c>
    6ec4:	f7fb fc34 	bl	2730 <__stack_chk_fail>
    6ec8:	7820      	ldrb	r0, [r4, #0]
}
    6eca:	b003      	add	sp, #12
    6ecc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt8( macroPauseMode );
    6ed0:	f008 bbb8 	b.w	f644 <printInt8>
    6ed4:	1fff89d0 	.word	0x1fff89d0
    6ed8:	1fffa33f 	.word	0x1fffa33f
    6edc:	00015df4 	.word	0x00015df4
    6ee0:	000121f2 	.word	0x000121f2

00006ee4 <cliFunc_capList>:
{
    6ee4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    6ee8:	4d18      	ldr	r5, [pc, #96]	; (6f4c <cliFunc_capList+0x68>)
	print( NL );
    6eea:	4819      	ldr	r0, [pc, #100]	; (6f50 <cliFunc_capList+0x6c>)
{
    6eec:	682b      	ldr	r3, [r5, #0]
    6eee:	9301      	str	r3, [sp, #4]
	print( NL );
    6ef0:	f008 fb3e 	bl	f570 <_print>
	info_msg("Capabilities List ");
    6ef4:	4817      	ldr	r0, [pc, #92]	; (6f54 <cliFunc_capList+0x70>)
		print( NL "\t" );
    6ef6:	f8df 9068 	ldr.w	r9, [pc, #104]	; 6f60 <cliFunc_capList+0x7c>
		print(" - ");
    6efa:	4e17      	ldr	r6, [pc, #92]	; (6f58 <cliFunc_capList+0x74>)
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ cap ].func);
    6efc:	4f17      	ldr	r7, [pc, #92]	; (6f5c <cliFunc_capList+0x78>)
	info_msg("Capabilities List ");
    6efe:	f008 fb37 	bl	f570 <_print>
	printHex( CapabilitiesNum );
    6f02:	2101      	movs	r1, #1
    6f04:	201c      	movs	r0, #28
    6f06:	f008 fc59 	bl	f7bc <printHex_op>
    6f0a:	2400      	movs	r4, #0
    6f0c:	46a8      	mov	r8, r5
		print( NL "\t" );
    6f0e:	4648      	mov	r0, r9
    6f10:	f008 fb2e 	bl	f570 <_print>
		printHex( cap );
    6f14:	2101      	movs	r1, #1
    6f16:	b2a0      	uxth	r0, r4
    6f18:	f008 fc50 	bl	f7bc <printHex_op>
		print(" - ");
    6f1c:	4630      	mov	r0, r6
    6f1e:	f008 fb27 	bl	f570 <_print>
		capability( 0, 0xFF, 0xFF, 0 );
    6f22:	2300      	movs	r3, #0
    6f24:	22ff      	movs	r2, #255	; 0xff
    6f26:	f857 5034 	ldr.w	r5, [r7, r4, lsl #3]
    6f2a:	4611      	mov	r1, r2
    6f2c:	4618      	mov	r0, r3
    6f2e:	3401      	adds	r4, #1
    6f30:	47a8      	blx	r5
	for ( var_uint_t cap = 0; cap < CapabilitiesNum; cap++ )
    6f32:	2c1c      	cmp	r4, #28
    6f34:	d1eb      	bne.n	6f0e <cliFunc_capList+0x2a>
}
    6f36:	9a01      	ldr	r2, [sp, #4]
    6f38:	f8d8 3000 	ldr.w	r3, [r8]
    6f3c:	429a      	cmp	r2, r3
    6f3e:	d001      	beq.n	6f44 <cliFunc_capList+0x60>
    6f40:	f7fb fbf6 	bl	2730 <__stack_chk_fail>
    6f44:	b003      	add	sp, #12
    6f46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    6f4a:	bf00      	nop
    6f4c:	1fff89d0 	.word	0x1fff89d0
    6f50:	00015df4 	.word	0x00015df4
    6f54:	00011f39 	.word	0x00011f39
    6f58:	00016378 	.word	0x00016378
    6f5c:	00011460 	.word	0x00011460
    6f60:	00011f5e 	.word	0x00011f5e

00006f64 <cliFunc_macroList>:
{
    6f64:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6f68:	4c54      	ldr	r4, [pc, #336]	; (70bc <cliFunc_macroList+0x158>)
	print( NL );
    6f6a:	4855      	ldr	r0, [pc, #340]	; (70c0 <cliFunc_macroList+0x15c>)
{
    6f6c:	6823      	ldr	r3, [r4, #0]
	printInt16( (uint16_t)macroTriggerEventBufferSize );
    6f6e:	4d55      	ldr	r5, [pc, #340]	; (70c4 <cliFunc_macroList+0x160>)
{
    6f70:	9301      	str	r3, [sp, #4]
	print( NL );
    6f72:	f008 fafd 	bl	f570 <_print>
	info_msg("Pending Key Events: ");
    6f76:	4854      	ldr	r0, [pc, #336]	; (70c8 <cliFunc_macroList+0x164>)
		printHex( macroTriggerEventBuffer[ key ].index );
    6f78:	f8df 8180 	ldr.w	r8, [pc, #384]	; 70fc <cliFunc_macroList+0x198>
		print(" ");
    6f7c:	4e53      	ldr	r6, [pc, #332]	; (70cc <cliFunc_macroList+0x168>)
	info_msg("Pending Key Events: ");
    6f7e:	f008 faf7 	bl	f570 <_print>
	printInt16( (uint16_t)macroTriggerEventBufferSize );
    6f82:	8828      	ldrh	r0, [r5, #0]
    6f84:	f008 fb94 	bl	f6b0 <printInt16>
	print(" : ");
    6f88:	4851      	ldr	r0, [pc, #324]	; (70d0 <cliFunc_macroList+0x16c>)
    6f8a:	f008 faf1 	bl	f570 <_print>
	for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    6f8e:	2300      	movs	r3, #0
    6f90:	8829      	ldrh	r1, [r5, #0]
    6f92:	b29a      	uxth	r2, r3
    6f94:	4291      	cmp	r1, r2
    6f96:	f103 0701 	add.w	r7, r3, #1
    6f9a:	d867      	bhi.n	706c <cliFunc_macroList+0x108>
	print( NL );
    6f9c:	4848      	ldr	r0, [pc, #288]	; (70c0 <cliFunc_macroList+0x15c>)
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    6f9e:	4d4d      	ldr	r5, [pc, #308]	; (70d4 <cliFunc_macroList+0x170>)
		printHex( macroTriggerMacroPendingList[ macro ] );
    6fa0:	f8df 815c 	ldr.w	r8, [pc, #348]	; 7100 <cliFunc_macroList+0x19c>
		print(" ");
    6fa4:	4f49      	ldr	r7, [pc, #292]	; (70cc <cliFunc_macroList+0x168>)
	print( NL );
    6fa6:	f008 fae3 	bl	f570 <_print>
	info_msg("Pending Trigger Macros: ");
    6faa:	484b      	ldr	r0, [pc, #300]	; (70d8 <cliFunc_macroList+0x174>)
    6fac:	f008 fae0 	bl	f570 <_print>
	printInt16( (uint16_t)macroTriggerMacroPendingListSize );
    6fb0:	8828      	ldrh	r0, [r5, #0]
    6fb2:	f008 fb7d 	bl	f6b0 <printInt16>
	print(" : ");
    6fb6:	4846      	ldr	r0, [pc, #280]	; (70d0 <cliFunc_macroList+0x16c>)
    6fb8:	f008 fada 	bl	f570 <_print>
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    6fbc:	2300      	movs	r3, #0
    6fbe:	8829      	ldrh	r1, [r5, #0]
    6fc0:	b29a      	uxth	r2, r3
    6fc2:	4291      	cmp	r1, r2
    6fc4:	f103 0601 	add.w	r6, r3, #1
    6fc8:	d85d      	bhi.n	7086 <cliFunc_macroList+0x122>
	print( NL );
    6fca:	483d      	ldr	r0, [pc, #244]	; (70c0 <cliFunc_macroList+0x15c>)
	printInt16( (uint16_t)macroResultMacroPendingList.size );
    6fcc:	4d43      	ldr	r5, [pc, #268]	; (70dc <cliFunc_macroList+0x178>)
		print(" ");
    6fce:	4e3f      	ldr	r6, [pc, #252]	; (70cc <cliFunc_macroList+0x168>)
	print( NL );
    6fd0:	f008 face 	bl	f570 <_print>
	info_msg("Pending Result Macros: ");
    6fd4:	4842      	ldr	r0, [pc, #264]	; (70e0 <cliFunc_macroList+0x17c>)
    6fd6:	f008 facb 	bl	f570 <_print>
	printInt16( (uint16_t)macroResultMacroPendingList.size );
    6fda:	f8b5 0258 	ldrh.w	r0, [r5, #600]	; 0x258
    6fde:	f008 fb67 	bl	f6b0 <printInt16>
	print(" : ");
    6fe2:	483b      	ldr	r0, [pc, #236]	; (70d0 <cliFunc_macroList+0x16c>)
    6fe4:	f008 fac4 	bl	f570 <_print>
		printHex( macroResultMacroPendingList.data[ macro ].index );
    6fe8:	f04f 080c 	mov.w	r8, #12
	for ( var_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    6fec:	2300      	movs	r3, #0
    6fee:	f8b5 1258 	ldrh.w	r1, [r5, #600]	; 0x258
    6ff2:	b29a      	uxth	r2, r3
    6ff4:	4291      	cmp	r1, r2
    6ff6:	f103 0701 	add.w	r7, r3, #1
    6ffa:	d84f      	bhi.n	709c <cliFunc_macroList+0x138>
	print( NL );
    6ffc:	4830      	ldr	r0, [pc, #192]	; (70c0 <cliFunc_macroList+0x15c>)
		print( NL );
    6ffe:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 70c0 <cliFunc_macroList+0x15c>
		print("\tT");
    7002:	4f38      	ldr	r7, [pc, #224]	; (70e4 <cliFunc_macroList+0x180>)
		print(" : R");
    7004:	4e38      	ldr	r6, [pc, #224]	; (70e8 <cliFunc_macroList+0x184>)
	print( NL );
    7006:	f008 fab3 	bl	f570 <_print>
	info_msg("Trigger Macros Range: T0 -> T");
    700a:	4838      	ldr	r0, [pc, #224]	; (70ec <cliFunc_macroList+0x188>)
    700c:	f008 fab0 	bl	f570 <_print>
	printInt16( (uint16_t)TriggerMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    7010:	2073      	movs	r0, #115	; 0x73
    7012:	f008 fb4d 	bl	f6b0 <printInt16>
	print( NL );
    7016:	482a      	ldr	r0, [pc, #168]	; (70c0 <cliFunc_macroList+0x15c>)
    7018:	f008 faaa 	bl	f570 <_print>
	info_msg("Result  Macros Range: R0 -> R");
    701c:	4834      	ldr	r0, [pc, #208]	; (70f0 <cliFunc_macroList+0x18c>)
    701e:	f008 faa7 	bl	f570 <_print>
	printInt16( (uint16_t)ResultMacroNum - 1 ); // Hopefully large enough :P (can't assume 32-bit)
    7022:	206a      	movs	r0, #106	; 0x6a
    7024:	f008 fb44 	bl	f6b0 <printInt16>
	print( NL );
    7028:	4825      	ldr	r0, [pc, #148]	; (70c0 <cliFunc_macroList+0x15c>)
    702a:	f008 faa1 	bl	f570 <_print>
	info_msg("Trigger : Result Macro Pairs");
    702e:	4831      	ldr	r0, [pc, #196]	; (70f4 <cliFunc_macroList+0x190>)
    7030:	f008 fa9e 	bl	f570 <_print>
    7034:	2500      	movs	r5, #0
		print( NL );
    7036:	4640      	mov	r0, r8
    7038:	f008 fa9a 	bl	f570 <_print>
		print("\tT");
    703c:	4638      	mov	r0, r7
    703e:	f008 fa97 	bl	f570 <_print>
		printInt16( (uint16_t)macro ); // Hopefully large enough :P (can't assume 32-bit)
    7042:	b2a8      	uxth	r0, r5
    7044:	f008 fb34 	bl	f6b0 <printInt16>
		print(" : R");
    7048:	4630      	mov	r0, r6
    704a:	f008 fa91 	bl	f570 <_print>
		printInt16( (uint16_t)TriggerMacroList[ macro ].result ); // Hopefully large enough :P (can't assume 32-bit)
    704e:	4b2a      	ldr	r3, [pc, #168]	; (70f8 <cliFunc_macroList+0x194>)
    7050:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
    7054:	3501      	adds	r5, #1
    7056:	8898      	ldrh	r0, [r3, #4]
    7058:	f008 fb2a 	bl	f6b0 <printInt16>
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    705c:	2d74      	cmp	r5, #116	; 0x74
    705e:	d1ea      	bne.n	7036 <cliFunc_macroList+0xd2>
}
    7060:	9a01      	ldr	r2, [sp, #4]
    7062:	6823      	ldr	r3, [r4, #0]
    7064:	429a      	cmp	r2, r3
    7066:	d025      	beq.n	70b4 <cliFunc_macroList+0x150>
    7068:	f7fb fb62 	bl	2730 <__stack_chk_fail>
		printHex( macroTriggerEventBuffer[ key ].index );
    706c:	b29b      	uxth	r3, r3
    706e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    7072:	4443      	add	r3, r8
    7074:	2101      	movs	r1, #1
    7076:	7898      	ldrb	r0, [r3, #2]
    7078:	f008 fba0 	bl	f7bc <printHex_op>
		print(" ");
    707c:	4630      	mov	r0, r6
    707e:	f008 fa77 	bl	f570 <_print>
    7082:	463b      	mov	r3, r7
    7084:	e784      	b.n	6f90 <cliFunc_macroList+0x2c>
		printHex( macroTriggerMacroPendingList[ macro ] );
    7086:	b29b      	uxth	r3, r3
    7088:	2101      	movs	r1, #1
    708a:	f838 0013 	ldrh.w	r0, [r8, r3, lsl #1]
    708e:	f008 fb95 	bl	f7bc <printHex_op>
		print(" ");
    7092:	4638      	mov	r0, r7
    7094:	f008 fa6c 	bl	f570 <_print>
    7098:	4633      	mov	r3, r6
    709a:	e790      	b.n	6fbe <cliFunc_macroList+0x5a>
		printHex( macroResultMacroPendingList.data[ macro ].index );
    709c:	b29b      	uxth	r3, r3
    709e:	fb08 5303 	mla	r3, r8, r3, r5
    70a2:	2101      	movs	r1, #1
    70a4:	8898      	ldrh	r0, [r3, #4]
    70a6:	f008 fb89 	bl	f7bc <printHex_op>
		print(" ");
    70aa:	4630      	mov	r0, r6
    70ac:	f008 fa60 	bl	f570 <_print>
    70b0:	463b      	mov	r3, r7
    70b2:	e79c      	b.n	6fee <cliFunc_macroList+0x8a>
}
    70b4:	b002      	add	sp, #8
    70b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    70ba:	bf00      	nop
    70bc:	1fff89d0 	.word	0x1fff89d0
    70c0:	00015df4 	.word	0x00015df4
    70c4:	1fffa340 	.word	0x1fffa340
    70c8:	000120db 	.word	0x000120db
    70cc:	00016f5e 	.word	0x00016f5e
    70d0:	00012102 	.word	0x00012102
    70d4:	1fff96cc 	.word	0x1fff96cc
    70d8:	00012106 	.word	0x00012106
    70dc:	1fffa8a4 	.word	0x1fffa8a4
    70e0:	00012131 	.word	0x00012131
    70e4:	000121ea 	.word	0x000121ea
    70e8:	000121ed 	.word	0x000121ed
    70ec:	0001215b 	.word	0x0001215b
    70f0:	0001218b 	.word	0x0001218b
    70f4:	000121bb 	.word	0x000121bb
    70f8:	00011a74 	.word	0x00011a74
    70fc:	1fffa346 	.word	0x1fffa346
    7100:	1fff95e4 	.word	0x1fff95e4

00007104 <cliFunc_macroDebug>:
{
    7104:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    7106:	4c1d      	ldr	r4, [pc, #116]	; (717c <cliFunc_macroDebug+0x78>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    7108:	aa02      	add	r2, sp, #8
{
    710a:	6823      	ldr	r3, [r4, #0]
    710c:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    710e:	a901      	add	r1, sp, #4
    7110:	f007 fd00 	bl	eb14 <CLI_argumentIsolation>
	switch ( arg1Ptr[0] )
    7114:	9b01      	ldr	r3, [sp, #4]
    7116:	781b      	ldrb	r3, [r3, #0]
    7118:	2b31      	cmp	r3, #49	; 0x31
    711a:	d024      	beq.n	7166 <cliFunc_macroDebug+0x62>
    711c:	d806      	bhi.n	712c <cliFunc_macroDebug+0x28>
    711e:	b313      	cbz	r3, 7166 <cliFunc_macroDebug+0x62>
}
    7120:	9a03      	ldr	r2, [sp, #12]
    7122:	6823      	ldr	r3, [r4, #0]
    7124:	429a      	cmp	r2, r3
    7126:	d026      	beq.n	7176 <cliFunc_macroDebug+0x72>
    7128:	f7fb fb02 	bl	2730 <__stack_chk_fail>
	switch ( arg1Ptr[0] )
    712c:	2b32      	cmp	r3, #50	; 0x32
    712e:	d014      	beq.n	715a <cliFunc_macroDebug+0x56>
    7130:	2b33      	cmp	r3, #51	; 0x33
    7132:	d1f5      	bne.n	7120 <cliFunc_macroDebug+0x1c>
		macroDebugMode = macroDebugMode != 3 ? 3 : 0;
    7134:	4b12      	ldr	r3, [pc, #72]	; (7180 <cliFunc_macroDebug+0x7c>)
    7136:	781a      	ldrb	r2, [r3, #0]
    7138:	2a03      	cmp	r2, #3
    713a:	bf18      	it	ne
    713c:	2203      	movne	r2, #3
		macroDebugMode = macroDebugMode != 2 ? 2 : 0;
    713e:	bf08      	it	eq
    7140:	2200      	moveq	r2, #0
    7142:	701a      	strb	r2, [r3, #0]
	print( NL );
    7144:	480f      	ldr	r0, [pc, #60]	; (7184 <cliFunc_macroDebug+0x80>)
    7146:	f008 fa13 	bl	f570 <_print>
	info_msg("Macro Debug Mode: ");
    714a:	480f      	ldr	r0, [pc, #60]	; (7188 <cliFunc_macroDebug+0x84>)
    714c:	f008 fa10 	bl	f570 <_print>
	printInt8( macroDebugMode );
    7150:	4b0b      	ldr	r3, [pc, #44]	; (7180 <cliFunc_macroDebug+0x7c>)
    7152:	7818      	ldrb	r0, [r3, #0]
    7154:	f008 fa76 	bl	f644 <printInt8>
    7158:	e7e2      	b.n	7120 <cliFunc_macroDebug+0x1c>
		macroDebugMode = macroDebugMode != 2 ? 2 : 0;
    715a:	4b09      	ldr	r3, [pc, #36]	; (7180 <cliFunc_macroDebug+0x7c>)
    715c:	781a      	ldrb	r2, [r3, #0]
    715e:	2a02      	cmp	r2, #2
    7160:	bf18      	it	ne
    7162:	2202      	movne	r2, #2
    7164:	e7eb      	b.n	713e <cliFunc_macroDebug+0x3a>
		macroDebugMode = macroDebugMode != 1 ? 1 : 0;
    7166:	4a06      	ldr	r2, [pc, #24]	; (7180 <cliFunc_macroDebug+0x7c>)
    7168:	7813      	ldrb	r3, [r2, #0]
    716a:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    716e:	bf18      	it	ne
    7170:	2301      	movne	r3, #1
    7172:	7013      	strb	r3, [r2, #0]
		break;
    7174:	e7e6      	b.n	7144 <cliFunc_macroDebug+0x40>
}
    7176:	b004      	add	sp, #16
    7178:	bd10      	pop	{r4, pc}
    717a:	bf00      	nop
    717c:	1fff89d0 	.word	0x1fff89d0
    7180:	1fffa45a 	.word	0x1fffa45a
    7184:	00015df4 	.word	0x00015df4
    7188:	000120b6 	.word	0x000120b6

0000718c <cliFunc_capSelect>:
{
    718c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7190:	4a3e      	ldr	r2, [pc, #248]	; (728c <cliFunc_capSelect+0x100>)
			print(" - ");
    7192:	f8df 9118 	ldr.w	r9, [pc, #280]	; 72ac <cliFunc_capSelect+0x120>
{
    7196:	6813      	ldr	r3, [r2, #0]
    7198:	b085      	sub	sp, #20
	char* arg2Ptr = args;
    719a:	2600      	movs	r6, #0
{
    719c:	4604      	mov	r4, r0
    719e:	9303      	str	r3, [sp, #12]
	char* arg2Ptr = args;
    71a0:	9002      	str	r0, [sp, #8]
	var_uint_t argSetCount = 0;
    71a2:	4637      	mov	r7, r6
	var_uint_t cap = 0;
    71a4:	46b0      	mov	r8, r6
	var_uint_t totalArgs = 2; // Always at least two args
    71a6:	f04f 0b02 	mov.w	fp, #2
    71aa:	4692      	mov	sl, r2
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    71ac:	aa02      	add	r2, sp, #8
    71ae:	9802      	ldr	r0, [sp, #8]
    71b0:	a901      	add	r1, sp, #4
    71b2:	f007 fcaf 	bl	eb14 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    71b6:	9801      	ldr	r0, [sp, #4]
    71b8:	7802      	ldrb	r2, [r0, #0]
    71ba:	2a00      	cmp	r2, #0
    71bc:	d050      	beq.n	7260 <cliFunc_capSelect+0xd4>
		if ( c == 0 ) switch ( arg1Ptr[0] )
    71be:	b2b1      	uxth	r1, r6
    71c0:	b9a9      	cbnz	r1, 71ee <cliFunc_capSelect+0x62>
    71c2:	2a4b      	cmp	r2, #75	; 0x4b
    71c4:	d113      	bne.n	71ee <cliFunc_capSelect+0x62>
			cap = numToInt( &arg1Ptr[1] );
    71c6:	3001      	adds	r0, #1
    71c8:	f008 fba2 	bl	f910 <numToInt>
			totalArgs += CapabilitiesList[ cap ].argCount;
    71cc:	4a30      	ldr	r2, [pc, #192]	; (7290 <cliFunc_capSelect+0x104>)
			cap = numToInt( &arg1Ptr[1] );
    71ce:	fa1f f880 	uxth.w	r8, r0
			totalArgs += CapabilitiesList[ cap ].argCount;
    71d2:	eb02 00c8 	add.w	r0, r2, r8, lsl #3
			continue;
    71d6:	463d      	mov	r5, r7
			totalArgs += CapabilitiesList[ cap ].argCount;
    71d8:	7902      	ldrb	r2, [r0, #4]
    71da:	eb0b 0302 	add.w	r3, fp, r2
    71de:	fa1f fb83 	uxth.w	fp, r3
	for ( var_uint_t c = 0; argSetCount < totalArgs; c++ )
    71e2:	45ab      	cmp	fp, r5
    71e4:	f106 0601 	add.w	r6, r6, #1
    71e8:	d93a      	bls.n	7260 <cliFunc_capSelect+0xd4>
    71ea:	462f      	mov	r7, r5
    71ec:	e7de      	b.n	71ac <cliFunc_capSelect+0x20>
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    71ee:	f008 fb8f 	bl	f910 <numToInt>
    71f2:	1c7d      	adds	r5, r7, #1
    71f4:	b2ad      	uxth	r5, r5
		if ( argSetCount == totalArgs )
    71f6:	455d      	cmp	r5, fp
		argSet[ argSetCount++ ] = (uint8_t)numToInt( arg1Ptr );
    71f8:	55e0      	strb	r0, [r4, r7]
		if ( argSetCount == totalArgs )
    71fa:	d1f2      	bne.n	71e2 <cliFunc_capSelect+0x56>
			print( NL );
    71fc:	4825      	ldr	r0, [pc, #148]	; (7294 <cliFunc_capSelect+0x108>)
    71fe:	f008 f9b7 	bl	f570 <_print>
			info_msg("K");
    7202:	4825      	ldr	r0, [pc, #148]	; (7298 <cliFunc_capSelect+0x10c>)
    7204:	f008 f9b4 	bl	f570 <_print>
			printInt8( cap );
    7208:	fa5f f088 	uxtb.w	r0, r8
    720c:	f008 fa1a 	bl	f644 <printInt8>
			print(" - ");
    7210:	4648      	mov	r0, r9
    7212:	f008 f9ad 	bl	f570 <_print>
			printHex( argSet[0] );
    7216:	2101      	movs	r1, #1
    7218:	7820      	ldrb	r0, [r4, #0]
    721a:	f008 facf 	bl	f7bc <printHex_op>
			print(" - ");
    721e:	4648      	mov	r0, r9
    7220:	f008 f9a6 	bl	f570 <_print>
			printHex( argSet[1] );
    7224:	2101      	movs	r1, #1
    7226:	7860      	ldrb	r0, [r4, #1]
    7228:	f008 fac8 	bl	f7bc <printHex_op>
			print(" - ");
    722c:	4648      	mov	r0, r9
    722e:	f008 f99f 	bl	f570 <_print>
			printHex( argSet[2] );
    7232:	2101      	movs	r1, #1
    7234:	78a0      	ldrb	r0, [r4, #2]
    7236:	f008 fac1 	bl	f7bc <printHex_op>
			print( "..." NL );
    723a:	4818      	ldr	r0, [pc, #96]	; (729c <cliFunc_capSelect+0x110>)
    723c:	f008 f998 	bl	f570 <_print>
				if ( CapabilitiesList[ cap ].func == (const void*)Output_flashMode_capability )
    7240:	4a13      	ldr	r2, [pc, #76]	; (7290 <cliFunc_capSelect+0x104>)
    7242:	4917      	ldr	r1, [pc, #92]	; (72a0 <cliFunc_capSelect+0x114>)
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
    7244:	2300      	movs	r3, #0
				if ( CapabilitiesList[ cap ].func == (const void*)Output_flashMode_capability )
    7246:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
    724a:	4288      	cmp	r0, r1
    724c:	d10f      	bne.n	726e <cliFunc_capSelect+0xe2>
					print( NL );
    724e:	4811      	ldr	r0, [pc, #68]	; (7294 <cliFunc_capSelect+0x108>)
    7250:	f008 f98e 	bl	f570 <_print>
					warn_print("flashModeEnabled not set, cancelling firmware reload...");
    7254:	4813      	ldr	r0, [pc, #76]	; (72a4 <cliFunc_capSelect+0x118>)
    7256:	f008 f98b 	bl	f570 <_print>
					info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    725a:	4813      	ldr	r0, [pc, #76]	; (72a8 <cliFunc_capSelect+0x11c>)
    725c:	f008 f988 	bl	f570 <_print>
}
    7260:	9a03      	ldr	r2, [sp, #12]
    7262:	f8da 3000 	ldr.w	r3, [sl]
    7266:	429a      	cmp	r2, r3
    7268:	d00d      	beq.n	7286 <cliFunc_capSelect+0xfa>
    726a:	f7fb fa61 	bl	2730 <__stack_chk_fail>
			if ( flashModeEnabled_define == 0 ) for ( uint32_t cap = 0; cap < CapabilitiesNum; cap++ )
    726e:	3301      	adds	r3, #1
    7270:	2b1c      	cmp	r3, #28
    7272:	d1e8      	bne.n	7246 <cliFunc_capSelect+0xba>
			capability( 0, argSet[0], argSet[1], &argSet[2] );
    7274:	f852 7038 	ldr.w	r7, [r2, r8, lsl #3]
    7278:	7821      	ldrb	r1, [r4, #0]
    727a:	7862      	ldrb	r2, [r4, #1]
    727c:	1ca3      	adds	r3, r4, #2
    727e:	2000      	movs	r0, #0
    7280:	47b8      	blx	r7
    7282:	46ab      	mov	fp, r5
    7284:	e7ad      	b.n	71e2 <cliFunc_capSelect+0x56>
}
    7286:	b005      	add	sp, #20
    7288:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    728c:	1fff89d0 	.word	0x1fff89d0
    7290:	00011460 	.word	0x00011460
    7294:	00015df4 	.word	0x00015df4
    7298:	00011f62 	.word	0x00011f62
    729c:	00011fbf 	.word	0x00011fbf
    72a0:	0000bb9d 	.word	0x0000bb9d
    72a4:	00011f76 	.word	0x00011f76
    72a8:	00011fc5 	.word	0x00011fc5
    72ac:	00016378 	.word	0x00016378

000072b0 <cliFunc_layerState>:
{
    72b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    72b2:	4c1a      	ldr	r4, [pc, #104]	; (731c <cliFunc_layerState+0x6c>)
    72b4:	b085      	sub	sp, #20
    72b6:	6822      	ldr	r2, [r4, #0]
    72b8:	9203      	str	r2, [sp, #12]
	for ( uint8_t c = 0; c < 2; c++ )
    72ba:	2500      	movs	r5, #0
	char* arg2Ptr = args;
    72bc:	9002      	str	r0, [sp, #8]
	uint8_t arg1 = 0;
    72be:	462e      	mov	r6, r5
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    72c0:	9802      	ldr	r0, [sp, #8]
    72c2:	aa02      	add	r2, sp, #8
    72c4:	a901      	add	r1, sp, #4
    72c6:	f007 fc25 	bl	eb14 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    72ca:	9801      	ldr	r0, [sp, #4]
    72cc:	7803      	ldrb	r3, [r0, #0]
    72ce:	b1eb      	cbz	r3, 730c <cliFunc_layerState+0x5c>
		switch ( c )
    72d0:	b93d      	cbnz	r5, 72e2 <cliFunc_layerState+0x32>
			if ( arg1Ptr[0] != 'L' )
    72d2:	2b4c      	cmp	r3, #76	; 0x4c
    72d4:	d11a      	bne.n	730c <cliFunc_layerState+0x5c>
			arg1 = (uint8_t)numToInt( &arg1Ptr[1] );
    72d6:	3001      	adds	r0, #1
    72d8:	f008 fb1a 	bl	f910 <numToInt>
    72dc:	2501      	movs	r5, #1
    72de:	b2c6      	uxtb	r6, r0
    72e0:	e7ee      	b.n	72c0 <cliFunc_layerState+0x10>
			arg2 = (uint8_t)numToInt( arg1Ptr );
    72e2:	f008 fb15 	bl	f910 <numToInt>
    72e6:	b2c7      	uxtb	r7, r0
			print( NL );
    72e8:	480d      	ldr	r0, [pc, #52]	; (7320 <cliFunc_layerState+0x70>)
    72ea:	f008 f941 	bl	f570 <_print>
			info_msg("Setting Layer L");
    72ee:	480d      	ldr	r0, [pc, #52]	; (7324 <cliFunc_layerState+0x74>)
    72f0:	f008 f93e 	bl	f570 <_print>
			printInt8( arg1 );
    72f4:	4630      	mov	r0, r6
    72f6:	f008 f9a5 	bl	f644 <printInt8>
			print(" to - ");
    72fa:	480b      	ldr	r0, [pc, #44]	; (7328 <cliFunc_layerState+0x78>)
    72fc:	f008 f938 	bl	f570 <_print>
			printHex( arg2 );
    7300:	4629      	mov	r1, r5
    7302:	4638      	mov	r0, r7
    7304:	f008 fa5a 	bl	f7bc <printHex_op>
			LayerState[ arg1 ] = arg2;
    7308:	4b08      	ldr	r3, [pc, #32]	; (732c <cliFunc_layerState+0x7c>)
    730a:	559f      	strb	r7, [r3, r6]
}
    730c:	9a03      	ldr	r2, [sp, #12]
    730e:	6823      	ldr	r3, [r4, #0]
    7310:	429a      	cmp	r2, r3
    7312:	d001      	beq.n	7318 <cliFunc_layerState+0x68>
    7314:	f7fb fa0c 	bl	2730 <__stack_chk_fail>
    7318:	b005      	add	sp, #20
    731a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    731c:	1fff89d0 	.word	0x1fff89d0
    7320:	00015df4 	.word	0x00015df4
    7324:	0001208d 	.word	0x0001208d
    7328:	000120af 	.word	0x000120af
    732c:	1fffa343 	.word	0x1fffa343

00007330 <cliFunc_macroStep>:
{
    7330:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    7332:	4c0c      	ldr	r4, [pc, #48]	; (7364 <cliFunc_macroStep+0x34>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    7334:	aa02      	add	r2, sp, #8
{
    7336:	6823      	ldr	r3, [r4, #0]
    7338:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    733a:	a901      	add	r1, sp, #4
    733c:	f007 fbea 	bl	eb14 <CLI_argumentIsolation>
	var_uint_t count = (var_uint_t)numToInt( arg1Ptr );
    7340:	9801      	ldr	r0, [sp, #4]
    7342:	f008 fae5 	bl	f910 <numToInt>
    7346:	b280      	uxth	r0, r0
		count = 1;
    7348:	2800      	cmp	r0, #0
	macroStepCounter = count;
    734a:	4b07      	ldr	r3, [pc, #28]	; (7368 <cliFunc_macroStep+0x38>)
}
    734c:	9a03      	ldr	r2, [sp, #12]
		count = 1;
    734e:	bf08      	it	eq
    7350:	2001      	moveq	r0, #1
	macroStepCounter = count;
    7352:	8018      	strh	r0, [r3, #0]
}
    7354:	6823      	ldr	r3, [r4, #0]
    7356:	429a      	cmp	r2, r3
    7358:	d001      	beq.n	735e <cliFunc_macroStep+0x2e>
    735a:	f7fb f9e9 	bl	2730 <__stack_chk_fail>
    735e:	b004      	add	sp, #16
    7360:	bd10      	pop	{r4, pc}
    7362:	bf00      	nop
    7364:	1fff89d0 	.word	0x1fff89d0
    7368:	1fffa458 	.word	0x1fffa458

0000736c <cliFunc_layerList>:
{
    736c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    7370:	4e21      	ldr	r6, [pc, #132]	; (73f8 <cliFunc_layerList+0x8c>)
	print( NL );
    7372:	4822      	ldr	r0, [pc, #136]	; (73fc <cliFunc_layerList+0x90>)
{
    7374:	6833      	ldr	r3, [r6, #0]
    7376:	9301      	str	r3, [sp, #4]
	print( NL );
    7378:	f008 f8fa 	bl	f570 <_print>
	info_msg("Layer List");
    737c:	4820      	ldr	r0, [pc, #128]	; (7400 <cliFunc_layerList+0x94>)
    737e:	4d21      	ldr	r5, [pc, #132]	; (7404 <cliFunc_layerList+0x98>)
		print( NL "\t" );
    7380:	4f21      	ldr	r7, [pc, #132]	; (7408 <cliFunc_layerList+0x9c>)
		print(" - ");
    7382:	f8df 809c 	ldr.w	r8, [pc, #156]	; 7420 <cliFunc_layerList+0xb4>
	info_msg("Layer List");
    7386:	f008 f8f3 	bl	f570 <_print>
    738a:	2400      	movs	r4, #0
		print( NL "\t" );
    738c:	4638      	mov	r0, r7
    738e:	f008 f8ef 	bl	f570 <_print>
		printHex( layer );
    7392:	2101      	movs	r1, #1
    7394:	b2a0      	uxth	r0, r4
    7396:	f008 fa11 	bl	f7bc <printHex_op>
		print(" - ");
    739a:	4640      	mov	r0, r8
    739c:	f008 f8e8 	bl	f570 <_print>
		dPrint( (char*)LayerIndex[ layer ].name );
    73a0:	6868      	ldr	r0, [r5, #4]
    73a2:	f004 fd5d 	bl	be60 <Output_putstr>
		if ( layer == 0 )
    73a6:	b914      	cbnz	r4, 73ae <cliFunc_layerList+0x42>
			print(" \033[1m(default)\033[0m");
    73a8:	4818      	ldr	r0, [pc, #96]	; (740c <cliFunc_layerList+0xa0>)
    73aa:	f008 f8e1 	bl	f570 <_print>
		print( NL "\t\t Layer State: " );
    73ae:	4818      	ldr	r0, [pc, #96]	; (7410 <cliFunc_layerList+0xa4>)
    73b0:	f008 f8de 	bl	f570 <_print>
		printHex( LayerState[ layer ] );
    73b4:	4b17      	ldr	r3, [pc, #92]	; (7414 <cliFunc_layerList+0xa8>)
    73b6:	2101      	movs	r1, #1
    73b8:	5d18      	ldrb	r0, [r3, r4]
    73ba:	f008 f9ff 	bl	f7bc <printHex_op>
		print(" First -> Last Indices: ");
    73be:	4816      	ldr	r0, [pc, #88]	; (7418 <cliFunc_layerList+0xac>)
    73c0:	f008 f8d6 	bl	f570 <_print>
		printHex( LayerIndex[ layer ].first );
    73c4:	2101      	movs	r1, #1
    73c6:	7a28      	ldrb	r0, [r5, #8]
    73c8:	f008 f9f8 	bl	f7bc <printHex_op>
		print(" -> ");
    73cc:	4813      	ldr	r0, [pc, #76]	; (741c <cliFunc_layerList+0xb0>)
    73ce:	f008 f8cf 	bl	f570 <_print>
    73d2:	3401      	adds	r4, #1
		printHex( LayerIndex[ layer ].last );
    73d4:	7a68      	ldrb	r0, [r5, #9]
    73d6:	2101      	movs	r1, #1
    73d8:	f008 f9f0 	bl	f7bc <printHex_op>
	for ( index_uint_t layer = 0; layer < LayerNum; layer++ )
    73dc:	2c03      	cmp	r4, #3
    73de:	f105 050c 	add.w	r5, r5, #12
    73e2:	d1d3      	bne.n	738c <cliFunc_layerList+0x20>
}
    73e4:	9a01      	ldr	r2, [sp, #4]
    73e6:	6833      	ldr	r3, [r6, #0]
    73e8:	429a      	cmp	r2, r3
    73ea:	d001      	beq.n	73f0 <cliFunc_layerList+0x84>
    73ec:	f7fb f9a0 	bl	2730 <__stack_chk_fail>
    73f0:	b002      	add	sp, #8
    73f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    73f6:	bf00      	nop
    73f8:	1fff89d0 	.word	0x1fff89d0
    73fc:	00015df4 	.word	0x00015df4
    7400:	00012031 	.word	0x00012031
    7404:	00011544 	.word	0x00011544
    7408:	00011f5e 	.word	0x00011f5e
    740c:	0001204e 	.word	0x0001204e
    7410:	00012061 	.word	0x00012061
    7414:	1fffa343 	.word	0x1fffa343
    7418:	00012074 	.word	0x00012074
    741c:	00010c65 	.word	0x00010c65
    7420:	00016378 	.word	0x00016378

00007424 <cliFunc_voteDebug>:

void cliFunc_voteDebug( char* args )
{
    7424:	b530      	push	{r4, r5, lr}
    7426:	4c12      	ldr	r4, [pc, #72]	; (7470 <cliFunc_voteDebug+0x4c>)
    7428:	b085      	sub	sp, #20
    742a:	6823      	ldr	r3, [r4, #0]
    742c:	9303      	str	r3, [sp, #12]
	// Parse number from argument
	//  NOTE: Only first argument is used
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    742e:	aa02      	add	r2, sp, #8
    7430:	a901      	add	r1, sp, #4
    7432:	f007 fb6f 	bl	eb14 <CLI_argumentIsolation>

	// Set the vote debug flag depending on the argument
	switch ( arg1Ptr[0] )
    7436:	9b01      	ldr	r3, [sp, #4]
    7438:	781b      	ldrb	r3, [r3, #0]
    743a:	2b01      	cmp	r3, #1
    743c:	d80f      	bhi.n	745e <cliFunc_voteDebug+0x3a>
	{
	// No argument
	case 1:
	case '\0':
		voteDebugMode = voteDebugMode != 1 ? 1 : 0;
    743e:	4d0d      	ldr	r5, [pc, #52]	; (7474 <cliFunc_voteDebug+0x50>)
	// Invalid argument
	default:
		return;
	}

	print( NL );
    7440:	480d      	ldr	r0, [pc, #52]	; (7478 <cliFunc_voteDebug+0x54>)
		voteDebugMode = voteDebugMode != 1 ? 1 : 0;
    7442:	782b      	ldrb	r3, [r5, #0]
    7444:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
    7448:	bf18      	it	ne
    744a:	2301      	movne	r3, #1
    744c:	702b      	strb	r3, [r5, #0]
	print( NL );
    744e:	f008 f88f 	bl	f570 <_print>
	info_msg("Vote Debug Mode: ");
    7452:	480a      	ldr	r0, [pc, #40]	; (747c <cliFunc_voteDebug+0x58>)
    7454:	f008 f88c 	bl	f570 <_print>
	printInt8( voteDebugMode );
    7458:	7828      	ldrb	r0, [r5, #0]
    745a:	f008 f8f3 	bl	f644 <printInt8>
}
    745e:	9a03      	ldr	r2, [sp, #12]
    7460:	6823      	ldr	r3, [r4, #0]
    7462:	429a      	cmp	r2, r3
    7464:	d001      	beq.n	746a <cliFunc_voteDebug+0x46>
    7466:	f7fb f963 	bl	2730 <__stack_chk_fail>
    746a:	b005      	add	sp, #20
    746c:	bd30      	pop	{r4, r5, pc}
    746e:	bf00      	nop
    7470:	1fff89d0 	.word	0x1fff89d0
    7474:	1fffa342 	.word	0x1fffa342
    7478:	00015df4 	.word	0x00015df4
    747c:	0001221c 	.word	0x0001221c

00007480 <Macro_showScheduleType>:
{
    7480:	b573      	push	{r0, r1, r4, r5, r6, lr}
    7482:	4c23      	ldr	r4, [pc, #140]	; (7510 <Macro_showScheduleType+0x90>)
    7484:	f000 060f 	and.w	r6, r0, #15
    7488:	6823      	ldr	r3, [r4, #0]
    748a:	9301      	str	r3, [sp, #4]
    748c:	4605      	mov	r5, r0
	switch ( state & 0x0F )
    748e:	2e07      	cmp	r6, #7
    7490:	d824      	bhi.n	74dc <Macro_showScheduleType+0x5c>
    7492:	e8df f006 	tbb	[pc, r6]
    7496:	0419      	.short	0x0419
    7498:	1d1b1715 	.word	0x1d1b1715
    749c:	211f      	.short	0x211f
		print("\033[1;33mP\033[0m");
    749e:	481d      	ldr	r0, [pc, #116]	; (7514 <Macro_showScheduleType+0x94>)
		print("\033[1;32mH\033[0m");
    74a0:	f008 f866 	bl	f570 <_print>
	switch ( state & 0xF0 )
    74a4:	f005 00f0 	and.w	r0, r5, #240	; 0xf0
    74a8:	2820      	cmp	r0, #32
		print("La");
    74aa:	9a01      	ldr	r2, [sp, #4]
    74ac:	6823      	ldr	r3, [r4, #0]
	switch ( state & 0xF0 )
    74ae:	d022      	beq.n	74f6 <Macro_showScheduleType+0x76>
    74b0:	2840      	cmp	r0, #64	; 0x40
    74b2:	d024      	beq.n	74fe <Macro_showScheduleType+0x7e>
    74b4:	2810      	cmp	r0, #16
    74b6:	d126      	bne.n	7506 <Macro_showScheduleType+0x86>
		print("Sh");
    74b8:	429a      	cmp	r2, r3
    74ba:	d016      	beq.n	74ea <Macro_showScheduleType+0x6a>
}
    74bc:	f7fb f938 	bl	2730 <__stack_chk_fail>
		print("\033[1;32mH\033[0m");
    74c0:	4815      	ldr	r0, [pc, #84]	; (7518 <Macro_showScheduleType+0x98>)
    74c2:	e7ed      	b.n	74a0 <Macro_showScheduleType+0x20>
		print("\033[1;35mR\033[0m");
    74c4:	4815      	ldr	r0, [pc, #84]	; (751c <Macro_showScheduleType+0x9c>)
    74c6:	e7eb      	b.n	74a0 <Macro_showScheduleType+0x20>
		print("\033[1mO\033[0m");
    74c8:	4815      	ldr	r0, [pc, #84]	; (7520 <Macro_showScheduleType+0xa0>)
    74ca:	e7e9      	b.n	74a0 <Macro_showScheduleType+0x20>
		print("UP");
    74cc:	4815      	ldr	r0, [pc, #84]	; (7524 <Macro_showScheduleType+0xa4>)
    74ce:	e7e7      	b.n	74a0 <Macro_showScheduleType+0x20>
		print("UR");
    74d0:	4815      	ldr	r0, [pc, #84]	; (7528 <Macro_showScheduleType+0xa8>)
    74d2:	e7e5      	b.n	74a0 <Macro_showScheduleType+0x20>
		print("Done");
    74d4:	4815      	ldr	r0, [pc, #84]	; (752c <Macro_showScheduleType+0xac>)
    74d6:	e7e3      	b.n	74a0 <Macro_showScheduleType+0x20>
		print("Repeat");
    74d8:	4815      	ldr	r0, [pc, #84]	; (7530 <Macro_showScheduleType+0xb0>)
    74da:	e7e1      	b.n	74a0 <Macro_showScheduleType+0x20>
		print("\033[1;31mINVALID\033[0m");
    74dc:	4815      	ldr	r0, [pc, #84]	; (7534 <Macro_showScheduleType+0xb4>)
    74de:	f008 f847 	bl	f570 <_print>
		printInt8( state & 0x0F );
    74e2:	4630      	mov	r0, r6
    74e4:	f008 f8ae 	bl	f644 <printInt8>
		break;
    74e8:	e7dc      	b.n	74a4 <Macro_showScheduleType+0x24>
		print("Sh");
    74ea:	4813      	ldr	r0, [pc, #76]	; (7538 <Macro_showScheduleType+0xb8>)
}
    74ec:	b002      	add	sp, #8
    74ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Lo");
    74f2:	f008 b83d 	b.w	f570 <_print>
		print("La");
    74f6:	429a      	cmp	r2, r3
    74f8:	d1e0      	bne.n	74bc <Macro_showScheduleType+0x3c>
    74fa:	4810      	ldr	r0, [pc, #64]	; (753c <Macro_showScheduleType+0xbc>)
    74fc:	e7f6      	b.n	74ec <Macro_showScheduleType+0x6c>
		print("Lo");
    74fe:	429a      	cmp	r2, r3
    7500:	d1dc      	bne.n	74bc <Macro_showScheduleType+0x3c>
    7502:	480f      	ldr	r0, [pc, #60]	; (7540 <Macro_showScheduleType+0xc0>)
    7504:	e7f2      	b.n	74ec <Macro_showScheduleType+0x6c>
}
    7506:	429a      	cmp	r2, r3
    7508:	d1d8      	bne.n	74bc <Macro_showScheduleType+0x3c>
    750a:	b002      	add	sp, #8
    750c:	bd70      	pop	{r4, r5, r6, pc}
    750e:	bf00      	nop
    7510:	1fff89d0 	.word	0x1fff89d0
    7514:	0000fda7 	.word	0x0000fda7
    7518:	0000fdb4 	.word	0x0000fdb4
    751c:	0000fdc1 	.word	0x0000fdc1
    7520:	0000fd9d 	.word	0x0000fd9d
    7524:	00011780 	.word	0x00011780
    7528:	00011783 	.word	0x00011783
    752c:	00011786 	.word	0x00011786
    7530:	0001178b 	.word	0x0001178b
    7534:	00011792 	.word	0x00011792
    7538:	000117a5 	.word	0x000117a5
    753c:	000117a8 	.word	0x000117a8
    7540:	000117ab 	.word	0x000117ab

00007544 <Macro_showTriggerType>:
{
    7544:	b507      	push	{r0, r1, r2, lr}
    7546:	4b34      	ldr	r3, [pc, #208]	; (7618 <Macro_showTriggerType+0xd4>)
	switch ( type )
    7548:	2810      	cmp	r0, #16
{
    754a:	681a      	ldr	r2, [r3, #0]
    754c:	9201      	str	r2, [sp, #4]
    754e:	4619      	mov	r1, r3
	switch ( type )
    7550:	d80d      	bhi.n	756e <Macro_showTriggerType+0x2a>
    7552:	280d      	cmp	r0, #13
    7554:	d23b      	bcs.n	75ce <Macro_showTriggerType+0x8a>
    7556:	2808      	cmp	r0, #8
    7558:	d833      	bhi.n	75c2 <Macro_showTriggerType+0x7e>
    755a:	2805      	cmp	r0, #5
    755c:	d22b      	bcs.n	75b6 <Macro_showTriggerType+0x72>
    755e:	2803      	cmp	r0, #3
    7560:	d823      	bhi.n	75aa <Macro_showTriggerType+0x66>
		print("Sw");
    7562:	9a01      	ldr	r2, [sp, #4]
    7564:	681b      	ldr	r3, [r3, #0]
    7566:	429a      	cmp	r2, r3
    7568:	d019      	beq.n	759e <Macro_showTriggerType+0x5a>
		print("Debug");
    756a:	f7fb f8e1 	bl	2730 <__stack_chk_fail>
	switch ( type )
    756e:	2813      	cmp	r0, #19
    7570:	d03f      	beq.n	75f2 <Macro_showTriggerType+0xae>
    7572:	d809      	bhi.n	7588 <Macro_showTriggerType+0x44>
    7574:	2811      	cmp	r0, #17
    7576:	d030      	beq.n	75da <Macro_showTriggerType+0x96>
    7578:	2812      	cmp	r0, #18
    757a:	d034      	beq.n	75e6 <Macro_showTriggerType+0xa2>
		print("INVALID");
    757c:	9a01      	ldr	r2, [sp, #4]
    757e:	680b      	ldr	r3, [r1, #0]
    7580:	429a      	cmp	r2, r3
    7582:	d1f2      	bne.n	756a <Macro_showTriggerType+0x26>
    7584:	4825      	ldr	r0, [pc, #148]	; (761c <Macro_showTriggerType+0xd8>)
    7586:	e00b      	b.n	75a0 <Macro_showTriggerType+0x5c>
	switch ( type )
    7588:	2815      	cmp	r0, #21
    758a:	d03e      	beq.n	760a <Macro_showTriggerType+0xc6>
    758c:	d337      	bcc.n	75fe <Macro_showTriggerType+0xba>
    758e:	28ff      	cmp	r0, #255	; 0xff
    7590:	d1f4      	bne.n	757c <Macro_showTriggerType+0x38>
		print("Debug");
    7592:	9a01      	ldr	r2, [sp, #4]
    7594:	681b      	ldr	r3, [r3, #0]
    7596:	429a      	cmp	r2, r3
    7598:	d1e7      	bne.n	756a <Macro_showTriggerType+0x26>
    759a:	4821      	ldr	r0, [pc, #132]	; (7620 <Macro_showTriggerType+0xdc>)
    759c:	e000      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("Sw");
    759e:	4821      	ldr	r0, [pc, #132]	; (7624 <Macro_showTriggerType+0xe0>)
}
    75a0:	b003      	add	sp, #12
    75a2:	f85d eb04 	ldr.w	lr, [sp], #4
		print("Debug");
    75a6:	f007 bfe3 	b.w	f570 <_print>
		print("LED");
    75aa:	9a01      	ldr	r2, [sp, #4]
    75ac:	681b      	ldr	r3, [r3, #0]
    75ae:	429a      	cmp	r2, r3
    75b0:	d1db      	bne.n	756a <Macro_showTriggerType+0x26>
    75b2:	481d      	ldr	r0, [pc, #116]	; (7628 <Macro_showTriggerType+0xe4>)
    75b4:	e7f4      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("An");
    75b6:	9a01      	ldr	r2, [sp, #4]
    75b8:	681b      	ldr	r3, [r3, #0]
    75ba:	429a      	cmp	r2, r3
    75bc:	d1d5      	bne.n	756a <Macro_showTriggerType+0x26>
    75be:	481b      	ldr	r0, [pc, #108]	; (762c <Macro_showTriggerType+0xe8>)
    75c0:	e7ee      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("Layer");
    75c2:	9a01      	ldr	r2, [sp, #4]
    75c4:	681b      	ldr	r3, [r3, #0]
    75c6:	429a      	cmp	r2, r3
    75c8:	d1cf      	bne.n	756a <Macro_showTriggerType+0x26>
    75ca:	4819      	ldr	r0, [pc, #100]	; (7630 <Macro_showTriggerType+0xec>)
    75cc:	e7e8      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("Animation");
    75ce:	9a01      	ldr	r2, [sp, #4]
    75d0:	681b      	ldr	r3, [r3, #0]
    75d2:	429a      	cmp	r2, r3
    75d4:	d1c9      	bne.n	756a <Macro_showTriggerType+0x26>
    75d6:	4817      	ldr	r0, [pc, #92]	; (7634 <Macro_showTriggerType+0xf0>)
    75d8:	e7e2      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("Sleep");
    75da:	9a01      	ldr	r2, [sp, #4]
    75dc:	681b      	ldr	r3, [r3, #0]
    75de:	429a      	cmp	r2, r3
    75e0:	d1c3      	bne.n	756a <Macro_showTriggerType+0x26>
    75e2:	4815      	ldr	r0, [pc, #84]	; (7638 <Macro_showTriggerType+0xf4>)
    75e4:	e7dc      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("Resume");
    75e6:	9a01      	ldr	r2, [sp, #4]
    75e8:	681b      	ldr	r3, [r3, #0]
    75ea:	429a      	cmp	r2, r3
    75ec:	d1bd      	bne.n	756a <Macro_showTriggerType+0x26>
    75ee:	4813      	ldr	r0, [pc, #76]	; (763c <Macro_showTriggerType+0xf8>)
    75f0:	e7d6      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("Inactive");
    75f2:	9a01      	ldr	r2, [sp, #4]
    75f4:	681b      	ldr	r3, [r3, #0]
    75f6:	429a      	cmp	r2, r3
    75f8:	d1b7      	bne.n	756a <Macro_showTriggerType+0x26>
    75fa:	4811      	ldr	r0, [pc, #68]	; (7640 <Macro_showTriggerType+0xfc>)
    75fc:	e7d0      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("Active");
    75fe:	9a01      	ldr	r2, [sp, #4]
    7600:	681b      	ldr	r3, [r3, #0]
    7602:	429a      	cmp	r2, r3
    7604:	d1b1      	bne.n	756a <Macro_showTriggerType+0x26>
    7606:	480f      	ldr	r0, [pc, #60]	; (7644 <Macro_showTriggerType+0x100>)
    7608:	e7ca      	b.n	75a0 <Macro_showTriggerType+0x5c>
		print("Rotation");
    760a:	9a01      	ldr	r2, [sp, #4]
    760c:	681b      	ldr	r3, [r3, #0]
    760e:	429a      	cmp	r2, r3
    7610:	d1ab      	bne.n	756a <Macro_showTriggerType+0x26>
    7612:	480d      	ldr	r0, [pc, #52]	; (7648 <Macro_showTriggerType+0x104>)
    7614:	e7c4      	b.n	75a0 <Macro_showTriggerType+0x5c>
    7616:	bf00      	nop
    7618:	1fff89d0 	.word	0x1fff89d0
    761c:	000117e4 	.word	0x000117e4
    7620:	00012fb9 	.word	0x00012fb9
    7624:	000117ae 	.word	0x000117ae
    7628:	000117b1 	.word	0x000117b1
    762c:	000117b5 	.word	0x000117b5
    7630:	000117b8 	.word	0x000117b8
    7634:	000112a9 	.word	0x000112a9
    7638:	000117be 	.word	0x000117be
    763c:	000117c4 	.word	0x000117c4
    7640:	000117cb 	.word	0x000117cb
    7644:	000117d4 	.word	0x000117d4
    7648:	000117db 	.word	0x000117db

0000764c <Macro_testThreadSafe_capability>:
{
    764c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    764e:	4c18      	ldr	r4, [pc, #96]	; (76b0 <Macro_testThreadSafe_capability+0x64>)
    7650:	460d      	mov	r5, r1
    7652:	6823      	ldr	r3, [r4, #0]
    7654:	9301      	str	r3, [sp, #4]
    7656:	4607      	mov	r7, r0
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    7658:	4611      	mov	r1, r2
    765a:	4628      	mov	r0, r5
{
    765c:	4616      	mov	r6, r2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    765e:	f7ff f86f 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    7662:	28ff      	cmp	r0, #255	; 0xff
    7664:	d10b      	bne.n	767e <Macro_testThreadSafe_capability+0x32>
		print("Macro_testThreadSafe()");
    7666:	9a01      	ldr	r2, [sp, #4]
    7668:	6823      	ldr	r3, [r4, #0]
    766a:	429a      	cmp	r2, r3
    766c:	d001      	beq.n	7672 <Macro_testThreadSafe_capability+0x26>
	print(NL);
    766e:	f7fb f85f 	bl	2730 <__stack_chk_fail>
		print("Macro_testThreadSafe()");
    7672:	4810      	ldr	r0, [pc, #64]	; (76b4 <Macro_testThreadSafe_capability+0x68>)
}
    7674:	b003      	add	sp, #12
    7676:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	print(NL);
    767a:	f007 bf79 	b.w	f570 <_print>
	print("ThreadSafe: ");
    767e:	480e      	ldr	r0, [pc, #56]	; (76b8 <Macro_testThreadSafe_capability+0x6c>)
    7680:	f007 ff76 	bl	f570 <_print>
	Macro_showTriggerType( (TriggerType)stateType );
    7684:	4630      	mov	r0, r6
    7686:	f7ff ff5d 	bl	7544 <Macro_showTriggerType>
	print(" ");
    768a:	480c      	ldr	r0, [pc, #48]	; (76bc <Macro_testThreadSafe_capability+0x70>)
    768c:	f007 ff70 	bl	f570 <_print>
	Macro_showScheduleType( (ScheduleState)state );
    7690:	4628      	mov	r0, r5
    7692:	f7ff fef5 	bl	7480 <Macro_showScheduleType>
	print(" - ");
    7696:	480a      	ldr	r0, [pc, #40]	; (76c0 <Macro_testThreadSafe_capability+0x74>)
    7698:	f007 ff6a 	bl	f570 <_print>
	printHex32( (intptr_t)trigger );
    769c:	2101      	movs	r1, #1
    769e:	4638      	mov	r0, r7
    76a0:	f008 f8de 	bl	f860 <printHex32_op>
	print(NL);
    76a4:	9a01      	ldr	r2, [sp, #4]
    76a6:	6823      	ldr	r3, [r4, #0]
    76a8:	429a      	cmp	r2, r3
    76aa:	d1e0      	bne.n	766e <Macro_testThreadSafe_capability+0x22>
    76ac:	4805      	ldr	r0, [pc, #20]	; (76c4 <Macro_testThreadSafe_capability+0x78>)
    76ae:	e7e1      	b.n	7674 <Macro_testThreadSafe_capability+0x28>
    76b0:	1fff89d0 	.word	0x1fff89d0
    76b4:	000117ec 	.word	0x000117ec
    76b8:	00011803 	.word	0x00011803
    76bc:	00016f5e 	.word	0x00016f5e
    76c0:	00016378 	.word	0x00016378
    76c4:	00015df4 	.word	0x00015df4

000076c8 <Macro_testThreadUnsafe_capability>:
{
    76c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    76ca:	4c18      	ldr	r4, [pc, #96]	; (772c <Macro_testThreadUnsafe_capability+0x64>)
    76cc:	460d      	mov	r5, r1
    76ce:	6823      	ldr	r3, [r4, #0]
    76d0:	9301      	str	r3, [sp, #4]
    76d2:	4607      	mov	r7, r0
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    76d4:	4611      	mov	r1, r2
    76d6:	4628      	mov	r0, r5
{
    76d8:	4616      	mov	r6, r2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    76da:	f7ff f831 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    76de:	28ff      	cmp	r0, #255	; 0xff
    76e0:	d10b      	bne.n	76fa <Macro_testThreadUnsafe_capability+0x32>
		print("Macro_testThreadUnsafe()");
    76e2:	9a01      	ldr	r2, [sp, #4]
    76e4:	6823      	ldr	r3, [r4, #0]
    76e6:	429a      	cmp	r2, r3
    76e8:	d001      	beq.n	76ee <Macro_testThreadUnsafe_capability+0x26>
	print(NL);
    76ea:	f7fb f821 	bl	2730 <__stack_chk_fail>
		print("Macro_testThreadUnsafe()");
    76ee:	4810      	ldr	r0, [pc, #64]	; (7730 <Macro_testThreadUnsafe_capability+0x68>)
}
    76f0:	b003      	add	sp, #12
    76f2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	print(NL);
    76f6:	f007 bf3b 	b.w	f570 <_print>
	print("ThreadUnsafe: ");
    76fa:	480e      	ldr	r0, [pc, #56]	; (7734 <Macro_testThreadUnsafe_capability+0x6c>)
    76fc:	f007 ff38 	bl	f570 <_print>
	Macro_showTriggerType( (TriggerType)stateType );
    7700:	4630      	mov	r0, r6
    7702:	f7ff ff1f 	bl	7544 <Macro_showTriggerType>
	print(" ");
    7706:	480c      	ldr	r0, [pc, #48]	; (7738 <Macro_testThreadUnsafe_capability+0x70>)
    7708:	f007 ff32 	bl	f570 <_print>
	Macro_showScheduleType( (ScheduleState)state );
    770c:	4628      	mov	r0, r5
    770e:	f7ff feb7 	bl	7480 <Macro_showScheduleType>
	print(" - ");
    7712:	480a      	ldr	r0, [pc, #40]	; (773c <Macro_testThreadUnsafe_capability+0x74>)
    7714:	f007 ff2c 	bl	f570 <_print>
	printHex32( (intptr_t)trigger );
    7718:	2101      	movs	r1, #1
    771a:	4638      	mov	r0, r7
    771c:	f008 f8a0 	bl	f860 <printHex32_op>
	print(NL);
    7720:	9a01      	ldr	r2, [sp, #4]
    7722:	6823      	ldr	r3, [r4, #0]
    7724:	429a      	cmp	r2, r3
    7726:	d1e0      	bne.n	76ea <Macro_testThreadUnsafe_capability+0x22>
    7728:	4805      	ldr	r0, [pc, #20]	; (7740 <Macro_testThreadUnsafe_capability+0x78>)
    772a:	e7e1      	b.n	76f0 <Macro_testThreadUnsafe_capability+0x28>
    772c:	1fff89d0 	.word	0x1fff89d0
    7730:	00011810 	.word	0x00011810
    7734:	00011829 	.word	0x00011829
    7738:	00016f5e 	.word	0x00016f5e
    773c:	00016378 	.word	0x00016378
    7740:	00015df4 	.word	0x00015df4

00007744 <Macro_showTriggerEvent>:
{
    7744:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7746:	4d18      	ldr	r5, [pc, #96]	; (77a8 <Macro_showTriggerEvent+0x64>)
    7748:	4604      	mov	r4, r0
    774a:	682b      	ldr	r3, [r5, #0]
	Macro_showTriggerType( event->type );
    774c:	7800      	ldrb	r0, [r0, #0]
{
    774e:	9301      	str	r3, [sp, #4]
	Macro_showTriggerType( event->type );
    7750:	f7ff fef8 	bl	7544 <Macro_showTriggerType>
	print(" ");
    7754:	4815      	ldr	r0, [pc, #84]	; (77ac <Macro_showTriggerEvent+0x68>)
    7756:	f007 ff0b 	bl	f570 <_print>
    775a:	7823      	ldrb	r3, [r4, #0]
    775c:	7860      	ldrb	r0, [r4, #1]
    775e:	3b05      	subs	r3, #5
    7760:	b2db      	uxtb	r3, r3
    7762:	2b10      	cmp	r3, #16
    7764:	d816      	bhi.n	7794 <Macro_showTriggerEvent+0x50>
    7766:	2201      	movs	r2, #1
    7768:	fa02 f303 	lsl.w	r3, r2, r3
    776c:	4a10      	ldr	r2, [pc, #64]	; (77b0 <Macro_showTriggerEvent+0x6c>)
    776e:	401a      	ands	r2, r3
    7770:	b182      	cbz	r2, 7794 <Macro_showTriggerEvent+0x50>
		printInt8( event->state );
    7772:	f007 ff67 	bl	f644 <printInt8>
	print(" ");
    7776:	480d      	ldr	r0, [pc, #52]	; (77ac <Macro_showTriggerEvent+0x68>)
    7778:	f007 fefa 	bl	f570 <_print>
	printInt8( event->type );
    777c:	7820      	ldrb	r0, [r4, #0]
    777e:	f007 ff61 	bl	f644 <printInt8>
	print(":");
    7782:	480c      	ldr	r0, [pc, #48]	; (77b4 <Macro_showTriggerEvent+0x70>)
    7784:	f007 fef4 	bl	f570 <_print>
	printInt8( event->index );
    7788:	9a01      	ldr	r2, [sp, #4]
    778a:	682b      	ldr	r3, [r5, #0]
    778c:	429a      	cmp	r2, r3
    778e:	d004      	beq.n	779a <Macro_showTriggerEvent+0x56>
    7790:	f7fa ffce 	bl	2730 <__stack_chk_fail>
		Macro_showScheduleType( event->state );
    7794:	f7ff fe74 	bl	7480 <Macro_showScheduleType>
		break;
    7798:	e7ed      	b.n	7776 <Macro_showTriggerEvent+0x32>
	printInt8( event->index );
    779a:	78a0      	ldrb	r0, [r4, #2]
}
    779c:	b003      	add	sp, #12
    779e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt8( event->index );
    77a2:	f007 bf4f 	b.w	f644 <printInt8>
    77a6:	bf00      	nop
    77a8:	1fff89d0 	.word	0x1fff89d0
    77ac:	00016f5e 	.word	0x00016f5e
    77b0:	0001000f 	.word	0x0001000f
    77b4:	00014d02 	.word	0x00014d02

000077b8 <Macro_pressReleaseAdd>:
{
    77b8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    77bc:	4c33      	ldr	r4, [pc, #204]	; (788c <Macro_pressReleaseAdd+0xd4>)
    77be:	6823      	ldr	r3, [r4, #0]
    77c0:	9301      	str	r3, [sp, #4]
	switch ( trigger->type )
    77c2:	7803      	ldrb	r3, [r0, #0]
    77c4:	2b15      	cmp	r3, #21
{
    77c6:	4605      	mov	r5, r0
    77c8:	d832      	bhi.n	7830 <Macro_pressReleaseAdd+0x78>
    77ca:	2601      	movs	r6, #1
    77cc:	4830      	ldr	r0, [pc, #192]	; (7890 <Macro_pressReleaseAdd+0xd8>)
    77ce:	fa06 f303 	lsl.w	r3, r6, r3
    77d2:	4018      	ands	r0, r3
    77d4:	d12e      	bne.n	7834 <Macro_pressReleaseAdd+0x7c>
    77d6:	06db      	lsls	r3, r3, #27
    77d8:	d02a      	beq.n	7830 <Macro_pressReleaseAdd+0x78>
		switch ( trigger->state )
    77da:	786b      	ldrb	r3, [r5, #1]
    77dc:	2b03      	cmp	r3, #3
    77de:	d903      	bls.n	77e8 <Macro_pressReleaseAdd+0x30>
			erro_msg("Invalid key state - ");
    77e0:	482c      	ldr	r0, [pc, #176]	; (7894 <Macro_pressReleaseAdd+0xdc>)
		erro_msg("Invalid type - ");
    77e2:	f007 fec5 	bl	f570 <_print>
		error = 1;
    77e6:	2001      	movs	r0, #1
	if ( trigger->index > MaxScanCode_KLL )
    77e8:	f895 e002 	ldrb.w	lr, [r5, #2]
    77ec:	f1be 0f5a 	cmp.w	lr, #90	; 0x5a
    77f0:	d922      	bls.n	7838 <Macro_pressReleaseAdd+0x80>
		warn_msg("ScanCode is out of range/not defined - ");
    77f2:	4829      	ldr	r0, [pc, #164]	; (7898 <Macro_pressReleaseAdd+0xe0>)
    77f4:	f007 febc 	bl	f570 <_print>
		printHex( trigger->type );
    77f8:	2101      	movs	r1, #1
    77fa:	7828      	ldrb	r0, [r5, #0]
    77fc:	f007 ffde 	bl	f7bc <printHex_op>
		print(" ");
    7800:	4826      	ldr	r0, [pc, #152]	; (789c <Macro_pressReleaseAdd+0xe4>)
    7802:	f007 feb5 	bl	f570 <_print>
		printHex( trigger->state );
    7806:	2101      	movs	r1, #1
    7808:	7868      	ldrb	r0, [r5, #1]
    780a:	f007 ffd7 	bl	f7bc <printHex_op>
		print(" ");
    780e:	4823      	ldr	r0, [pc, #140]	; (789c <Macro_pressReleaseAdd+0xe4>)
    7810:	f007 feae 	bl	f570 <_print>
		printHex( trigger->index );
    7814:	2101      	movs	r1, #1
    7816:	78a8      	ldrb	r0, [r5, #2]
    7818:	f007 ffd0 	bl	f7bc <printHex_op>
		print( NL );
    781c:	4820      	ldr	r0, [pc, #128]	; (78a0 <Macro_pressReleaseAdd+0xe8>)
    781e:	f007 fea7 	bl	f570 <_print>
		return 2;
    7822:	2002      	movs	r0, #2
}
    7824:	9a01      	ldr	r2, [sp, #4]
    7826:	6823      	ldr	r3, [r4, #0]
    7828:	429a      	cmp	r2, r3
    782a:	d02c      	beq.n	7886 <Macro_pressReleaseAdd+0xce>
    782c:	f7fa ff80 	bl	2730 <__stack_chk_fail>
		erro_msg("Invalid type - ");
    7830:	481c      	ldr	r0, [pc, #112]	; (78a4 <Macro_pressReleaseAdd+0xec>)
    7832:	e7d6      	b.n	77e2 <Macro_pressReleaseAdd+0x2a>
	uint8_t error = 0;
    7834:	2000      	movs	r0, #0
    7836:	e7d7      	b.n	77e8 <Macro_pressReleaseAdd+0x30>
	if ( error )
    7838:	2800      	cmp	r0, #0
    783a:	d1dd      	bne.n	77f8 <Macro_pressReleaseAdd+0x40>
	for ( var_uint_t c = 0; c < macroInterconnectCacheSize; c++ )
    783c:	491a      	ldr	r1, [pc, #104]	; (78a8 <Macro_pressReleaseAdd+0xf0>)
    783e:	4e1b      	ldr	r6, [pc, #108]	; (78ac <Macro_pressReleaseAdd+0xf4>)
    7840:	780b      	ldrb	r3, [r1, #0]
    7842:	4602      	mov	r2, r0
    7844:	fa1f f883 	uxth.w	r8, r3
    7848:	468c      	mov	ip, r1
    784a:	b291      	uxth	r1, r2
    784c:	4588      	cmp	r8, r1
    784e:	d80b      	bhi.n	7868 <Macro_pressReleaseAdd+0xb0>
	macroInterconnectCache[ macroInterconnectCacheSize++ ] = *trigger;
    7850:	1c5a      	adds	r2, r3, #1
    7852:	f88c 2000 	strb.w	r2, [ip]
    7856:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    785a:	8829      	ldrh	r1, [r5, #0]
    785c:	52f1      	strh	r1, [r6, r3]
    785e:	18f2      	adds	r2, r6, r3
    7860:	78ab      	ldrb	r3, [r5, #2]
    7862:	7093      	strb	r3, [r2, #2]
	return 1;
    7864:	2001      	movs	r0, #1
    7866:	e7dd      	b.n	7824 <Macro_pressReleaseAdd+0x6c>
		if ( macroInterconnectCache[ c ].index == trigger->index )
    7868:	4611      	mov	r1, r2
    786a:	3201      	adds	r2, #1
    786c:	eb02 0742 	add.w	r7, r2, r2, lsl #1
    7870:	4437      	add	r7, r6
    7872:	f817 7c01 	ldrb.w	r7, [r7, #-1]
    7876:	4577      	cmp	r7, lr
    7878:	d1e7      	bne.n	784a <Macro_pressReleaseAdd+0x92>
			macroInterconnectCache[ c ].state = trigger->state;
    787a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    787e:	4431      	add	r1, r6
    7880:	786b      	ldrb	r3, [r5, #1]
    7882:	704b      	strb	r3, [r1, #1]
			return 0;
    7884:	e7ce      	b.n	7824 <Macro_pressReleaseAdd+0x6c>
}
    7886:	b002      	add	sp, #8
    7888:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    788c:	1fff89d0 	.word	0x1fff89d0
    7890:	002001e0 	.word	0x002001e0
    7894:	000116da 	.word	0x000116da
    7898:	00011729 	.word	0x00011729
    789c:	00016f5e 	.word	0x00016f5e
    78a0:	00015df4 	.word	0x00015df4
    78a4:	00011704 	.word	0x00011704
    78a8:	1fff95e2 	.word	0x1fff95e2
    78ac:	1fffa45b 	.word	0x1fffa45b

000078b0 <Macro_keyState>:
{
    78b0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    78b2:	4c19      	ldr	r4, [pc, #100]	; (7918 <Macro_keyState+0x68>)
    78b4:	6823      	ldr	r3, [r4, #0]
    78b6:	9301      	str	r3, [sp, #4]
	if ( !Connect_master )
    78b8:	4b18      	ldr	r3, [pc, #96]	; (791c <Macro_keyState+0x6c>)
    78ba:	781b      	ldrb	r3, [r3, #0]
{
    78bc:	4605      	mov	r5, r0
	if ( !Connect_master )
    78be:	b913      	cbnz	r3, 78c6 <Macro_keyState+0x16>
		switch ( state )
    78c0:	b321      	cbz	r1, 790c <Macro_keyState+0x5c>
    78c2:	2902      	cmp	r1, #2
    78c4:	d022      	beq.n	790c <Macro_keyState+0x5c>
	switch ( state )
    78c6:	1e4b      	subs	r3, r1, #1
    78c8:	2b02      	cmp	r3, #2
    78ca:	d81f      	bhi.n	790c <Macro_keyState+0x5c>
		if ( scanCode > MaxScanCode_KLL )
    78cc:	2d5a      	cmp	r5, #90	; 0x5a
    78ce:	d911      	bls.n	78f4 <Macro_keyState+0x44>
			warn_msg("ScanCode is out of range/not defined: ");
    78d0:	4813      	ldr	r0, [pc, #76]	; (7920 <Macro_keyState+0x70>)
    78d2:	f007 fe4d 	bl	f570 <_print>
			printInt16( scanCode );
    78d6:	4628      	mov	r0, r5
    78d8:	f007 feea 	bl	f6b0 <printInt16>
			print( NL );
    78dc:	9a01      	ldr	r2, [sp, #4]
    78de:	6823      	ldr	r3, [r4, #0]
    78e0:	429a      	cmp	r2, r3
    78e2:	d001      	beq.n	78e8 <Macro_keyState+0x38>
}
    78e4:	f7fa ff24 	bl	2730 <__stack_chk_fail>
			print( NL );
    78e8:	480e      	ldr	r0, [pc, #56]	; (7924 <Macro_keyState+0x74>)
}
    78ea:	b003      	add	sp, #12
    78ec:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			print( NL );
    78f0:	f007 be3e 	b.w	f570 <_print>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    78f4:	4a0c      	ldr	r2, [pc, #48]	; (7928 <Macro_keyState+0x78>)
    78f6:	4e0d      	ldr	r6, [pc, #52]	; (792c <Macro_keyState+0x7c>)
    78f8:	8813      	ldrh	r3, [r2, #0]
    78fa:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    78fe:	1837      	adds	r7, r6, r0
		macroTriggerEventBufferSize++;
    7900:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    7902:	7079      	strb	r1, [r7, #1]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    7904:	2100      	movs	r1, #0
    7906:	5431      	strb	r1, [r6, r0]
			index = scanCode;
    7908:	70bd      	strb	r5, [r7, #2]
		macroTriggerEventBufferSize++;
    790a:	8013      	strh	r3, [r2, #0]
}
    790c:	9a01      	ldr	r2, [sp, #4]
    790e:	6823      	ldr	r3, [r4, #0]
    7910:	429a      	cmp	r2, r3
    7912:	d1e7      	bne.n	78e4 <Macro_keyState+0x34>
    7914:	b003      	add	sp, #12
    7916:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7918:	1fff89d0 	.word	0x1fff89d0
    791c:	1fff94cc 	.word	0x1fff94cc
    7920:	000115aa 	.word	0x000115aa
    7924:	00015df4 	.word	0x00015df4
    7928:	1fffa340 	.word	0x1fffa340
    792c:	1fffa346 	.word	0x1fffa346

00007930 <cliFunc_keyHold>:
{
    7930:	b530      	push	{r4, r5, lr}
    7932:	b085      	sub	sp, #20
    7934:	4c0f      	ldr	r4, [pc, #60]	; (7974 <cliFunc_keyHold+0x44>)
	char* arg2Ptr = args;
    7936:	ad04      	add	r5, sp, #16
{
    7938:	6822      	ldr	r2, [r4, #0]
	char* arg2Ptr = args;
    793a:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    793e:	9203      	str	r2, [sp, #12]
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    7940:	9802      	ldr	r0, [sp, #8]
    7942:	462a      	mov	r2, r5
    7944:	a901      	add	r1, sp, #4
    7946:	f007 f8e5 	bl	eb14 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    794a:	9801      	ldr	r0, [sp, #4]
    794c:	7803      	ldrb	r3, [r0, #0]
    794e:	b14b      	cbz	r3, 7964 <cliFunc_keyHold+0x34>
		switch ( arg1Ptr[0] )
    7950:	2b53      	cmp	r3, #83	; 0x53
    7952:	d1f5      	bne.n	7940 <cliFunc_keyHold+0x10>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x02 ); // Hold scancode
    7954:	3001      	adds	r0, #1
    7956:	f007 ffdb 	bl	f910 <numToInt>
    795a:	2102      	movs	r1, #2
    795c:	b2c0      	uxtb	r0, r0
    795e:	f7ff ffa7 	bl	78b0 <Macro_keyState>
			break;
    7962:	e7ed      	b.n	7940 <cliFunc_keyHold+0x10>
}
    7964:	9a03      	ldr	r2, [sp, #12]
    7966:	6823      	ldr	r3, [r4, #0]
    7968:	429a      	cmp	r2, r3
    796a:	d001      	beq.n	7970 <cliFunc_keyHold+0x40>
    796c:	f7fa fee0 	bl	2730 <__stack_chk_fail>
    7970:	b005      	add	sp, #20
    7972:	bd30      	pop	{r4, r5, pc}
    7974:	1fff89d0 	.word	0x1fff89d0

00007978 <cliFunc_keyPress>:
{
    7978:	b530      	push	{r4, r5, lr}
    797a:	b085      	sub	sp, #20
    797c:	4c0f      	ldr	r4, [pc, #60]	; (79bc <cliFunc_keyPress+0x44>)
	char* arg2Ptr = args;
    797e:	ad04      	add	r5, sp, #16
{
    7980:	6822      	ldr	r2, [r4, #0]
	char* arg2Ptr = args;
    7982:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    7986:	9203      	str	r2, [sp, #12]
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    7988:	9802      	ldr	r0, [sp, #8]
    798a:	462a      	mov	r2, r5
    798c:	a901      	add	r1, sp, #4
    798e:	f007 f8c1 	bl	eb14 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    7992:	9801      	ldr	r0, [sp, #4]
    7994:	7803      	ldrb	r3, [r0, #0]
    7996:	b14b      	cbz	r3, 79ac <cliFunc_keyPress+0x34>
		switch ( arg1Ptr[0] )
    7998:	2b53      	cmp	r3, #83	; 0x53
    799a:	d1f5      	bne.n	7988 <cliFunc_keyPress+0x10>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x01 ); // Press scancode
    799c:	3001      	adds	r0, #1
    799e:	f007 ffb7 	bl	f910 <numToInt>
    79a2:	2101      	movs	r1, #1
    79a4:	b2c0      	uxtb	r0, r0
    79a6:	f7ff ff83 	bl	78b0 <Macro_keyState>
			break;
    79aa:	e7ed      	b.n	7988 <cliFunc_keyPress+0x10>
}
    79ac:	9a03      	ldr	r2, [sp, #12]
    79ae:	6823      	ldr	r3, [r4, #0]
    79b0:	429a      	cmp	r2, r3
    79b2:	d001      	beq.n	79b8 <cliFunc_keyPress+0x40>
    79b4:	f7fa febc 	bl	2730 <__stack_chk_fail>
    79b8:	b005      	add	sp, #20
    79ba:	bd30      	pop	{r4, r5, pc}
    79bc:	1fff89d0 	.word	0x1fff89d0

000079c0 <cliFunc_keyRelease>:
{
    79c0:	b530      	push	{r4, r5, lr}
    79c2:	b085      	sub	sp, #20
    79c4:	4c0f      	ldr	r4, [pc, #60]	; (7a04 <cliFunc_keyRelease+0x44>)
	char* arg2Ptr = args;
    79c6:	ad04      	add	r5, sp, #16
{
    79c8:	6822      	ldr	r2, [r4, #0]
	char* arg2Ptr = args;
    79ca:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    79ce:	9203      	str	r2, [sp, #12]
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    79d0:	9802      	ldr	r0, [sp, #8]
    79d2:	462a      	mov	r2, r5
    79d4:	a901      	add	r1, sp, #4
    79d6:	f007 f89d 	bl	eb14 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    79da:	9801      	ldr	r0, [sp, #4]
    79dc:	7803      	ldrb	r3, [r0, #0]
    79de:	b14b      	cbz	r3, 79f4 <cliFunc_keyRelease+0x34>
		switch ( arg1Ptr[0] )
    79e0:	2b53      	cmp	r3, #83	; 0x53
    79e2:	d1f5      	bne.n	79d0 <cliFunc_keyRelease+0x10>
			Macro_keyState( (uint8_t)numToInt( &arg1Ptr[1] ), 0x03 ); // Release scancode
    79e4:	3001      	adds	r0, #1
    79e6:	f007 ff93 	bl	f910 <numToInt>
    79ea:	2103      	movs	r1, #3
    79ec:	b2c0      	uxtb	r0, r0
    79ee:	f7ff ff5f 	bl	78b0 <Macro_keyState>
			break;
    79f2:	e7ed      	b.n	79d0 <cliFunc_keyRelease+0x10>
}
    79f4:	9a03      	ldr	r2, [sp, #12]
    79f6:	6823      	ldr	r3, [r4, #0]
    79f8:	429a      	cmp	r2, r3
    79fa:	d001      	beq.n	7a00 <cliFunc_keyRelease+0x40>
    79fc:	f7fa fe98 	bl	2730 <__stack_chk_fail>
    7a00:	b005      	add	sp, #20
    7a02:	bd30      	pop	{r4, r5, pc}
    7a04:	1fff89d0 	.word	0x1fff89d0

00007a08 <Macro_ledState>:
{
    7a08:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7a0a:	4b0d      	ldr	r3, [pc, #52]	; (7a40 <Macro_ledState+0x38>)
    7a0c:	681a      	ldr	r2, [r3, #0]
    7a0e:	9201      	str	r2, [sp, #4]
	switch ( state )
    7a10:	1e4a      	subs	r2, r1, #1
    7a12:	2a02      	cmp	r2, #2
    7a14:	461a      	mov	r2, r3
    7a16:	d80b      	bhi.n	7a30 <Macro_ledState+0x28>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    7a18:	4c0a      	ldr	r4, [pc, #40]	; (7a44 <Macro_ledState+0x3c>)
    7a1a:	4e0b      	ldr	r6, [pc, #44]	; (7a48 <Macro_ledState+0x40>)
    7a1c:	8823      	ldrh	r3, [r4, #0]
    7a1e:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    7a22:	1977      	adds	r7, r6, r5
		macroTriggerEventBufferSize++;
    7a24:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    7a26:	7079      	strb	r1, [r7, #1]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    7a28:	2104      	movs	r1, #4
    7a2a:	5571      	strb	r1, [r6, r5]
	uint8_t index = ledCode;
    7a2c:	70b8      	strb	r0, [r7, #2]
		macroTriggerEventBufferSize++;
    7a2e:	8023      	strh	r3, [r4, #0]
}
    7a30:	9901      	ldr	r1, [sp, #4]
    7a32:	6813      	ldr	r3, [r2, #0]
    7a34:	4299      	cmp	r1, r3
    7a36:	d001      	beq.n	7a3c <Macro_ledState+0x34>
    7a38:	f7fa fe7a 	bl	2730 <__stack_chk_fail>
    7a3c:	b003      	add	sp, #12
    7a3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7a40:	1fff89d0 	.word	0x1fff89d0
    7a44:	1fffa340 	.word	0x1fffa340
    7a48:	1fffa346 	.word	0x1fffa346

00007a4c <Macro_animationState>:
{
    7a4c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7a4e:	4d17      	ldr	r5, [pc, #92]	; (7aac <Macro_animationState+0x60>)
    7a50:	682b      	ldr	r3, [r5, #0]
    7a52:	9301      	str	r3, [sp, #4]
	switch ( state )
    7a54:	1f8b      	subs	r3, r1, #6
    7a56:	2b01      	cmp	r3, #1
{
    7a58:	4604      	mov	r4, r0
    7a5a:	462f      	mov	r7, r5
	switch ( state )
    7a5c:	d81f      	bhi.n	7a9e <Macro_animationState+0x52>
		if ( animationIndex > AnimationNum_KLL )
    7a5e:	2801      	cmp	r0, #1
    7a60:	d911      	bls.n	7a86 <Macro_animationState+0x3a>
			warn_msg("AnimationIndex is out of range/not defined: ");
    7a62:	4813      	ldr	r0, [pc, #76]	; (7ab0 <Macro_animationState+0x64>)
    7a64:	f007 fd84 	bl	f570 <_print>
			printInt16( animationIndex );
    7a68:	4620      	mov	r0, r4
    7a6a:	f007 fe21 	bl	f6b0 <printInt16>
			print( NL );
    7a6e:	9a01      	ldr	r2, [sp, #4]
    7a70:	682b      	ldr	r3, [r5, #0]
    7a72:	429a      	cmp	r2, r3
    7a74:	d001      	beq.n	7a7a <Macro_animationState+0x2e>
}
    7a76:	f7fa fe5b 	bl	2730 <__stack_chk_fail>
			print( NL );
    7a7a:	480e      	ldr	r0, [pc, #56]	; (7ab4 <Macro_animationState+0x68>)
}
    7a7c:	b003      	add	sp, #12
    7a7e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			print( NL );
    7a82:	f007 bd75 	b.w	f570 <_print>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    7a86:	4a0c      	ldr	r2, [pc, #48]	; (7ab8 <Macro_animationState+0x6c>)
    7a88:	4d0c      	ldr	r5, [pc, #48]	; (7abc <Macro_animationState+0x70>)
    7a8a:	8813      	ldrh	r3, [r2, #0]
    7a8c:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    7a90:	182e      	adds	r6, r5, r0
		macroTriggerEventBufferSize++;
    7a92:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    7a94:	7071      	strb	r1, [r6, #1]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    7a96:	210d      	movs	r1, #13
    7a98:	5429      	strb	r1, [r5, r0]
			index = animationIndex;
    7a9a:	70b4      	strb	r4, [r6, #2]
		macroTriggerEventBufferSize++;
    7a9c:	8013      	strh	r3, [r2, #0]
}
    7a9e:	9a01      	ldr	r2, [sp, #4]
    7aa0:	683b      	ldr	r3, [r7, #0]
    7aa2:	429a      	cmp	r2, r3
    7aa4:	d1e7      	bne.n	7a76 <Macro_animationState+0x2a>
    7aa6:	b003      	add	sp, #12
    7aa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7aaa:	bf00      	nop
    7aac:	1fff89d0 	.word	0x1fff89d0
    7ab0:	00011568 	.word	0x00011568
    7ab4:	00015df4 	.word	0x00015df4
    7ab8:	1fffa340 	.word	0x1fffa340
    7abc:	1fffa346 	.word	0x1fffa346

00007ac0 <Macro_layerState>:
{
    7ac0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7ac2:	4d18      	ldr	r5, [pc, #96]	; (7b24 <Macro_layerState+0x64>)
    7ac4:	682b      	ldr	r3, [r5, #0]
    7ac6:	9301      	str	r3, [sp, #4]
	switch ( state & ScheduleType_D )
    7ac8:	f001 0303 	and.w	r3, r1, #3
    7acc:	3b01      	subs	r3, #1
    7ace:	2b02      	cmp	r3, #2
{
    7ad0:	4604      	mov	r4, r0
    7ad2:	462f      	mov	r7, r5
	switch ( state & ScheduleType_D )
    7ad4:	d81f      	bhi.n	7b16 <Macro_layerState+0x56>
		if ( layerIndex > LayerNum_KLL )
    7ad6:	2803      	cmp	r0, #3
    7ad8:	d911      	bls.n	7afe <Macro_layerState+0x3e>
			warn_msg("LayerIndex is out of range/not defined: ");
    7ada:	4813      	ldr	r0, [pc, #76]	; (7b28 <Macro_layerState+0x68>)
    7adc:	f007 fd48 	bl	f570 <_print>
			printInt16( layerIndex );
    7ae0:	4620      	mov	r0, r4
    7ae2:	f007 fde5 	bl	f6b0 <printInt16>
			print( NL );
    7ae6:	9a01      	ldr	r2, [sp, #4]
    7ae8:	682b      	ldr	r3, [r5, #0]
    7aea:	429a      	cmp	r2, r3
    7aec:	d001      	beq.n	7af2 <Macro_layerState+0x32>
}
    7aee:	f7fa fe1f 	bl	2730 <__stack_chk_fail>
			print( NL );
    7af2:	480e      	ldr	r0, [pc, #56]	; (7b2c <Macro_layerState+0x6c>)
}
    7af4:	b003      	add	sp, #12
    7af6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			print( NL );
    7afa:	f007 bd39 	b.w	f570 <_print>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    7afe:	4a0c      	ldr	r2, [pc, #48]	; (7b30 <Macro_layerState+0x70>)
    7b00:	4d0c      	ldr	r5, [pc, #48]	; (7b34 <Macro_layerState+0x74>)
    7b02:	8813      	ldrh	r3, [r2, #0]
    7b04:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    7b08:	182e      	adds	r6, r5, r0
		macroTriggerEventBufferSize++;
    7b0a:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    7b0c:	7071      	strb	r1, [r6, #1]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    7b0e:	2109      	movs	r1, #9
    7b10:	5429      	strb	r1, [r5, r0]
			index = layerIndex;
    7b12:	70b4      	strb	r4, [r6, #2]
		macroTriggerEventBufferSize++;
    7b14:	8013      	strh	r3, [r2, #0]
}
    7b16:	9a01      	ldr	r2, [sp, #4]
    7b18:	683b      	ldr	r3, [r7, #0]
    7b1a:	429a      	cmp	r2, r3
    7b1c:	d1e7      	bne.n	7aee <Macro_layerState+0x2e>
    7b1e:	b003      	add	sp, #12
    7b20:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7b22:	bf00      	nop
    7b24:	1fff89d0 	.word	0x1fff89d0
    7b28:	000115e6 	.word	0x000115e6
    7b2c:	00015df4 	.word	0x00015df4
    7b30:	1fffa340 	.word	0x1fffa340
    7b34:	1fffa346 	.word	0x1fffa346

00007b38 <Macro_timeState>:
{
    7b38:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7b3a:	4c1d      	ldr	r4, [pc, #116]	; (7bb0 <Macro_timeState+0x78>)
    7b3c:	6823      	ldr	r3, [r4, #0]
    7b3e:	9301      	str	r3, [sp, #4]
	switch ( type )
    7b40:	f1a0 0311 	sub.w	r3, r0, #17
    7b44:	2b03      	cmp	r3, #3
{
    7b46:	4605      	mov	r5, r0
    7b48:	460e      	mov	r6, r1
    7b4a:	46a4      	mov	ip, r4
	switch ( type )
    7b4c:	d90c      	bls.n	7b68 <Macro_timeState+0x30>
		warn_msg("Invalid time state trigger update: ");
    7b4e:	4819      	ldr	r0, [pc, #100]	; (7bb4 <Macro_timeState+0x7c>)
    7b50:	f007 fd0e 	bl	f570 <_print>
		printHex( type );
    7b54:	2101      	movs	r1, #1
    7b56:	4628      	mov	r0, r5
    7b58:	f007 fe30 	bl	f7bc <printHex_op>
		print(NL);
    7b5c:	9a01      	ldr	r2, [sp, #4]
    7b5e:	6823      	ldr	r3, [r4, #0]
    7b60:	429a      	cmp	r2, r3
    7b62:	d00a      	beq.n	7b7a <Macro_timeState+0x42>
}
    7b64:	f7fa fde4 	bl	2730 <__stack_chk_fail>
	if ( cur_time > 0xFF )
    7b68:	29ff      	cmp	r1, #255	; 0xff
    7b6a:	d90c      	bls.n	7b86 <Macro_timeState+0x4e>
		warn_msg("Only 255 time instances are accepted for a time state trigger: ");
    7b6c:	4812      	ldr	r0, [pc, #72]	; (7bb8 <Macro_timeState+0x80>)
    7b6e:	f007 fcff 	bl	f570 <_print>
		printInt16( cur_time );
    7b72:	4630      	mov	r0, r6
    7b74:	f007 fd9c 	bl	f6b0 <printInt16>
    7b78:	e7f0      	b.n	7b5c <Macro_timeState+0x24>
		print(NL);
    7b7a:	4810      	ldr	r0, [pc, #64]	; (7bbc <Macro_timeState+0x84>)
}
    7b7c:	b003      	add	sp, #12
    7b7e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		print(NL);
    7b82:	f007 bcf5 	b.w	f570 <_print>
	switch ( state )
    7b86:	1e53      	subs	r3, r2, #1
    7b88:	2b02      	cmp	r3, #2
    7b8a:	d80a      	bhi.n	7ba2 <Macro_timeState+0x6a>
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    7b8c:	490c      	ldr	r1, [pc, #48]	; (7bc0 <Macro_timeState+0x88>)
    7b8e:	4c0d      	ldr	r4, [pc, #52]	; (7bc4 <Macro_timeState+0x8c>)
    7b90:	880b      	ldrh	r3, [r1, #0]
    7b92:	eb03 0043 	add.w	r0, r3, r3, lsl #1
    7b96:	1827      	adds	r7, r4, r0
		macroTriggerEventBufferSize++;
    7b98:	3301      	adds	r3, #1
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    7b9a:	5425      	strb	r5, [r4, r0]
	uint8_t index = cur_time;
    7b9c:	70be      	strb	r6, [r7, #2]
		macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = state;
    7b9e:	707a      	strb	r2, [r7, #1]
		macroTriggerEventBufferSize++;
    7ba0:	800b      	strh	r3, [r1, #0]
}
    7ba2:	9a01      	ldr	r2, [sp, #4]
    7ba4:	f8dc 3000 	ldr.w	r3, [ip]
    7ba8:	429a      	cmp	r2, r3
    7baa:	d1db      	bne.n	7b64 <Macro_timeState+0x2c>
    7bac:	b003      	add	sp, #12
    7bae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7bb0:	1fff89d0 	.word	0x1fff89d0
    7bb4:	00011838 	.word	0x00011838
    7bb8:	00011871 	.word	0x00011871
    7bbc:	00015df4 	.word	0x00015df4
    7bc0:	1fffa340 	.word	0x1fffa340
    7bc4:	1fffa346 	.word	0x1fffa346

00007bc8 <Macro_rotationState>:
{
    7bc8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7bca:	4a15      	ldr	r2, [pc, #84]	; (7c20 <Macro_rotationState+0x58>)
    7bcc:	6813      	ldr	r3, [r2, #0]
    7bce:	9301      	str	r3, [sp, #4]
	if ( index > RotationNum )
    7bd0:	b9e8      	cbnz	r0, 7c0e <Macro_rotationState+0x46>
	int16_t position = Macro_rotation_store[index] + increment;
    7bd2:	4b14      	ldr	r3, [pc, #80]	; (7c24 <Macro_rotationState+0x5c>)
    7bd4:	781c      	ldrb	r4, [r3, #0]
	if ( Macro_rotation_store[index] == 255 )
    7bd6:	2cff      	cmp	r4, #255	; 0xff
    7bd8:	d00a      	beq.n	7bf0 <Macro_rotationState+0x28>
	int16_t position = Macro_rotation_store[index] + increment;
    7bda:	1860      	adds	r0, r4, r1
    7bdc:	2800      	cmp	r0, #0
    7bde:	bfa8      	it	ge
    7be0:	1a00      	subge	r0, r0, r0
	if ( position < 0 )
    7be2:	b128      	cbz	r0, 7bf0 <Macro_rotationState+0x28>
			position += Rotation_MaxParameter[index] - 1;
    7be4:	4601      	mov	r1, r0
		while ( position * -1 > Rotation_MaxParameter[index] )
    7be6:	2900      	cmp	r1, #0
    7be8:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    7bec:	b200      	sxth	r0, r0
    7bee:	dbf9      	blt.n	7be4 <Macro_rotationState+0x1c>
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    7bf0:	490d      	ldr	r1, [pc, #52]	; (7c28 <Macro_rotationState+0x60>)
    7bf2:	4d0e      	ldr	r5, [pc, #56]	; (7c2c <Macro_rotationState+0x64>)
	Macro_rotation_store[index] = position;
    7bf4:	b2c0      	uxtb	r0, r0
    7bf6:	7018      	strb	r0, [r3, #0]
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    7bf8:	880b      	ldrh	r3, [r1, #0]
    7bfa:	eb03 0443 	add.w	r4, r3, r3, lsl #1
    7bfe:	192e      	adds	r6, r5, r4
    7c00:	2700      	movs	r7, #0
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].state = position;
    7c02:	7070      	strb	r0, [r6, #1]
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    7c04:	2015      	movs	r0, #21
	macroTriggerEventBufferSize++;
    7c06:	3301      	adds	r3, #1
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].type  = type;
    7c08:	5528      	strb	r0, [r5, r4]
	macroTriggerEventBuffer[ macroTriggerEventBufferSize ].index = index;
    7c0a:	70b7      	strb	r7, [r6, #2]
	macroTriggerEventBufferSize++;
    7c0c:	800b      	strh	r3, [r1, #0]
}
    7c0e:	9901      	ldr	r1, [sp, #4]
    7c10:	6813      	ldr	r3, [r2, #0]
    7c12:	4299      	cmp	r1, r3
    7c14:	d001      	beq.n	7c1a <Macro_rotationState+0x52>
    7c16:	f7fa fd8b 	bl	2730 <__stack_chk_fail>
    7c1a:	b003      	add	sp, #12
    7c1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7c1e:	bf00      	nop
    7c20:	1fff89d0 	.word	0x1fff89d0
    7c24:	1fff94e2 	.word	0x1fff94e2
    7c28:	1fffa340 	.word	0x1fffa340
    7c2c:	1fffa346 	.word	0x1fffa346

00007c30 <Macro_rotate_capability>:
{
    7c30:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7c32:	4c13      	ldr	r4, [pc, #76]	; (7c80 <Macro_rotate_capability+0x50>)
    7c34:	4608      	mov	r0, r1
    7c36:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    7c38:	4611      	mov	r1, r2
{
    7c3a:	6823      	ldr	r3, [r4, #0]
    7c3c:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    7c3e:	f7fe fd7f 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    7c42:	2801      	cmp	r0, #1
	Macro_rotationState( index, increment );
    7c44:	9a01      	ldr	r2, [sp, #4]
    7c46:	6823      	ldr	r3, [r4, #0]
	switch ( cstate )
    7c48:	d00b      	beq.n	7c62 <Macro_rotate_capability+0x32>
    7c4a:	28ff      	cmp	r0, #255	; 0xff
    7c4c:	d113      	bne.n	7c76 <Macro_rotate_capability+0x46>
		print("Macro_rotate()");
    7c4e:	429a      	cmp	r2, r3
    7c50:	d001      	beq.n	7c56 <Macro_rotate_capability+0x26>
}
    7c52:	f7fa fd6d 	bl	2730 <__stack_chk_fail>
		print("Macro_rotate()");
    7c56:	480b      	ldr	r0, [pc, #44]	; (7c84 <Macro_rotate_capability+0x54>)
}
    7c58:	b003      	add	sp, #12
    7c5a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		print("Macro_rotate()");
    7c5e:	f007 bc87 	b.w	f570 <_print>
	Macro_rotationState( index, increment );
    7c62:	429a      	cmp	r2, r3
    7c64:	d1f5      	bne.n	7c52 <Macro_rotate_capability+0x22>
    7c66:	f995 1001 	ldrsb.w	r1, [r5, #1]
    7c6a:	7828      	ldrb	r0, [r5, #0]
}
    7c6c:	b003      	add	sp, #12
    7c6e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	Macro_rotationState( index, increment );
    7c72:	f7ff bfa9 	b.w	7bc8 <Macro_rotationState>
}
    7c76:	429a      	cmp	r2, r3
    7c78:	d1eb      	bne.n	7c52 <Macro_rotate_capability+0x22>
    7c7a:	b003      	add	sp, #12
    7c7c:	bd30      	pop	{r4, r5, pc}
    7c7e:	bf00      	nop
    7c80:	1fff89d0 	.word	0x1fff89d0
    7c84:	00011766 	.word	0x00011766

00007c88 <Macro_tick_update>:
{
    7c88:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    7c8c:	4e17      	ldr	r6, [pc, #92]	; (7cec <Macro_tick_update+0x64>)
    7c8e:	4605      	mov	r5, r0
    7c90:	6833      	ldr	r3, [r6, #0]
    7c92:	9301      	str	r3, [sp, #4]
    7c94:	4688      	mov	r8, r1
	uint32_t ticks = Time_tick_update( store );
    7c96:	f7fb fa3f 	bl	3118 <Time_tick_update>
	if ( store->fresh_store )
    7c9a:	7e2f      	ldrb	r7, [r5, #24]
	uint32_t ticks = Time_tick_update( store );
    7c9c:	4604      	mov	r4, r0
	if ( store->fresh_store )
    7c9e:	b167      	cbz	r7, 7cba <Macro_tick_update+0x32>
		Time_tick_reset( store );
    7ca0:	4628      	mov	r0, r5
    7ca2:	f7fb f9ff 	bl	30a4 <Time_tick_reset>
		store->fresh_store = 0;
    7ca6:	2100      	movs	r1, #0
    7ca8:	7629      	strb	r1, [r5, #24]
		Macro_timeState( type, 0, ScheduleType_A );
    7caa:	2201      	movs	r2, #1
    7cac:	4640      	mov	r0, r8
    7cae:	f7ff ff43 	bl	7b38 <Macro_timeState>
		store->ticks_since_start++;
    7cb2:	692b      	ldr	r3, [r5, #16]
    7cb4:	3301      	adds	r3, #1
    7cb6:	612b      	str	r3, [r5, #16]
		signal_sent = 1;
    7cb8:	2701      	movs	r7, #1
	if ( ticks == 0 )
    7cba:	b934      	cbnz	r4, 7cca <Macro_tick_update+0x42>
}
    7cbc:	9a01      	ldr	r2, [sp, #4]
    7cbe:	6833      	ldr	r3, [r6, #0]
    7cc0:	429a      	cmp	r2, r3
    7cc2:	4638      	mov	r0, r7
    7cc4:	d00e      	beq.n	7ce4 <Macro_tick_update+0x5c>
    7cc6:	f7fa fd33 	bl	2730 <__stack_chk_fail>
		uint16_t signal = store->ticks_since_start - ticks;
    7cca:	692b      	ldr	r3, [r5, #16]
    7ccc:	1b1c      	subs	r4, r3, r4
	for (
    7cce:	692b      	ldr	r3, [r5, #16]
		signal++
    7cd0:	b2a4      	uxth	r4, r4
	for (
    7cd2:	429c      	cmp	r4, r3
    7cd4:	d2f2      	bcs.n	7cbc <Macro_tick_update+0x34>
		Macro_timeState( type, signal, ScheduleStateSize_define );
    7cd6:	4621      	mov	r1, r4
    7cd8:	2208      	movs	r2, #8
    7cda:	4640      	mov	r0, r8
    7cdc:	f7ff ff2c 	bl	7b38 <Macro_timeState>
		signal++
    7ce0:	3401      	adds	r4, #1
    7ce2:	e7f4      	b.n	7cce <Macro_tick_update+0x46>
}
    7ce4:	b002      	add	sp, #8
    7ce6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    7cea:	bf00      	nop
    7cec:	1fff89d0 	.word	0x1fff89d0

00007cf0 <Macro_poll>:
{
    7cf0:	b507      	push	{r0, r1, r2, lr}
    7cf2:	4b07      	ldr	r3, [pc, #28]	; (7d10 <Macro_poll+0x20>)
    7cf4:	681a      	ldr	r2, [r3, #0]
    7cf6:	9201      	str	r2, [sp, #4]
	Result_process_delayed();
    7cf8:	9a01      	ldr	r2, [sp, #4]
    7cfa:	681b      	ldr	r3, [r3, #0]
    7cfc:	429a      	cmp	r2, r3
    7cfe:	d001      	beq.n	7d04 <Macro_poll+0x14>
    7d00:	f7fa fd16 	bl	2730 <__stack_chk_fail>
}
    7d04:	b003      	add	sp, #12
    7d06:	f85d eb04 	ldr.w	lr, [sp], #4
	Result_process_delayed();
    7d0a:	f000 bc5f 	b.w	85cc <Result_process_delayed>
    7d0e:	bf00      	nop
    7d10:	1fff89d0 	.word	0x1fff89d0

00007d14 <Macro_periodic>:
{
    7d14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7d18:	4e5c      	ldr	r6, [pc, #368]	; (7e8c <Macro_periodic+0x178>)
	Latency_start_time( macroLatencyResource );
    7d1a:	4f5d      	ldr	r7, [pc, #372]	; (7e90 <Macro_periodic+0x17c>)
{
    7d1c:	6833      	ldr	r3, [r6, #0]
	Latency_start_time( macroLatencyResource );
    7d1e:	7838      	ldrb	r0, [r7, #0]
    7d20:	4c5c      	ldr	r4, [pc, #368]	; (7e94 <Macro_periodic+0x180>)
{
    7d22:	b085      	sub	sp, #20
    7d24:	9303      	str	r3, [sp, #12]
	Latency_start_time( macroLatencyResource );
    7d26:	f007 fb51 	bl	f3cc <Latency_start_time>
	if ( !Connect_master )
    7d2a:	4b5b      	ldr	r3, [pc, #364]	; (7e98 <Macro_periodic+0x184>)
    7d2c:	781d      	ldrb	r5, [r3, #0]
    7d2e:	b97d      	cbnz	r5, 7d50 <Macro_periodic+0x3c>
		if ( macroTriggerEventBufferSize > 0 )
    7d30:	8822      	ldrh	r2, [r4, #0]
    7d32:	b132      	cbz	r2, 7d42 <Macro_periodic+0x2e>
			Connect_send_ScanCode( Connect_id, macroTriggerEventBuffer, macroTriggerEventBufferSize );
    7d34:	4b59      	ldr	r3, [pc, #356]	; (7e9c <Macro_periodic+0x188>)
    7d36:	495a      	ldr	r1, [pc, #360]	; (7ea0 <Macro_periodic+0x18c>)
    7d38:	7818      	ldrb	r0, [r3, #0]
    7d3a:	b2d2      	uxtb	r2, r2
    7d3c:	f7fd ff26 	bl	5b8c <Connect_send_ScanCode>
			macroTriggerEventBufferSize = 0;
    7d40:	8025      	strh	r5, [r4, #0]
}
    7d42:	9a03      	ldr	r2, [sp, #12]
    7d44:	6833      	ldr	r3, [r6, #0]
    7d46:	429a      	cmp	r2, r3
    7d48:	f000 809c 	beq.w	7e84 <Macro_periodic+0x170>
    7d4c:	f7fa fcf0 	bl	2730 <__stack_chk_fail>
	if ( Connect_master && macroInterconnectCacheSize > 0 )
    7d50:	4a54      	ldr	r2, [pc, #336]	; (7ea4 <Macro_periodic+0x190>)
    7d52:	7813      	ldrb	r3, [r2, #0]
    7d54:	4690      	mov	r8, r2
    7d56:	b953      	cbnz	r3, 7d6e <Macro_periodic+0x5a>
	switch ( macroDebugMode )
    7d58:	4d53      	ldr	r5, [pc, #332]	; (7ea8 <Macro_periodic+0x194>)
    7d5a:	782b      	ldrb	r3, [r5, #0]
    7d5c:	3b01      	subs	r3, #1
    7d5e:	2b01      	cmp	r3, #1
    7d60:	d85b      	bhi.n	7e1a <Macro_periodic+0x106>
    7d62:	2000      	movs	r0, #0
			Macro_showTriggerEvent( &macroTriggerEventBuffer[trigger] );
    7d64:	f8df a138 	ldr.w	sl, [pc, #312]	; 7ea0 <Macro_periodic+0x18c>
			print( NL );
    7d68:	f8df 8148 	ldr.w	r8, [pc, #328]	; 7eb4 <Macro_periodic+0x1a0>
    7d6c:	e04f      	b.n	7e0e <Macro_periodic+0xfa>
		macroInterconnectCacheSize = 0;
    7d6e:	2200      	movs	r2, #0
    7d70:	4d4e      	ldr	r5, [pc, #312]	; (7eac <Macro_periodic+0x198>)
    7d72:	f888 2000 	strb.w	r2, [r8]
    7d76:	f04f 0903 	mov.w	r9, #3
			macroTriggerEventBuffer[ macroTriggerEventBufferSize++ ] = macroInterconnectCache[ c ];
    7d7a:	f8df a124 	ldr.w	sl, [pc, #292]	; 7ea0 <Macro_periodic+0x18c>
				erro_msg("Interconnect Trigger Event Type - Not Implemented ");
    7d7e:	4a4c      	ldr	r2, [pc, #304]	; (7eb0 <Macro_periodic+0x19c>)
    7d80:	fb19 5903 	smlabb	r9, r9, r3, r5
					macroInterconnectCache[ macroInterconnectCacheSize++ ] = macroInterconnectCache[ c ];
    7d84:	f105 3bff 	add.w	fp, r5, #4294967295	; 0xffffffff
		for ( uint8_t c = 0; c < currentInterconnectCacheSize; c++ )
    7d88:	454d      	cmp	r5, r9
    7d8a:	8823      	ldrh	r3, [r4, #0]
    7d8c:	d0e4      	beq.n	7d58 <Macro_periodic+0x44>
			macroTriggerEventBuffer[ macroTriggerEventBufferSize++ ] = macroInterconnectCache[ c ];
    7d8e:	1c59      	adds	r1, r3, #1
    7d90:	8021      	strh	r1, [r4, #0]
    7d92:	4629      	mov	r1, r5
    7d94:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    7d98:	f831 cd01 	ldrh.w	ip, [r1, #-1]!
    7d9c:	f82a c003 	strh.w	ip, [sl, r3]
    7da0:	eb0a 0003 	add.w	r0, sl, r3
    7da4:	788b      	ldrb	r3, [r1, #2]
    7da6:	7083      	strb	r3, [r0, #2]
			switch ( macroInterconnectCache[ c ].type )
    7da8:	f815 3c01 	ldrb.w	r3, [r5, #-1]
    7dac:	2b04      	cmp	r3, #4
    7dae:	d90e      	bls.n	7dce <Macro_periodic+0xba>
    7db0:	2b15      	cmp	r3, #21
    7db2:	d020      	beq.n	7df6 <Macro_periodic+0xe2>
				erro_msg("Interconnect Trigger Event Type - Not Implemented ");
    7db4:	4610      	mov	r0, r2
    7db6:	9201      	str	r2, [sp, #4]
    7db8:	f007 fbda 	bl	f570 <_print>
				printInt8( macroInterconnectCache[ c ].type );
    7dbc:	f815 0c01 	ldrb.w	r0, [r5, #-1]
    7dc0:	f007 fc40 	bl	f644 <printInt8>
				print( NL );
    7dc4:	483b      	ldr	r0, [pc, #236]	; (7eb4 <Macro_periodic+0x1a0>)
    7dc6:	f007 fbd3 	bl	f570 <_print>
    7dca:	9a01      	ldr	r2, [sp, #4]
				break;
    7dcc:	e013      	b.n	7df6 <Macro_periodic+0xe2>
				switch ( macroInterconnectCache[ c ].state )
    7dce:	782b      	ldrb	r3, [r5, #0]
    7dd0:	2b01      	cmp	r3, #1
    7dd2:	d110      	bne.n	7df6 <Macro_periodic+0xe2>
					macroInterconnectCache[ c ].state = ScheduleType_H;
    7dd4:	2302      	movs	r3, #2
    7dd6:	702b      	strb	r3, [r5, #0]
					macroInterconnectCache[ macroInterconnectCacheSize++ ] = macroInterconnectCache[ c ];
    7dd8:	f898 3000 	ldrb.w	r3, [r8]
    7ddc:	f8b1 c000 	ldrh.w	ip, [r1]
    7de0:	1c58      	adds	r0, r3, #1
    7de2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    7de6:	f888 0000 	strb.w	r0, [r8]
    7dea:	f82b c003 	strh.w	ip, [fp, r3]
    7dee:	eb0b 0003 	add.w	r0, fp, r3
    7df2:	788b      	ldrb	r3, [r1, #2]
    7df4:	7083      	strb	r3, [r0, #2]
    7df6:	3503      	adds	r5, #3
    7df8:	e7c6      	b.n	7d88 <Macro_periodic+0x74>
			Macro_showTriggerEvent( &macroTriggerEventBuffer[trigger] );
    7dfa:	b280      	uxth	r0, r0
    7dfc:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    7e00:	4450      	add	r0, sl
    7e02:	f7ff fc9f 	bl	7744 <Macro_showTriggerEvent>
			print( NL );
    7e06:	4640      	mov	r0, r8
    7e08:	f007 fbb2 	bl	f570 <_print>
    7e0c:	4648      	mov	r0, r9
		for ( uint16_t trigger = 0; trigger < macroTriggerEventBufferSize; trigger++ )
    7e0e:	8822      	ldrh	r2, [r4, #0]
    7e10:	b283      	uxth	r3, r0
    7e12:	429a      	cmp	r2, r3
    7e14:	f100 0901 	add.w	r9, r0, #1
    7e18:	d8ef      	bhi.n	7dfa <Macro_periodic+0xe6>
	if ( macroTriggerEventBufferSize >= MaxScanCode_KLL )
    7e1a:	8823      	ldrh	r3, [r4, #0]
    7e1c:	2b59      	cmp	r3, #89	; 0x59
    7e1e:	d90a      	bls.n	7e36 <Macro_periodic+0x122>
			erro_msg("Macro Trigger Event Overflow! Serious Bug! ");
    7e20:	4825      	ldr	r0, [pc, #148]	; (7eb8 <Macro_periodic+0x1a4>)
    7e22:	f007 fba5 	bl	f570 <_print>
			printInt16( macroTriggerEventBufferSize );
    7e26:	8820      	ldrh	r0, [r4, #0]
    7e28:	f007 fc42 	bl	f6b0 <printInt16>
			print( NL );
    7e2c:	4821      	ldr	r0, [pc, #132]	; (7eb4 <Macro_periodic+0x1a0>)
    7e2e:	f007 fb9f 	bl	f570 <_print>
			macroTriggerEventBufferSize = 0;
    7e32:	2300      	movs	r3, #0
    7e34:	8023      	strh	r3, [r4, #0]
	if ( macroPauseMode )
    7e36:	4b21      	ldr	r3, [pc, #132]	; (7ebc <Macro_periodic+0x1a8>)
    7e38:	781b      	ldrb	r3, [r3, #0]
    7e3a:	b14b      	cbz	r3, 7e50 <Macro_periodic+0x13c>
		if ( macroStepCounter == 0 )
    7e3c:	4a20      	ldr	r2, [pc, #128]	; (7ec0 <Macro_periodic+0x1ac>)
    7e3e:	8813      	ldrh	r3, [r2, #0]
    7e40:	2b00      	cmp	r3, #0
    7e42:	f43f af7e 	beq.w	7d42 <Macro_periodic+0x2e>
		macroStepCounter--;
    7e46:	3b01      	subs	r3, #1
		dbug_print("Macro Step");
    7e48:	481e      	ldr	r0, [pc, #120]	; (7ec4 <Macro_periodic+0x1b0>)
		macroStepCounter--;
    7e4a:	8013      	strh	r3, [r2, #0]
		dbug_print("Macro Step");
    7e4c:	f007 fb90 	bl	f570 <_print>
	Trigger_process();
    7e50:	f000 ffcc 	bl	8dec <Trigger_process>
	var_uint_t macroTriggerEventBufferSize_processed = macroTriggerEventBufferSize;
    7e54:	f8b4 9000 	ldrh.w	r9, [r4]
	macroTriggerEventBufferSize = 0;
    7e58:	f04f 0800 	mov.w	r8, #0
    7e5c:	f8a4 8000 	strh.w	r8, [r4]
	Result_process();
    7e60:	f000 fc0a 	bl	8678 <Result_process>
	Scan_finishedWithMacro( macroTriggerEventBufferSize_processed );
    7e64:	fa5f f089 	uxtb.w	r0, r9
    7e68:	f7fe fc02 	bl	6670 <Scan_finishedWithMacro>
	Latency_end_time( macroLatencyResource );
    7e6c:	7838      	ldrb	r0, [r7, #0]
    7e6e:	f007 facb 	bl	f408 <Latency_end_time>
	if ( macroDebugMode == 1 || macroDebugMode == 3 )
    7e72:	782b      	ldrb	r3, [r5, #0]
    7e74:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    7e78:	2b01      	cmp	r3, #1
		USBKeys_primary.changed = 0;
    7e7a:	bf04      	itt	eq
    7e7c:	4b12      	ldreq	r3, [pc, #72]	; (7ec8 <Macro_periodic+0x1b4>)
    7e7e:	f883 8020 	strbeq.w	r8, [r3, #32]
    7e82:	e75e      	b.n	7d42 <Macro_periodic+0x2e>
}
    7e84:	b005      	add	sp, #20
    7e86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7e8a:	bf00      	nop
    7e8c:	1fff89d0 	.word	0x1fff89d0
    7e90:	1fff95e3 	.word	0x1fff95e3
    7e94:	1fffa340 	.word	0x1fffa340
    7e98:	1fff94cc 	.word	0x1fff94cc
    7e9c:	1fff89e2 	.word	0x1fff89e2
    7ea0:	1fffa346 	.word	0x1fffa346
    7ea4:	1fff95e2 	.word	0x1fff95e2
    7ea8:	1fffa45a 	.word	0x1fffa45a
    7eac:	1fffa45c 	.word	0x1fffa45c
    7eb0:	00011631 	.word	0x00011631
    7eb4:	00015df4 	.word	0x00015df4
    7eb8:	00011679 	.word	0x00011679
    7ebc:	1fffa33f 	.word	0x1fffa33f
    7ec0:	1fffa458 	.word	0x1fffa458
    7ec4:	000116ba 	.word	0x000116ba
    7ec8:	1fffb306 	.word	0x1fffb306

00007ecc <Macro_setup>:
{
    7ecc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    7ece:	4d16      	ldr	r5, [pc, #88]	; (7f28 <Macro_setup+0x5c>)
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    7ed0:	4916      	ldr	r1, [pc, #88]	; (7f2c <Macro_setup+0x60>)
{
    7ed2:	682b      	ldr	r3, [r5, #0]
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    7ed4:	4816      	ldr	r0, [pc, #88]	; (7f30 <Macro_setup+0x64>)
{
    7ed6:	9301      	str	r3, [sp, #4]
	CLI_registerDictionary( macroCLIDict, macroCLIDictName );
    7ed8:	f006 feda 	bl	ec90 <CLI_registerDictionary>
	macroDebugMode = 0;
    7edc:	4b15      	ldr	r3, [pc, #84]	; (7f34 <Macro_setup+0x68>)
	memset( Macro_rotation_store, 255, sizeof(Macro_rotate_capability) );
    7ede:	4816      	ldr	r0, [pc, #88]	; (7f38 <Macro_setup+0x6c>)
	macroDebugMode = 0;
    7ee0:	2400      	movs	r4, #0
    7ee2:	701c      	strb	r4, [r3, #0]
	macroPauseMode = 0;
    7ee4:	4b15      	ldr	r3, [pc, #84]	; (7f3c <Macro_setup+0x70>)
    7ee6:	701c      	strb	r4, [r3, #0]
	macroStepCounter = 0;
    7ee8:	4b15      	ldr	r3, [pc, #84]	; (7f40 <Macro_setup+0x74>)
    7eea:	801c      	strh	r4, [r3, #0]
	voteDebugMode = 0;
    7eec:	4b15      	ldr	r3, [pc, #84]	; (7f44 <Macro_setup+0x78>)
    7eee:	701c      	strb	r4, [r3, #0]
	triggerPendingDebugMode = 0;
    7ef0:	4b15      	ldr	r3, [pc, #84]	; (7f48 <Macro_setup+0x7c>)
    7ef2:	701c      	strb	r4, [r3, #0]
	macroTriggerEventBufferSize = 0;
    7ef4:	4b15      	ldr	r3, [pc, #84]	; (7f4c <Macro_setup+0x80>)
	memset( Macro_rotation_store, 255, sizeof(Macro_rotate_capability) );
    7ef6:	2201      	movs	r2, #1
    7ef8:	21ff      	movs	r1, #255	; 0xff
	macroTriggerEventBufferSize = 0;
    7efa:	801c      	strh	r4, [r3, #0]
	memset( Macro_rotation_store, 255, sizeof(Macro_rotate_capability) );
    7efc:	f7fa fc26 	bl	274c <memset>
	Layer_setup();
    7f00:	f7fe fe90 	bl	6c24 <Layer_setup>
	Trigger_setup();
    7f04:	f000 ff56 	bl	8db4 <Trigger_setup>
	Result_setup();
    7f08:	f000 fb42 	bl	8590 <Result_setup>
	macroLatencyResource = Latency_add_resource("PartialMap", LatencyOption_Ticks);
    7f0c:	4621      	mov	r1, r4
    7f0e:	4810      	ldr	r0, [pc, #64]	; (7f50 <Macro_setup+0x84>)
    7f10:	f007 f9e4 	bl	f2dc <Latency_add_resource>
    7f14:	4b0f      	ldr	r3, [pc, #60]	; (7f54 <Macro_setup+0x88>)
}
    7f16:	9a01      	ldr	r2, [sp, #4]
	macroLatencyResource = Latency_add_resource("PartialMap", LatencyOption_Ticks);
    7f18:	7018      	strb	r0, [r3, #0]
}
    7f1a:	682b      	ldr	r3, [r5, #0]
    7f1c:	429a      	cmp	r2, r3
    7f1e:	d001      	beq.n	7f24 <Macro_setup+0x58>
    7f20:	f7fa fc06 	bl	2730 <__stack_chk_fail>
    7f24:	b003      	add	sp, #12
    7f26:	bd30      	pop	{r4, r5, pc}
    7f28:	1fff89d0 	.word	0x1fff89d0
    7f2c:	00012b2c 	.word	0x00012b2c
    7f30:	00012a60 	.word	0x00012a60
    7f34:	1fffa45a 	.word	0x1fffa45a
    7f38:	1fff94e2 	.word	0x1fff94e2
    7f3c:	1fffa33f 	.word	0x1fffa33f
    7f40:	1fffa458 	.word	0x1fffa458
    7f44:	1fffa342 	.word	0x1fffa342
    7f48:	1fffa33e 	.word	0x1fffa33e
    7f4c:	1fffa340 	.word	0x1fffa340
    7f50:	00011775 	.word	0x00011775
    7f54:	1fff95e3 	.word	0x1fff95e3

00007f58 <macroDebugShowTrigger>:
{
    7f58:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7f5c:	4c4a      	ldr	r4, [pc, #296]	; (8088 <macroDebugShowTrigger+0x130>)
	if ( index >= TriggerMacroNum )
    7f5e:	2873      	cmp	r0, #115	; 0x73
{
    7f60:	6823      	ldr	r3, [r4, #0]
    7f62:	9301      	str	r3, [sp, #4]
    7f64:	4606      	mov	r6, r0
	if ( index >= TriggerMacroNum )
    7f66:	f200 8088 	bhi.w	807a <macroDebugShowTrigger+0x122>
	print( NL );
    7f6a:	4848      	ldr	r0, [pc, #288]	; (808c <macroDebugShowTrigger+0x134>)
	uint8_t comboLength = macro->guide[ pos ];
    7f6c:	4d48      	ldr	r5, [pc, #288]	; (8090 <macroDebugShowTrigger+0x138>)
			print("|");
    7f6e:	f8df 9154 	ldr.w	r9, [pc, #340]	; 80c4 <macroDebugShowTrigger+0x16c>
	print( NL );
    7f72:	f007 fafd 	bl	f570 <_print>
	info_msg("Trigger Macro Index: ");
    7f76:	4847      	ldr	r0, [pc, #284]	; (8094 <macroDebugShowTrigger+0x13c>)
    7f78:	f007 fafa 	bl	f570 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    7f7c:	4630      	mov	r0, r6
    7f7e:	f007 fb97 	bl	f6b0 <printInt16>
	print( NL );
    7f82:	4842      	ldr	r0, [pc, #264]	; (808c <macroDebugShowTrigger+0x134>)
    7f84:	f007 faf4 	bl	f570 <_print>
	uint8_t comboLength = macro->guide[ pos ];
    7f88:	f855 8036 	ldr.w	r8, [r5, r6, lsl #3]
    7f8c:	f898 7000 	ldrb.w	r7, [r8]
	var_uint_t pos = 0;
    7f90:	f04f 0a00 	mov.w	sl, #0
	while ( comboLength != 0 )
    7f94:	bb0f      	cbnz	r7, 7fda <macroDebugShowTrigger+0x82>
	print( NL "Position: " );
    7f96:	4840      	ldr	r0, [pc, #256]	; (8098 <macroDebugShowTrigger+0x140>)
    7f98:	f007 faea 	bl	f570 <_print>
	printInt16( (uint16_t)record->pos ); // Hopefully large enough :P (can't assume 32-bit)
    7f9c:	2306      	movs	r3, #6
    7f9e:	4373      	muls	r3, r6
    7fa0:	4a3e      	ldr	r2, [pc, #248]	; (809c <macroDebugShowTrigger+0x144>)
    7fa2:	18d7      	adds	r7, r2, r3
    7fa4:	5ad0      	ldrh	r0, [r2, r3]
    7fa6:	f007 fb83 	bl	f6b0 <printInt16>
	print(" ");
    7faa:	483d      	ldr	r0, [pc, #244]	; (80a0 <macroDebugShowTrigger+0x148>)
    7fac:	f007 fae0 	bl	f570 <_print>
	printInt16( (uint16_t)macro->result ); // Hopefully large enough :P (can't assume 32-bit)
    7fb0:	eb05 05c6 	add.w	r5, r5, r6, lsl #3
	printInt16( (uint16_t)record->prevPos );
    7fb4:	8878      	ldrh	r0, [r7, #2]
    7fb6:	f007 fb7b 	bl	f6b0 <printInt16>
	print( NL "Result Macro Index: " );
    7fba:	483a      	ldr	r0, [pc, #232]	; (80a4 <macroDebugShowTrigger+0x14c>)
    7fbc:	f007 fad8 	bl	f570 <_print>
	printInt16( (uint16_t)macro->result ); // Hopefully large enough :P (can't assume 32-bit)
    7fc0:	88a8      	ldrh	r0, [r5, #4]
    7fc2:	f007 fb75 	bl	f6b0 <printInt16>
	print( NL "Trigger Macro State: " );
    7fc6:	4838      	ldr	r0, [pc, #224]	; (80a8 <macroDebugShowTrigger+0x150>)
    7fc8:	f007 fad2 	bl	f570 <_print>
	switch ( record->state )
    7fcc:	793b      	ldrb	r3, [r7, #4]
    7fce:	2b03      	cmp	r3, #3
    7fd0:	d853      	bhi.n	807a <macroDebugShowTrigger+0x122>
    7fd2:	e8df f003 	tbb	[pc, r3]
    7fd6:	344c      	.short	0x344c
    7fd8:	4640      	.short	0x4640
		var_uint_t comboPos = ++pos;
    7fda:	f10a 0301 	add.w	r3, sl, #1
    7fde:	fa1f fa83 	uxth.w	sl, r3
		while ( pos < comboLength * TriggerGuideSize + comboPos )
    7fe2:	2203      	movs	r2, #3
    7fe4:	fb12 a707 	smlabb	r7, r2, r7, sl
    7fe8:	45ba      	cmp	sl, r7
    7fea:	eb08 0b0a 	add.w	fp, r8, sl
    7fee:	d307      	bcc.n	8000 <macroDebugShowTrigger+0xa8>
		comboLength = macro->guide[ pos ];
    7ff0:	f89b 7000 	ldrb.w	r7, [fp]
		if ( comboLength != 0 )
    7ff4:	2f00      	cmp	r7, #0
    7ff6:	d0ce      	beq.n	7f96 <macroDebugShowTrigger+0x3e>
			print(";");
    7ff8:	482c      	ldr	r0, [pc, #176]	; (80ac <macroDebugShowTrigger+0x154>)
    7ffa:	f007 fab9 	bl	f570 <_print>
    7ffe:	e7c9      	b.n	7f94 <macroDebugShowTrigger+0x3c>
			printHex( guide->scanCode );
    8000:	2101      	movs	r1, #1
    8002:	f89b 0002 	ldrb.w	r0, [fp, #2]
    8006:	f007 fbd9 	bl	f7bc <printHex_op>
			print("|");
    800a:	4648      	mov	r0, r9
    800c:	f007 fab0 	bl	f570 <_print>
			printHex( guide->type );
    8010:	2101      	movs	r1, #1
    8012:	f818 000a 	ldrb.w	r0, [r8, sl]
    8016:	f007 fbd1 	bl	f7bc <printHex_op>
			print("|");
    801a:	4648      	mov	r0, r9
    801c:	f007 faa8 	bl	f570 <_print>
			printHex( guide->state );
    8020:	2101      	movs	r1, #1
    8022:	f89b 0001 	ldrb.w	r0, [fp, #1]
    8026:	f007 fbc9 	bl	f7bc <printHex_op>
			pos += TriggerGuideSize;
    802a:	f10a 0303 	add.w	r3, sl, #3
    802e:	fa1f fa83 	uxth.w	sl, r3
			if ( pos < comboLength * TriggerGuideSize + comboPos )
    8032:	45ba      	cmp	sl, r7
    8034:	d2d8      	bcs.n	7fe8 <macroDebugShowTrigger+0x90>
				print("+");
    8036:	481e      	ldr	r0, [pc, #120]	; (80b0 <macroDebugShowTrigger+0x158>)
    8038:	f007 fa9a 	bl	f570 <_print>
    803c:	e7d4      	b.n	7fe8 <macroDebugShowTrigger+0x90>
	case TriggerMacro_Press:        print("Press");   break;
    803e:	9a01      	ldr	r2, [sp, #4]
    8040:	6823      	ldr	r3, [r4, #0]
    8042:	429a      	cmp	r2, r3
    8044:	d001      	beq.n	804a <macroDebugShowTrigger+0xf2>
}
    8046:	f7fa fb73 	bl	2730 <__stack_chk_fail>
	case TriggerMacro_Press:        print("Press");   break;
    804a:	481a      	ldr	r0, [pc, #104]	; (80b4 <macroDebugShowTrigger+0x15c>)
}
    804c:	b003      	add	sp, #12
    804e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	case TriggerMacro_Waiting:      print("Waiting"); break;
    8052:	f007 ba8d 	b.w	f570 <_print>
	case TriggerMacro_Release:      print("Release"); break;
    8056:	9a01      	ldr	r2, [sp, #4]
    8058:	6823      	ldr	r3, [r4, #0]
    805a:	429a      	cmp	r2, r3
    805c:	d1f3      	bne.n	8046 <macroDebugShowTrigger+0xee>
    805e:	4816      	ldr	r0, [pc, #88]	; (80b8 <macroDebugShowTrigger+0x160>)
    8060:	e7f4      	b.n	804c <macroDebugShowTrigger+0xf4>
	case TriggerMacro_PressRelease: print("Press|Release"); break;
    8062:	9a01      	ldr	r2, [sp, #4]
    8064:	6823      	ldr	r3, [r4, #0]
    8066:	429a      	cmp	r2, r3
    8068:	d1ed      	bne.n	8046 <macroDebugShowTrigger+0xee>
    806a:	4814      	ldr	r0, [pc, #80]	; (80bc <macroDebugShowTrigger+0x164>)
    806c:	e7ee      	b.n	804c <macroDebugShowTrigger+0xf4>
	case TriggerMacro_Waiting:      print("Waiting"); break;
    806e:	9a01      	ldr	r2, [sp, #4]
    8070:	6823      	ldr	r3, [r4, #0]
    8072:	429a      	cmp	r2, r3
    8074:	d1e7      	bne.n	8046 <macroDebugShowTrigger+0xee>
    8076:	4812      	ldr	r0, [pc, #72]	; (80c0 <macroDebugShowTrigger+0x168>)
    8078:	e7e8      	b.n	804c <macroDebugShowTrigger+0xf4>
}
    807a:	9a01      	ldr	r2, [sp, #4]
    807c:	6823      	ldr	r3, [r4, #0]
    807e:	429a      	cmp	r2, r3
    8080:	d1e1      	bne.n	8046 <macroDebugShowTrigger+0xee>
    8082:	b003      	add	sp, #12
    8084:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8088:	1fff89d0 	.word	0x1fff89d0
    808c:	00015df4 	.word	0x00015df4
    8090:	00011a74 	.word	0x00011a74
    8094:	00012bbc 	.word	0x00012bbc
    8098:	00012be8 	.word	0x00012be8
    809c:	1fffa56c 	.word	0x1fffa56c
    80a0:	00016f5e 	.word	0x00016f5e
    80a4:	00012bf5 	.word	0x00012bf5
    80a8:	00012c0c 	.word	0x00012c0c
    80ac:	00012be6 	.word	0x00012be6
    80b0:	00010bae 	.word	0x00010bae
    80b4:	00012f49 	.word	0x00012f49
    80b8:	00012f52 	.word	0x00012f52
    80bc:	00012c24 	.word	0x00012c24
    80c0:	00012c32 	.word	0x00012c32
    80c4:	00012be4 	.word	0x00012be4

000080c8 <macroDebugShowResult>:
{
    80c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    80cc:	4b41      	ldr	r3, [pc, #260]	; (81d4 <macroDebugShowResult+0x10c>)
    80ce:	b085      	sub	sp, #20
    80d0:	681a      	ldr	r2, [r3, #0]
    80d2:	9203      	str	r2, [sp, #12]
	if ( index >= ResultMacroNum )
    80d4:	286a      	cmp	r0, #106	; 0x6a
{
    80d6:	4604      	mov	r4, r0
    80d8:	9301      	str	r3, [sp, #4]
	if ( index >= ResultMacroNum )
    80da:	d816      	bhi.n	810a <macroDebugShowResult+0x42>
	print( NL );
    80dc:	483e      	ldr	r0, [pc, #248]	; (81d8 <macroDebugShowResult+0x110>)
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    80de:	f8df 811c 	ldr.w	r8, [pc, #284]	; 81fc <macroDebugShowResult+0x134>
	print( NL );
    80e2:	f007 fa45 	bl	f570 <_print>
	info_msg("Result Macro Index: ");
    80e6:	483d      	ldr	r0, [pc, #244]	; (81dc <macroDebugShowResult+0x114>)
    80e8:	f007 fa42 	bl	f570 <_print>
	printInt16( (uint16_t)index ); // Hopefully large enough :P (can't assume 32-bit)
    80ec:	4620      	mov	r0, r4
    80ee:	f007 fadf 	bl	f6b0 <printInt16>
	print( NL );
    80f2:	4839      	ldr	r0, [pc, #228]	; (81d8 <macroDebugShowResult+0x110>)
    80f4:	f007 fa3c 	bl	f570 <_print>
	uint8_t comboLength = macro->guide[ pos++ ];
    80f8:	4b39      	ldr	r3, [pc, #228]	; (81e0 <macroDebugShowResult+0x118>)
    80fa:	f853 7024 	ldr.w	r7, [r3, r4, lsl #2]
    80fe:	f897 9000 	ldrb.w	r9, [r7]
    8102:	2401      	movs	r4, #1
	while ( comboLength != 0 )
    8104:	f1b9 0f00 	cmp.w	r9, #0
    8108:	d15f      	bne.n	81ca <macroDebugShowResult+0x102>
}
    810a:	9b01      	ldr	r3, [sp, #4]
    810c:	9a03      	ldr	r2, [sp, #12]
    810e:	681b      	ldr	r3, [r3, #0]
    8110:	429a      	cmp	r2, r3
    8112:	d05c      	beq.n	81ce <macroDebugShowResult+0x106>
    8114:	f7fa fb0c 	bl	2730 <__stack_chk_fail>
			printHex( guide->index );
    8118:	2101      	movs	r1, #1
    811a:	4658      	mov	r0, fp
    811c:	f007 fb4e 	bl	f7bc <printHex_op>
			print("|");
    8120:	4830      	ldr	r0, [pc, #192]	; (81e4 <macroDebugShowResult+0x11c>)
    8122:	f007 fa25 	bl	f570 <_print>
			printHex( (nat_ptr_t)CapabilitiesList[ guide->index ].func );
    8126:	5d3b      	ldrb	r3, [r7, r4]
    8128:	2101      	movs	r1, #1
    812a:	f838 0033 	ldrh.w	r0, [r8, r3, lsl #3]
    812e:	f007 fb45 	bl	f7bc <printHex_op>
			print("|");
    8132:	482c      	ldr	r0, [pc, #176]	; (81e4 <macroDebugShowResult+0x11c>)
    8134:	f007 fa1c 	bl	f570 <_print>
				(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ guide->index ].func);
    8138:	5d3b      	ldrb	r3, [r7, r4]
			capability( 0, 0xFF, 0xFF, 0 );
    813a:	22ff      	movs	r2, #255	; 0xff
    813c:	f858 b033 	ldr.w	fp, [r8, r3, lsl #3]
    8140:	2300      	movs	r3, #0
    8142:	4618      	mov	r0, r3
    8144:	4611      	mov	r1, r2
    8146:	47d8      	blx	fp
			print("(");
    8148:	4827      	ldr	r0, [pc, #156]	; (81e8 <macroDebugShowResult+0x120>)
    814a:	f007 fa11 	bl	f570 <_print>
    814e:	46b3      	mov	fp, r6
			for ( var_uint_t arg = 0; arg < CapabilitiesList[ guide->index ].argCount; arg++ )
    8150:	7831      	ldrb	r1, [r6, #0]
    8152:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
    8156:	ebab 0306 	sub.w	r3, fp, r6
    815a:	7909      	ldrb	r1, [r1, #4]
    815c:	b29b      	uxth	r3, r3
    815e:	4299      	cmp	r1, r3
    8160:	d822      	bhi.n	81a8 <macroDebugShowResult+0xe0>
			print(")");
    8162:	4822      	ldr	r0, [pc, #136]	; (81ec <macroDebugShowResult+0x124>)
    8164:	f007 fa04 	bl	f570 <_print>
			pos += ResultGuideSize( guide );
    8168:	7833      	ldrb	r3, [r6, #0]
    816a:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
			funcCount++;
    816e:	3501      	adds	r5, #1
			pos += ResultGuideSize( guide );
    8170:	791b      	ldrb	r3, [r3, #4]
			funcCount++;
    8172:	b2ad      	uxth	r5, r5
			pos += ResultGuideSize( guide );
    8174:	3301      	adds	r3, #1
    8176:	441c      	add	r4, r3
			if ( funcCount < comboLength )
    8178:	4555      	cmp	r5, sl
			pos += ResultGuideSize( guide );
    817a:	b2a4      	uxth	r4, r4
			if ( funcCount < comboLength )
    817c:	d202      	bcs.n	8184 <macroDebugShowResult+0xbc>
				print("+");
    817e:	481c      	ldr	r0, [pc, #112]	; (81f0 <macroDebugShowResult+0x128>)
    8180:	f007 f9f6 	bl	f570 <_print>
		while ( funcCount < comboLength )
    8184:	fa1f fa89 	uxth.w	sl, r9
    8188:	4555      	cmp	r5, sl
    818a:	eb07 0604 	add.w	r6, r7, r4
    818e:	f817 b004 	ldrb.w	fp, [r7, r4]
    8192:	d3c1      	bcc.n	8118 <macroDebugShowResult+0x50>
		comboLength = macro->guide[ pos++ ];
    8194:	3401      	adds	r4, #1
    8196:	b2a4      	uxth	r4, r4
		if ( comboLength != 0 )
    8198:	f1bb 0f00 	cmp.w	fp, #0
    819c:	d002      	beq.n	81a4 <macroDebugShowResult+0xdc>
			print(";");
    819e:	4815      	ldr	r0, [pc, #84]	; (81f4 <macroDebugShowResult+0x12c>)
    81a0:	f007 f9e6 	bl	f570 <_print>
		var_uint_t funcCount = 0;
    81a4:	46d9      	mov	r9, fp
    81a6:	e7ad      	b.n	8104 <macroDebugShowResult+0x3c>
				printHex( (&guide->args)[ arg ] );
    81a8:	2101      	movs	r1, #1
    81aa:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
    81ae:	f007 fb05 	bl	f7bc <printHex_op>
				if ( arg + 1 < CapabilitiesList[ guide->index ].argCount )
    81b2:	7833      	ldrb	r3, [r6, #0]
    81b4:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
    81b8:	7919      	ldrb	r1, [r3, #4]
    81ba:	ebab 0306 	sub.w	r3, fp, r6
    81be:	4299      	cmp	r1, r3
    81c0:	ddc6      	ble.n	8150 <macroDebugShowResult+0x88>
					print(",");
    81c2:	480d      	ldr	r0, [pc, #52]	; (81f8 <macroDebugShowResult+0x130>)
    81c4:	f007 f9d4 	bl	f570 <_print>
    81c8:	e7c2      	b.n	8150 <macroDebugShowResult+0x88>
		var_uint_t funcCount = 0;
    81ca:	2500      	movs	r5, #0
    81cc:	e7da      	b.n	8184 <macroDebugShowResult+0xbc>
}
    81ce:	b005      	add	sp, #20
    81d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    81d4:	1fff89d0 	.word	0x1fff89d0
    81d8:	00015df4 	.word	0x00015df4
    81dc:	00012b93 	.word	0x00012b93
    81e0:	000118c8 	.word	0x000118c8
    81e4:	00012be4 	.word	0x00012be4
    81e8:	00014e2a 	.word	0x00014e2a
    81ec:	00015c35 	.word	0x00015c35
    81f0:	00010bae 	.word	0x00010bae
    81f4:	00012be6 	.word	0x00012be6
    81f8:	00012bba 	.word	0x00012bba
    81fc:	00011460 	.word	0x00011460

00008200 <cliFunc_macroShow>:
{
    8200:	b530      	push	{r4, r5, lr}
    8202:	b085      	sub	sp, #20
    8204:	4c13      	ldr	r4, [pc, #76]	; (8254 <cliFunc_macroShow+0x54>)
	char* arg2Ptr = args;
    8206:	ad04      	add	r5, sp, #16
{
    8208:	6822      	ldr	r2, [r4, #0]
	char* arg2Ptr = args;
    820a:	f845 0d08 	str.w	r0, [r5, #-8]!
{
    820e:	9203      	str	r2, [sp, #12]
		CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    8210:	9802      	ldr	r0, [sp, #8]
    8212:	462a      	mov	r2, r5
    8214:	a901      	add	r1, sp, #4
    8216:	f006 fc7d 	bl	eb14 <CLI_argumentIsolation>
		if ( *arg1Ptr == '\0' )
    821a:	9801      	ldr	r0, [sp, #4]
    821c:	7803      	ldrb	r3, [r0, #0]
    821e:	b18b      	cbz	r3, 8244 <cliFunc_macroShow+0x44>
		switch ( arg1Ptr[0] )
    8220:	2b52      	cmp	r3, #82	; 0x52
    8222:	d008      	beq.n	8236 <cliFunc_macroShow+0x36>
    8224:	2b54      	cmp	r3, #84	; 0x54
    8226:	d1f3      	bne.n	8210 <cliFunc_macroShow+0x10>
			macroDebugShowTrigger( numToInt( &arg1Ptr[1] ) );
    8228:	3001      	adds	r0, #1
    822a:	f007 fb71 	bl	f910 <numToInt>
    822e:	b280      	uxth	r0, r0
    8230:	f7ff fe92 	bl	7f58 <macroDebugShowTrigger>
			break;
    8234:	e7ec      	b.n	8210 <cliFunc_macroShow+0x10>
			macroDebugShowResult( numToInt( &arg1Ptr[1] ) );
    8236:	3001      	adds	r0, #1
    8238:	f007 fb6a 	bl	f910 <numToInt>
    823c:	b280      	uxth	r0, r0
    823e:	f7ff ff43 	bl	80c8 <macroDebugShowResult>
			break;
    8242:	e7e5      	b.n	8210 <cliFunc_macroShow+0x10>
}
    8244:	9a03      	ldr	r2, [sp, #12]
    8246:	6823      	ldr	r3, [r4, #0]
    8248:	429a      	cmp	r2, r3
    824a:	d001      	beq.n	8250 <cliFunc_macroShow+0x50>
    824c:	f7fa fa70 	bl	2730 <__stack_chk_fail>
    8250:	b005      	add	sp, #20
    8252:	bd30      	pop	{r4, r5, pc}
    8254:	1fff89d0 	.word	0x1fff89d0

00008258 <Result_evalResultMacroCombo>:
	ResultPendingElem *resultElem,
	const ResultMacro *macro,
	ResultMacroRecord *record,
	var_uint_t *comboItem
)
{
    8258:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    825c:	461f      	mov	r7, r3
    825e:	4b4d      	ldr	r3, [pc, #308]	; (8394 <Result_evalResultMacroCombo+0x13c>)

			// Call capability
			capability( resultElem->trigger, record->state, record->stateType, &guide->args );
		}
		// Otherwise, queue up the capability for later
		else if ( macroResultDelayedCapabilities.size < ResultCapabilityStackSize_define )
    8260:	4c4d      	ldr	r4, [pc, #308]	; (8398 <Result_evalResultMacroCombo+0x140>)
{
    8262:	681b      	ldr	r3, [r3, #0]
    8264:	b087      	sub	sp, #28
    8266:	4616      	mov	r6, r2
    8268:	9305      	str	r3, [sp, #20]
	uint8_t pos = *comboItem - 1;
    826a:	783b      	ldrb	r3, [r7, #0]
	uint8_t comboLength = macro->guide[ pos ];
    826c:	680a      	ldr	r2, [r1, #0]
	uint8_t pos = *comboItem - 1;
    826e:	3b01      	subs	r3, #1
	uint8_t comboLength = macro->guide[ pos ];
    8270:	b2db      	uxtb	r3, r3
{
    8272:	4680      	mov	r8, r0
	uint8_t comboLength = macro->guide[ pos ];
    8274:	5cd3      	ldrb	r3, [r2, r3]
    8276:	9303      	str	r3, [sp, #12]
{
    8278:	4689      	mov	r9, r1
	while ( funcCount < comboLength )
    827a:	f04f 0a00 	mov.w	sl, #0
    827e:	9a03      	ldr	r2, [sp, #12]
    8280:	fa1f f38a 	uxth.w	r3, sl
    8284:	429a      	cmp	r2, r3
    8286:	d806      	bhi.n	8296 <Result_evalResultMacroCombo+0x3e>

		// Increment counters
		funcCount++;
		*comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ *comboItem ]) );
	}
}
    8288:	4b42      	ldr	r3, [pc, #264]	; (8394 <Result_evalResultMacroCombo+0x13c>)
    828a:	9a05      	ldr	r2, [sp, #20]
    828c:	681b      	ldr	r3, [r3, #0]
    828e:	429a      	cmp	r2, r3
    8290:	d07d      	beq.n	838e <Result_evalResultMacroCombo+0x136>
    8292:	f7fa fa4d 	bl	2730 <__stack_chk_fail>
		ResultGuide *guide = (ResultGuide*)(&macro->guide[ *comboItem ]);
    8296:	883b      	ldrh	r3, [r7, #0]
    8298:	f8d9 2000 	ldr.w	r2, [r9]
    829c:	18d5      	adds	r5, r2, r3
		if ( CapabilitiesList[ guide->index ].features & CapabilityFeature_Safe )
    829e:	5cd1      	ldrb	r1, [r2, r3]
    82a0:	4a3e      	ldr	r2, [pc, #248]	; (839c <Result_evalResultMacroCombo+0x144>)
    82a2:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
    82a6:	795b      	ldrb	r3, [r3, #5]
    82a8:	f013 0301 	ands.w	r3, r3, #1
    82ac:	d025      	beq.n	82fa <Result_evalResultMacroCombo+0xa2>
			if ( capDebugMode )
    82ae:	4b3c      	ldr	r3, [pc, #240]	; (83a0 <Result_evalResultMacroCombo+0x148>)
			void (*capability)(TriggerMacro*, uint8_t, uint8_t, uint8_t*) = \
    82b0:	f852 b031 	ldr.w	fp, [r2, r1, lsl #3]
			if ( capDebugMode )
    82b4:	781b      	ldrb	r3, [r3, #0]
    82b6:	3501      	adds	r5, #1
    82b8:	b15b      	cbz	r3, 82d2 <Result_evalResultMacroCombo+0x7a>
				dbug_msg("Safe: ");
    82ba:	483a      	ldr	r0, [pc, #232]	; (83a4 <Result_evalResultMacroCombo+0x14c>)
    82bc:	f007 f958 	bl	f570 <_print>
				capability( resultElem->trigger, ScheduleType_Debug, TriggerType_Debug, &guide->args );
    82c0:	22ff      	movs	r2, #255	; 0xff
    82c2:	f8d8 0000 	ldr.w	r0, [r8]
    82c6:	462b      	mov	r3, r5
    82c8:	4611      	mov	r1, r2
    82ca:	47d8      	blx	fp
				print( NL );
    82cc:	4836      	ldr	r0, [pc, #216]	; (83a8 <Result_evalResultMacroCombo+0x150>)
    82ce:	f007 f94f 	bl	f570 <_print>
			capability( resultElem->trigger, record->state, record->stateType, &guide->args );
    82d2:	462b      	mov	r3, r5
    82d4:	7972      	ldrb	r2, [r6, #5]
    82d6:	7931      	ldrb	r1, [r6, #4]
    82d8:	f8d8 0000 	ldr.w	r0, [r8]
    82dc:	47d8      	blx	fp
		*comboItem += ResultGuideSize( (ResultGuide*)(&macro->guide[ *comboItem ]) );
    82de:	883b      	ldrh	r3, [r7, #0]
    82e0:	f8d9 2000 	ldr.w	r2, [r9]
    82e4:	492d      	ldr	r1, [pc, #180]	; (839c <Result_evalResultMacroCombo+0x144>)
    82e6:	5cd2      	ldrb	r2, [r2, r3]
    82e8:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
    82ec:	3301      	adds	r3, #1
    82ee:	7912      	ldrb	r2, [r2, #4]
    82f0:	4413      	add	r3, r2
    82f2:	803b      	strh	r3, [r7, #0]
    82f4:	f10a 0a01 	add.w	sl, sl, #1
    82f8:	e7c1      	b.n	827e <Result_evalResultMacroCombo+0x26>
		else if ( macroResultDelayedCapabilities.size < ResultCapabilityStackSize_define )
    82fa:	f894 2078 	ldrb.w	r2, [r4, #120]	; 0x78
    82fe:	2a09      	cmp	r2, #9
    8300:	d841      	bhi.n	8386 <Result_evalResultMacroCombo+0x12e>
    8302:	f8d8 2000 	ldr.w	r2, [r8]
			uint8_t size = macroResultDelayedCapabilities.size;
    8306:	f894 0078 	ldrb.w	r0, [r4, #120]	; 0x78
    830a:	9201      	str	r2, [sp, #4]
    830c:	f896 b005 	ldrb.w	fp, [r6, #5]
    8310:	7932      	ldrb	r2, [r6, #4]
    8312:	9202      	str	r2, [sp, #8]
    8314:	b2c0      	uxtb	r0, r0
			for ( ; pos < size; pos++ )
    8316:	fa5f fc83 	uxtb.w	ip, r3
    831a:	4560      	cmp	r0, ip
    831c:	d813      	bhi.n	8346 <Result_evalResultMacroCombo+0xee>
				item->trigger         = resultElem->trigger;
    831e:	230c      	movs	r3, #12
    8320:	fb03 f200 	mul.w	r2, r3, r0
    8324:	18a3      	adds	r3, r4, r2
    8326:	9801      	ldr	r0, [sp, #4]
    8328:	50a0      	str	r0, [r4, r2]
				item->args            = &guide->args;
    832a:	3501      	adds	r5, #1
				item->state           = record->state;
    832c:	9a02      	ldr	r2, [sp, #8]
    832e:	711a      	strb	r2, [r3, #4]
				item->stateType       = record->stateType;
    8330:	f883 b005 	strb.w	fp, [r3, #5]
				item->capabilityIndex = guide->index;
    8334:	7199      	strb	r1, [r3, #6]
				item->args            = &guide->args;
    8336:	609d      	str	r5, [r3, #8]
				macroResultDelayedCapabilities.size++;
    8338:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    833c:	3301      	adds	r3, #1
    833e:	b2db      	uxtb	r3, r3
    8340:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    8344:	e7cb      	b.n	82de <Result_evalResultMacroCombo+0x86>
					item->trigger == resultElem->trigger &&
    8346:	220c      	movs	r2, #12
    8348:	fb02 fe03 	mul.w	lr, r2, r3
    834c:	eb04 0c0e 	add.w	ip, r4, lr
				if (
    8350:	9a01      	ldr	r2, [sp, #4]
					item->trigger == resultElem->trigger &&
    8352:	f854 e00e 	ldr.w	lr, [r4, lr]
				if (
    8356:	4596      	cmp	lr, r2
    8358:	d113      	bne.n	8382 <Result_evalResultMacroCombo+0x12a>
					item->state == record->state &&
    835a:	f89c e004 	ldrb.w	lr, [ip, #4]
					item->trigger == resultElem->trigger &&
    835e:	9a02      	ldr	r2, [sp, #8]
    8360:	4596      	cmp	lr, r2
    8362:	d10e      	bne.n	8382 <Result_evalResultMacroCombo+0x12a>
					item->stateType == record->stateType &&
    8364:	f89c e005 	ldrb.w	lr, [ip, #5]
					item->state == record->state &&
    8368:	45de      	cmp	lr, fp
    836a:	d10a      	bne.n	8382 <Result_evalResultMacroCombo+0x12a>
					item->capabilityIndex == guide->index
    836c:	f89c e006 	ldrb.w	lr, [ip, #6]
					item->stateType == record->stateType &&
    8370:	4571      	cmp	r1, lr
    8372:	d106      	bne.n	8382 <Result_evalResultMacroCombo+0x12a>
					if ( guide->args != 0 && item->args == &guide->args )
    8374:	f895 e001 	ldrb.w	lr, [r5, #1]
    8378:	f1be 0f00 	cmp.w	lr, #0
    837c:	d001      	beq.n	8382 <Result_evalResultMacroCombo+0x12a>
    837e:	f8dc c008 	ldr.w	ip, [ip, #8]
    8382:	3301      	adds	r3, #1
    8384:	e7c7      	b.n	8316 <Result_evalResultMacroCombo+0xbe>
			warn_print("Delayed capability stack full!");
    8386:	4809      	ldr	r0, [pc, #36]	; (83ac <Result_evalResultMacroCombo+0x154>)
    8388:	f007 f8f2 	bl	f570 <_print>
    838c:	e7a7      	b.n	82de <Result_evalResultMacroCombo+0x86>
}
    838e:	b007      	add	sp, #28
    8390:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8394:	1fff89d0 	.word	0x1fff89d0
    8398:	1fffa824 	.word	0x1fffa824
    839c:	00011460 	.word	0x00011460
    83a0:	1fffa8a0 	.word	0x1fffa8a0
    83a4:	000145c1 	.word	0x000145c1
    83a8:	00015df4 	.word	0x00015df4
    83ac:	000145db 	.word	0x000145db

000083b0 <Result_appendResultMacroToPendingList>:


// Append result macro to pending list, duplicates are ok
void Result_appendResultMacroToPendingList( const TriggerMacro *triggerMacro )
{
    83b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	var_uint_t resultMacroIndex = triggerMacro->result;

	// Add, even if there's a duplicate
	// There may be multiple triggers that specify the capability
	// Different triggers may result in different final results
	ResultPendingElem *elem = &macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ];
    83b4:	4e4b      	ldr	r6, [pc, #300]	; (84e4 <Result_appendResultMacroToPendingList+0x134>)
{
    83b6:	4f4c      	ldr	r7, [pc, #304]	; (84e8 <Result_appendResultMacroToPendingList+0x138>)
	ResultPendingElem *elem = &macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ];
    83b8:	f8b6 8258 	ldrh.w	r8, [r6, #600]	; 0x258
{
    83bc:	683b      	ldr	r3, [r7, #0]
	var_uint_t resultMacroIndex = triggerMacro->result;
    83be:	8881      	ldrh	r1, [r0, #4]
{
    83c0:	b085      	sub	sp, #20
    83c2:	4681      	mov	r9, r0
    83c4:	9303      	str	r3, [sp, #12]
	ResultPendingElem *elem = &macroResultMacroPendingList.data[ macroResultMacroPendingList.size++ ];
    83c6:	f108 0301 	add.w	r3, r8, #1
    83ca:	f8a6 3258 	strh.w	r3, [r6, #600]	; 0x258
	elem->trigger = (TriggerMacro*)triggerMacro;
    83ce:	230c      	movs	r3, #12
    83d0:	fb03 f308 	mul.w	r3, r3, r8
    83d4:	18f2      	adds	r2, r6, r3
    83d6:	50f0      	str	r0, [r6, r3]
	elem->index = resultMacroIndex;
    83d8:	8091      	strh	r1, [r2, #4]
	// Lookup index and type of a key in the last combo
	// Depending on the trigger type, which key selected will vary
	// First, find the last combo
	var_uint_t prev_pos = 0;
	var_uint_t pos = 0;
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    83da:	6802      	ldr	r2, [r0, #0]
	var_uint_t pos = 0;
    83dc:	2300      	movs	r3, #0
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    83de:	7814      	ldrb	r4, [r2, #0]
	var_uint_t prev_pos = 0;
    83e0:	469a      	mov	sl, r3
	for ( uint8_t comboLength = triggerMacro->guide[0]; comboLength > 0; )
    83e2:	b98c      	cbnz	r4, 8408 <Result_appendResultMacroToPendingList+0x58>

		// Lookup index in buffer list for the current state and stateType
		for ( var_uint_t keyIndex = 0; keyIndex < macroTriggerEventBufferSize; keyIndex++ )
		{
			if (
				macroTriggerEventBuffer[ keyIndex ].index == cur_guide->scanCode &&
    83e4:	f8df b114 	ldr.w	fp, [pc, #276]	; 84fc <Result_appendResultMacroToPendingList+0x14c>
	TriggerEvent *event = 0;
    83e8:	4625      	mov	r5, r4
	for ( uint8_t elem = 0; elem < triggerMacro->guide[prev_pos]; elem++ )
    83ea:	f8d9 2000 	ldr.w	r2, [r9]
    83ee:	f812 100a 	ldrb.w	r1, [r2, sl]
    83f2:	b2e3      	uxtb	r3, r4
    83f4:	4299      	cmp	r1, r3
    83f6:	d810      	bhi.n	841a <Result_appendResultMacroToPendingList+0x6a>
			break;
		}
	}

	// If event was not set, ignore
	if ( !event )
    83f8:	2d00      	cmp	r5, #0
    83fa:	d153      	bne.n	84a4 <Result_appendResultMacroToPendingList+0xf4>
	{
		erro_print("No event found! Bug!");
    83fc:	9a03      	ldr	r2, [sp, #12]
    83fe:	683b      	ldr	r3, [r7, #0]
    8400:	429a      	cmp	r2, r3
    8402:	d049      	beq.n	8498 <Result_appendResultMacroToPendingList+0xe8>
	}

	// Reset the macro position
	elem->record.prevPos = 0;
	elem->record.pos = 0;
}
    8404:	f7fa f994 	bl	2730 <__stack_chk_fail>
		pos += TriggerGuideSize * comboLength + 1;
    8408:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    840c:	3401      	adds	r4, #1
    840e:	441c      	add	r4, r3
    8410:	b2a1      	uxth	r1, r4
		prev_pos = pos;
    8412:	469a      	mov	sl, r3
		comboLength = triggerMacro->guide[ pos ];
    8414:	5c54      	ldrb	r4, [r2, r1]
		pos += TriggerGuideSize * comboLength + 1;
    8416:	460b      	mov	r3, r1
    8418:	e7e3      	b.n	83e2 <Result_appendResultMacroToPendingList+0x32>
		TriggerGuide *cur_guide = (TriggerGuide*)&triggerMacro->guide[prev_pos + 1];
    841a:	f10a 0301 	add.w	r3, sl, #1
    841e:	441a      	add	r2, r3
		for ( var_uint_t keyIndex = 0; keyIndex < macroTriggerEventBufferSize; keyIndex++ )
    8420:	4b32      	ldr	r3, [pc, #200]	; (84ec <Result_appendResultMacroToPendingList+0x13c>)
    8422:	881b      	ldrh	r3, [r3, #0]
    8424:	9301      	str	r3, [sp, #4]
    8426:	2100      	movs	r1, #0
    8428:	9801      	ldr	r0, [sp, #4]
    842a:	b28b      	uxth	r3, r1
    842c:	4283      	cmp	r3, r0
    842e:	d303      	bcc.n	8438 <Result_appendResultMacroToPendingList+0x88>
			erro_print("Could not find event in event buffer for activated trigger! This is a bug!");
    8430:	482f      	ldr	r0, [pc, #188]	; (84f0 <Result_appendResultMacroToPendingList+0x140>)
    8432:	f007 f89d 	bl	f570 <_print>
			continue;
    8436:	e024      	b.n	8482 <Result_appendResultMacroToPendingList+0xd2>
    8438:	eb01 0041 	add.w	r0, r1, r1, lsl #1
				macroTriggerEventBuffer[ keyIndex ].index == cur_guide->scanCode &&
    843c:	eb00 030b 	add.w	r3, r0, fp
			if (
    8440:	f892 c002 	ldrb.w	ip, [r2, #2]
    8444:	f893 e002 	ldrb.w	lr, [r3, #2]
    8448:	45e6      	cmp	lr, ip
    844a:	d11c      	bne.n	8486 <Result_appendResultMacroToPendingList+0xd6>
				macroTriggerEventBuffer[ keyIndex ].type == cur_guide->type
    844c:	f810 c00b 	ldrb.w	ip, [r0, fp]
				macroTriggerEventBuffer[ keyIndex ].index == cur_guide->scanCode &&
    8450:	7810      	ldrb	r0, [r2, #0]
    8452:	4560      	cmp	r0, ip
    8454:	d117      	bne.n	8486 <Result_appendResultMacroToPendingList+0xd6>
				cur_event = &macroTriggerEventBuffer[ keyIndex ];
    8456:	2d00      	cmp	r5, #0
    8458:	bf08      	it	eq
    845a:	461d      	moveq	r5, r3
    845c:	2814      	cmp	r0, #20
    845e:	d810      	bhi.n	8482 <Result_appendResultMacroToPendingList+0xd2>
    8460:	2101      	movs	r1, #1
    8462:	4a24      	ldr	r2, [pc, #144]	; (84f4 <Result_appendResultMacroToPendingList+0x144>)
    8464:	4081      	lsls	r1, r0
    8466:	400a      	ands	r2, r1
    8468:	b15a      	cbz	r2, 8482 <Result_appendResultMacroToPendingList+0xd2>
				( event->state == ScheduleType_H || event->state == ScheduleType_O ) &&
    846a:	7869      	ldrb	r1, [r5, #1]
    846c:	f011 0ffd 	tst.w	r1, #253	; 0xfd
    8470:	d10b      	bne.n	848a <Result_appendResultMacroToPendingList+0xda>
				( cur_event->state != event->state ) &&
    8472:	785a      	ldrb	r2, [r3, #1]
				( event->state == ScheduleType_H || event->state == ScheduleType_O ) &&
    8474:	4291      	cmp	r1, r2
    8476:	d004      	beq.n	8482 <Result_appendResultMacroToPendingList+0xd2>
				( cur_event->state != event->state ) &&
    8478:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
				cur_event = &macroTriggerEventBuffer[ keyIndex ];
    847c:	2a01      	cmp	r2, #1
    847e:	bf08      	it	eq
    8480:	461d      	moveq	r5, r3
    8482:	3401      	adds	r4, #1
    8484:	e7b1      	b.n	83ea <Result_appendResultMacroToPendingList+0x3a>
    8486:	3101      	adds	r1, #1
    8488:	e7ce      	b.n	8428 <Result_appendResultMacroToPendingList+0x78>
			else if ( event->state == ScheduleType_P && cur_event->state == ScheduleType_R )
    848a:	2901      	cmp	r1, #1
    848c:	d1f9      	bne.n	8482 <Result_appendResultMacroToPendingList+0xd2>
    848e:	785a      	ldrb	r2, [r3, #1]
				cur_event = &macroTriggerEventBuffer[ keyIndex ];
    8490:	2a03      	cmp	r2, #3
    8492:	bf08      	it	eq
    8494:	461d      	moveq	r5, r3
    8496:	e7f4      	b.n	8482 <Result_appendResultMacroToPendingList+0xd2>
		erro_print("No event found! Bug!");
    8498:	4817      	ldr	r0, [pc, #92]	; (84f8 <Result_appendResultMacroToPendingList+0x148>)
}
    849a:	b005      	add	sp, #20
    849c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		erro_print("No event found! Bug!");
    84a0:	f007 b866 	b.w	f570 <_print>
	elem->record.state     = event->state;
    84a4:	220c      	movs	r2, #12
    84a6:	fb02 6208 	mla	r2, r2, r8, r6
	elem->record.stateType = event->type;
    84aa:	7829      	ldrb	r1, [r5, #0]
    84ac:	72d1      	strb	r1, [r2, #11]
	switch ( elem->record.stateType )
    84ae:	3909      	subs	r1, #9
	elem->record.state     = event->state;
    84b0:	786b      	ldrb	r3, [r5, #1]
    84b2:	7293      	strb	r3, [r2, #10]
	switch ( elem->record.stateType )
    84b4:	2903      	cmp	r1, #3
    84b6:	d807      	bhi.n	84c8 <Result_appendResultMacroToPendingList+0x118>
		if ( elem->record.state & 0xF0 && ( elem->record.state & 0x80 ) == 0x00 )
    84b8:	f013 0ff0 	tst.w	r3, #240	; 0xf0
    84bc:	d004      	beq.n	84c8 <Result_appendResultMacroToPendingList+0x118>
    84be:	0619      	lsls	r1, r3, #24
			elem->record.state &= 0x8F;
    84c0:	bf5c      	itt	pl
    84c2:	f023 0370 	bicpl.w	r3, r3, #112	; 0x70
    84c6:	7293      	strbpl	r3, [r2, #10]
	elem->record.prevPos = 0;
    84c8:	230c      	movs	r3, #12
    84ca:	fb03 6608 	mla	r6, r3, r8, r6
    84ce:	2300      	movs	r3, #0
}
    84d0:	9a03      	ldr	r2, [sp, #12]
	elem->record.prevPos = 0;
    84d2:	8133      	strh	r3, [r6, #8]
	elem->record.pos = 0;
    84d4:	80f3      	strh	r3, [r6, #6]
}
    84d6:	683b      	ldr	r3, [r7, #0]
    84d8:	429a      	cmp	r2, r3
    84da:	d193      	bne.n	8404 <Result_appendResultMacroToPendingList+0x54>
    84dc:	b005      	add	sp, #20
    84de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    84e2:	bf00      	nop
    84e4:	1fffa8a4 	.word	0x1fffa8a4
    84e8:	1fff89d0 	.word	0x1fff89d0
    84ec:	1fffa340 	.word	0x1fffa340
    84f0:	0001455f 	.word	0x0001455f
    84f4:	001e1e1f 	.word	0x001e1e1f
    84f8:	00014533 	.word	0x00014533
    84fc:	1fffa346 	.word	0x1fffa346

00008500 <Result_evalResultMacro>:


// Evaluate/Update ResultMacro
ResultMacroEval Result_evalResultMacro( ResultPendingElem *resultElem )
{
    8500:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    8504:	4d20      	ldr	r5, [pc, #128]	; (8588 <Result_evalResultMacro+0x88>)

	// Lookup ResultMacroRecord
	ResultMacroRecord *record = &resultElem->record;

	// Current Macro position
	var_uint_t pos = record->pos;
    8506:	88c2      	ldrh	r2, [r0, #6]
{
    8508:	682b      	ldr	r3, [r5, #0]
	const ResultMacro *macro = &ResultMacroList[ resultElem->index ];
    850a:	8887      	ldrh	r7, [r0, #4]
    850c:	4e1f      	ldr	r6, [pc, #124]	; (858c <Result_evalResultMacro+0x8c>)
{
    850e:	b085      	sub	sp, #20
    8510:	4604      	mov	r4, r0
    8512:	9303      	str	r3, [sp, #12]

	// Combo Item Position within the guide
	var_uint_t comboItem = pos + 1;
    8514:	1c53      	adds	r3, r2, #1
    8516:	f8ad 3000 	strh.w	r3, [sp]

	// Process opposing event for previous item in sequence (if necessary)
	if ( record->prevPos != pos )
    851a:	8903      	ldrh	r3, [r0, #8]
    851c:	4293      	cmp	r3, r2
	const ResultMacro *macro = &ResultMacroList[ resultElem->index ];
    851e:	eb06 0887 	add.w	r8, r6, r7, lsl #2
	ResultMacroRecord *record = &resultElem->record;
    8522:	f100 0906 	add.w	r9, r0, #6
	if ( record->prevPos != pos )
    8526:	d012      	beq.n	854e <Result_evalResultMacro+0x4e>
	{
		// Previous comboItem position
		var_uint_t oComboItem = record->prevPos + 1;
    8528:	1c59      	adds	r1, r3, #1

		// TODO (HaaTa) Calculate opposing state and stateType
		ResultMacroRecord oRecord = {
    852a:	f8ad 3006 	strh.w	r3, [sp, #6]
    852e:	2303      	movs	r3, #3
    8530:	f88d 3008 	strb.w	r3, [sp, #8]
    8534:	7ac3      	ldrb	r3, [r0, #11]
		var_uint_t oComboItem = record->prevPos + 1;
    8536:	f8ad 1002 	strh.w	r1, [sp, #2]
		ResultMacroRecord oRecord = {
    853a:	f8ad 2004 	strh.w	r2, [sp, #4]
    853e:	f88d 3009 	strb.w	r3, [sp, #9]
			record->pos,
			record->prevPos,
			ScheduleType_R,
			record->stateType,
		};
		Result_evalResultMacroCombo( resultElem, macro, &oRecord, &oComboItem );
    8542:	aa01      	add	r2, sp, #4
    8544:	f10d 0302 	add.w	r3, sp, #2
    8548:	4641      	mov	r1, r8
    854a:	f7ff fe85 	bl	8258 <Result_evalResultMacroCombo>
	}

	// Evaluate Combo
	Result_evalResultMacroCombo( resultElem, macro, record, &comboItem );
    854e:	466b      	mov	r3, sp
    8550:	464a      	mov	r2, r9
    8552:	4641      	mov	r1, r8
    8554:	4620      	mov	r0, r4
    8556:	f7ff fe7f 	bl	8258 <Result_evalResultMacroCombo>

	// Move to next item in the sequence
	record->prevPos = record->pos;
    855a:	88e3      	ldrh	r3, [r4, #6]
    855c:	8123      	strh	r3, [r4, #8]
	record->pos = comboItem;

	// If the ResultMacro is finished, remove
	if ( macro->guide[ comboItem ] == 0 )
    855e:	f856 2027 	ldr.w	r2, [r6, r7, lsl #2]
	record->pos = comboItem;
    8562:	f8bd 3000 	ldrh.w	r3, [sp]
    8566:	80e3      	strh	r3, [r4, #6]
	if ( macro->guide[ comboItem ] == 0 )
    8568:	5cd3      	ldrb	r3, [r2, r3]
    856a:	b943      	cbnz	r3, 857e <Result_evalResultMacro+0x7e>
	{
		record->prevPos = 0;
    856c:	8123      	strh	r3, [r4, #8]
		record->pos = 0;
    856e:	80e3      	strh	r3, [r4, #6]
		return ResultMacroEval_Remove;
    8570:	2001      	movs	r0, #1
	}

	// Otherwise leave the macro in the list
	return ResultMacroEval_DoNothing;
}
    8572:	9a03      	ldr	r2, [sp, #12]
    8574:	682b      	ldr	r3, [r5, #0]
    8576:	429a      	cmp	r2, r3
    8578:	d003      	beq.n	8582 <Result_evalResultMacro+0x82>
    857a:	f7fa f8d9 	bl	2730 <__stack_chk_fail>
	return ResultMacroEval_DoNothing;
    857e:	2000      	movs	r0, #0
    8580:	e7f7      	b.n	8572 <Result_evalResultMacro+0x72>
}
    8582:	b005      	add	sp, #20
    8584:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    8588:	1fff89d0 	.word	0x1fff89d0
    858c:	000118c8 	.word	0x000118c8

00008590 <Result_setup>:


void Result_setup()
{
    8590:	b507      	push	{r0, r1, r2, lr}
    8592:	4a0a      	ldr	r2, [pc, #40]	; (85bc <Result_setup+0x2c>)
	// Initialize macroResultMacroPendingList
	macroResultMacroPendingList.size = 0;
    8594:	490a      	ldr	r1, [pc, #40]	; (85c0 <Result_setup+0x30>)
{
    8596:	6813      	ldr	r3, [r2, #0]
    8598:	9301      	str	r3, [sp, #4]
	macroResultMacroPendingList.size = 0;
    859a:	2300      	movs	r3, #0
    859c:	f8a1 3258 	strh.w	r3, [r1, #600]	; 0x258

	// Reset delayed capabilities stack
	macroResultDelayedCapabilities.size = 0;
    85a0:	4908      	ldr	r1, [pc, #32]	; (85c4 <Result_setup+0x34>)
    85a2:	f881 3078 	strb.w	r3, [r1, #120]	; 0x78

	// Capability debug mode
	capDebugMode = 0;
    85a6:	4908      	ldr	r1, [pc, #32]	; (85c8 <Result_setup+0x38>)
    85a8:	700b      	strb	r3, [r1, #0]
}
    85aa:	9901      	ldr	r1, [sp, #4]
    85ac:	6813      	ldr	r3, [r2, #0]
    85ae:	4299      	cmp	r1, r3
    85b0:	d001      	beq.n	85b6 <Result_setup+0x26>
    85b2:	f7fa f8bd 	bl	2730 <__stack_chk_fail>
    85b6:	b003      	add	sp, #12
    85b8:	f85d fb04 	ldr.w	pc, [sp], #4
    85bc:	1fff89d0 	.word	0x1fff89d0
    85c0:	1fffa8a4 	.word	0x1fffa8a4
    85c4:	1fffa824 	.word	0x1fffa824
    85c8:	1fffa8a0 	.word	0x1fffa8a0

000085cc <Result_process_delayed>:

// Process delayed capabilities
// Capabilities that are not called immediately (i.e. ones that are not deemed as thread safe)
// are processed with this function
void Result_process_delayed()
{
    85cc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    85d0:	4d23      	ldr	r5, [pc, #140]	; (8660 <Result_process_delayed+0x94>)
	// Disable periodic interrupts if we have delayed capabilities
	Periodic_disable();

	// Process stack until empty
	// For each empty, make sure interrupts are disabled
	while ( macroResultDelayedCapabilities.size > 0 )
    85d2:	4c24      	ldr	r4, [pc, #144]	; (8664 <Result_process_delayed+0x98>)
{
    85d4:	682b      	ldr	r3, [r5, #0]
    85d6:	9301      	str	r3, [sp, #4]
	Periodic_disable();
    85d8:	f7fa fb44 	bl	2c64 <Periodic_disable>
		// Lookup stack
		volatile ResultCapabilityStackItem *item = &macroResultDelayedCapabilities.stack[macroResultDelayedCapabilities.size - 1];

		// Do lookup on capability function
		void (*capability)(TriggerMacro*, uint8_t, uint8_t, uint8_t*) = \
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ item->capabilityIndex ].func);
    85dc:	4f22      	ldr	r7, [pc, #136]	; (8668 <Result_process_delayed+0x9c>)
    85de:	4626      	mov	r6, r4
	while ( macroResultDelayedCapabilities.size > 0 )
    85e0:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
    85e4:	b92b      	cbnz	r3, 85f2 <Result_process_delayed+0x26>
		// Decrease stack size
		macroResultDelayedCapabilities.size--;
	}

	// Re-enable periodic interrupts
	Periodic_enable();
    85e6:	9a01      	ldr	r2, [sp, #4]
    85e8:	682b      	ldr	r3, [r5, #0]
    85ea:	429a      	cmp	r2, r3
    85ec:	d033      	beq.n	8656 <Result_process_delayed+0x8a>
    85ee:	f7fa f89f 	bl	2730 <__stack_chk_fail>
		volatile ResultCapabilityStackItem *item = &macroResultDelayedCapabilities.stack[macroResultDelayedCapabilities.size - 1];
    85f2:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ item->capabilityIndex ].func);
    85f6:	f04f 0a0c 	mov.w	sl, #12
		volatile ResultCapabilityStackItem *item = &macroResultDelayedCapabilities.stack[macroResultDelayedCapabilities.size - 1];
    85fa:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
			(void(*)(TriggerMacro*, uint8_t, uint8_t, uint8_t*))(CapabilitiesList[ item->capabilityIndex ].func);
    85fe:	fb0a fa08 	mul.w	sl, sl, r8
    8602:	eb04 0b0a 	add.w	fp, r4, sl
    8606:	f89b 3006 	ldrb.w	r3, [fp, #6]
		void (*capability)(TriggerMacro*, uint8_t, uint8_t, uint8_t*) = \
    860a:	f857 9033 	ldr.w	r9, [r7, r3, lsl #3]
		if ( capDebugMode )
    860e:	4b17      	ldr	r3, [pc, #92]	; (866c <Result_process_delayed+0xa0>)
    8610:	781b      	ldrb	r3, [r3, #0]
    8612:	b163      	cbz	r3, 862e <Result_process_delayed+0x62>
			dbug_msg("Un-safe: ");
    8614:	4816      	ldr	r0, [pc, #88]	; (8670 <Result_process_delayed+0xa4>)
    8616:	f006 ffab 	bl	f570 <_print>
			capability( item->trigger, ScheduleType_Debug, TriggerType_Debug, item->args );
    861a:	22ff      	movs	r2, #255	; 0xff
    861c:	f854 000a 	ldr.w	r0, [r4, sl]
    8620:	f8db 3008 	ldr.w	r3, [fp, #8]
    8624:	4611      	mov	r1, r2
    8626:	47c8      	blx	r9
			print( NL );
    8628:	4812      	ldr	r0, [pc, #72]	; (8674 <Result_process_delayed+0xa8>)
    862a:	f006 ffa1 	bl	f570 <_print>
		capability( item->trigger, item->state, item->stateType, item->args );
    862e:	230c      	movs	r3, #12
    8630:	fb03 f308 	mul.w	r3, r3, r8
    8634:	eb06 0c03 	add.w	ip, r6, r3
    8638:	58f0      	ldr	r0, [r6, r3]
    863a:	f89c 1004 	ldrb.w	r1, [ip, #4]
    863e:	f89c 2005 	ldrb.w	r2, [ip, #5]
    8642:	f8dc 3008 	ldr.w	r3, [ip, #8]
    8646:	47c8      	blx	r9
		macroResultDelayedCapabilities.size--;
    8648:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
    864c:	3b01      	subs	r3, #1
    864e:	b2db      	uxtb	r3, r3
    8650:	f886 3078 	strb.w	r3, [r6, #120]	; 0x78
    8654:	e7c4      	b.n	85e0 <Result_process_delayed+0x14>
}
    8656:	b003      	add	sp, #12
    8658:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	Periodic_enable();
    865c:	f7fa baee 	b.w	2c3c <Periodic_enable>
    8660:	1fff89d0 	.word	0x1fff89d0
    8664:	1fffa824 	.word	0x1fffa824
    8668:	00011460 	.word	0x00011460
    866c:	1fffa8a0 	.word	0x1fffa8a0
    8670:	00014611 	.word	0x00014611
    8674:	00015df4 	.word	0x00015df4

00008678 <Result_process>:


void Result_process()
{
    8678:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    867c:	4d16      	ldr	r5, [pc, #88]	; (86d8 <Result_process+0x60>)
	// Tail pointer for macroResultMacroPendingList
	// Macros must be explicitly re-added
	index_uint_t macroResultMacroPendingListTail = 0;

	// Iterate through the pending ResultMacros, processing each of them
	for ( index_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    867e:	4e17      	ldr	r6, [pc, #92]	; (86dc <Result_process+0x64>)
{
    8680:	682b      	ldr	r3, [r5, #0]
    8682:	9301      	str	r3, [sp, #4]
	for ( index_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    8684:	2400      	movs	r4, #0
	index_uint_t macroResultMacroPendingListTail = 0;
    8686:	4627      	mov	r7, r4
	{
		switch ( Result_evalResultMacro( &macroResultMacroPendingList.data[ macro ] ) )
    8688:	f04f 0a0c 	mov.w	sl, #12
	for ( index_uint_t macro = 0; macro < macroResultMacroPendingList.size; macro++ )
    868c:	f8b6 2258 	ldrh.w	r2, [r6, #600]	; 0x258
    8690:	b2a3      	uxth	r3, r4
    8692:	429a      	cmp	r2, r3
    8694:	d807      	bhi.n	86a6 <Result_process+0x2e>
		}
	}

	// Update the macroResultMacroPendingListSize with the tail pointer
	macroResultMacroPendingList.size = macroResultMacroPendingListTail;
}
    8696:	9a01      	ldr	r2, [sp, #4]
    8698:	682b      	ldr	r3, [r5, #0]
	macroResultMacroPendingList.size = macroResultMacroPendingListTail;
    869a:	f8a6 7258 	strh.w	r7, [r6, #600]	; 0x258
}
    869e:	429a      	cmp	r2, r3
    86a0:	d017      	beq.n	86d2 <Result_process+0x5a>
    86a2:	f7fa f845 	bl	2730 <__stack_chk_fail>
		switch ( Result_evalResultMacro( &macroResultMacroPendingList.data[ macro ] ) )
    86a6:	fa1f f884 	uxth.w	r8, r4
    86aa:	fb0a 6808 	mla	r8, sl, r8, r6
    86ae:	4640      	mov	r0, r8
    86b0:	f7ff ff26 	bl	8500 <Result_evalResultMacro>
    86b4:	2801      	cmp	r0, #1
    86b6:	d00a      	beq.n	86ce <Result_process+0x56>
			memcpy( &macroResultMacroPendingList.data[ macroResultMacroPendingListTail++ ],
    86b8:	fb0a 6007 	mla	r0, sl, r7, r6
    86bc:	220c      	movs	r2, #12
    86be:	4641      	mov	r1, r8
    86c0:	f107 0901 	add.w	r9, r7, #1
    86c4:	f7fa f858 	bl	2778 <memcpy>
    86c8:	fa1f f989 	uxth.w	r9, r9
    86cc:	464f      	mov	r7, r9
    86ce:	3401      	adds	r4, #1
    86d0:	e7dc      	b.n	868c <Result_process+0x14>
}
    86d2:	b002      	add	sp, #8
    86d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    86d8:	1fff89d0 	.word	0x1fff89d0
    86dc:	1fffa8a4 	.word	0x1fffa8a4

000086e0 <Trigger_showTriggerMacroVote>:

// -- Debug --

// Show TriggerMacroVote
void Trigger_showTriggerMacroVote( TriggerMacroVote vote, uint8_t long_trigger_macro )
{
    86e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    86e2:	4c1f      	ldr	r4, [pc, #124]	; (8760 <Trigger_showTriggerMacroVote+0x80>)
    86e4:	6823      	ldr	r3, [r4, #0]
    86e6:	9301      	str	r3, [sp, #4]
    86e8:	4605      	mov	r5, r0
	const char *result = "";

	// Long Macro
	if ( long_trigger_macro )
    86ea:	b1b1      	cbz	r1, 871a <Trigger_showTriggerMacroVote+0x3a>
	{
		print("l");
    86ec:	481d      	ldr	r0, [pc, #116]	; (8764 <Trigger_showTriggerMacroVote+0x84>)
	}
	// Short Macro
	else
	{
		print("s");
    86ee:	f006 ff3f 	bl	f570 <_print>
	}

	// Static voting
	switch ( vote )
    86f2:	2d08      	cmp	r5, #8
    86f4:	d02d      	beq.n	8752 <Trigger_showTriggerMacroVote+0x72>
    86f6:	d812      	bhi.n	871e <Trigger_showTriggerMacroVote+0x3e>
    86f8:	b34d      	cbz	r5, 874e <Trigger_showTriggerMacroVote+0x6e>
	case TriggerMacroVote_PassRelease:
		result = "V:PR";
		break;

	default:
		print("V:");
    86fa:	481b      	ldr	r0, [pc, #108]	; (8768 <Trigger_showTriggerMacroVote+0x88>)
    86fc:	f006 ff38 	bl	f570 <_print>
		if ( vote & TriggerMacroVote_Fail )
    8700:	07eb      	lsls	r3, r5, #31
    8702:	d502      	bpl.n	870a <Trigger_showTriggerMacroVote+0x2a>
		{
			print("F");
    8704:	4819      	ldr	r0, [pc, #100]	; (876c <Trigger_showTriggerMacroVote+0x8c>)
    8706:	f006 ff33 	bl	f570 <_print>
		}
		if ( vote & TriggerMacroVote_DoNothingRelease )
    870a:	0768      	lsls	r0, r5, #29
		{
			print("NR");
    870c:	9a01      	ldr	r2, [sp, #4]
    870e:	6823      	ldr	r3, [r4, #0]
		if ( vote & TriggerMacroVote_DoNothingRelease )
    8710:	d517      	bpl.n	8742 <Trigger_showTriggerMacroVote+0x62>
			print("NR");
    8712:	429a      	cmp	r2, r3
    8714:	d00f      	beq.n	8736 <Trigger_showTriggerMacroVote+0x56>
		}
		return;
	}

	print( result );
}
    8716:	f7fa f80b 	bl	2730 <__stack_chk_fail>
		print("s");
    871a:	4815      	ldr	r0, [pc, #84]	; (8770 <Trigger_showTriggerMacroVote+0x90>)
    871c:	e7e7      	b.n	86ee <Trigger_showTriggerMacroVote+0xe>
	switch ( vote )
    871e:	2d10      	cmp	r5, #16
    8720:	d003      	beq.n	872a <Trigger_showTriggerMacroVote+0x4a>
    8722:	2d18      	cmp	r5, #24
    8724:	d1e9      	bne.n	86fa <Trigger_showTriggerMacroVote+0x1a>
		result = "V:PR";
    8726:	4813      	ldr	r0, [pc, #76]	; (8774 <Trigger_showTriggerMacroVote+0x94>)
		break;
    8728:	e000      	b.n	872c <Trigger_showTriggerMacroVote+0x4c>
		result = "V:R";
    872a:	4813      	ldr	r0, [pc, #76]	; (8778 <Trigger_showTriggerMacroVote+0x98>)
	print( result );
    872c:	9a01      	ldr	r2, [sp, #4]
    872e:	6823      	ldr	r3, [r4, #0]
    8730:	429a      	cmp	r2, r3
    8732:	d001      	beq.n	8738 <Trigger_showTriggerMacroVote+0x58>
    8734:	e7ef      	b.n	8716 <Trigger_showTriggerMacroVote+0x36>
			print("NR");
    8736:	4811      	ldr	r0, [pc, #68]	; (877c <Trigger_showTriggerMacroVote+0x9c>)
}
    8738:	b003      	add	sp, #12
    873a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	print( result );
    873e:	f006 bf17 	b.w	f570 <_print>
		else if ( vote & TriggerMacroVote_DoNothing )
    8742:	07a9      	lsls	r1, r5, #30
    8744:	d507      	bpl.n	8756 <Trigger_showTriggerMacroVote+0x76>
			print("N");
    8746:	429a      	cmp	r2, r3
    8748:	d1e5      	bne.n	8716 <Trigger_showTriggerMacroVote+0x36>
    874a:	480d      	ldr	r0, [pc, #52]	; (8780 <Trigger_showTriggerMacroVote+0xa0>)
    874c:	e7f4      	b.n	8738 <Trigger_showTriggerMacroVote+0x58>
		result = "V:I";
    874e:	480d      	ldr	r0, [pc, #52]	; (8784 <Trigger_showTriggerMacroVote+0xa4>)
    8750:	e7ec      	b.n	872c <Trigger_showTriggerMacroVote+0x4c>
		result = "V:P";
    8752:	480d      	ldr	r0, [pc, #52]	; (8788 <Trigger_showTriggerMacroVote+0xa8>)
    8754:	e7ea      	b.n	872c <Trigger_showTriggerMacroVote+0x4c>
}
    8756:	429a      	cmp	r2, r3
    8758:	d1dd      	bne.n	8716 <Trigger_showTriggerMacroVote+0x36>
    875a:	b003      	add	sp, #12
    875c:	bd30      	pop	{r4, r5, pc}
    875e:	bf00      	nop
    8760:	1fff89d0 	.word	0x1fff89d0
    8764:	00011309 	.word	0x00011309
    8768:	0001477f 	.word	0x0001477f
    876c:	00014782 	.word	0x00014782
    8770:	00015fd4 	.word	0x00015fd4
    8774:	0001477a 	.word	0x0001477a
    8778:	00014772 	.word	0x00014772
    877c:	00014784 	.word	0x00014784
    8780:	00014787 	.word	0x00014787
    8784:	0001476e 	.word	0x0001476e
    8788:	00014776 	.word	0x00014776

0000878c <Trigger_isLongResultMacro>:

// -- General --

// Determine if long ResultMacro (more than 1 seqence element)
uint8_t Trigger_isLongResultMacro( const ResultMacro *macro )
{
    878c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    878e:	4a0e      	ldr	r2, [pc, #56]	; (87c8 <Trigger_isLongResultMacro+0x3c>)
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	var_uint_t position = 1;
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    8790:	6804      	ldr	r4, [r0, #0]
{
    8792:	6813      	ldr	r3, [r2, #0]
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    8794:	7826      	ldrb	r6, [r4, #0]
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    8796:	4f0d      	ldr	r7, [pc, #52]	; (87cc <Trigger_isLongResultMacro+0x40>)
{
    8798:	9301      	str	r3, [sp, #4]
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    879a:	2100      	movs	r1, #0
	var_uint_t position = 1;
    879c:	2301      	movs	r3, #1
	for ( var_uint_t result = 0; result < macro->guide[0]; result++ )
    879e:	b28d      	uxth	r5, r1
    87a0:	42ae      	cmp	r6, r5
    87a2:	5ce0      	ldrb	r0, [r4, r3]
    87a4:	d805      	bhi.n	87b2 <Trigger_isLongResultMacro+0x26>
	return macro->guide[ position ];
}
    87a6:	9901      	ldr	r1, [sp, #4]
    87a8:	6813      	ldr	r3, [r2, #0]
    87aa:	4299      	cmp	r1, r3
    87ac:	d009      	beq.n	87c2 <Trigger_isLongResultMacro+0x36>
    87ae:	f7f9 ffbf 	bl	2730 <__stack_chk_fail>
		position += ResultGuideSize( (ResultGuide*)&macro->guide[ position ] );
    87b2:	eb07 00c0 	add.w	r0, r7, r0, lsl #3
    87b6:	3101      	adds	r1, #1
    87b8:	7900      	ldrb	r0, [r0, #4]
    87ba:	3001      	adds	r0, #1
    87bc:	4403      	add	r3, r0
    87be:	b29b      	uxth	r3, r3
    87c0:	e7ed      	b.n	879e <Trigger_isLongResultMacro+0x12>
}
    87c2:	b003      	add	sp, #12
    87c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    87c6:	bf00      	nop
    87c8:	1fff89d0 	.word	0x1fff89d0
    87cc:	00011460 	.word	0x00011460

000087d0 <Trigger_isLongTriggerMacro>:


// Determine if long TriggerMacro (more than 1 sequence element)
uint8_t Trigger_isLongTriggerMacro( const TriggerMacro *macro )
{
    87d0:	b507      	push	{r0, r1, r2, lr}
    87d2:	4a09      	ldr	r2, [pc, #36]	; (87f8 <Trigger_isLongTriggerMacro+0x28>)
	// Check the second sequence combo length
	// If non-zero return non-zero (long sequence)
	// 0 otherwise (short sequence)
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    87d4:	6801      	ldr	r1, [r0, #0]
{
    87d6:	6813      	ldr	r3, [r2, #0]
    87d8:	9301      	str	r3, [sp, #4]
	return macro->guide[ macro->guide[0] * TriggerGuideSize + 1 ];
    87da:	780b      	ldrb	r3, [r1, #0]
    87dc:	2003      	movs	r0, #3
    87de:	fb00 1303 	mla	r3, r0, r3, r1
}
    87e2:	9901      	ldr	r1, [sp, #4]
    87e4:	7858      	ldrb	r0, [r3, #1]
    87e6:	6813      	ldr	r3, [r2, #0]
    87e8:	4299      	cmp	r1, r3
    87ea:	d001      	beq.n	87f0 <Trigger_isLongTriggerMacro+0x20>
    87ec:	f7f9 ffa0 	bl	2730 <__stack_chk_fail>
    87f0:	b003      	add	sp, #12
    87f2:	f85d fb04 	ldr.w	pc, [sp], #4
    87f6:	bf00      	nop
    87f8:	1fff89d0 	.word	0x1fff89d0

000087fc <Trigger_evalShortTriggerMacroVote_PHRO>:


// Handle short trigger PHRO/AODO state transitions
TriggerMacroVote Trigger_evalShortTriggerMacroVote_PHRO( ScheduleState state )
{
    87fc:	b507      	push	{r0, r1, r2, lr}
    87fe:	f000 000f 	and.w	r0, r0, #15
    8802:	4b0a      	ldr	r3, [pc, #40]	; (882c <Trigger_evalShortTriggerMacroVote_PHRO+0x30>)
    8804:	3801      	subs	r0, #1
    8806:	b2c0      	uxtb	r0, r0
    8808:	681a      	ldr	r2, [r3, #0]
    880a:	9201      	str	r2, [sp, #4]
    880c:	2802      	cmp	r0, #2
    880e:	bf9c      	itt	ls
    8810:	4a07      	ldrls	r2, [pc, #28]	; (8830 <Trigger_evalShortTriggerMacroVote_PHRO+0x34>)
    8812:	5c10      	ldrbls	r0, [r2, r0]

	// Invalid state, fail
	default:
		return TriggerMacroVote_Fail;
	}
}
    8814:	9a01      	ldr	r2, [sp, #4]
    8816:	681b      	ldr	r3, [r3, #0]
{
    8818:	bf88      	it	hi
    881a:	2001      	movhi	r0, #1
}
    881c:	429a      	cmp	r2, r3
    881e:	d001      	beq.n	8824 <Trigger_evalShortTriggerMacroVote_PHRO+0x28>
    8820:	f7f9 ff86 	bl	2730 <__stack_chk_fail>
    8824:	b003      	add	sp, #12
    8826:	f85d fb04 	ldr.w	pc, [sp], #4
    882a:	bf00      	nop
    882c:	1fff89d0 	.word	0x1fff89d0
    8830:	0001462e 	.word	0x0001462e

00008834 <Trigger_evalShortTriggerMacroVote_DRO>:


// Handle short trigger DRO state transitions
TriggerMacroVote Trigger_evalShortTriggerMacroVote_DRO( ScheduleState state )
{
    8834:	b507      	push	{r0, r1, r2, lr}
    8836:	4b08      	ldr	r3, [pc, #32]	; (8858 <Trigger_evalShortTriggerMacroVote_DRO+0x24>)
    8838:	681a      	ldr	r2, [r3, #0]
    883a:	9201      	str	r2, [sp, #4]
	switch ( state )
    883c:	3806      	subs	r0, #6

	// Invalid state, fail
	default:
		return TriggerMacroVote_Fail;
	}
}
    883e:	9a01      	ldr	r2, [sp, #4]
    8840:	681b      	ldr	r3, [r3, #0]
		return TriggerMacroVote_Pass;
    8842:	2801      	cmp	r0, #1
}
    8844:	bf8c      	ite	hi
    8846:	2001      	movhi	r0, #1
    8848:	2008      	movls	r0, #8
    884a:	429a      	cmp	r2, r3
    884c:	d001      	beq.n	8852 <Trigger_evalShortTriggerMacroVote_DRO+0x1e>
    884e:	f7f9 ff6f 	bl	2730 <__stack_chk_fail>
    8852:	b003      	add	sp, #12
    8854:	f85d fb04 	ldr.w	pc, [sp], #4
    8858:	1fff89d0 	.word	0x1fff89d0

0000885c <Trigger_evalShortTriggerMacroVote>:


// Votes on the given key vs. guide, short macros
TriggerMacroVote Trigger_evalShortTriggerMacroVote( TriggerEvent *event, TriggerGuide *guide, TriggerMacroVote *cur_vote )
{
    885c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    8860:	460d      	mov	r5, r1
    8862:	4e38      	ldr	r6, [pc, #224]	; (8944 <Trigger_evalShortTriggerMacroVote+0xe8>)
	// Lookup full index
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    8864:	7889      	ldrb	r1, [r1, #2]
{
    8866:	6833      	ldr	r3, [r6, #0]
    8868:	9301      	str	r3, [sp, #4]
    886a:	4604      	mov	r4, r0
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    886c:	7828      	ldrb	r0, [r5, #0]
{
    886e:	4690      	mov	r8, r2
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    8870:	f7fd ff3a 	bl	66e8 <KLL_TriggerIndex_loopkup>
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    8874:	78a1      	ldrb	r1, [r4, #2]
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    8876:	4681      	mov	r9, r0
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    8878:	7820      	ldrb	r0, [r4, #0]
    887a:	f7fd ff35 	bl	66e8 <KLL_TriggerIndex_loopkup>

	// Return value
	TriggerMacroVote vote = TriggerMacroVote_Invalid;

	// Depending on key type
	switch ( guide->type )
    887e:	782b      	ldrb	r3, [r5, #0]
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    8880:	4607      	mov	r7, r0
	switch ( guide->type )
    8882:	2b15      	cmp	r3, #21
    8884:	d857      	bhi.n	8936 <Trigger_evalShortTriggerMacroVote+0xda>
    8886:	e8df f003 	tbb	[pc, r3]
    888a:	0b0b      	.short	0x0b0b
    888c:	390b0b0b 	.word	0x390b0b0b
    8890:	0b393939 	.word	0x0b393939
    8894:	3e0b0b0b 	.word	0x3e0b0b0b
    8898:	0b3e3e3e 	.word	0x0b3e3e3e
    889c:	4a0b0b0b 	.word	0x4a0b0b0b
	case TriggerType_Inactive1:
	case TriggerType_Active1:
		// For short TriggerMacros completely ignore incorrect keys
		// Only monitor 0x70 bits if set in the guide, otherwise ensure they are 0x00
		// Used for Layer state information
		if (
    88a0:	4581      	cmp	r9, r0
    88a2:	d129      	bne.n	88f8 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide_index == event_index &&
    88a4:	7822      	ldrb	r2, [r4, #0]
    88a6:	429a      	cmp	r2, r3
    88a8:	d126      	bne.n	88f8 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide->type == event->type &&
			(
				(guide->state & 0x70) == (event->state & 0x70) ||
    88aa:	786b      	ldrb	r3, [r5, #1]
    88ac:	7860      	ldrb	r0, [r4, #1]
    88ae:	ea83 0200 	eor.w	r2, r3, r0
			guide->type == event->type &&
    88b2:	f012 0f70 	tst.w	r2, #112	; 0x70
    88b6:	d002      	beq.n	88be <Trigger_evalShortTriggerMacroVote+0x62>
				(guide->state & 0x70) == (event->state & 0x70) ||
    88b8:	f013 0f70 	tst.w	r3, #112	; 0x70
    88bc:	d11c      	bne.n	88f8 <Trigger_evalShortTriggerMacroVote+0x9c>
				(guide->state & 0x70) == 0x00
			)
		)
		{
			// If this trigger is generic, we can just vote based on the incoming state
			if ( guide->state & ScheduleType_Gen )
    88be:	061b      	lsls	r3, r3, #24
    88c0:	d517      	bpl.n	88f2 <Trigger_evalShortTriggerMacroVote+0x96>
			{
				vote = Trigger_evalShortTriggerMacroVote_PHRO( event->state );
    88c2:	f7ff ff9b 	bl	87fc <Trigger_evalShortTriggerMacroVote_PHRO>
		erro_print("Invalid State Type. This is a bug.");
		break;
	}

	// If this is a combo macro, make a preference for TriggerMacroVote_Pass instead of TriggerMacroVote_PassRelease
	if ( *cur_vote != TriggerMacroVote_Invalid && event_index == guide_index )
    88c6:	f898 3000 	ldrb.w	r3, [r8]
    88ca:	b163      	cbz	r3, 88e6 <Trigger_evalShortTriggerMacroVote+0x8a>
    88cc:	45b9      	cmp	r9, r7
    88ce:	d10a      	bne.n	88e6 <Trigger_evalShortTriggerMacroVote+0x8a>
	{
		// Make sure the votes are different and one of them are Pass
		if ( *cur_vote != vote
    88d0:	4283      	cmp	r3, r0
    88d2:	d008      	beq.n	88e6 <Trigger_evalShortTriggerMacroVote+0x8a>
			&& ( *cur_vote == TriggerMacroVote_Pass || vote == TriggerMacroVote_Pass )
    88d4:	2b08      	cmp	r3, #8
    88d6:	d030      	beq.n	893a <Trigger_evalShortTriggerMacroVote+0xde>
    88d8:	2808      	cmp	r0, #8
    88da:	d104      	bne.n	88e6 <Trigger_evalShortTriggerMacroVote+0x8a>
			&& ( *cur_vote == TriggerMacroVote_PassRelease || vote == TriggerMacroVote_PassRelease )
    88dc:	2b18      	cmp	r3, #24
		)
		{
			*cur_vote = TriggerMacroVote_Pass;
    88de:	bf04      	itt	eq
    88e0:	2008      	moveq	r0, #8
    88e2:	f888 0000 	strbeq.w	r0, [r8]
			vote = TriggerMacroVote_Pass;
		}
	}

	return vote;
}
    88e6:	9a01      	ldr	r2, [sp, #4]
    88e8:	6833      	ldr	r3, [r6, #0]
    88ea:	429a      	cmp	r2, r3
    88ec:	d027      	beq.n	893e <Trigger_evalShortTriggerMacroVote+0xe2>
    88ee:	f7f9 ff1f 	bl	2730 <__stack_chk_fail>
			erro_print("State Scheduling not implemented yet...");
    88f2:	4815      	ldr	r0, [pc, #84]	; (8948 <Trigger_evalShortTriggerMacroVote+0xec>)
    88f4:	f006 fe3c 	bl	f570 <_print>
		vote = TriggerMacroVote_DoNothing;
    88f8:	2002      	movs	r0, #2
    88fa:	e7e4      	b.n	88c6 <Trigger_evalShortTriggerMacroVote+0x6a>
		erro_print("Analog State Type - Not implemented...");
    88fc:	4813      	ldr	r0, [pc, #76]	; (894c <Trigger_evalShortTriggerMacroVote+0xf0>)
		erro_print("Invalid State Type. This is a bug.");
    88fe:	f006 fe37 	bl	f570 <_print>
	TriggerMacroVote vote = TriggerMacroVote_Invalid;
    8902:	2000      	movs	r0, #0
		break;
    8904:	e7df      	b.n	88c6 <Trigger_evalShortTriggerMacroVote+0x6a>
		if (
    8906:	4581      	cmp	r9, r0
    8908:	d1f6      	bne.n	88f8 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide_index == event_index &&
    890a:	7822      	ldrb	r2, [r4, #0]
    890c:	429a      	cmp	r2, r3
    890e:	d1f3      	bne.n	88f8 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide->state == event->state
    8910:	786b      	ldrb	r3, [r5, #1]
			guide->type == event->type &&
    8912:	7860      	ldrb	r0, [r4, #1]
    8914:	4298      	cmp	r0, r3
    8916:	d1ef      	bne.n	88f8 <Trigger_evalShortTriggerMacroVote+0x9c>
			vote = Trigger_evalShortTriggerMacroVote_DRO( event->state );
    8918:	f7ff ff8c 	bl	8834 <Trigger_evalShortTriggerMacroVote_DRO>
			break;
    891c:	e7d3      	b.n	88c6 <Trigger_evalShortTriggerMacroVote+0x6a>
		if (
    891e:	4581      	cmp	r9, r0
    8920:	d1ea      	bne.n	88f8 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide_index == event_index &&
    8922:	7823      	ldrb	r3, [r4, #0]
    8924:	2b15      	cmp	r3, #21
    8926:	d1e7      	bne.n	88f8 <Trigger_evalShortTriggerMacroVote+0x9c>
			guide->type == event->type &&
    8928:	7868      	ldrb	r0, [r5, #1]
    892a:	7863      	ldrb	r3, [r4, #1]
			vote = Trigger_evalShortTriggerMacroVote_PHRO( ScheduleType_P );
    892c:	4298      	cmp	r0, r3
    892e:	bf14      	ite	ne
    8930:	2002      	movne	r0, #2
    8932:	2008      	moveq	r0, #8
    8934:	e7c7      	b.n	88c6 <Trigger_evalShortTriggerMacroVote+0x6a>
		erro_print("Invalid State Type. This is a bug.");
    8936:	4806      	ldr	r0, [pc, #24]	; (8950 <Trigger_evalShortTriggerMacroVote+0xf4>)
    8938:	e7e1      	b.n	88fe <Trigger_evalShortTriggerMacroVote+0xa2>
			&& ( *cur_vote == TriggerMacroVote_PassRelease || vote == TriggerMacroVote_PassRelease )
    893a:	2818      	cmp	r0, #24
    893c:	e7cf      	b.n	88de <Trigger_evalShortTriggerMacroVote+0x82>
}
    893e:	b003      	add	sp, #12
    8940:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    8944:	1fff89d0 	.word	0x1fff89d0
    8948:	0001467f 	.word	0x0001467f
    894c:	000146be 	.word	0x000146be
    8950:	000146fc 	.word	0x000146fc

00008954 <Trigger_evalLongTriggerMacroVote>:


// Votes on the given key vs. guide, long macros
// A long macro is defined as a guide with more than 1 combo
TriggerMacroVote Trigger_evalLongTriggerMacroVote( TriggerEvent *event, TriggerGuide *guide, TriggerMacroVote *cur_vote )
{
    8954:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8956:	460d      	mov	r5, r1
    8958:	4e2e      	ldr	r6, [pc, #184]	; (8a14 <Trigger_evalLongTriggerMacroVote+0xc0>)
	// Lookup full index
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    895a:	7889      	ldrb	r1, [r1, #2]
{
    895c:	6833      	ldr	r3, [r6, #0]
    895e:	9301      	str	r3, [sp, #4]
    8960:	4604      	mov	r4, r0
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    8962:	7828      	ldrb	r0, [r5, #0]
    8964:	f7fd fec0 	bl	66e8 <KLL_TriggerIndex_loopkup>
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    8968:	78a1      	ldrb	r1, [r4, #2]
	var_uint_t guide_index = KLL_TriggerIndex_loopkup( guide->type, guide->scanCode );
    896a:	4607      	mov	r7, r0
	var_uint_t event_index = KLL_TriggerIndex_loopkup( event->type, event->index );
    896c:	7820      	ldrb	r0, [r4, #0]
    896e:	f7fd febb 	bl	66e8 <KLL_TriggerIndex_loopkup>

	// Depending on key type
	switch ( guide->type )
    8972:	782a      	ldrb	r2, [r5, #0]
    8974:	2a15      	cmp	r2, #21
    8976:	d844      	bhi.n	8a02 <Trigger_evalLongTriggerMacroVote+0xae>
    8978:	e8df f002 	tbb	[pc, r2]
    897c:	0b0b0b0b 	.word	0x0b0b0b0b
    8980:	2d2d2d0b 	.word	0x2d2d2d0b
    8984:	0b0b0b2d 	.word	0x0b0b0b2d
    8988:	3232320b 	.word	0x3232320b
    898c:	0b0b0b32 	.word	0x0b0b0b32
    8990:	410b      	.short	0x410b
	case TriggerType_Active1:
		// Depending on the state of the buffered key, make voting decision
		// Only monitor 0x70 bits if set in the guide, otherwise ensure they are 0x00
		// Used for Layer state information
		// Correct key
		if (
    8992:	4287      	cmp	r7, r0
    8994:	7863      	ldrb	r3, [r4, #1]
    8996:	d117      	bne.n	89c8 <Trigger_evalLongTriggerMacroVote+0x74>
			guide_index == event_index &&
    8998:	7821      	ldrb	r1, [r4, #0]
    899a:	4291      	cmp	r1, r2
    899c:	d114      	bne.n	89c8 <Trigger_evalLongTriggerMacroVote+0x74>
			guide->type == event->type &&
			(
				(guide->state & 0x70) == (event->state & 0x70) ||
    899e:	786a      	ldrb	r2, [r5, #1]
    89a0:	ea82 0103 	eor.w	r1, r2, r3
			guide->type == event->type &&
    89a4:	f011 0f70 	tst.w	r1, #112	; 0x70
    89a8:	d002      	beq.n	89b0 <Trigger_evalLongTriggerMacroVote+0x5c>
				(guide->state & 0x70) == (event->state & 0x70) ||
    89aa:	f012 0f70 	tst.w	r2, #112	; 0x70
    89ae:	d10b      	bne.n	89c8 <Trigger_evalLongTriggerMacroVote+0x74>
    89b0:	1e58      	subs	r0, r3, #1
    89b2:	b2c0      	uxtb	r0, r0
    89b4:	2802      	cmp	r0, #2
    89b6:	d828      	bhi.n	8a0a <Trigger_evalLongTriggerMacroVote+0xb6>
    89b8:	4b17      	ldr	r3, [pc, #92]	; (8a18 <Trigger_evalLongTriggerMacroVote+0xc4>)
    89ba:	5c18      	ldrb	r0, [r3, r0]
		break;
	}

	// XXX Shouldn't reach here
	return TriggerMacroVote_Invalid;
}
    89bc:	9a01      	ldr	r2, [sp, #4]
    89be:	6833      	ldr	r3, [r6, #0]
    89c0:	429a      	cmp	r2, r3
    89c2:	d024      	beq.n	8a0e <Trigger_evalLongTriggerMacroVote+0xba>
    89c4:	f7f9 feb4 	bl	2730 <__stack_chk_fail>
		switch ( state )
    89c8:	2b02      	cmp	r3, #2
    89ca:	d01c      	beq.n	8a06 <Trigger_evalLongTriggerMacroVote+0xb2>
			return TriggerMacroVote_Fail;
    89cc:	2b03      	cmp	r3, #3
    89ce:	bf0c      	ite	eq
    89d0:	2006      	moveq	r0, #6
    89d2:	2001      	movne	r0, #1
    89d4:	e7f2      	b.n	89bc <Trigger_evalLongTriggerMacroVote+0x68>
		erro_print("Analog State Type - Not implemented...");
    89d6:	4811      	ldr	r0, [pc, #68]	; (8a1c <Trigger_evalLongTriggerMacroVote+0xc8>)
		erro_print("Invalid State Type. This is a bug.");
    89d8:	f006 fdca 	bl	f570 <_print>
	return TriggerMacroVote_Invalid;
    89dc:	2000      	movs	r0, #0
		break;
    89de:	e7ed      	b.n	89bc <Trigger_evalLongTriggerMacroVote+0x68>
		if (
    89e0:	4287      	cmp	r7, r0
    89e2:	d112      	bne.n	8a0a <Trigger_evalLongTriggerMacroVote+0xb6>
			guide_index == event_index &&
    89e4:	7823      	ldrb	r3, [r4, #0]
    89e6:	4293      	cmp	r3, r2
    89e8:	d10f      	bne.n	8a0a <Trigger_evalLongTriggerMacroVote+0xb6>
			guide->state == event->state
    89ea:	786a      	ldrb	r2, [r5, #1]
			guide->type == event->type &&
    89ec:	7863      	ldrb	r3, [r4, #1]
    89ee:	4293      	cmp	r3, r2
    89f0:	d10b      	bne.n	8a0a <Trigger_evalLongTriggerMacroVote+0xb6>
		switch ( state )
    89f2:	3b06      	subs	r3, #6
			return TriggerMacroVote_Pass;
    89f4:	2b01      	cmp	r3, #1
    89f6:	bf8c      	ite	hi
    89f8:	2001      	movhi	r0, #1
    89fa:	2008      	movls	r0, #8
    89fc:	e7de      	b.n	89bc <Trigger_evalLongTriggerMacroVote+0x68>
		erro_print("Rotation State Type (Long Macros) - Not implemented...");
    89fe:	4808      	ldr	r0, [pc, #32]	; (8a20 <Trigger_evalLongTriggerMacroVote+0xcc>)
    8a00:	e7ea      	b.n	89d8 <Trigger_evalLongTriggerMacroVote+0x84>
		erro_print("Invalid State Type. This is a bug.");
    8a02:	4808      	ldr	r0, [pc, #32]	; (8a24 <Trigger_evalLongTriggerMacroVote+0xd0>)
    8a04:	e7e8      	b.n	89d8 <Trigger_evalLongTriggerMacroVote+0x84>
			return TriggerMacroVote_DoNothing;
    8a06:	4618      	mov	r0, r3
    8a08:	e7d8      	b.n	89bc <Trigger_evalLongTriggerMacroVote+0x68>
    8a0a:	2001      	movs	r0, #1
    8a0c:	e7d6      	b.n	89bc <Trigger_evalLongTriggerMacroVote+0x68>
}
    8a0e:	b003      	add	sp, #12
    8a10:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8a12:	bf00      	nop
    8a14:	1fff89d0 	.word	0x1fff89d0
    8a18:	0001462e 	.word	0x0001462e
    8a1c:	000146be 	.word	0x000146be
    8a20:	00014631 	.word	0x00014631
    8a24:	000146fc 	.word	0x000146fc

00008a28 <Trigger_overallVote>:
	const TriggerMacro *macro,
	TriggerMacroRecord *record,
	uint8_t long_trigger_macro,
	var_uint_t pos
)
{
    8a28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8a2c:	492b      	ldr	r1, [pc, #172]	; (8adc <Trigger_overallVote+0xb4>)
    8a2e:	b085      	sub	sp, #20
    8a30:	4690      	mov	r8, r2
    8a32:	680a      	ldr	r2, [r1, #0]
    8a34:	9203      	str	r2, [sp, #12]
	// Length of the combo being processed
	uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    8a36:	6802      	ldr	r2, [r0, #0]
    8a38:	9101      	str	r1, [sp, #4]
    8a3a:	5cd2      	ldrb	r2, [r2, r3]
    8a3c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    8a40:	fa5f fa82 	uxtb.w	sl, r2
	// Once all keys have been pressed/held (only those keys), entered TriggerMacro_Press state (passing)
	// Transition to the next combo (if it exists) when a single key is released (TriggerMacro_Release state)
	// On scan after position increment, change to TriggerMacro_Waiting state
	// TODO Add support for 0x00 Key state (not pressing a key, not all that useful in general)
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    8a44:	1c5d      	adds	r5, r3, #1
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    8a46:	2200      	movs	r2, #0
{
    8a48:	4681      	mov	r9, r0
    8a4a:	469b      	mov	fp, r3
	TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    8a4c:	f88d 200b 	strb.w	r2, [sp, #11]
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    8a50:	b2ed      	uxtb	r5, r5
    8a52:	eb0b 020a 	add.w	r2, fp, sl
    8a56:	42aa      	cmp	r2, r5
    8a58:	da08      	bge.n	8a6c <Trigger_overallVote+0x44>
		// After voting, append to overall vote
		overallVote |= vote;
	}

	return overallVote;
}
    8a5a:	9b01      	ldr	r3, [sp, #4]
    8a5c:	9a03      	ldr	r2, [sp, #12]
    8a5e:	681b      	ldr	r3, [r3, #0]
    8a60:	f89d 000b 	ldrb.w	r0, [sp, #11]
    8a64:	429a      	cmp	r2, r3
    8a66:	d036      	beq.n	8ad6 <Trigger_overallVote+0xae>
    8a68:	f7f9 fe62 	bl	2730 <__stack_chk_fail>
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    8a6c:	f8d9 7000 	ldr.w	r7, [r9]
		for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    8a70:	2600      	movs	r6, #0
		TriggerGuide *guide = (TriggerGuide*)(&macro->guide[ comboItem ]);
    8a72:	442f      	add	r7, r5
		TriggerMacroVote vote = TriggerMacroVote_Invalid;
    8a74:	4634      	mov	r4, r6
		for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    8a76:	4b1a      	ldr	r3, [pc, #104]	; (8ae0 <Trigger_overallVote+0xb8>)
    8a78:	8819      	ldrh	r1, [r3, #0]
    8a7a:	b2b2      	uxth	r2, r6
    8a7c:	4291      	cmp	r1, r2
    8a7e:	d812      	bhi.n	8aa6 <Trigger_overallVote+0x7e>
		if ( vote >= TriggerMacroVote_Pass )
    8a80:	2c07      	cmp	r4, #7
    8a82:	d924      	bls.n	8ace <Trigger_overallVote+0xa6>
			vote &= TriggerMacroVote_Release | TriggerMacroVote_PassRelease | TriggerMacroVote_Pass;
    8a84:	f004 0418 	and.w	r4, r4, #24
		if ( !long_trigger_macro && vote < TriggerMacroVote_Pass )
    8a88:	f1b8 0f00 	cmp.w	r8, #0
    8a8c:	d103      	bne.n	8a96 <Trigger_overallVote+0x6e>
    8a8e:	2c07      	cmp	r4, #7
    8a90:	d801      	bhi.n	8a96 <Trigger_overallVote+0x6e>
			vote |= TriggerMacroVote_Fail;
    8a92:	f044 0401 	orr.w	r4, r4, #1
		overallVote |= vote;
    8a96:	f89d 000b 	ldrb.w	r0, [sp, #11]
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    8a9a:	3503      	adds	r5, #3
		overallVote |= vote;
    8a9c:	4304      	orrs	r4, r0
    8a9e:	f88d 400b 	strb.w	r4, [sp, #11]
	for ( uint8_t comboItem = pos + 1; comboItem < pos + comboLength + 1; comboItem += TriggerGuideSize )
    8aa2:	b2ed      	uxtb	r5, r5
    8aa4:	e7d5      	b.n	8a52 <Trigger_overallVote+0x2a>
			TriggerEvent *triggerInfo = &macroTriggerEventBuffer[ key ];
    8aa6:	b2b0      	uxth	r0, r6
    8aa8:	4b0e      	ldr	r3, [pc, #56]	; (8ae4 <Trigger_overallVote+0xbc>)
    8aaa:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    8aae:	4418      	add	r0, r3
				? Trigger_evalLongTriggerMacroVote( triggerInfo, guide, &overallVote )
    8ab0:	f10d 020b 	add.w	r2, sp, #11
    8ab4:	4639      	mov	r1, r7
				: Trigger_evalShortTriggerMacroVote( triggerInfo, guide, &overallVote );
    8ab6:	f1b8 0f00 	cmp.w	r8, #0
    8aba:	d005      	beq.n	8ac8 <Trigger_overallVote+0xa0>
				? Trigger_evalLongTriggerMacroVote( triggerInfo, guide, &overallVote )
    8abc:	f7ff ff4a 	bl	8954 <Trigger_evalLongTriggerMacroVote>
			vote |= long_trigger_macro
    8ac0:	4304      	orrs	r4, r0
    8ac2:	b2e4      	uxtb	r4, r4
    8ac4:	3601      	adds	r6, #1
    8ac6:	e7d6      	b.n	8a76 <Trigger_overallVote+0x4e>
				: Trigger_evalShortTriggerMacroVote( triggerInfo, guide, &overallVote );
    8ac8:	f7ff fec8 	bl	885c <Trigger_evalShortTriggerMacroVote>
    8acc:	e7f8      	b.n	8ac0 <Trigger_overallVote+0x98>
		if ( !long_trigger_macro && vote < TriggerMacroVote_Pass )
    8ace:	f1b8 0f00 	cmp.w	r8, #0
    8ad2:	d0de      	beq.n	8a92 <Trigger_overallVote+0x6a>
    8ad4:	e7df      	b.n	8a96 <Trigger_overallVote+0x6e>
}
    8ad6:	b005      	add	sp, #20
    8ad8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8adc:	1fff89d0 	.word	0x1fff89d0
    8ae0:	1fffa340 	.word	0x1fffa340
    8ae4:	1fffa346 	.word	0x1fffa346

00008ae8 <Trigger_evalTriggerMacro>:


// Evaluate/Update TriggerMacro
TriggerMacroEval Trigger_evalTriggerMacro( var_uint_t triggerMacroIndex )
{
    8ae8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8aec:	4c75      	ldr	r4, [pc, #468]	; (8cc4 <Trigger_evalTriggerMacro+0x1dc>)
	// Lookup TriggerMacro
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    8aee:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 8cdc <Trigger_evalTriggerMacro+0x1f4>
{
    8af2:	6823      	ldr	r3, [r4, #0]
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    8af4:	4f74      	ldr	r7, [pc, #464]	; (8cc8 <Trigger_evalTriggerMacro+0x1e0>)
{
    8af6:	b085      	sub	sp, #20
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    8af8:	00c6      	lsls	r6, r0, #3
{
    8afa:	9303      	str	r3, [sp, #12]
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    8afc:	2106      	movs	r1, #6
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    8afe:	eb06 0308 	add.w	r3, r6, r8
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    8b02:	fb01 fb00 	mul.w	fp, r1, r0
{
    8b06:	4605      	mov	r5, r0

	// Check if this is a long Trigger Macro
	uint8_t long_trigger_macro = Trigger_isLongTriggerMacro( macro );
    8b08:	4618      	mov	r0, r3
	const TriggerMacro *macro = &TriggerMacroList[ triggerMacroIndex ];
    8b0a:	9300      	str	r3, [sp, #0]
	uint8_t long_trigger_macro = Trigger_isLongTriggerMacro( macro );
    8b0c:	f7ff fe60 	bl	87d0 <Trigger_isLongTriggerMacro>
	TriggerMacroRecord *record = &TriggerMacroRecordList[ triggerMacroIndex ];
    8b10:	eb0b 0a07 	add.w	sl, fp, r7
    8b14:	f83b 3007 	ldrh.w	r3, [fp, r7]
    8b18:	9401      	str	r4, [sp, #4]

	// Long Macro
	if ( long_trigger_macro )
    8b1a:	4681      	mov	r9, r0
    8b1c:	4644      	mov	r4, r8
    8b1e:	2800      	cmp	r0, #0
    8b20:	f000 8089 	beq.w	8c36 <Trigger_evalTriggerMacro+0x14e>
	{
		// Check if macro has finished and should be incremented sequence elements
		if ( record->state != TriggerMacro_Waiting )
    8b24:	f89a 2004 	ldrb.w	r2, [sl, #4]
    8b28:	f858 8035 	ldr.w	r8, [r8, r5, lsl #3]
    8b2c:	b14a      	cbz	r2, 8b42 <Trigger_evalTriggerMacro+0x5a>
		{
			record->prevPos = record->pos;
    8b2e:	f8aa 3002 	strh.w	r3, [sl, #2]
			record->pos = record->pos + macro->guide[ record->pos ] * TriggerGuideSize + 1;
    8b32:	f818 2003 	ldrb.w	r2, [r8, r3]
    8b36:	3301      	adds	r3, #1
    8b38:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    8b3c:	4413      	add	r3, r2
    8b3e:	f82b 3007 	strh.w	r3, [fp, r7]
		}

		// Current Macro position
		var_uint_t pos = record->pos;
    8b42:	2306      	movs	r3, #6
    8b44:	436b      	muls	r3, r5
    8b46:	5afe      	ldrh	r6, [r7, r3]

		// Length of the combo being processed
		uint8_t comboLength = macro->guide[ pos ] * TriggerGuideSize;
    8b48:	f818 0006 	ldrb.w	r0, [r8, r6]
    8b4c:	eb00 0040 	add.w	r0, r0, r0, lsl #1

		TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
		// Iterate through the items in the combo, voting the on the key state
		// If any of the pressed keys do not match, fail the macro
		if ( comboLength != 0 )
    8b50:	f010 0bff 	ands.w	fp, r0, #255	; 0xff
    8b54:	d034      	beq.n	8bc0 <Trigger_evalTriggerMacro+0xd8>
		{
			overallVote |= Trigger_overallVote( macro, record, long_trigger_macro, pos );
    8b56:	4633      	mov	r3, r6
    8b58:	464a      	mov	r2, r9
    8b5a:	4651      	mov	r1, sl
    8b5c:	9800      	ldr	r0, [sp, #0]
    8b5e:	f7ff ff63 	bl	8a28 <Trigger_overallVote>
    8b62:	4604      	mov	r4, r0
		}

		// If this is a sequence, and have processed at least one vote already
		// then we need to keep track of releases
		if ( pos != 0 )
    8b64:	b156      	cbz	r6, 8b7c <Trigger_evalTriggerMacro+0x94>
		{
			overallVote |= Trigger_overallVote( macro, record, long_trigger_macro, record->prevPos );
    8b66:	2306      	movs	r3, #6
    8b68:	fb03 7305 	mla	r3, r3, r5, r7
    8b6c:	464a      	mov	r2, r9
    8b6e:	885b      	ldrh	r3, [r3, #2]
    8b70:	9800      	ldr	r0, [sp, #0]
    8b72:	4651      	mov	r1, sl
    8b74:	f7ff ff58 	bl	8a28 <Trigger_overallVote>
    8b78:	4304      	orrs	r4, r0
    8b7a:	b2e4      	uxtb	r4, r4
		}

		// If no pass vote was found after scanning the entire combo
		// And this is the first position in the combo, just remove it (nothing important happened)
		if ( overallVote & TriggerMacroVote_DoNothingRelease && pos == 0 )
    8b7c:	0762      	lsls	r2, r4, #29
    8b7e:	d503      	bpl.n	8b88 <Trigger_evalTriggerMacro+0xa0>
    8b80:	b916      	cbnz	r6, 8b88 <Trigger_evalTriggerMacro+0xa0>
		{
			overallVote |= TriggerMacroVote_Fail;
    8b82:	f044 0401 	orr.w	r4, r4, #1
    8b86:	b2e4      	uxtb	r4, r4
		}

		// Vote Debug
		switch ( voteDebugMode )
    8b88:	4b50      	ldr	r3, [pc, #320]	; (8ccc <Trigger_evalTriggerMacro+0x1e4>)
    8b8a:	781b      	ldrb	r3, [r3, #0]
    8b8c:	2b01      	cmp	r3, #1
    8b8e:	d10c      	bne.n	8baa <Trigger_evalTriggerMacro+0xc2>
		{
		case 1:
			Trigger_showTriggerMacroVote( overallVote, long_trigger_macro );
    8b90:	4649      	mov	r1, r9
    8b92:	4620      	mov	r0, r4
    8b94:	f7ff fda4 	bl	86e0 <Trigger_showTriggerMacroVote>
			print(" TriggerMacroList[");
    8b98:	484d      	ldr	r0, [pc, #308]	; (8cd0 <Trigger_evalTriggerMacro+0x1e8>)
    8b9a:	f006 fce9 	bl	f570 <_print>
			printInt16( triggerMacroIndex );
    8b9e:	4628      	mov	r0, r5
    8ba0:	f006 fd86 	bl	f6b0 <printInt16>
			print("]");
    8ba4:	484b      	ldr	r0, [pc, #300]	; (8cd4 <Trigger_evalTriggerMacro+0x1ec>)
    8ba6:	f006 fce3 	bl	f570 <_print>
			break;
		}

		// Decide new state of macro after voting
		// Fail macro, remove from pending list
		if ( overallVote & TriggerMacroVote_Fail )
    8baa:	f014 0001 	ands.w	r0, r4, #1
    8bae:	f040 8084 	bne.w	8cba <Trigger_evalTriggerMacro+0x1d2>
		{
			return TriggerMacroEval_Remove;
		}
		// Do nothing, incorrect key is being held or released
		else if ( overallVote & TriggerMacroVote_DoNothing )
    8bb2:	07a3      	lsls	r3, r4, #30
    8bb4:	d506      	bpl.n	8bc4 <Trigger_evalTriggerMacro+0xdc>
		{
			record->state = TriggerMacro_Waiting;
    8bb6:	2306      	movs	r3, #6
    8bb8:	fb03 7505 	mla	r5, r3, r5, r7
		else if ( overallVote & TriggerMacroVote_Release )
		{
			// Long result macro (more than 1 combo) are ignored (only on press)
			if ( !Trigger_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
			{
				record->state = TriggerMacro_Release;
    8bbc:	7128      	strb	r0, [r5, #4]

				return TriggerMacroEval_DoResultAndRemove;
    8bbe:	e01f      	b.n	8c00 <Trigger_evalTriggerMacro+0x118>
		TriggerMacroVote overallVote = TriggerMacroVote_Invalid;
    8bc0:	465c      	mov	r4, fp
    8bc2:	e7cf      	b.n	8b64 <Trigger_evalTriggerMacro+0x7c>
		else if ( ( overallVote & TriggerMacroVote_PassRelease ) == TriggerMacroVote_PassRelease )
    8bc4:	f004 0318 	and.w	r3, r4, #24
    8bc8:	2b18      	cmp	r3, #24
    8bca:	d10a      	bne.n	8be2 <Trigger_evalTriggerMacro+0xfa>
			record->state = TriggerMacro_PressRelease;
    8bcc:	2306      	movs	r3, #6
    8bce:	fb03 7505 	mla	r5, r3, r5, r7
    8bd2:	2303      	movs	r3, #3
			if ( macro->guide[ pos + comboLength + 1 ] == 0 )
    8bd4:	4446      	add	r6, r8
    8bd6:	445e      	add	r6, fp
			record->state = TriggerMacro_Press;
    8bd8:	712b      	strb	r3, [r5, #4]
			if ( macro->guide[ pos + comboLength + 1 ] == 0 )
    8bda:	7870      	ldrb	r0, [r6, #1]
			return TriggerMacroEval_Remove;
    8bdc:	fab0 f080 	clz	r0, r0
    8be0:	e017      	b.n	8c12 <Trigger_evalTriggerMacro+0x12a>
		else if ( overallVote & TriggerMacroVote_Release && record->state & TriggerMacro_Press )
    8be2:	06e1      	lsls	r1, r4, #27
    8be4:	d517      	bpl.n	8c16 <Trigger_evalTriggerMacro+0x12e>
    8be6:	2306      	movs	r3, #6
    8be8:	fb03 7305 	mla	r3, r3, r5, r7
    8bec:	791a      	ldrb	r2, [r3, #4]
    8bee:	07d2      	lsls	r2, r2, #31
    8bf0:	d511      	bpl.n	8c16 <Trigger_evalTriggerMacro+0x12e>
			if ( macro->guide[ pos + comboLength + 1 ] == 0 || comboLength == 0 )
    8bf2:	4446      	add	r6, r8
			record->state = TriggerMacro_Release;
    8bf4:	2202      	movs	r2, #2
			if ( macro->guide[ pos + comboLength + 1 ] == 0 || comboLength == 0 )
    8bf6:	445e      	add	r6, fp
			record->state = TriggerMacro_Release;
    8bf8:	711a      	strb	r2, [r3, #4]
			if ( macro->guide[ pos + comboLength + 1 ] == 0 || comboLength == 0 )
    8bfa:	7873      	ldrb	r3, [r6, #1]
    8bfc:	b93b      	cbnz	r3, 8c0e <Trigger_evalTriggerMacro+0x126>
				return TriggerMacroEval_DoResult;
    8bfe:	2001      	movs	r0, #1
		// The state can be rebuilt on the next iteration
		return TriggerMacroEval_Remove;
	}

	return TriggerMacroEval_DoNothing;
}
    8c00:	9b01      	ldr	r3, [sp, #4]
    8c02:	9a03      	ldr	r2, [sp, #12]
    8c04:	681b      	ldr	r3, [r3, #0]
    8c06:	429a      	cmp	r2, r3
    8c08:	d059      	beq.n	8cbe <Trigger_evalTriggerMacro+0x1d6>
    8c0a:	f7f9 fd91 	bl	2730 <__stack_chk_fail>
			return TriggerMacroEval_Remove;
    8c0e:	fabb f08b 	clz	r0, fp
    8c12:	0940      	lsrs	r0, r0, #5
    8c14:	e7f4      	b.n	8c00 <Trigger_evalTriggerMacro+0x118>
		else if ( overallVote & TriggerMacroVote_Pass
    8c16:	f014 0008 	ands.w	r0, r4, #8
    8c1a:	d0f1      	beq.n	8c00 <Trigger_evalTriggerMacro+0x118>
			&& ( record->state == TriggerMacro_Waiting || record->state & TriggerMacro_Press ) )
    8c1c:	2306      	movs	r3, #6
    8c1e:	fb03 7305 	mla	r3, r3, r5, r7
    8c22:	7918      	ldrb	r0, [r3, #4]
    8c24:	b110      	cbz	r0, 8c2c <Trigger_evalTriggerMacro+0x144>
    8c26:	f010 0001 	ands.w	r0, r0, #1
    8c2a:	d0e9      	beq.n	8c00 <Trigger_evalTriggerMacro+0x118>
			record->state = TriggerMacro_Press;
    8c2c:	2306      	movs	r3, #6
    8c2e:	fb03 7505 	mla	r5, r3, r5, r7
    8c32:	2301      	movs	r3, #1
    8c34:	e7ce      	b.n	8bd4 <Trigger_evalTriggerMacro+0xec>
		TriggerMacroVote overallVote = Trigger_overallVote( macro, record, long_trigger_macro, pos );
    8c36:	4602      	mov	r2, r0
    8c38:	4651      	mov	r1, sl
    8c3a:	9800      	ldr	r0, [sp, #0]
    8c3c:	f7ff fef4 	bl	8a28 <Trigger_overallVote>
		switch ( voteDebugMode )
    8c40:	4b22      	ldr	r3, [pc, #136]	; (8ccc <Trigger_evalTriggerMacro+0x1e4>)
    8c42:	781b      	ldrb	r3, [r3, #0]
    8c44:	2b01      	cmp	r3, #1
		TriggerMacroVote overallVote = Trigger_overallVote( macro, record, long_trigger_macro, pos );
    8c46:	4680      	mov	r8, r0
		switch ( voteDebugMode )
    8c48:	d10b      	bne.n	8c62 <Trigger_evalTriggerMacro+0x17a>
			Trigger_showTriggerMacroVote( overallVote, long_trigger_macro );
    8c4a:	4649      	mov	r1, r9
    8c4c:	f7ff fd48 	bl	86e0 <Trigger_showTriggerMacroVote>
			print(" TriggerMacroList[");
    8c50:	481f      	ldr	r0, [pc, #124]	; (8cd0 <Trigger_evalTriggerMacro+0x1e8>)
    8c52:	f006 fc8d 	bl	f570 <_print>
			printInt16( triggerMacroIndex );
    8c56:	4628      	mov	r0, r5
    8c58:	f006 fd2a 	bl	f6b0 <printInt16>
			print("]");
    8c5c:	481d      	ldr	r0, [pc, #116]	; (8cd4 <Trigger_evalTriggerMacro+0x1ec>)
    8c5e:	f006 fc87 	bl	f570 <_print>
		if ( overallVote & TriggerMacroVote_Fail )
    8c62:	f018 0f01 	tst.w	r8, #1
    8c66:	d128      	bne.n	8cba <Trigger_evalTriggerMacro+0x1d2>
		else if ( overallVote & TriggerMacroVote_Pass
    8c68:	f018 0f08 	tst.w	r8, #8
    8c6c:	d015      	beq.n	8c9a <Trigger_evalTriggerMacro+0x1b2>
			&& ( record->state == TriggerMacro_Waiting || record->state == TriggerMacro_Press )
    8c6e:	2306      	movs	r3, #6
    8c70:	fb03 7305 	mla	r3, r3, r5, r7
    8c74:	791a      	ldrb	r2, [r3, #4]
    8c76:	2a01      	cmp	r2, #1
    8c78:	d80f      	bhi.n	8c9a <Trigger_evalTriggerMacro+0x1b2>
			if ( Trigger_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    8c7a:	4434      	add	r4, r6
			record->state = TriggerMacro_Press;
    8c7c:	2201      	movs	r2, #1
    8c7e:	711a      	strb	r2, [r3, #4]
			if ( Trigger_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    8c80:	88a0      	ldrh	r0, [r4, #4]
    8c82:	4b15      	ldr	r3, [pc, #84]	; (8cd8 <Trigger_evalTriggerMacro+0x1f0>)
    8c84:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    8c88:	f7ff fd80 	bl	878c <Trigger_isLongResultMacro>
    8c8c:	2800      	cmp	r0, #0
    8c8e:	d0b6      	beq.n	8bfe <Trigger_evalTriggerMacro+0x116>
				if ( overallVote == TriggerMacroVote_Pass )
    8c90:	f1b8 0f08 	cmp.w	r8, #8
    8c94:	d111      	bne.n	8cba <Trigger_evalTriggerMacro+0x1d2>
					return TriggerMacroEval_DoResultAndRemove;
    8c96:	2002      	movs	r0, #2
    8c98:	e7b2      	b.n	8c00 <Trigger_evalTriggerMacro+0x118>
		else if ( overallVote & TriggerMacroVote_Release )
    8c9a:	f018 0f10 	tst.w	r8, #16
    8c9e:	d00c      	beq.n	8cba <Trigger_evalTriggerMacro+0x1d2>
			if ( !Trigger_isLongResultMacro( &ResultMacroList[ macro->result ] ) )
    8ca0:	4434      	add	r4, r6
    8ca2:	4b0d      	ldr	r3, [pc, #52]	; (8cd8 <Trigger_evalTriggerMacro+0x1f0>)
    8ca4:	88a0      	ldrh	r0, [r4, #4]
    8ca6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    8caa:	f7ff fd6f 	bl	878c <Trigger_isLongResultMacro>
    8cae:	b920      	cbnz	r0, 8cba <Trigger_evalTriggerMacro+0x1d2>
				record->state = TriggerMacro_Release;
    8cb0:	2306      	movs	r3, #6
    8cb2:	fb03 7505 	mla	r5, r3, r5, r7
    8cb6:	2002      	movs	r0, #2
    8cb8:	e780      	b.n	8bbc <Trigger_evalTriggerMacro+0xd4>
		return TriggerMacroEval_Remove;
    8cba:	2003      	movs	r0, #3
    8cbc:	e7a0      	b.n	8c00 <Trigger_evalTriggerMacro+0x118>
}
    8cbe:	b005      	add	sp, #20
    8cc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8cc4:	1fff89d0 	.word	0x1fff89d0
    8cc8:	1fffa56c 	.word	0x1fffa56c
    8ccc:	1fffa342 	.word	0x1fffa342
    8cd0:	00014736 	.word	0x00014736
    8cd4:	00014749 	.word	0x00014749
    8cd8:	000118c8 	.word	0x000118c8
    8cdc:	00011a74 	.word	0x00011a74

00008ce0 <Trigger_updateTriggerMacroPendingList>:


// Update pending trigger list
void Trigger_updateTriggerMacroPendingList()
{
    8ce0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8ce4:	4b2d      	ldr	r3, [pc, #180]	; (8d9c <Trigger_updateTriggerMacroPendingList+0xbc>)
			//  triggerList needs to be added
			var_uint_t pending = 0;
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
			{
				// Stop scanning if the trigger macro index is found in the pending list
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    8ce6:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8da8 <Trigger_updateTriggerMacroPendingList+0xc8>
{
    8cea:	681a      	ldr	r2, [r3, #0]
    8cec:	b085      	sub	sp, #20
	for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    8cee:	2500      	movs	r5, #0
{
    8cf0:	9203      	str	r2, [sp, #12]
    8cf2:	9301      	str	r3, [sp, #4]
	for ( var_uint_t key = 0; key < macroTriggerEventBufferSize; key++ )
    8cf4:	4b2a      	ldr	r3, [pc, #168]	; (8da0 <Trigger_updateTriggerMacroPendingList+0xc0>)
    8cf6:	881a      	ldrh	r2, [r3, #0]
    8cf8:	b2ab      	uxth	r3, r5
    8cfa:	429a      	cmp	r2, r3
    8cfc:	d806      	bhi.n	8d0c <Trigger_updateTriggerMacroPendingList+0x2c>
				TriggerMacroRecordList[ triggerMacroIndex ].prevPos = 0;
				TriggerMacroRecordList[ triggerMacroIndex ].state   = TriggerMacro_Waiting;
			}
		}
	}
}
    8cfe:	9b01      	ldr	r3, [sp, #4]
    8d00:	9a03      	ldr	r2, [sp, #12]
    8d02:	681b      	ldr	r3, [r3, #0]
    8d04:	429a      	cmp	r2, r3
    8d06:	d046      	beq.n	8d96 <Trigger_updateTriggerMacroPendingList+0xb6>
    8d08:	f7f9 fd12 	bl	2730 <__stack_chk_fail>
    8d0c:	b2a8      	uxth	r0, r5
		uint8_t latch_expire = event->state == ScheduleType_R;
    8d0e:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    8d12:	4824      	ldr	r0, [pc, #144]	; (8da4 <Trigger_updateTriggerMacroPendingList+0xc4>)
    8d14:	4418      	add	r0, r3
    8d16:	7841      	ldrb	r1, [r0, #1]
		nat_ptr_t *triggerList = Layer_layerLookup( event, latch_expire );
    8d18:	1ecb      	subs	r3, r1, #3
    8d1a:	4259      	negs	r1, r3
    8d1c:	4159      	adcs	r1, r3
    8d1e:	f7fd ff9b 	bl	6c58 <Layer_layerLookup>
		if ( triggerList == 0 )
    8d22:	b198      	cbz	r0, 8d4c <Trigger_updateTriggerMacroPendingList+0x6c>
		nat_ptr_t triggerListSize = triggerList[0];
    8d24:	6803      	ldr	r3, [r0, #0]
    8d26:	f8df c084 	ldr.w	ip, [pc, #132]	; 8dac <Trigger_updateTriggerMacroPendingList+0xcc>
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    8d2a:	f8df e084 	ldr.w	lr, [pc, #132]	; 8db0 <Trigger_updateTriggerMacroPendingList+0xd0>
    8d2e:	f8bc 2000 	ldrh.w	r2, [ip]
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    8d32:	2101      	movs	r1, #1
    8d34:	2600      	movs	r6, #0
    8d36:	440b      	add	r3, r1
    8d38:	9300      	str	r3, [sp, #0]
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    8d3a:	f04f 0a06 	mov.w	sl, #6
    8d3e:	4637      	mov	r7, r6
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    8d40:	9b00      	ldr	r3, [sp, #0]
    8d42:	4299      	cmp	r1, r3
    8d44:	d304      	bcc.n	8d50 <Trigger_updateTriggerMacroPendingList+0x70>
    8d46:	b10e      	cbz	r6, 8d4c <Trigger_updateTriggerMacroPendingList+0x6c>
    8d48:	f8ac 2000 	strh.w	r2, [ip]
    8d4c:	3501      	adds	r5, #1
    8d4e:	e7d1      	b.n	8cf4 <Trigger_updateTriggerMacroPendingList+0x14>
			var_uint_t triggerMacroIndex = triggerList[ macro ];
    8d50:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    8d54:	2400      	movs	r4, #0
			var_uint_t triggerMacroIndex = triggerList[ macro ];
    8d56:	fa1f f983 	uxth.w	r9, r3
    8d5a:	fa1f fb84 	uxth.w	fp, r4
			for ( ; pending < macroTriggerMacroPendingListSize; pending++ )
    8d5e:	4593      	cmp	fp, r2
    8d60:	d30f      	bcc.n	8d82 <Trigger_updateTriggerMacroPendingList+0xa2>
			if ( pending == macroTriggerMacroPendingListSize )
    8d62:	d115      	bne.n	8d90 <Trigger_updateTriggerMacroPendingList+0xb0>
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    8d64:	b29b      	uxth	r3, r3
    8d66:	fb0a f303 	mul.w	r3, sl, r3
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    8d6a:	f828 9014 	strh.w	r9, [r8, r4, lsl #1]
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    8d6e:	eb0e 0403 	add.w	r4, lr, r3
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    8d72:	3201      	adds	r2, #1
				TriggerMacroRecordList[ triggerMacroIndex ].pos     = 0;
    8d74:	f82e 7003 	strh.w	r7, [lr, r3]
				macroTriggerMacroPendingList[ macroTriggerMacroPendingListSize++ ] = triggerMacroIndex;
    8d78:	b292      	uxth	r2, r2
				TriggerMacroRecordList[ triggerMacroIndex ].prevPos = 0;
    8d7a:	8067      	strh	r7, [r4, #2]
				TriggerMacroRecordList[ triggerMacroIndex ].state   = TriggerMacro_Waiting;
    8d7c:	7127      	strb	r7, [r4, #4]
    8d7e:	2601      	movs	r6, #1
    8d80:	e006      	b.n	8d90 <Trigger_updateTriggerMacroPendingList+0xb0>
    8d82:	3401      	adds	r4, #1
				if ( macroTriggerMacroPendingList[ pending ] == triggerMacroIndex )
    8d84:	eb08 0b44 	add.w	fp, r8, r4, lsl #1
    8d88:	f83b bc02 	ldrh.w	fp, [fp, #-2]
    8d8c:	45cb      	cmp	fp, r9
    8d8e:	d1e4      	bne.n	8d5a <Trigger_updateTriggerMacroPendingList+0x7a>
		for ( var_uint_t macro = 1; macro < triggerListSize + 1; macro++ )
    8d90:	3101      	adds	r1, #1
    8d92:	b289      	uxth	r1, r1
    8d94:	e7d4      	b.n	8d40 <Trigger_updateTriggerMacroPendingList+0x60>
}
    8d96:	b005      	add	sp, #20
    8d98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8d9c:	1fff89d0 	.word	0x1fff89d0
    8da0:	1fffa340 	.word	0x1fffa340
    8da4:	1fffa346 	.word	0x1fffa346
    8da8:	1fff95e4 	.word	0x1fff95e4
    8dac:	1fff96cc 	.word	0x1fff96cc
    8db0:	1fffa56c 	.word	0x1fffa56c

00008db4 <Trigger_setup>:


void Trigger_setup()
{
    8db4:	b507      	push	{r0, r1, r2, lr}
    8db6:	4a0b      	ldr	r2, [pc, #44]	; (8de4 <Trigger_setup+0x30>)
    8db8:	6813      	ldr	r3, [r2, #0]
    8dba:	9301      	str	r3, [sp, #4]
    8dbc:	4b0a      	ldr	r3, [pc, #40]	; (8de8 <Trigger_setup+0x34>)
	// Initialize TriggerMacro states
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
	{
		TriggerMacroRecordList[ macro ].pos     = 0;
    8dbe:	2100      	movs	r1, #0
    8dc0:	f503 702e 	add.w	r0, r3, #696	; 0x2b8
    8dc4:	8019      	strh	r1, [r3, #0]
		TriggerMacroRecordList[ macro ].prevPos = 0;
    8dc6:	8059      	strh	r1, [r3, #2]
		TriggerMacroRecordList[ macro ].state   = TriggerMacro_Waiting;
    8dc8:	7119      	strb	r1, [r3, #4]
    8dca:	3306      	adds	r3, #6
	for ( var_uint_t macro = 0; macro < TriggerMacroNum; macro++ )
    8dcc:	4283      	cmp	r3, r0
    8dce:	d1f9      	bne.n	8dc4 <Trigger_setup+0x10>
	}
}
    8dd0:	9901      	ldr	r1, [sp, #4]
    8dd2:	6813      	ldr	r3, [r2, #0]
    8dd4:	4299      	cmp	r1, r3
    8dd6:	d001      	beq.n	8ddc <Trigger_setup+0x28>
    8dd8:	f7f9 fcaa 	bl	2730 <__stack_chk_fail>
    8ddc:	b003      	add	sp, #12
    8dde:	f85d fb04 	ldr.w	pc, [sp], #4
    8de2:	bf00      	nop
    8de4:	1fff89d0 	.word	0x1fff89d0
    8de8:	1fffa56c 	.word	0x1fffa56c

00008dec <Trigger_process>:


void Trigger_process()
{
    8dec:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    8df0:	4d35      	ldr	r5, [pc, #212]	; (8ec8 <Trigger_process+0xdc>)
    8df2:	f8df 9100 	ldr.w	r9, [pc, #256]	; 8ef4 <Trigger_process+0x108>
    8df6:	682b      	ldr	r3, [r5, #0]
    8df8:	9301      	str	r3, [sp, #4]
	// Update pending trigger list, before processing TriggerMacros
	Trigger_updateTriggerMacroPendingList();
    8dfa:	f7ff ff71 	bl	8ce0 <Trigger_updateTriggerMacroPendingList>
	// Tail pointer for macroTriggerMacroPendingList
	// Macros must be explicitly re-added
	var_uint_t macroTriggerMacroPendingListTail = 0;

	// Display trigger information before processing
	if ( triggerPendingDebugMode )
    8dfe:	4b33      	ldr	r3, [pc, #204]	; (8ecc <Trigger_process+0xe0>)
    8e00:	781b      	ldrb	r3, [r3, #0]
    8e02:	b183      	cbz	r3, 8e26 <Trigger_process+0x3a>
	{
		print("\033[1;30mTPe\033[0m");
    8e04:	4832      	ldr	r0, [pc, #200]	; (8ed0 <Trigger_process+0xe4>)
		for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
		{
			print(" ");
    8e06:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 8ef8 <Trigger_process+0x10c>
			printInt8( macroTriggerMacroPendingList[ macro ] );
    8e0a:	4f32      	ldr	r7, [pc, #200]	; (8ed4 <Trigger_process+0xe8>)
		print("\033[1;30mTPe\033[0m");
    8e0c:	f006 fbb0 	bl	f570 <_print>
		for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    8e10:	2400      	movs	r4, #0
    8e12:	f8b9 2000 	ldrh.w	r2, [r9]
    8e16:	b2a3      	uxth	r3, r4
    8e18:	429a      	cmp	r2, r3
    8e1a:	f104 0601 	add.w	r6, r4, #1
    8e1e:	d814      	bhi.n	8e4a <Trigger_process+0x5e>
		}
		print(NL);
    8e20:	482d      	ldr	r0, [pc, #180]	; (8ed8 <Trigger_process+0xec>)
    8e22:	f006 fba5 	bl	f570 <_print>
		default:
			if ( voteDebugMode )
			{
				print(" _" NL);
			}
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = cur_macro;
    8e26:	2400      	movs	r4, #0
		index_uint_t cur_macro = macroTriggerMacroPendingList[ macro ];
    8e28:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 8ed4 <Trigger_process+0xe8>
    8e2c:	4f2b      	ldr	r7, [pc, #172]	; (8edc <Trigger_process+0xf0>)
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = cur_macro;
    8e2e:	4626      	mov	r6, r4
	for ( var_uint_t macro = 0; macro < macroTriggerMacroPendingListSize; macro++ )
    8e30:	f8b9 2000 	ldrh.w	r2, [r9]
    8e34:	b2a3      	uxth	r3, r4
    8e36:	429a      	cmp	r2, r3
    8e38:	d811      	bhi.n	8e5e <Trigger_process+0x72>
		}
	}

	// Update the macroTriggerMacroPendingListSize with the tail pointer
	macroTriggerMacroPendingListSize = macroTriggerMacroPendingListTail;
}
    8e3a:	9a01      	ldr	r2, [sp, #4]
    8e3c:	682b      	ldr	r3, [r5, #0]
	macroTriggerMacroPendingListSize = macroTriggerMacroPendingListTail;
    8e3e:	f8a9 6000 	strh.w	r6, [r9]
}
    8e42:	429a      	cmp	r2, r3
    8e44:	d03d      	beq.n	8ec2 <Trigger_process+0xd6>
    8e46:	f7f9 fc73 	bl	2730 <__stack_chk_fail>
			printInt8( macroTriggerMacroPendingList[ macro ] );
    8e4a:	b2a4      	uxth	r4, r4
			print(" ");
    8e4c:	4640      	mov	r0, r8
    8e4e:	f006 fb8f 	bl	f570 <_print>
			printInt8( macroTriggerMacroPendingList[ macro ] );
    8e52:	f817 0014 	ldrb.w	r0, [r7, r4, lsl #1]
    8e56:	f006 fbf5 	bl	f644 <printInt8>
    8e5a:	4634      	mov	r4, r6
    8e5c:	e7d9      	b.n	8e12 <Trigger_process+0x26>
		index_uint_t cur_macro = macroTriggerMacroPendingList[ macro ];
    8e5e:	b2a3      	uxth	r3, r4
    8e60:	f83a 8013 	ldrh.w	r8, [sl, r3, lsl #1]
		switch ( Trigger_evalTriggerMacro( cur_macro ) )
    8e64:	4640      	mov	r0, r8
    8e66:	f7ff fe3f 	bl	8ae8 <Trigger_evalTriggerMacro>
    8e6a:	2802      	cmp	r0, #2
    8e6c:	d018      	beq.n	8ea0 <Trigger_process+0xb4>
    8e6e:	2803      	cmp	r0, #3
    8e70:	d020      	beq.n	8eb4 <Trigger_process+0xc8>
    8e72:	2801      	cmp	r0, #1
    8e74:	d109      	bne.n	8e8a <Trigger_process+0x9e>
			if ( voteDebugMode )
    8e76:	783b      	ldrb	r3, [r7, #0]
    8e78:	b113      	cbz	r3, 8e80 <Trigger_process+0x94>
				print(" DR");
    8e7a:	4819      	ldr	r0, [pc, #100]	; (8ee0 <Trigger_process+0xf4>)
    8e7c:	f006 fb78 	bl	f570 <_print>
			Result_appendResultMacroToPendingList(
    8e80:	4818      	ldr	r0, [pc, #96]	; (8ee4 <Trigger_process+0xf8>)
    8e82:	eb00 00c8 	add.w	r0, r0, r8, lsl #3
    8e86:	f7ff fa93 	bl	83b0 <Result_appendResultMacroToPendingList>
			if ( voteDebugMode )
    8e8a:	783b      	ldrb	r3, [r7, #0]
    8e8c:	b113      	cbz	r3, 8e94 <Trigger_process+0xa8>
				print(" _" NL);
    8e8e:	4816      	ldr	r0, [pc, #88]	; (8ee8 <Trigger_process+0xfc>)
    8e90:	f006 fb6e 	bl	f570 <_print>
			macroTriggerMacroPendingList[ macroTriggerMacroPendingListTail++ ] = cur_macro;
    8e94:	1c73      	adds	r3, r6, #1
    8e96:	f82a 8016 	strh.w	r8, [sl, r6, lsl #1]
    8e9a:	b29e      	uxth	r6, r3
    8e9c:	3401      	adds	r4, #1
    8e9e:	e7c7      	b.n	8e30 <Trigger_process+0x44>
			if ( voteDebugMode )
    8ea0:	783b      	ldrb	r3, [r7, #0]
    8ea2:	b113      	cbz	r3, 8eaa <Trigger_process+0xbe>
				print(" DRaR");
    8ea4:	4811      	ldr	r0, [pc, #68]	; (8eec <Trigger_process+0x100>)
    8ea6:	f006 fb63 	bl	f570 <_print>
			Result_appendResultMacroToPendingList(
    8eaa:	480e      	ldr	r0, [pc, #56]	; (8ee4 <Trigger_process+0xf8>)
    8eac:	eb00 00c8 	add.w	r0, r0, r8, lsl #3
    8eb0:	f7ff fa7e 	bl	83b0 <Result_appendResultMacroToPendingList>
			if ( voteDebugMode )
    8eb4:	783b      	ldrb	r3, [r7, #0]
    8eb6:	2b00      	cmp	r3, #0
    8eb8:	d0f0      	beq.n	8e9c <Trigger_process+0xb0>
				print(" R" NL);
    8eba:	480d      	ldr	r0, [pc, #52]	; (8ef0 <Trigger_process+0x104>)
    8ebc:	f006 fb58 	bl	f570 <_print>
    8ec0:	e7ec      	b.n	8e9c <Trigger_process+0xb0>
}
    8ec2:	b002      	add	sp, #8
    8ec4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8ec8:	1fff89d0 	.word	0x1fff89d0
    8ecc:	1fffa33e 	.word	0x1fffa33e
    8ed0:	0001474b 	.word	0x0001474b
    8ed4:	1fff95e4 	.word	0x1fff95e4
    8ed8:	00015df4 	.word	0x00015df4
    8edc:	1fffa342 	.word	0x1fffa342
    8ee0:	0001475a 	.word	0x0001475a
    8ee4:	00011a74 	.word	0x00011a74
    8ee8:	0001475e 	.word	0x0001475e
    8eec:	00014763 	.word	0x00014763
    8ef0:	00014769 	.word	0x00014769
    8ef4:	1fff96cc 	.word	0x1fff96cc
    8ef8:	00016f5e 	.word	0x00016f5e

00008efc <cliFunc_aniAdd>:

	// Toggle pixel
	Pixel_pixelToggle( elem );
}
void cliFunc_aniAdd( char* args )
{
    8efc:	b507      	push	{r0, r1, r2, lr}
    8efe:	4b07      	ldr	r3, [pc, #28]	; (8f1c <cliFunc_aniAdd+0x20>)
    8f00:	681a      	ldr	r2, [r3, #0]
    8f02:	9201      	str	r2, [sp, #4]
	print( NL ); // No \r\n by default after the command is entered
    8f04:	9a01      	ldr	r2, [sp, #4]
    8f06:	681b      	ldr	r3, [r3, #0]
    8f08:	429a      	cmp	r2, r3
    8f0a:	d001      	beq.n	8f10 <cliFunc_aniAdd+0x14>
    8f0c:	f7f9 fc10 	bl	2730 <__stack_chk_fail>
    8f10:	4803      	ldr	r0, [pc, #12]	; (8f20 <cliFunc_aniAdd+0x24>)
	Pixel_AnimationStack.stack[index].loops = 1;
	Pixel_AnimationStack.stack[index].divider = 0;
	Pixel_AnimationStack.stack[index].modifier = AnimationModifier_None;
	Pixel_AnimationStack.size++;
	*/
}
    8f12:	b003      	add	sp, #12
    8f14:	f85d eb04 	ldr.w	lr, [sp], #4
	print( NL ); // No \r\n by default after the command is entered
    8f18:	f006 bb2a 	b.w	f570 <_print>
    8f1c:	1fff89d0 	.word	0x1fff89d0
    8f20:	00015df4 	.word	0x00015df4

00008f24 <cliFunc_aniDel>:

void cliFunc_aniDel( char* args )
{
    8f24:	b513      	push	{r0, r1, r4, lr}
    8f26:	4c09      	ldr	r4, [pc, #36]	; (8f4c <cliFunc_aniDel+0x28>)
	print( NL ); // No \r\n by default after the command is entered
    8f28:	4809      	ldr	r0, [pc, #36]	; (8f50 <cliFunc_aniDel+0x2c>)
{
    8f2a:	6823      	ldr	r3, [r4, #0]
    8f2c:	9301      	str	r3, [sp, #4]
	print( NL ); // No \r\n by default after the command is entered
    8f2e:	f006 fb1f 	bl	f570 <_print>

	// TODO
	Pixel_AnimationStack.size--;
    8f32:	4a08      	ldr	r2, [pc, #32]	; (8f54 <cliFunc_aniDel+0x30>)
    8f34:	8813      	ldrh	r3, [r2, #0]
    8f36:	3b01      	subs	r3, #1
    8f38:	8013      	strh	r3, [r2, #0]
}
    8f3a:	9a01      	ldr	r2, [sp, #4]
    8f3c:	6823      	ldr	r3, [r4, #0]
    8f3e:	429a      	cmp	r2, r3
    8f40:	d001      	beq.n	8f46 <cliFunc_aniDel+0x22>
    8f42:	f7f9 fbf5 	bl	2730 <__stack_chk_fail>
    8f46:	b002      	add	sp, #8
    8f48:	bd10      	pop	{r4, pc}
    8f4a:	bf00      	nop
    8f4c:	1fff89d0 	.word	0x1fff89d0
    8f50:	00015df4 	.word	0x00015df4
    8f54:	1fffab00 	.word	0x1fffab00

00008f58 <cliFunc_aniStack>:

void cliFunc_aniStack( char* args )
{
    8f58:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    8f5c:	4e2b      	ldr	r6, [pc, #172]	; (900c <cliFunc_aniStack+0xb4>)
	print(NL);
    8f5e:	482c      	ldr	r0, [pc, #176]	; (9010 <cliFunc_aniStack+0xb8>)
{
    8f60:	6833      	ldr	r3, [r6, #0]
	info_msg("Stack Size: ");
	printInt16( Pixel_AnimationStack.size );
    8f62:	4d2c      	ldr	r5, [pc, #176]	; (9014 <cliFunc_aniStack+0xbc>)
{
    8f64:	9301      	str	r3, [sp, #4]
	print(NL);
    8f66:	f006 fb03 	bl	f570 <_print>
	info_msg("Stack Size: ");
    8f6a:	482b      	ldr	r0, [pc, #172]	; (9018 <cliFunc_aniStack+0xc0>)
	for ( uint8_t pos = 0; pos < Pixel_AnimationStack.size; pos++ )
	{
		print(NL);
    8f6c:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 9010 <cliFunc_aniStack+0xb8>
		AnimationStackElement *elem = Pixel_AnimationStack.stack[pos];
		print(" index(");
    8f70:	4f2a      	ldr	r7, [pc, #168]	; (901c <cliFunc_aniStack+0xc4>)
		printInt16( elem->index );
		print(") pos(");
    8f72:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 9038 <cliFunc_aniStack+0xe0>
	info_msg("Stack Size: ");
    8f76:	f006 fafb 	bl	f570 <_print>
	printInt16( Pixel_AnimationStack.size );
    8f7a:	8828      	ldrh	r0, [r5, #0]
    8f7c:	f006 fb98 	bl	f6b0 <printInt16>
	for ( uint8_t pos = 0; pos < Pixel_AnimationStack.size; pos++ )
    8f80:	2300      	movs	r3, #0
    8f82:	b2dc      	uxtb	r4, r3
    8f84:	f103 0901 	add.w	r9, r3, #1
    8f88:	882b      	ldrh	r3, [r5, #0]
    8f8a:	429c      	cmp	r4, r3
    8f8c:	d305      	bcc.n	8f9a <cliFunc_aniStack+0x42>
		printInt8( elem->ffunc );
		print(") pfunc(");
		printInt8( elem->pfunc );
		print(")");
	}
}
    8f8e:	9a01      	ldr	r2, [sp, #4]
    8f90:	6833      	ldr	r3, [r6, #0]
    8f92:	429a      	cmp	r2, r3
    8f94:	d036      	beq.n	9004 <cliFunc_aniStack+0xac>
    8f96:	f7f9 fbcb 	bl	2730 <__stack_chk_fail>
		print(NL);
    8f9a:	4650      	mov	r0, sl
    8f9c:	f006 fae8 	bl	f570 <_print>
		AnimationStackElement *elem = Pixel_AnimationStack.stack[pos];
    8fa0:	eb05 0384 	add.w	r3, r5, r4, lsl #2
		print(" index(");
    8fa4:	4638      	mov	r0, r7
		AnimationStackElement *elem = Pixel_AnimationStack.stack[pos];
    8fa6:	685c      	ldr	r4, [r3, #4]
		print(" index(");
    8fa8:	f006 fae2 	bl	f570 <_print>
		printInt16( elem->index );
    8fac:	88a0      	ldrh	r0, [r4, #4]
    8fae:	f006 fb7f 	bl	f6b0 <printInt16>
		print(") pos(");
    8fb2:	4640      	mov	r0, r8
    8fb4:	f006 fadc 	bl	f570 <_print>
		printInt16( elem->pos );
    8fb8:	88e0      	ldrh	r0, [r4, #6]
    8fba:	f006 fb79 	bl	f6b0 <printInt16>
		print(") loops(");
    8fbe:	4818      	ldr	r0, [pc, #96]	; (9020 <cliFunc_aniStack+0xc8>)
    8fc0:	f006 fad6 	bl	f570 <_print>
		printInt8( elem->loops );
    8fc4:	7a60      	ldrb	r0, [r4, #9]
    8fc6:	f006 fb3d 	bl	f644 <printInt8>
		print(") framedelay(");
    8fca:	4816      	ldr	r0, [pc, #88]	; (9024 <cliFunc_aniStack+0xcc>)
    8fcc:	f006 fad0 	bl	f570 <_print>
		printInt8( elem->framedelay );
    8fd0:	7aa0      	ldrb	r0, [r4, #10]
    8fd2:	f006 fb37 	bl	f644 <printInt8>
		print(") frameoption(");
    8fd6:	4814      	ldr	r0, [pc, #80]	; (9028 <cliFunc_aniStack+0xd0>)
    8fd8:	f006 faca 	bl	f570 <_print>
		printInt8( elem->frameoption );
    8fdc:	7ae0      	ldrb	r0, [r4, #11]
    8fde:	f006 fb31 	bl	f644 <printInt8>
		print(") ffunc(");
    8fe2:	4812      	ldr	r0, [pc, #72]	; (902c <cliFunc_aniStack+0xd4>)
    8fe4:	f006 fac4 	bl	f570 <_print>
		printInt8( elem->ffunc );
    8fe8:	7b20      	ldrb	r0, [r4, #12]
    8fea:	f006 fb2b 	bl	f644 <printInt8>
		print(") pfunc(");
    8fee:	4810      	ldr	r0, [pc, #64]	; (9030 <cliFunc_aniStack+0xd8>)
    8ff0:	f006 fabe 	bl	f570 <_print>
		printInt8( elem->pfunc );
    8ff4:	7b60      	ldrb	r0, [r4, #13]
    8ff6:	f006 fb25 	bl	f644 <printInt8>
		print(")");
    8ffa:	480e      	ldr	r0, [pc, #56]	; (9034 <cliFunc_aniStack+0xdc>)
    8ffc:	f006 fab8 	bl	f570 <_print>
    9000:	464b      	mov	r3, r9
    9002:	e7be      	b.n	8f82 <cliFunc_aniStack+0x2a>
}
    9004:	b002      	add	sp, #8
    9006:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    900a:	bf00      	nop
    900c:	1fff89d0 	.word	0x1fff89d0
    9010:	00015df4 	.word	0x00015df4
    9014:	1fffab00 	.word	0x1fffab00
    9018:	00014dcf 	.word	0x00014dcf
    901c:	00014dee 	.word	0x00014dee
    9020:	00014dfd 	.word	0x00014dfd
    9024:	00014e06 	.word	0x00014e06
    9028:	00014e14 	.word	0x00014e14
    902c:	00014e23 	.word	0x00014e23
    9030:	00014e2c 	.word	0x00014e2c
    9034:	00015c35 	.word	0x00015c35
    9038:	00014df6 	.word	0x00014df6

0000903c <cliFunc_pixelList>:
{
    903c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9040:	4e46      	ldr	r6, [pc, #280]	; (915c <cliFunc_pixelList+0x120>)
    9042:	b087      	sub	sp, #28
    9044:	6833      	ldr	r3, [r6, #0]
    9046:	9305      	str	r3, [sp, #20]
    9048:	4604      	mov	r4, r0
	print( NL ); // No \r\n by default after the command is entered
    904a:	4845      	ldr	r0, [pc, #276]	; (9160 <cliFunc_pixelList+0x124>)
    904c:	f006 fa90 	bl	f570 <_print>
	char* arg2Ptr = args;
    9050:	aa06      	add	r2, sp, #24
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    9052:	a903      	add	r1, sp, #12
	char* arg2Ptr = args;
    9054:	f842 4d08 	str.w	r4, [r2, #-8]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    9058:	4620      	mov	r0, r4
    905a:	f005 fd5b 	bl	eb14 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    905e:	9b03      	ldr	r3, [sp, #12]
    9060:	781b      	ldrb	r3, [r3, #0]
    9062:	2b42      	cmp	r3, #66	; 0x42
    9064:	d001      	beq.n	906a <cliFunc_pixelList+0x2e>
    9066:	2b62      	cmp	r3, #98	; 0x62
    9068:	d125      	bne.n	90b6 <cliFunc_pixelList+0x7a>
		info_msg("Buffer List");
    906a:	483e      	ldr	r0, [pc, #248]	; (9164 <cliFunc_pixelList+0x128>)
			printHex32( (uint32_t)(uintptr_t)(Pixel_Buffers[ buf ].data) );
    906c:	4c3e      	ldr	r4, [pc, #248]	; (9168 <cliFunc_pixelList+0x12c>)
		info_msg("Buffer List");
    906e:	f006 fa7f 	bl	f570 <_print>
			print( NL "\t" );
    9072:	483e      	ldr	r0, [pc, #248]	; (916c <cliFunc_pixelList+0x130>)
    9074:	f006 fa7c 	bl	f570 <_print>
			printInt8( buf );
    9078:	2000      	movs	r0, #0
    907a:	f006 fae3 	bl	f644 <printInt8>
			print(":");
    907e:	483c      	ldr	r0, [pc, #240]	; (9170 <cliFunc_pixelList+0x134>)
    9080:	f006 fa76 	bl	f570 <_print>
			printHex32( (uint32_t)(uintptr_t)(Pixel_Buffers[ buf ].data) );
    9084:	2101      	movs	r1, #1
    9086:	6860      	ldr	r0, [r4, #4]
    9088:	f006 fbea 	bl	f860 <printHex32_op>
			print(":width(");
    908c:	4839      	ldr	r0, [pc, #228]	; (9174 <cliFunc_pixelList+0x138>)
    908e:	f006 fa6f 	bl	f570 <_print>
			printInt8( Pixel_Buffers[ buf ].width );
    9092:	7860      	ldrb	r0, [r4, #1]
    9094:	f006 fad6 	bl	f644 <printInt8>
			print("):size(");
    9098:	4837      	ldr	r0, [pc, #220]	; (9178 <cliFunc_pixelList+0x13c>)
    909a:	f006 fa69 	bl	f570 <_print>
			printInt8( Pixel_Buffers[ buf ].size );
    909e:	7820      	ldrb	r0, [r4, #0]
    90a0:	f006 fad0 	bl	f644 <printInt8>
			print(")");
    90a4:	4835      	ldr	r0, [pc, #212]	; (917c <cliFunc_pixelList+0x140>)
    90a6:	f006 fa63 	bl	f570 <_print>
}
    90aa:	9a05      	ldr	r2, [sp, #20]
    90ac:	6833      	ldr	r3, [r6, #0]
    90ae:	429a      	cmp	r2, r3
    90b0:	d050      	beq.n	9154 <cliFunc_pixelList+0x118>
    90b2:	f7f9 fb3d 	bl	2730 <__stack_chk_fail>
		info_msg("Pixel List - <num>[<ch1>,...]<width>:...");
    90b6:	4832      	ldr	r0, [pc, #200]	; (9180 <cliFunc_pixelList+0x144>)
    90b8:	4c32      	ldr	r4, [pc, #200]	; (9184 <cliFunc_pixelList+0x148>)
				print( NL );
    90ba:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 9160 <cliFunc_pixelList+0x124>
			print(":");
    90be:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 9170 <cliFunc_pixelList+0x134>
		info_msg("Pixel List - <num>[<ch1>,...]<width>:...");
    90c2:	f006 fa55 	bl	f570 <_print>
    90c6:	2500      	movs	r5, #0
    90c8:	4627      	mov	r7, r4
    90ca:	fa1f fa85 	uxth.w	sl, r5
			if ( pixel % 5 == 0 )
    90ce:	2305      	movs	r3, #5
    90d0:	fbba f3f3 	udiv	r3, sl, r3
    90d4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    90d8:	ebaa 0303 	sub.w	r3, sl, r3
    90dc:	b29b      	uxth	r3, r3
    90de:	b913      	cbnz	r3, 90e6 <cliFunc_pixelList+0xaa>
				print( NL );
    90e0:	4640      	mov	r0, r8
    90e2:	f006 fa45 	bl	f570 <_print>
			printHex_op( pixel, 2 );
    90e6:	2102      	movs	r1, #2
    90e8:	4650      	mov	r0, sl
    90ea:	f006 fb67 	bl	f7bc <printHex_op>
			print(":");
    90ee:	4648      	mov	r0, r9
    90f0:	f006 fa3e 	bl	f570 <_print>
			printInt8( elem->width );
    90f4:	7820      	ldrb	r0, [r4, #0]
    90f6:	f006 faa5 	bl	f644 <printInt8>
			print("[");
    90fa:	4823      	ldr	r0, [pc, #140]	; (9188 <cliFunc_pixelList+0x14c>)
    90fc:	f006 fa38 	bl	f570 <_print>
			printHex_op( elem->indices[0], 2 );
    9100:	2102      	movs	r1, #2
    9102:	8860      	ldrh	r0, [r4, #2]
    9104:	f006 fb5a 	bl	f7bc <printHex_op>
				print(",");
    9108:	4a20      	ldr	r2, [pc, #128]	; (918c <cliFunc_pixelList+0x150>)
			for ( uint8_t ch = 1; ch < elem->channels; ch++ )
    910a:	f04f 0a01 	mov.w	sl, #1
				printHex_op( elem->indices[ch], 2 );
    910e:	ea4f 0b85 	mov.w	fp, r5, lsl #2
			for ( uint8_t ch = 1; ch < elem->channels; ch++ )
    9112:	7863      	ldrb	r3, [r4, #1]
    9114:	4553      	cmp	r3, sl
    9116:	d80b      	bhi.n	9130 <cliFunc_pixelList+0xf4>
			print("]");
    9118:	481d      	ldr	r0, [pc, #116]	; (9190 <cliFunc_pixelList+0x154>)
    911a:	f006 fa29 	bl	f570 <_print>
    911e:	3501      	adds	r5, #1
			print("  ");
    9120:	481c      	ldr	r0, [pc, #112]	; (9194 <cliFunc_pixelList+0x158>)
    9122:	f006 fa25 	bl	f570 <_print>
		for ( uint16_t pixel = 0; pixel < Pixel_TotalPixels_KLL; pixel++ )
    9126:	2d26      	cmp	r5, #38	; 0x26
    9128:	f104 0408 	add.w	r4, r4, #8
    912c:	d1cd      	bne.n	90ca <cliFunc_pixelList+0x8e>
    912e:	e7bc      	b.n	90aa <cliFunc_pixelList+0x6e>
				print(",");
    9130:	4610      	mov	r0, r2
    9132:	9201      	str	r2, [sp, #4]
    9134:	f006 fa1c 	bl	f570 <_print>
				printHex_op( elem->indices[ch], 2 );
    9138:	eb0b 030a 	add.w	r3, fp, sl
    913c:	eb07 0343 	add.w	r3, r7, r3, lsl #1
    9140:	2102      	movs	r1, #2
    9142:	8858      	ldrh	r0, [r3, #2]
			for ( uint8_t ch = 1; ch < elem->channels; ch++ )
    9144:	f10a 0a01 	add.w	sl, sl, #1
				printHex_op( elem->indices[ch], 2 );
    9148:	f006 fb38 	bl	f7bc <printHex_op>
			for ( uint8_t ch = 1; ch < elem->channels; ch++ )
    914c:	fa5f fa8a 	uxtb.w	sl, sl
    9150:	9a01      	ldr	r2, [sp, #4]
    9152:	e7de      	b.n	9112 <cliFunc_pixelList+0xd6>
}
    9154:	b007      	add	sp, #28
    9156:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    915a:	bf00      	nop
    915c:	1fff89d0 	.word	0x1fff89d0
    9160:	00015df4 	.word	0x00015df4
    9164:	00014ec0 	.word	0x00014ec0
    9168:	1fff8e34 	.word	0x1fff8e34
    916c:	00011f5e 	.word	0x00011f5e
    9170:	00014d02 	.word	0x00014d02
    9174:	00014ede 	.word	0x00014ede
    9178:	00014ee6 	.word	0x00014ee6
    917c:	00015c35 	.word	0x00015c35
    9180:	00014eee 	.word	0x00014eee
    9184:	00015530 	.word	0x00015530
    9188:	00016533 	.word	0x00016533
    918c:	00012bba 	.word	0x00012bba
    9190:	00014749 	.word	0x00014749
    9194:	00016f5d 	.word	0x00016f5d

00009198 <cliFunc_pixelTest>:
{
    9198:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    919a:	4e37      	ldr	r6, [pc, #220]	; (9278 <cliFunc_pixelTest+0xe0>)
    919c:	4c37      	ldr	r4, [pc, #220]	; (927c <cliFunc_pixelTest+0xe4>)
    919e:	6833      	ldr	r3, [r6, #0]
    91a0:	9303      	str	r3, [sp, #12]
    91a2:	4605      	mov	r5, r0
	print( NL ); // No \r\n by default after the command is entered
    91a4:	4836      	ldr	r0, [pc, #216]	; (9280 <cliFunc_pixelTest+0xe8>)
    91a6:	f006 f9e3 	bl	f570 <_print>
	char* arg2Ptr = args;
    91aa:	aa04      	add	r2, sp, #16
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    91ac:	4628      	mov	r0, r5
	char* arg2Ptr = args;
    91ae:	f842 5d08 	str.w	r5, [r2, #-8]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    91b2:	a901      	add	r1, sp, #4
    91b4:	f005 fcae 	bl	eb14 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    91b8:	9801      	ldr	r0, [sp, #4]
    91ba:	7803      	ldrb	r3, [r0, #0]
    91bc:	2b53      	cmp	r3, #83	; 0x53
    91be:	d03e      	beq.n	923e <cliFunc_pixelTest+0xa6>
    91c0:	d82a      	bhi.n	9218 <cliFunc_pixelTest+0x80>
    91c2:	2b46      	cmp	r3, #70	; 0x46
    91c4:	d02f      	beq.n	9226 <cliFunc_pixelTest+0x8e>
    91c6:	d81b      	bhi.n	9200 <cliFunc_pixelTest+0x68>
    91c8:	2b41      	cmp	r3, #65	; 0x41
    91ca:	d03d      	beq.n	9248 <cliFunc_pixelTest+0xb0>
		Pixel_testMode = PixelTest_Pixel_Single;
    91cc:	2306      	movs	r3, #6
    91ce:	7023      	strb	r3, [r4, #0]
	if ( *arg1Ptr != '\0' )
    91d0:	7803      	ldrb	r3, [r0, #0]
    91d2:	4d2c      	ldr	r5, [pc, #176]	; (9284 <cliFunc_pixelTest+0xec>)
    91d4:	b11b      	cbz	r3, 91de <cliFunc_pixelTest+0x46>
		Pixel_testPos = numToInt( arg1Ptr );
    91d6:	f006 fb9b 	bl	f910 <numToInt>
    91da:	b280      	uxth	r0, r0
    91dc:	8028      	strh	r0, [r5, #0]
	if ( Pixel_testPos == 0 )
    91de:	882b      	ldrh	r3, [r5, #0]
    91e0:	b29b      	uxth	r3, r3
    91e2:	2b00      	cmp	r3, #0
    91e4:	d037      	beq.n	9256 <cliFunc_pixelTest+0xbe>
	print( NL );
    91e6:	4826      	ldr	r0, [pc, #152]	; (9280 <cliFunc_pixelTest+0xe8>)
    91e8:	f006 f9c2 	bl	f570 <_print>
	info_msg("Pixel: ");
    91ec:	4826      	ldr	r0, [pc, #152]	; (9288 <cliFunc_pixelTest+0xf0>)
    91ee:	f006 f9bf 	bl	f570 <_print>
	printInt16( Pixel_testPos );
    91f2:	8828      	ldrh	r0, [r5, #0]
    91f4:	f006 fa5c 	bl	f6b0 <printInt16>
	print(" ");
    91f8:	4824      	ldr	r0, [pc, #144]	; (928c <cliFunc_pixelTest+0xf4>)
    91fa:	f006 f9b9 	bl	f570 <_print>
    91fe:	e02b      	b.n	9258 <cliFunc_pixelTest+0xc0>
	switch ( *arg1Ptr )
    9200:	2b4f      	cmp	r3, #79	; 0x4f
    9202:	d02f      	beq.n	9264 <cliFunc_pixelTest+0xcc>
    9204:	2b52      	cmp	r3, #82	; 0x52
    9206:	d1e1      	bne.n	91cc <cliFunc_pixelTest+0x34>
		info_msg("Pixel roll test");
    9208:	4821      	ldr	r0, [pc, #132]	; (9290 <cliFunc_pixelTest+0xf8>)
    920a:	f006 f9b1 	bl	f570 <_print>
		Pixel_testPos = 0;
    920e:	4b1d      	ldr	r3, [pc, #116]	; (9284 <cliFunc_pixelTest+0xec>)
    9210:	2200      	movs	r2, #0
    9212:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Pixel_Roll;
    9214:	2308      	movs	r3, #8
    9216:	e01e      	b.n	9256 <cliFunc_pixelTest+0xbe>
	switch ( *arg1Ptr )
    9218:	2b6f      	cmp	r3, #111	; 0x6f
    921a:	d023      	beq.n	9264 <cliFunc_pixelTest+0xcc>
    921c:	d80b      	bhi.n	9236 <cliFunc_pixelTest+0x9e>
    921e:	2b61      	cmp	r3, #97	; 0x61
    9220:	d012      	beq.n	9248 <cliFunc_pixelTest+0xb0>
    9222:	2b66      	cmp	r3, #102	; 0x66
    9224:	d1d2      	bne.n	91cc <cliFunc_pixelTest+0x34>
		info_msg("Enable all pixels");
    9226:	481b      	ldr	r0, [pc, #108]	; (9294 <cliFunc_pixelTest+0xfc>)
    9228:	f006 f9a2 	bl	f570 <_print>
		Pixel_testPos = 0;
    922c:	4b15      	ldr	r3, [pc, #84]	; (9284 <cliFunc_pixelTest+0xec>)
    922e:	2200      	movs	r2, #0
    9230:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Pixel_Full;
    9232:	2309      	movs	r3, #9
    9234:	e00f      	b.n	9256 <cliFunc_pixelTest+0xbe>
	switch ( *arg1Ptr )
    9236:	2b72      	cmp	r3, #114	; 0x72
    9238:	d0e6      	beq.n	9208 <cliFunc_pixelTest+0x70>
    923a:	2b73      	cmp	r3, #115	; 0x73
    923c:	d1c6      	bne.n	91cc <cliFunc_pixelTest+0x34>
		info_msg("Stopping pixel test");
    923e:	4816      	ldr	r0, [pc, #88]	; (9298 <cliFunc_pixelTest+0x100>)
    9240:	f006 f996 	bl	f570 <_print>
		Pixel_testMode = PixelTest_Off;
    9244:	2300      	movs	r3, #0
    9246:	e006      	b.n	9256 <cliFunc_pixelTest+0xbe>
		info_msg("All pixel test");
    9248:	4814      	ldr	r0, [pc, #80]	; (929c <cliFunc_pixelTest+0x104>)
    924a:	f006 f991 	bl	f570 <_print>
		Pixel_testPos = 0;
    924e:	4b0d      	ldr	r3, [pc, #52]	; (9284 <cliFunc_pixelTest+0xec>)
    9250:	2200      	movs	r2, #0
    9252:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Pixel_All;
    9254:	2307      	movs	r3, #7
		Pixel_testMode = PixelTest_Off;
    9256:	7023      	strb	r3, [r4, #0]
}
    9258:	9a03      	ldr	r2, [sp, #12]
    925a:	6833      	ldr	r3, [r6, #0]
    925c:	429a      	cmp	r2, r3
    925e:	d009      	beq.n	9274 <cliFunc_pixelTest+0xdc>
    9260:	f7f9 fa66 	bl	2730 <__stack_chk_fail>
		info_msg("Disable all pixels");
    9264:	480e      	ldr	r0, [pc, #56]	; (92a0 <cliFunc_pixelTest+0x108>)
    9266:	f006 f983 	bl	f570 <_print>
		Pixel_testPos = 0;
    926a:	4b06      	ldr	r3, [pc, #24]	; (9284 <cliFunc_pixelTest+0xec>)
    926c:	2200      	movs	r2, #0
    926e:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Pixel_Off;
    9270:	230a      	movs	r3, #10
    9272:	e7f0      	b.n	9256 <cliFunc_pixelTest+0xbe>
}
    9274:	b004      	add	sp, #16
    9276:	bd70      	pop	{r4, r5, r6, pc}
    9278:	1fff89d0 	.word	0x1fff89d0
    927c:	1fffac98 	.word	0x1fffac98
    9280:	00015df4 	.word	0x00015df4
    9284:	1fff9724 	.word	0x1fff9724
    9288:	0001507c 	.word	0x0001507c
    928c:	00016f5e 	.word	0x00016f5e
    9290:	00014feb 	.word	0x00014feb
    9294:	00015033 	.word	0x00015033
    9298:	0001500d 	.word	0x0001500d
    929c:	00014fca 	.word	0x00014fca
    92a0:	00015057 	.word	0x00015057

000092a4 <cliFunc_chanTest>:
{
    92a4:	b530      	push	{r4, r5, lr}
    92a6:	4c36      	ldr	r4, [pc, #216]	; (9380 <cliFunc_chanTest+0xdc>)
    92a8:	b085      	sub	sp, #20
    92aa:	6823      	ldr	r3, [r4, #0]
    92ac:	9303      	str	r3, [sp, #12]
    92ae:	4605      	mov	r5, r0
	print( NL ); // No \r\n by default after the command is entered
    92b0:	4834      	ldr	r0, [pc, #208]	; (9384 <cliFunc_chanTest+0xe0>)
    92b2:	f006 f95d 	bl	f570 <_print>
	char* arg2Ptr = args;
    92b6:	aa04      	add	r2, sp, #16
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    92b8:	4628      	mov	r0, r5
	char* arg2Ptr = args;
    92ba:	f842 5d08 	str.w	r5, [r2, #-8]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    92be:	a901      	add	r1, sp, #4
    92c0:	f005 fc28 	bl	eb14 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    92c4:	9801      	ldr	r0, [sp, #4]
    92c6:	7803      	ldrb	r3, [r0, #0]
    92c8:	2b53      	cmp	r3, #83	; 0x53
    92ca:	4625      	mov	r5, r4
    92cc:	4c2e      	ldr	r4, [pc, #184]	; (9388 <cliFunc_chanTest+0xe4>)
    92ce:	d03a      	beq.n	9346 <cliFunc_chanTest+0xa2>
    92d0:	d826      	bhi.n	9320 <cliFunc_chanTest+0x7c>
    92d2:	2b46      	cmp	r3, #70	; 0x46
    92d4:	d02b      	beq.n	932e <cliFunc_chanTest+0x8a>
    92d6:	d817      	bhi.n	9308 <cliFunc_chanTest+0x64>
    92d8:	2b41      	cmp	r3, #65	; 0x41
    92da:	d039      	beq.n	9350 <cliFunc_chanTest+0xac>
		Pixel_testMode = PixelTest_Chan_Single;
    92dc:	2301      	movs	r3, #1
    92de:	7023      	strb	r3, [r4, #0]
	if ( *arg1Ptr != '\0' )
    92e0:	7803      	ldrb	r3, [r0, #0]
    92e2:	4c2a      	ldr	r4, [pc, #168]	; (938c <cliFunc_chanTest+0xe8>)
    92e4:	b11b      	cbz	r3, 92ee <cliFunc_chanTest+0x4a>
		Pixel_testPos = numToInt( arg1Ptr );
    92e6:	f006 fb13 	bl	f910 <numToInt>
    92ea:	b280      	uxth	r0, r0
    92ec:	8020      	strh	r0, [r4, #0]
	print( NL );
    92ee:	4825      	ldr	r0, [pc, #148]	; (9384 <cliFunc_chanTest+0xe0>)
    92f0:	f006 f93e 	bl	f570 <_print>
	info_msg("Channel: ");
    92f4:	4826      	ldr	r0, [pc, #152]	; (9390 <cliFunc_chanTest+0xec>)
    92f6:	f006 f93b 	bl	f570 <_print>
	printInt16( Pixel_testPos );
    92fa:	8820      	ldrh	r0, [r4, #0]
    92fc:	f006 f9d8 	bl	f6b0 <printInt16>
	print( NL );
    9300:	4820      	ldr	r0, [pc, #128]	; (9384 <cliFunc_chanTest+0xe0>)
    9302:	f006 f935 	bl	f570 <_print>
    9306:	e02b      	b.n	9360 <cliFunc_chanTest+0xbc>
	switch ( *arg1Ptr )
    9308:	2b4f      	cmp	r3, #79	; 0x4f
    930a:	d02f      	beq.n	936c <cliFunc_chanTest+0xc8>
    930c:	2b52      	cmp	r3, #82	; 0x52
    930e:	d1e5      	bne.n	92dc <cliFunc_chanTest+0x38>
		info_msg("Channel roll test");
    9310:	4820      	ldr	r0, [pc, #128]	; (9394 <cliFunc_chanTest+0xf0>)
    9312:	f006 f92d 	bl	f570 <_print>
		Pixel_testPos = 0;
    9316:	4b1d      	ldr	r3, [pc, #116]	; (938c <cliFunc_chanTest+0xe8>)
    9318:	2200      	movs	r2, #0
    931a:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Chan_Roll;
    931c:	2303      	movs	r3, #3
    931e:	e01e      	b.n	935e <cliFunc_chanTest+0xba>
	switch ( *arg1Ptr )
    9320:	2b6f      	cmp	r3, #111	; 0x6f
    9322:	d023      	beq.n	936c <cliFunc_chanTest+0xc8>
    9324:	d80b      	bhi.n	933e <cliFunc_chanTest+0x9a>
    9326:	2b61      	cmp	r3, #97	; 0x61
    9328:	d012      	beq.n	9350 <cliFunc_chanTest+0xac>
    932a:	2b66      	cmp	r3, #102	; 0x66
    932c:	d1d6      	bne.n	92dc <cliFunc_chanTest+0x38>
		info_msg("Enable all pixels");
    932e:	481a      	ldr	r0, [pc, #104]	; (9398 <cliFunc_chanTest+0xf4>)
    9330:	f006 f91e 	bl	f570 <_print>
		Pixel_testPos = 0;
    9334:	4b15      	ldr	r3, [pc, #84]	; (938c <cliFunc_chanTest+0xe8>)
    9336:	2200      	movs	r2, #0
    9338:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Chan_Full;
    933a:	2304      	movs	r3, #4
    933c:	e00f      	b.n	935e <cliFunc_chanTest+0xba>
	switch ( *arg1Ptr )
    933e:	2b72      	cmp	r3, #114	; 0x72
    9340:	d0e6      	beq.n	9310 <cliFunc_chanTest+0x6c>
    9342:	2b73      	cmp	r3, #115	; 0x73
    9344:	d1ca      	bne.n	92dc <cliFunc_chanTest+0x38>
		info_msg("Stopping channel test");
    9346:	4815      	ldr	r0, [pc, #84]	; (939c <cliFunc_chanTest+0xf8>)
    9348:	f006 f912 	bl	f570 <_print>
		Pixel_testMode = PixelTest_Off;
    934c:	2300      	movs	r3, #0
    934e:	e006      	b.n	935e <cliFunc_chanTest+0xba>
		info_msg("All channel test");
    9350:	4813      	ldr	r0, [pc, #76]	; (93a0 <cliFunc_chanTest+0xfc>)
    9352:	f006 f90d 	bl	f570 <_print>
		Pixel_testPos = 0;
    9356:	4b0d      	ldr	r3, [pc, #52]	; (938c <cliFunc_chanTest+0xe8>)
    9358:	2200      	movs	r2, #0
    935a:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Chan_All;
    935c:	2302      	movs	r3, #2
		Pixel_testMode = PixelTest_Chan_Off;
    935e:	7023      	strb	r3, [r4, #0]
}
    9360:	9a03      	ldr	r2, [sp, #12]
    9362:	682b      	ldr	r3, [r5, #0]
    9364:	429a      	cmp	r2, r3
    9366:	d009      	beq.n	937c <cliFunc_chanTest+0xd8>
    9368:	f7f9 f9e2 	bl	2730 <__stack_chk_fail>
		info_msg("Disable all pixels");
    936c:	480d      	ldr	r0, [pc, #52]	; (93a4 <cliFunc_chanTest+0x100>)
    936e:	f006 f8ff 	bl	f570 <_print>
		Pixel_testPos = 0;
    9372:	4b06      	ldr	r3, [pc, #24]	; (938c <cliFunc_chanTest+0xe8>)
    9374:	2200      	movs	r2, #0
    9376:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Chan_Off;
    9378:	2305      	movs	r3, #5
    937a:	e7f0      	b.n	935e <cliFunc_chanTest+0xba>
}
    937c:	b005      	add	sp, #20
    937e:	bd30      	pop	{r4, r5, pc}
    9380:	1fff89d0 	.word	0x1fff89d0
    9384:	00015df4 	.word	0x00015df4
    9388:	1fffac98 	.word	0x1fffac98
    938c:	1fff9724 	.word	0x1fff9724
    9390:	00014ea4 	.word	0x00014ea4
    9394:	00014e58 	.word	0x00014e58
    9398:	00015033 	.word	0x00015033
    939c:	00014e7c 	.word	0x00014e7c
    93a0:	00014e35 	.word	0x00014e35
    93a4:	00015057 	.word	0x00015057

000093a8 <cliFunc_pixelSCTest>:
{
    93a8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    93aa:	4d30      	ldr	r5, [pc, #192]	; (946c <cliFunc_pixelSCTest+0xc4>)
    93ac:	4604      	mov	r4, r0
    93ae:	682b      	ldr	r3, [r5, #0]
	print( NL ); // No \r\n by default after the command is entered
    93b0:	482f      	ldr	r0, [pc, #188]	; (9470 <cliFunc_pixelSCTest+0xc8>)
{
    93b2:	9303      	str	r3, [sp, #12]
	print( NL ); // No \r\n by default after the command is entered
    93b4:	f006 f8dc 	bl	f570 <_print>
	char* arg2Ptr = args;
    93b8:	aa04      	add	r2, sp, #16
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    93ba:	4620      	mov	r0, r4
	char* arg2Ptr = args;
    93bc:	f842 4d08 	str.w	r4, [r2, #-8]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    93c0:	a901      	add	r1, sp, #4
    93c2:	f005 fba7 	bl	eb14 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    93c6:	9801      	ldr	r0, [sp, #4]
    93c8:	4c2a      	ldr	r4, [pc, #168]	; (9474 <cliFunc_pixelSCTest+0xcc>)
    93ca:	7803      	ldrb	r3, [r0, #0]
    93cc:	2b53      	cmp	r3, #83	; 0x53
    93ce:	d046      	beq.n	945e <cliFunc_pixelSCTest+0xb6>
    93d0:	d829      	bhi.n	9426 <cliFunc_pixelSCTest+0x7e>
    93d2:	2b41      	cmp	r3, #65	; 0x41
    93d4:	d02d      	beq.n	9432 <cliFunc_pixelSCTest+0x8a>
    93d6:	2b52      	cmp	r3, #82	; 0x52
    93d8:	d039      	beq.n	944e <cliFunc_pixelSCTest+0xa6>
		Pixel_testMode = PixelTest_Scan_Single;
    93da:	230b      	movs	r3, #11
    93dc:	7023      	strb	r3, [r4, #0]
	if ( *arg1Ptr != '\0' )
    93de:	7803      	ldrb	r3, [r0, #0]
    93e0:	4e25      	ldr	r6, [pc, #148]	; (9478 <cliFunc_pixelSCTest+0xd0>)
    93e2:	b11b      	cbz	r3, 93ec <cliFunc_pixelSCTest+0x44>
		Pixel_testPos = numToInt( arg1Ptr );
    93e4:	f006 fa94 	bl	f910 <numToInt>
    93e8:	b280      	uxth	r0, r0
    93ea:	8030      	strh	r0, [r6, #0]
	if ( Pixel_testPos == 0 )
    93ec:	8833      	ldrh	r3, [r6, #0]
    93ee:	b29b      	uxth	r3, r3
    93f0:	b333      	cbz	r3, 9440 <cliFunc_pixelSCTest+0x98>
	uint16_t pixel = Pixel_ScanCodeToPixel[ Pixel_testPos ];
    93f2:	8833      	ldrh	r3, [r6, #0]
    93f4:	4a21      	ldr	r2, [pc, #132]	; (947c <cliFunc_pixelSCTest+0xd4>)
	print( NL );
    93f6:	481e      	ldr	r0, [pc, #120]	; (9470 <cliFunc_pixelSCTest+0xc8>)
	uint16_t pixel = Pixel_ScanCodeToPixel[ Pixel_testPos ];
    93f8:	b29b      	uxth	r3, r3
    93fa:	f832 4013 	ldrh.w	r4, [r2, r3, lsl #1]
	print( NL );
    93fe:	f006 f8b7 	bl	f570 <_print>
	info_msg("ScanCode: ");
    9402:	481f      	ldr	r0, [pc, #124]	; (9480 <cliFunc_pixelSCTest+0xd8>)
    9404:	f006 f8b4 	bl	f570 <_print>
	printInt16( Pixel_testPos + 1 );
    9408:	8830      	ldrh	r0, [r6, #0]
    940a:	3001      	adds	r0, #1
    940c:	b280      	uxth	r0, r0
    940e:	f006 f94f 	bl	f6b0 <printInt16>
	print(" Pixel: ");
    9412:	481c      	ldr	r0, [pc, #112]	; (9484 <cliFunc_pixelSCTest+0xdc>)
    9414:	f006 f8ac 	bl	f570 <_print>
	printInt16( pixel );
    9418:	4620      	mov	r0, r4
    941a:	f006 f949 	bl	f6b0 <printInt16>
	print(" ");
    941e:	481a      	ldr	r0, [pc, #104]	; (9488 <cliFunc_pixelSCTest+0xe0>)
    9420:	f006 f8a6 	bl	f570 <_print>
    9424:	e00d      	b.n	9442 <cliFunc_pixelSCTest+0x9a>
	switch ( *arg1Ptr )
    9426:	2b72      	cmp	r3, #114	; 0x72
    9428:	d011      	beq.n	944e <cliFunc_pixelSCTest+0xa6>
    942a:	2b73      	cmp	r3, #115	; 0x73
    942c:	d017      	beq.n	945e <cliFunc_pixelSCTest+0xb6>
    942e:	2b61      	cmp	r3, #97	; 0x61
    9430:	d1d3      	bne.n	93da <cliFunc_pixelSCTest+0x32>
		info_msg("All scancode pixel test");
    9432:	4816      	ldr	r0, [pc, #88]	; (948c <cliFunc_pixelSCTest+0xe4>)
    9434:	f006 f89c 	bl	f570 <_print>
		Pixel_testPos = 0;
    9438:	4b0f      	ldr	r3, [pc, #60]	; (9478 <cliFunc_pixelSCTest+0xd0>)
    943a:	2200      	movs	r2, #0
    943c:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Scan_All;
    943e:	230c      	movs	r3, #12
		Pixel_testMode = PixelTest_Off;
    9440:	7023      	strb	r3, [r4, #0]
}
    9442:	9a03      	ldr	r2, [sp, #12]
    9444:	682b      	ldr	r3, [r5, #0]
    9446:	429a      	cmp	r2, r3
    9448:	d00e      	beq.n	9468 <cliFunc_pixelSCTest+0xc0>
    944a:	f7f9 f971 	bl	2730 <__stack_chk_fail>
		info_msg("Scancode pixel roll test");
    944e:	4810      	ldr	r0, [pc, #64]	; (9490 <cliFunc_pixelSCTest+0xe8>)
    9450:	f006 f88e 	bl	f570 <_print>
		Pixel_testPos = 0;
    9454:	4b08      	ldr	r3, [pc, #32]	; (9478 <cliFunc_pixelSCTest+0xd0>)
    9456:	2200      	movs	r2, #0
    9458:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_Scan_Roll;
    945a:	230d      	movs	r3, #13
    945c:	e7f0      	b.n	9440 <cliFunc_pixelSCTest+0x98>
		info_msg("Stopping scancode pixel test");
    945e:	480d      	ldr	r0, [pc, #52]	; (9494 <cliFunc_pixelSCTest+0xec>)
    9460:	f006 f886 	bl	f570 <_print>
		Pixel_testMode = PixelTest_Off;
    9464:	2300      	movs	r3, #0
    9466:	e7eb      	b.n	9440 <cliFunc_pixelSCTest+0x98>
}
    9468:	b004      	add	sp, #16
    946a:	bd70      	pop	{r4, r5, r6, pc}
    946c:	1fff89d0 	.word	0x1fff89d0
    9470:	00015df4 	.word	0x00015df4
    9474:	1fffac98 	.word	0x1fffac98
    9478:	1fff9724 	.word	0x1fff9724
    947c:	000156ba 	.word	0x000156ba
    9480:	00014fad 	.word	0x00014fad
    9484:	0001508d 	.word	0x0001508d
    9488:	00016f5e 	.word	0x00016f5e
    948c:	00014f29 	.word	0x00014f29
    9490:	00014f53 	.word	0x00014f53
    9494:	00014f7e 	.word	0x00014f7e

00009498 <Pixel_Pixel_capability>:
{
    9498:	b513      	push	{r0, r1, r4, lr}
    949a:	4c0c      	ldr	r4, [pc, #48]	; (94cc <Pixel_Pixel_capability+0x34>)
    949c:	4608      	mov	r0, r1
    949e:	6823      	ldr	r3, [r4, #0]
    94a0:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    94a2:	4611      	mov	r1, r2
    94a4:	f7fd f94c 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    94a8:	28ff      	cmp	r0, #255	; 0xff
		print("Pixel_Pixel_capability(pixel,chan,value)");
    94aa:	9a01      	ldr	r2, [sp, #4]
    94ac:	6823      	ldr	r3, [r4, #0]
	switch ( cstate )
    94ae:	d109      	bne.n	94c4 <Pixel_Pixel_capability+0x2c>
		print("Pixel_Pixel_capability(pixel,chan,value)");
    94b0:	429a      	cmp	r2, r3
    94b2:	d001      	beq.n	94b8 <Pixel_Pixel_capability+0x20>
}
    94b4:	f7f9 f93c 	bl	2730 <__stack_chk_fail>
		print("Pixel_Pixel_capability(pixel,chan,value)");
    94b8:	4805      	ldr	r0, [pc, #20]	; (94d0 <Pixel_Pixel_capability+0x38>)
}
    94ba:	b002      	add	sp, #8
    94bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		print("Pixel_Pixel_capability(pixel,chan,value)");
    94c0:	f006 b856 	b.w	f570 <_print>
}
    94c4:	429a      	cmp	r2, r3
    94c6:	d1f5      	bne.n	94b4 <Pixel_Pixel_capability+0x1c>
    94c8:	b002      	add	sp, #8
    94ca:	bd10      	pop	{r4, pc}
    94cc:	1fff89d0 	.word	0x1fff89d0
    94d0:	000148bf 	.word	0x000148bf

000094d4 <Pixel_AnimationControl_capability>:
{
    94d4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    94d6:	4c20      	ldr	r4, [pc, #128]	; (9558 <Pixel_AnimationControl_capability+0x84>)
    94d8:	4608      	mov	r0, r1
    94da:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    94dc:	4611      	mov	r1, r2
{
    94de:	6823      	ldr	r3, [r4, #0]
    94e0:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    94e2:	f7fd f92d 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    94e6:	2801      	cmp	r0, #1
    94e8:	4621      	mov	r1, r4
    94ea:	d00d      	beq.n	9508 <Pixel_AnimationControl_capability+0x34>
    94ec:	28ff      	cmp	r0, #255	; 0xff
    94ee:	d11b      	bne.n	9528 <Pixel_AnimationControl_capability+0x54>
		print("Pixel_AnimationControl_capability(func)");
    94f0:	9a01      	ldr	r2, [sp, #4]
    94f2:	6823      	ldr	r3, [r4, #0]
    94f4:	429a      	cmp	r2, r3
    94f6:	d001      	beq.n	94fc <Pixel_AnimationControl_capability+0x28>
}
    94f8:	f7f9 f91a 	bl	2730 <__stack_chk_fail>
		print("Pixel_AnimationControl_capability(func)");
    94fc:	4817      	ldr	r0, [pc, #92]	; (955c <Pixel_AnimationControl_capability+0x88>)
}
    94fe:	b003      	add	sp, #12
    9500:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		print("Pixel_AnimationControl_capability(func)");
    9504:	f006 b834 	b.w	f570 <_print>
	switch ( arg )
    9508:	782b      	ldrb	r3, [r5, #0]
    950a:	2b07      	cmp	r3, #7
    950c:	d80c      	bhi.n	9528 <Pixel_AnimationControl_capability+0x54>
    950e:	e8df f003 	tbb	[pc, r3]
    9512:	1404      	.short	0x1404
    9514:	1d1a1711 	.word	0x1d1a1711
    9518:	2008      	.short	0x2008
		switch ( Pixel_animationControl )
    951a:	4b11      	ldr	r3, [pc, #68]	; (9560 <Pixel_AnimationControl_capability+0x8c>)
    951c:	781b      	ldrb	r3, [r3, #0]
    951e:	2b01      	cmp	r3, #1
    9520:	d808      	bhi.n	9534 <Pixel_AnimationControl_capability+0x60>
			Pixel_animationControl = AnimationControl_Pause;
    9522:	4b0f      	ldr	r3, [pc, #60]	; (9560 <Pixel_AnimationControl_capability+0x8c>)
    9524:	2202      	movs	r2, #2
		Pixel_animationControl = AnimationControl_Clear;
    9526:	701a      	strb	r2, [r3, #0]
}
    9528:	9a01      	ldr	r2, [sp, #4]
    952a:	680b      	ldr	r3, [r1, #0]
    952c:	429a      	cmp	r2, r3
    952e:	d1e3      	bne.n	94f8 <Pixel_AnimationControl_capability+0x24>
    9530:	b003      	add	sp, #12
    9532:	bd30      	pop	{r4, r5, pc}
			Pixel_animationControl = AnimationControl_Forward;
    9534:	4b0a      	ldr	r3, [pc, #40]	; (9560 <Pixel_AnimationControl_capability+0x8c>)
    9536:	2200      	movs	r2, #0
    9538:	e7f5      	b.n	9526 <Pixel_AnimationControl_capability+0x52>
		Pixel_animationControl = AnimationControl_ForwardOne;
    953a:	4b09      	ldr	r3, [pc, #36]	; (9560 <Pixel_AnimationControl_capability+0x8c>)
    953c:	2201      	movs	r2, #1
    953e:	e7f2      	b.n	9526 <Pixel_AnimationControl_capability+0x52>
		Pixel_animationControl = AnimationControl_Stop;
    9540:	4b07      	ldr	r3, [pc, #28]	; (9560 <Pixel_AnimationControl_capability+0x8c>)
    9542:	2203      	movs	r2, #3
    9544:	e7ef      	b.n	9526 <Pixel_AnimationControl_capability+0x52>
		Pixel_animationControl = AnimationControl_Reset;
    9546:	4b06      	ldr	r3, [pc, #24]	; (9560 <Pixel_AnimationControl_capability+0x8c>)
    9548:	2204      	movs	r2, #4
    954a:	e7ec      	b.n	9526 <Pixel_AnimationControl_capability+0x52>
		Pixel_animationControl = AnimationControl_WipePause;
    954c:	4b04      	ldr	r3, [pc, #16]	; (9560 <Pixel_AnimationControl_capability+0x8c>)
    954e:	2205      	movs	r2, #5
    9550:	e7e9      	b.n	9526 <Pixel_AnimationControl_capability+0x52>
		Pixel_animationControl = AnimationControl_Clear;
    9552:	4b03      	ldr	r3, [pc, #12]	; (9560 <Pixel_AnimationControl_capability+0x8c>)
    9554:	2206      	movs	r2, #6
    9556:	e7e6      	b.n	9526 <Pixel_AnimationControl_capability+0x52>
    9558:	1fff89d0 	.word	0x1fff89d0
    955c:	000147b6 	.word	0x000147b6
    9560:	1fffab54 	.word	0x1fffab54

00009564 <Pixel_FadeSet_capability>:
{
    9564:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9566:	4d1a      	ldr	r5, [pc, #104]	; (95d0 <Pixel_FadeSet_capability+0x6c>)
    9568:	4608      	mov	r0, r1
    956a:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    956c:	4611      	mov	r1, r2
{
    956e:	682b      	ldr	r3, [r5, #0]
    9570:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    9572:	f7fd f8e5 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    9576:	2801      	cmp	r0, #1
    9578:	462e      	mov	r6, r5
    957a:	d00d      	beq.n	9598 <Pixel_FadeSet_capability+0x34>
    957c:	28ff      	cmp	r0, #255	; 0xff
    957e:	d120      	bne.n	95c2 <Pixel_FadeSet_capability+0x5e>
		print("Pixel_FadeSet_capability(profile,config,period)");
    9580:	9a01      	ldr	r2, [sp, #4]
    9582:	682b      	ldr	r3, [r5, #0]
    9584:	429a      	cmp	r2, r3
    9586:	d001      	beq.n	958c <Pixel_FadeSet_capability+0x28>
}
    9588:	f7f9 f8d2 	bl	2730 <__stack_chk_fail>
		print("Pixel_FadeSet_capability(profile,config,period)");
    958c:	4811      	ldr	r0, [pc, #68]	; (95d4 <Pixel_FadeSet_capability+0x70>)
}
    958e:	b002      	add	sp, #8
    9590:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Pixel_FadeSet_capability(profile,config,period)");
    9594:	f005 bfec 	b.w	f570 <_print>
	Pixel_pixel_fade_profile_entries[profile].conf[config].start = period_config->start;
    9598:	7822      	ldrb	r2, [r4, #0]
    959a:	4b0f      	ldr	r3, [pc, #60]	; (95d8 <Pixel_FadeSet_capability+0x74>)
    959c:	7860      	ldrb	r0, [r4, #1]
	const PixelPeriodConfig *period_config = &Pixel_LED_FadePeriods[period];
    959e:	78a1      	ldrb	r1, [r4, #2]
	Pixel_pixel_fade_profile_entries[profile].conf[config].start = period_config->start;
    95a0:	240c      	movs	r4, #12
    95a2:	fb04 3302 	mla	r3, r4, r2, r3
    95a6:	4a0d      	ldr	r2, [pc, #52]	; (95dc <Pixel_FadeSet_capability+0x78>)
    95a8:	5c51      	ldrb	r1, [r2, r1]
    95aa:	5c1a      	ldrb	r2, [r3, r0]
    95ac:	f3c1 0403 	ubfx	r4, r1, #0, #4
    95b0:	f364 0203 	bfi	r2, r4, #0, #4
	Pixel_pixel_fade_profile_entries[profile].conf[config].end = period_config->end;
    95b4:	0909      	lsrs	r1, r1, #4
    95b6:	f361 1207 	bfi	r2, r1, #4, #4
    95ba:	541a      	strb	r2, [r3, r0]
	Pixel_pixel_fade_profile_entries[profile].pos = 0;
    95bc:	2200      	movs	r2, #0
    95be:	605a      	str	r2, [r3, #4]
	Pixel_pixel_fade_profile_entries[profile].period_conf = PixelPeriodIndex_Off_to_On;
    95c0:	721a      	strb	r2, [r3, #8]
}
    95c2:	9a01      	ldr	r2, [sp, #4]
    95c4:	6833      	ldr	r3, [r6, #0]
    95c6:	429a      	cmp	r2, r3
    95c8:	d1de      	bne.n	9588 <Pixel_FadeSet_capability+0x24>
    95ca:	b002      	add	sp, #8
    95cc:	bd70      	pop	{r4, r5, r6, pc}
    95ce:	bf00      	nop
    95d0:	1fff89d0 	.word	0x1fff89d0
    95d4:	0001488f 	.word	0x0001488f
    95d8:	1fff96f4 	.word	0x1fff96f4
    95dc:	00015520 	.word	0x00015520

000095e0 <Pixel_FadeLayerHighlight_capability>:
{
    95e0:	b507      	push	{r0, r1, r2, lr}
    95e2:	4b08      	ldr	r3, [pc, #32]	; (9604 <Pixel_FadeLayerHighlight_capability+0x24>)
    95e4:	4608      	mov	r0, r1
    95e6:	6819      	ldr	r1, [r3, #0]
    95e8:	9101      	str	r1, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    95ea:	9901      	ldr	r1, [sp, #4]
    95ec:	681b      	ldr	r3, [r3, #0]
    95ee:	4299      	cmp	r1, r3
    95f0:	d001      	beq.n	95f6 <Pixel_FadeLayerHighlight_capability+0x16>
    95f2:	f7f9 f89d 	bl	2730 <__stack_chk_fail>
    95f6:	4611      	mov	r1, r2
}
    95f8:	b003      	add	sp, #12
    95fa:	f85d eb04 	ldr.w	lr, [sp], #4
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    95fe:	f7fd b89f 	b.w	6740 <KLL_CapabilityState>
    9602:	bf00      	nop
    9604:	1fff89d0 	.word	0x1fff89d0

00009608 <Pixel_showPixelElement>:
{
    9608:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    960a:	4e17      	ldr	r6, [pc, #92]	; (9668 <Pixel_showPixelElement+0x60>)
		print(",");
    960c:	4f17      	ldr	r7, [pc, #92]	; (966c <Pixel_showPixelElement+0x64>)
{
    960e:	6833      	ldr	r3, [r6, #0]
    9610:	9301      	str	r3, [sp, #4]
    9612:	4605      	mov	r5, r0
	print("W:");
    9614:	4816      	ldr	r0, [pc, #88]	; (9670 <Pixel_showPixelElement+0x68>)
    9616:	f005 ffab 	bl	f570 <_print>
	printInt8( elem->width );
    961a:	7828      	ldrb	r0, [r5, #0]
    961c:	f006 f812 	bl	f644 <printInt8>
	print(" C:");
    9620:	4814      	ldr	r0, [pc, #80]	; (9674 <Pixel_showPixelElement+0x6c>)
    9622:	f005 ffa5 	bl	f570 <_print>
	printInt8( elem->channels );
    9626:	7868      	ldrb	r0, [r5, #1]
    9628:	f006 f80c 	bl	f644 <printInt8>
	print(" I:");
    962c:	4812      	ldr	r0, [pc, #72]	; (9678 <Pixel_showPixelElement+0x70>)
    962e:	f005 ff9f 	bl	f570 <_print>
	printInt16( elem->indices[0] );
    9632:	8868      	ldrh	r0, [r5, #2]
    9634:	f006 f83c 	bl	f6b0 <printInt16>
	for ( uint8_t c = 1; c < elem->channels; c++ )
    9638:	2401      	movs	r4, #1
    963a:	786b      	ldrb	r3, [r5, #1]
    963c:	42a3      	cmp	r3, r4
    963e:	d805      	bhi.n	964c <Pixel_showPixelElement+0x44>
}
    9640:	9a01      	ldr	r2, [sp, #4]
    9642:	6833      	ldr	r3, [r6, #0]
    9644:	429a      	cmp	r2, r3
    9646:	d00c      	beq.n	9662 <Pixel_showPixelElement+0x5a>
    9648:	f7f9 f872 	bl	2730 <__stack_chk_fail>
		print(",");
    964c:	4638      	mov	r0, r7
    964e:	f005 ff8f 	bl	f570 <_print>
		printInt16( elem->indices[c] );
    9652:	eb05 0344 	add.w	r3, r5, r4, lsl #1
	for ( uint8_t c = 1; c < elem->channels; c++ )
    9656:	3401      	adds	r4, #1
		printInt16( elem->indices[c] );
    9658:	8858      	ldrh	r0, [r3, #2]
    965a:	f006 f829 	bl	f6b0 <printInt16>
	for ( uint8_t c = 1; c < elem->channels; c++ )
    965e:	b2e4      	uxtb	r4, r4
    9660:	e7eb      	b.n	963a <Pixel_showPixelElement+0x32>
}
    9662:	b003      	add	sp, #12
    9664:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9666:	bf00      	nop
    9668:	1fff89d0 	.word	0x1fff89d0
    966c:	00012bba 	.word	0x00012bba
    9670:	00014cfd 	.word	0x00014cfd
    9674:	00014d00 	.word	0x00014d00
    9678:	00014d04 	.word	0x00014d04

0000967c <Pixel_clearAnimations>:
{
    967c:	b513      	push	{r0, r1, r4, lr}
    967e:	4a0b      	ldr	r2, [pc, #44]	; (96ac <Pixel_clearAnimations+0x30>)
	Pixel_AnimationStack.size = 0;
    9680:	490b      	ldr	r1, [pc, #44]	; (96b0 <Pixel_clearAnimations+0x34>)
{
    9682:	6813      	ldr	r3, [r2, #0]
    9684:	9301      	str	r3, [sp, #4]
		Pixel_AnimationElement_Stor[pos].index = 0xFFFF;
    9686:	4c0b      	ldr	r4, [pc, #44]	; (96b4 <Pixel_clearAnimations+0x38>)
	Pixel_AnimationStack.size = 0;
    9688:	2300      	movs	r3, #0
    968a:	800b      	strh	r3, [r1, #0]
		Pixel_AnimationElement_Stor[pos].index = 0xFFFF;
    968c:	f64f 70ff 	movw	r0, #65535	; 0xffff
    9690:	1919      	adds	r1, r3, r4
    9692:	3310      	adds	r3, #16
	for ( uint16_t pos = 0; pos < Pixel_AnimationStackSize; pos++ )
    9694:	f5b3 7fa0 	cmp.w	r3, #320	; 0x140
		Pixel_AnimationElement_Stor[pos].index = 0xFFFF;
    9698:	8088      	strh	r0, [r1, #4]
	for ( uint16_t pos = 0; pos < Pixel_AnimationStackSize; pos++ )
    969a:	d1f9      	bne.n	9690 <Pixel_clearAnimations+0x14>
}
    969c:	9901      	ldr	r1, [sp, #4]
    969e:	6813      	ldr	r3, [r2, #0]
    96a0:	4299      	cmp	r1, r3
    96a2:	d001      	beq.n	96a8 <Pixel_clearAnimations+0x2c>
    96a4:	f7f9 f844 	bl	2730 <__stack_chk_fail>
    96a8:	b002      	add	sp, #8
    96aa:	bd10      	pop	{r4, pc}
    96ac:	1fff89d0 	.word	0x1fff89d0
    96b0:	1fffab00 	.word	0x1fffab00
    96b4:	1fffab58 	.word	0x1fffab58

000096b8 <Pixel_lookupAnimation>:
{
    96b8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    96ba:	4a0d      	ldr	r2, [pc, #52]	; (96f0 <Pixel_lookupAnimation+0x38>)
    96bc:	6813      	ldr	r3, [r2, #0]
    96be:	9301      	str	r3, [sp, #4]
	for ( ; pos < Pixel_AnimationStack.size; pos++ )
    96c0:	4b0c      	ldr	r3, [pc, #48]	; (96f4 <Pixel_lookupAnimation+0x3c>)
{
    96c2:	4605      	mov	r5, r0
	for ( ; pos < Pixel_AnimationStack.size; pos++ )
    96c4:	881c      	ldrh	r4, [r3, #0]
    96c6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    96ca:	428c      	cmp	r4, r1
    96cc:	d806      	bhi.n	96dc <Pixel_lookupAnimation+0x24>
	return NULL;
    96ce:	2000      	movs	r0, #0
}
    96d0:	9901      	ldr	r1, [sp, #4]
    96d2:	6813      	ldr	r3, [r2, #0]
    96d4:	4299      	cmp	r1, r3
    96d6:	d009      	beq.n	96ec <Pixel_lookupAnimation+0x34>
    96d8:	f7f9 f82a 	bl	2730 <__stack_chk_fail>
		if ( Pixel_AnimationStack.stack[pos]->index == index )
    96dc:	f853 0f04 	ldr.w	r0, [r3, #4]!
    96e0:	8886      	ldrh	r6, [r0, #4]
    96e2:	42ae      	cmp	r6, r5
    96e4:	d0f4      	beq.n	96d0 <Pixel_lookupAnimation+0x18>
	for ( ; pos < Pixel_AnimationStack.size; pos++ )
    96e6:	3101      	adds	r1, #1
    96e8:	b289      	uxth	r1, r1
    96ea:	e7ee      	b.n	96ca <Pixel_lookupAnimation+0x12>
}
    96ec:	b002      	add	sp, #8
    96ee:	bd70      	pop	{r4, r5, r6, pc}
    96f0:	1fff89d0 	.word	0x1fff89d0
    96f4:	1fffab00 	.word	0x1fffab00

000096f8 <Pixel_addAnimation>:
{
    96f8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    96fa:	4d32      	ldr	r5, [pc, #200]	; (97c4 <Pixel_addAnimation+0xcc>)
	switch ( element->replace )
    96fc:	7b86      	ldrb	r6, [r0, #14]
{
    96fe:	682b      	ldr	r3, [r5, #0]
    9700:	9301      	str	r3, [sp, #4]
	switch ( element->replace )
    9702:	1e73      	subs	r3, r6, #1
{
    9704:	4604      	mov	r4, r0
    9706:	460f      	mov	r7, r1
	switch ( element->replace )
    9708:	2b03      	cmp	r3, #3
    970a:	d830      	bhi.n	976e <Pixel_addAnimation+0x76>
    970c:	e8df f003 	tbb	[pc, r3]
    9710:	2d250202 	.word	0x2d250202
		found = Pixel_lookupAnimation( element->index, 0 );
    9714:	2100      	movs	r1, #0
    9716:	8880      	ldrh	r0, [r0, #4]
    9718:	f7ff ffce 	bl	96b8 <Pixel_lookupAnimation>
		if ( found != NULL && ( found->trigger == element->trigger || element->replace == AnimationReplaceType_All ) )
    971c:	b1e8      	cbz	r0, 975a <Pixel_addAnimation+0x62>
    971e:	6802      	ldr	r2, [r0, #0]
    9720:	6823      	ldr	r3, [r4, #0]
    9722:	429a      	cmp	r2, r3
    9724:	d001      	beq.n	972a <Pixel_addAnimation+0x32>
    9726:	2e02      	cmp	r6, #2
    9728:	d117      	bne.n	975a <Pixel_addAnimation+0x62>
				found->pos = element->pos;
    972a:	88e3      	ldrh	r3, [r4, #6]
    972c:	80c3      	strh	r3, [r0, #6]
				found->subpos = element->subpos;
    972e:	7a23      	ldrb	r3, [r4, #8]
    9730:	7203      	strb	r3, [r0, #8]
				found->loops = element->loops;
    9732:	7a63      	ldrb	r3, [r4, #9]
    9734:	7243      	strb	r3, [r0, #9]
				found->pfunc = element->pfunc;
    9736:	7b63      	ldrb	r3, [r4, #13]
    9738:	7343      	strb	r3, [r0, #13]
				found->ffunc = element->ffunc;
    973a:	7b23      	ldrb	r3, [r4, #12]
    973c:	7303      	strb	r3, [r0, #12]
				found->framedelay = element->framedelay;
    973e:	7aa3      	ldrb	r3, [r4, #10]
    9740:	7283      	strb	r3, [r0, #10]
				found->frameoption = element->frameoption;
    9742:	7ae3      	ldrb	r3, [r4, #11]
    9744:	72c3      	strb	r3, [r0, #11]
				found->state = element->state;
    9746:	7be3      	ldrb	r3, [r4, #15]
				found->replace = element->replace;
    9748:	7386      	strb	r6, [r0, #14]
				found->state = element->state;
    974a:	73c3      	strb	r3, [r0, #15]
			return 0;
    974c:	2000      	movs	r0, #0
}
    974e:	9a01      	ldr	r2, [sp, #4]
    9750:	682b      	ldr	r3, [r5, #0]
    9752:	429a      	cmp	r2, r3
    9754:	d034      	beq.n	97c0 <Pixel_addAnimation+0xc8>
    9756:	f7f8 ffeb 	bl	2730 <__stack_chk_fail>
		found = Pixel_lookupAnimation( element->index, 0 );
    975a:	2100      	movs	r1, #0
    975c:	88a0      	ldrh	r0, [r4, #4]
    975e:	f7ff ffab 	bl	96b8 <Pixel_lookupAnimation>
		switch ( cstate )
    9762:	2f01      	cmp	r7, #1
    9764:	d00b      	beq.n	977e <Pixel_addAnimation+0x86>
    9766:	2f02      	cmp	r7, #2
    9768:	d00c      	beq.n	9784 <Pixel_addAnimation+0x8c>
		Pixel_clearAnimations();
    976a:	f7ff ff87 	bl	967c <Pixel_clearAnimations>
	if ( Pixel_AnimationStack.size >= Pixel_AnimationStackSize )
    976e:	4b16      	ldr	r3, [pc, #88]	; (97c8 <Pixel_addAnimation+0xd0>)
    9770:	8819      	ldrh	r1, [r3, #0]
    9772:	2913      	cmp	r1, #19
    9774:	d90a      	bls.n	978c <Pixel_addAnimation+0x94>
		warn_print("Animation stack is full...");
    9776:	4815      	ldr	r0, [pc, #84]	; (97cc <Pixel_addAnimation+0xd4>)
		erro_print("Animation Stack memory leak...this is a bug!");
    9778:	f005 fefa 	bl	f570 <_print>
    977c:	e7e6      	b.n	974c <Pixel_addAnimation+0x54>
			if ( found )
    977e:	2800      	cmp	r0, #0
    9780:	d1d3      	bne.n	972a <Pixel_addAnimation+0x32>
    9782:	e7f2      	b.n	976a <Pixel_addAnimation+0x72>
			if ( found )
    9784:	2800      	cmp	r0, #0
    9786:	d0e2      	beq.n	974e <Pixel_addAnimation+0x56>
				found->state = AnimationPlayState_Stop;
    9788:	73c7      	strb	r7, [r0, #15]
    978a:	e7df      	b.n	974c <Pixel_addAnimation+0x54>
		if ( Pixel_AnimationElement_Stor[pos].index == 0xFFFF )
    978c:	4e10      	ldr	r6, [pc, #64]	; (97d0 <Pixel_addAnimation+0xd8>)
    978e:	2200      	movs	r2, #0
    9790:	f64f 77ff 	movw	r7, #65535	; 0xffff
    9794:	eb06 1002 	add.w	r0, r6, r2, lsl #4
    9798:	f8b0 c004 	ldrh.w	ip, [r0, #4]
    979c:	45bc      	cmp	ip, r7
    979e:	d004      	beq.n	97aa <Pixel_addAnimation+0xb2>
    97a0:	3201      	adds	r2, #1
	for ( ; pos < Pixel_AnimationStackSize; pos++ )
    97a2:	2a14      	cmp	r2, #20
    97a4:	d1f6      	bne.n	9794 <Pixel_addAnimation+0x9c>
		erro_print("Animation Stack memory leak...this is a bug!");
    97a6:	480b      	ldr	r0, [pc, #44]	; (97d4 <Pixel_addAnimation+0xdc>)
    97a8:	e7e6      	b.n	9778 <Pixel_addAnimation+0x80>
	Pixel_AnimationStack.stack[Pixel_AnimationStack.size++] = &Pixel_AnimationElement_Stor[pos];
    97aa:	1c4a      	adds	r2, r1, #1
    97ac:	801a      	strh	r2, [r3, #0]
    97ae:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	memcpy( &Pixel_AnimationElement_Stor[pos], element, sizeof(AnimationStackElement) );
    97b2:	2210      	movs	r2, #16
    97b4:	4621      	mov	r1, r4
	Pixel_AnimationStack.stack[Pixel_AnimationStack.size++] = &Pixel_AnimationElement_Stor[pos];
    97b6:	6058      	str	r0, [r3, #4]
	memcpy( &Pixel_AnimationElement_Stor[pos], element, sizeof(AnimationStackElement) );
    97b8:	f7f8 ffde 	bl	2778 <memcpy>
	return 1;
    97bc:	2001      	movs	r0, #1
    97be:	e7c6      	b.n	974e <Pixel_addAnimation+0x56>
}
    97c0:	b003      	add	sp, #12
    97c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    97c4:	1fff89d0 	.word	0x1fff89d0
    97c8:	1fffab00 	.word	0x1fffab00
    97cc:	00014918 	.word	0x00014918
    97d0:	1fffab58 	.word	0x1fffab58
    97d4:	0001494a 	.word	0x0001494a

000097d8 <Pixel_AnimationIndex_capability>:
{
    97d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    97dc:	4d18      	ldr	r5, [pc, #96]	; (9840 <Pixel_AnimationIndex_capability+0x68>)
    97de:	b086      	sub	sp, #24
    97e0:	4607      	mov	r7, r0
    97e2:	4698      	mov	r8, r3
    97e4:	4608      	mov	r0, r1
    97e6:	682b      	ldr	r3, [r5, #0]
    97e8:	9305      	str	r3, [sp, #20]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    97ea:	4611      	mov	r1, r2
    97ec:	f7fc ffa8 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    97f0:	4606      	mov	r6, r0
    97f2:	b130      	cbz	r0, 9802 <Pixel_AnimationIndex_capability+0x2a>
    97f4:	2802      	cmp	r0, #2
    97f6:	d90a      	bls.n	980e <Pixel_AnimationIndex_capability+0x36>
    97f8:	28ff      	cmp	r0, #255	; 0xff
    97fa:	d102      	bne.n	9802 <Pixel_AnimationIndex_capability+0x2a>
		print("Pixel_AnimationIndex_capability(settingindex)");
    97fc:	4811      	ldr	r0, [pc, #68]	; (9844 <Pixel_AnimationIndex_capability+0x6c>)
		print( NL );
    97fe:	f005 feb7 	bl	f570 <_print>
}
    9802:	9a05      	ldr	r2, [sp, #20]
    9804:	682b      	ldr	r3, [r5, #0]
    9806:	429a      	cmp	r2, r3
    9808:	d017      	beq.n	983a <Pixel_AnimationIndex_capability+0x62>
    980a:	f7f8 ff91 	bl	2730 <__stack_chk_fail>
	uint16_t index = *(uint16_t*)(&args[0]);
    980e:	f8b8 4000 	ldrh.w	r4, [r8]
	if ( index >= Pixel_AnimationSettingsNum_KLL )
    9812:	b13c      	cbz	r4, 9824 <Pixel_AnimationIndex_capability+0x4c>
		warn_msg("Invalid AnimationSetting index: ");
    9814:	480c      	ldr	r0, [pc, #48]	; (9848 <Pixel_AnimationIndex_capability+0x70>)
    9816:	f005 feab 	bl	f570 <_print>
		printInt16( index );
    981a:	4620      	mov	r0, r4
    981c:	f005 ff48 	bl	f6b0 <printInt16>
		print( NL );
    9820:	480a      	ldr	r0, [pc, #40]	; (984c <Pixel_AnimationIndex_capability+0x74>)
    9822:	e7ec      	b.n	97fe <Pixel_AnimationIndex_capability+0x26>
	AnimationStackElement element = Pixel_AnimationSettings[ index ];
    9824:	4b0a      	ldr	r3, [pc, #40]	; (9850 <Pixel_AnimationIndex_capability+0x78>)
    9826:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    9828:	ac01      	add	r4, sp, #4
    982a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	Pixel_addAnimation( &element, cstate );
    982e:	4631      	mov	r1, r6
    9830:	4620      	mov	r0, r4
	element.trigger = trigger;
    9832:	9701      	str	r7, [sp, #4]
	Pixel_addAnimation( &element, cstate );
    9834:	f7ff ff60 	bl	96f8 <Pixel_addAnimation>
    9838:	e7e3      	b.n	9802 <Pixel_AnimationIndex_capability+0x2a>
}
    983a:	b006      	add	sp, #24
    983c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9840:	1fff89d0 	.word	0x1fff89d0
    9844:	000147de 	.word	0x000147de
    9848:	0001480c 	.word	0x0001480c
    984c:	00015df4 	.word	0x00015df4
    9850:	000153ac 	.word	0x000153ac

00009854 <Pixel_Animation_capability>:
{
    9854:	b570      	push	{r4, r5, r6, lr}
    9856:	4d1b      	ldr	r5, [pc, #108]	; (98c4 <Pixel_Animation_capability+0x70>)
    9858:	b086      	sub	sp, #24
    985a:	4606      	mov	r6, r0
    985c:	461c      	mov	r4, r3
    985e:	4608      	mov	r0, r1
    9860:	682b      	ldr	r3, [r5, #0]
    9862:	9305      	str	r3, [sp, #20]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    9864:	4611      	mov	r1, r2
    9866:	f7fc ff6b 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    986a:	2801      	cmp	r0, #1
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    986c:	4601      	mov	r1, r0
	switch ( cstate )
    986e:	d00a      	beq.n	9886 <Pixel_Animation_capability+0x32>
    9870:	28ff      	cmp	r0, #255	; 0xff
    9872:	d102      	bne.n	987a <Pixel_Animation_capability+0x26>
		print("Pixel_Animation_capability(index,loops,pfunc,framedelay,frameoption,replace)");
    9874:	4814      	ldr	r0, [pc, #80]	; (98c8 <Pixel_Animation_capability+0x74>)
    9876:	f005 fe7b 	bl	f570 <_print>
}
    987a:	9a05      	ldr	r2, [sp, #20]
    987c:	682b      	ldr	r3, [r5, #0]
    987e:	429a      	cmp	r2, r3
    9880:	d01d      	beq.n	98be <Pixel_Animation_capability+0x6a>
    9882:	f7f8 ff55 	bl	2730 <__stack_chk_fail>
	element.pos = 0; // TODO (HaaTa) Start at specific frame
    9886:	2300      	movs	r3, #0
    9888:	f8ad 300a 	strh.w	r3, [sp, #10]
	element.subpos = 0;
    988c:	f88d 300c 	strb.w	r3, [sp, #12]
	element.index = *(uint16_t*)(&args[0]);
    9890:	8823      	ldrh	r3, [r4, #0]
    9892:	f8ad 3008 	strh.w	r3, [sp, #8]
	element.loops = *(uint8_t*)(&args[2]);
    9896:	78a3      	ldrb	r3, [r4, #2]
    9898:	f88d 300d 	strb.w	r3, [sp, #13]
	element.pfunc = *(uint8_t*)(&args[3]);
    989c:	78e3      	ldrb	r3, [r4, #3]
    989e:	f88d 3011 	strb.w	r3, [sp, #17]
	element.framedelay = *(uint8_t*)(&args[4]);
    98a2:	7923      	ldrb	r3, [r4, #4]
    98a4:	f88d 300e 	strb.w	r3, [sp, #14]
	element.frameoption = *(uint8_t*)(&args[5]);
    98a8:	7963      	ldrb	r3, [r4, #5]
    98aa:	f88d 300f 	strb.w	r3, [sp, #15]
	Pixel_addAnimation( &element, cstate );
    98ae:	a801      	add	r0, sp, #4
	element.replace = *(uint8_t*)(&args[6]);
    98b0:	79a3      	ldrb	r3, [r4, #6]
	element.trigger = trigger;
    98b2:	9601      	str	r6, [sp, #4]
	element.replace = *(uint8_t*)(&args[6]);
    98b4:	f88d 3012 	strb.w	r3, [sp, #18]
	Pixel_addAnimation( &element, cstate );
    98b8:	f7ff ff1e 	bl	96f8 <Pixel_addAnimation>
    98bc:	e7dd      	b.n	987a <Pixel_Animation_capability+0x26>
}
    98be:	b006      	add	sp, #24
    98c0:	bd70      	pop	{r4, r5, r6, pc}
    98c2:	bf00      	nop
    98c4:	1fff89d0 	.word	0x1fff89d0
    98c8:	00014842 	.word	0x00014842

000098cc <Pixel_addDefaultAnimation>:
{
    98cc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    98ce:	4d11      	ldr	r5, [pc, #68]	; (9914 <Pixel_addDefaultAnimation+0x48>)
    98d0:	682b      	ldr	r3, [r5, #0]
    98d2:	9301      	str	r3, [sp, #4]
	if ( index >= Pixel_AnimationSettingsNum_KLL )
    98d4:	4604      	mov	r4, r0
    98d6:	b180      	cbz	r0, 98fa <Pixel_addDefaultAnimation+0x2e>
		warn_msg("Invalid AnimationSetting index: ");
    98d8:	480f      	ldr	r0, [pc, #60]	; (9918 <Pixel_addDefaultAnimation+0x4c>)
    98da:	f005 fe49 	bl	f570 <_print>
		printInt32( index );
    98de:	4620      	mov	r0, r4
    98e0:	f005 ff1c 	bl	f71c <printInt32>
		print( NL );
    98e4:	480d      	ldr	r0, [pc, #52]	; (991c <Pixel_addDefaultAnimation+0x50>)
    98e6:	f005 fe43 	bl	f570 <_print>
}
    98ea:	9a01      	ldr	r2, [sp, #4]
    98ec:	682b      	ldr	r3, [r5, #0]
    98ee:	429a      	cmp	r2, r3
    98f0:	f04f 0000 	mov.w	r0, #0
    98f4:	d00c      	beq.n	9910 <Pixel_addDefaultAnimation+0x44>
    98f6:	f7f8 ff1b 	bl	2730 <__stack_chk_fail>
	return Pixel_addAnimation( (AnimationStackElement*)&Pixel_AnimationSettings[ index ], CapabilityState_None );
    98fa:	9a01      	ldr	r2, [sp, #4]
    98fc:	682b      	ldr	r3, [r5, #0]
    98fe:	429a      	cmp	r2, r3
    9900:	d1f9      	bne.n	98f6 <Pixel_addDefaultAnimation+0x2a>
    9902:	4601      	mov	r1, r0
    9904:	4806      	ldr	r0, [pc, #24]	; (9920 <Pixel_addDefaultAnimation+0x54>)
}
    9906:	b003      	add	sp, #12
    9908:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return Pixel_addAnimation( (AnimationStackElement*)&Pixel_AnimationSettings[ index ], CapabilityState_None );
    990c:	f7ff bef4 	b.w	96f8 <Pixel_addAnimation>
}
    9910:	b003      	add	sp, #12
    9912:	bd30      	pop	{r4, r5, pc}
    9914:	1fff89d0 	.word	0x1fff89d0
    9918:	0001480c 	.word	0x0001480c
    991c:	00015df4 	.word	0x00015df4
    9920:	000153ac 	.word	0x000153ac

00009924 <Pixel_bufferMap>:
{
    9924:	b537      	push	{r0, r1, r2, r4, r5, lr}
    9926:	4d15      	ldr	r5, [pc, #84]	; (997c <Pixel_bufferMap+0x58>)
	if      ( channel < 144 ) return &Pixel_Buffers[0];
    9928:	288f      	cmp	r0, #143	; 0x8f
{
    992a:	682a      	ldr	r2, [r5, #0]
    992c:	9201      	str	r2, [sp, #4]
    992e:	4604      	mov	r4, r0
	if      ( channel < 144 ) return &Pixel_Buffers[0];
    9930:	d919      	bls.n	9966 <Pixel_bufferMap+0x42>
	else if ( channel < 288 ) return &Pixel_Buffers[1];
    9932:	f5b0 7f90 	cmp.w	r0, #288	; 0x120
    9936:	d318      	bcc.n	996a <Pixel_bufferMap+0x46>
	else if ( channel < 432 ) return &Pixel_Buffers[2];
    9938:	f5b0 7fd8 	cmp.w	r0, #432	; 0x1b0
    993c:	d317      	bcc.n	996e <Pixel_bufferMap+0x4a>
	else if ( channel < 576 ) return &Pixel_Buffers[3];
    993e:	f5b0 7f10 	cmp.w	r0, #576	; 0x240
    9942:	d316      	bcc.n	9972 <Pixel_bufferMap+0x4e>
	erro_msg("Invalid channel: ");
    9944:	480e      	ldr	r0, [pc, #56]	; (9980 <Pixel_bufferMap+0x5c>)
    9946:	f005 fe13 	bl	f570 <_print>
	printHex( channel );
    994a:	2101      	movs	r1, #1
    994c:	4620      	mov	r0, r4
    994e:	f005 ff35 	bl	f7bc <printHex_op>
	print( NL );
    9952:	480c      	ldr	r0, [pc, #48]	; (9984 <Pixel_bufferMap+0x60>)
    9954:	f005 fe0c 	bl	f570 <_print>
    9958:	2000      	movs	r0, #0
}
    995a:	9a01      	ldr	r2, [sp, #4]
    995c:	682b      	ldr	r3, [r5, #0]
    995e:	429a      	cmp	r2, r3
    9960:	d009      	beq.n	9976 <Pixel_bufferMap+0x52>
    9962:	f7f8 fee5 	bl	2730 <__stack_chk_fail>
	if      ( channel < 144 ) return &Pixel_Buffers[0];
    9966:	4808      	ldr	r0, [pc, #32]	; (9988 <Pixel_bufferMap+0x64>)
    9968:	e7f7      	b.n	995a <Pixel_bufferMap+0x36>
	else if ( channel < 288 ) return &Pixel_Buffers[1];
    996a:	4808      	ldr	r0, [pc, #32]	; (998c <Pixel_bufferMap+0x68>)
    996c:	e7f5      	b.n	995a <Pixel_bufferMap+0x36>
	else if ( channel < 432 ) return &Pixel_Buffers[2];
    996e:	4808      	ldr	r0, [pc, #32]	; (9990 <Pixel_bufferMap+0x6c>)
    9970:	e7f3      	b.n	995a <Pixel_bufferMap+0x36>
	else if ( channel < 576 ) return &Pixel_Buffers[3];
    9972:	4808      	ldr	r0, [pc, #32]	; (9994 <Pixel_bufferMap+0x70>)
    9974:	e7f1      	b.n	995a <Pixel_bufferMap+0x36>
}
    9976:	b003      	add	sp, #12
    9978:	bd30      	pop	{r4, r5, pc}
    997a:	bf00      	nop
    997c:	1fff89d0 	.word	0x1fff89d0
    9980:	0001498e 	.word	0x0001498e
    9984:	00015df4 	.word	0x00015df4
    9988:	1fff8e34 	.word	0x1fff8e34
    998c:	1fff8e3c 	.word	0x1fff8e3c
    9990:	1fff8e44 	.word	0x1fff8e44
    9994:	1fff8e4c 	.word	0x1fff8e4c

00009998 <LED_bufferMap>:
{
    9998:	b537      	push	{r0, r1, r2, r4, r5, lr}
    999a:	4d15      	ldr	r5, [pc, #84]	; (99f0 <LED_bufferMap+0x58>)
	if      ( channel < 144 ) return &LED_Buffers[0];
    999c:	288f      	cmp	r0, #143	; 0x8f
{
    999e:	682a      	ldr	r2, [r5, #0]
    99a0:	9201      	str	r2, [sp, #4]
    99a2:	4604      	mov	r4, r0
	if      ( channel < 144 ) return &LED_Buffers[0];
    99a4:	d919      	bls.n	99da <LED_bufferMap+0x42>
	else if ( channel < 288 ) return &LED_Buffers[1];
    99a6:	f5b0 7f90 	cmp.w	r0, #288	; 0x120
    99aa:	d318      	bcc.n	99de <LED_bufferMap+0x46>
	else if ( channel < 432 ) return &LED_Buffers[2];
    99ac:	f5b0 7fd8 	cmp.w	r0, #432	; 0x1b0
    99b0:	d317      	bcc.n	99e2 <LED_bufferMap+0x4a>
	else if ( channel < 576 ) return &LED_Buffers[3];
    99b2:	f5b0 7f10 	cmp.w	r0, #576	; 0x240
    99b6:	d316      	bcc.n	99e6 <LED_bufferMap+0x4e>
	erro_msg("Invalid channel (LED): ");
    99b8:	480e      	ldr	r0, [pc, #56]	; (99f4 <LED_bufferMap+0x5c>)
    99ba:	f005 fdd9 	bl	f570 <_print>
	printHex( channel );
    99be:	2101      	movs	r1, #1
    99c0:	4620      	mov	r0, r4
    99c2:	f005 fefb 	bl	f7bc <printHex_op>
	print( NL );
    99c6:	480c      	ldr	r0, [pc, #48]	; (99f8 <LED_bufferMap+0x60>)
    99c8:	f005 fdd2 	bl	f570 <_print>
    99cc:	2000      	movs	r0, #0
}
    99ce:	9a01      	ldr	r2, [sp, #4]
    99d0:	682b      	ldr	r3, [r5, #0]
    99d2:	429a      	cmp	r2, r3
    99d4:	d009      	beq.n	99ea <LED_bufferMap+0x52>
    99d6:	f7f8 feab 	bl	2730 <__stack_chk_fail>
	if      ( channel < 144 ) return &LED_Buffers[0];
    99da:	4808      	ldr	r0, [pc, #32]	; (99fc <LED_bufferMap+0x64>)
    99dc:	e7f7      	b.n	99ce <LED_bufferMap+0x36>
	else if ( channel < 288 ) return &LED_Buffers[1];
    99de:	4808      	ldr	r0, [pc, #32]	; (9a00 <LED_bufferMap+0x68>)
    99e0:	e7f5      	b.n	99ce <LED_bufferMap+0x36>
	else if ( channel < 432 ) return &LED_Buffers[2];
    99e2:	4808      	ldr	r0, [pc, #32]	; (9a04 <LED_bufferMap+0x6c>)
    99e4:	e7f3      	b.n	99ce <LED_bufferMap+0x36>
	else if ( channel < 576 ) return &LED_Buffers[3];
    99e6:	4808      	ldr	r0, [pc, #32]	; (9a08 <LED_bufferMap+0x70>)
    99e8:	e7f1      	b.n	99ce <LED_bufferMap+0x36>
}
    99ea:	b003      	add	sp, #12
    99ec:	bd30      	pop	{r4, r5, pc}
    99ee:	bf00      	nop
    99f0:	1fff89d0 	.word	0x1fff89d0
    99f4:	00014789 	.word	0x00014789
    99f8:	00015df4 	.word	0x00015df4
    99fc:	1fff8e28 	.word	0x1fff8e28
    9a00:	1fff8e30 	.word	0x1fff8e30
    9a04:	1fff8e38 	.word	0x1fff8e38
    9a08:	1fff8e40 	.word	0x1fff8e40

00009a0c <Pixel_pixelEvaluation>:
{
    9a0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9a10:	4ba6      	ldr	r3, [pc, #664]	; (9cac <Pixel_pixelEvaluation+0x2a0>)
    9a12:	b085      	sub	sp, #20
    9a14:	681a      	ldr	r2, [r3, #0]
    9a16:	9203      	str	r2, [sp, #12]
    9a18:	4607      	mov	r7, r0
	if ( elem == 0 )
    9a1a:	4688      	mov	r8, r1
    9a1c:	9300      	str	r3, [sp, #0]
    9a1e:	b139      	cbz	r1, 9a30 <Pixel_pixelEvaluation+0x24>
    9a20:	784b      	ldrb	r3, [r1, #1]
    9a22:	1c8e      	adds	r6, r1, #2
    9a24:	eb06 0a43 	add.w	sl, r6, r3, lsl #1
	uint8_t position_iter = 0;
    9a28:	f04f 0b00 	mov.w	fp, #0
	for ( uint8_t ch = 0; ch < channels; ch++ )
    9a2c:	4556      	cmp	r6, sl
    9a2e:	d107      	bne.n	9a40 <Pixel_pixelEvaluation+0x34>
}
    9a30:	9b00      	ldr	r3, [sp, #0]
    9a32:	9a03      	ldr	r2, [sp, #12]
    9a34:	681b      	ldr	r3, [r3, #0]
    9a36:	429a      	cmp	r2, r3
    9a38:	f000 8182 	beq.w	9d40 <Pixel_pixelEvaluation+0x334>
    9a3c:	f7f8 fe78 	bl	2730 <__stack_chk_fail>
		uint16_t ch_pos = elem->indices[ch];
    9a40:	f836 9b02 	ldrh.w	r9, [r6], #2
		PixelBuf *pixbuf = Pixel_bufferMap( ch_pos );
    9a44:	4648      	mov	r0, r9
    9a46:	f7ff ff6d 	bl	9924 <Pixel_bufferMap>
		if ( pixbuf == 0 )
    9a4a:	4604      	mov	r4, r0
    9a4c:	2800      	cmp	r0, #0
    9a4e:	d0ef      	beq.n	9a30 <Pixel_pixelEvaluation+0x24>
		switch ( elem->width )
    9a50:	f898 0000 	ldrb.w	r0, [r8]
		PixelChange change = (PixelChange)mod->data[ position_iter++ ];
    9a54:	eb07 010b 	add.w	r1, r7, fp
    9a58:	f10b 0501 	add.w	r5, fp, #1
		switch ( elem->width )
    9a5c:	2810      	cmp	r0, #16
		PixelChange change = (PixelChange)mod->data[ position_iter++ ];
    9a5e:	b2ed      	uxtb	r5, r5
    9a60:	7949      	ldrb	r1, [r1, #5]
		switch ( elem->width )
    9a62:	d014      	beq.n	9a8e <Pixel_pixelEvaluation+0x82>
    9a64:	2820      	cmp	r0, #32
    9a66:	d01c      	beq.n	9aa2 <Pixel_pixelEvaluation+0x96>
    9a68:	2808      	cmp	r0, #8
    9a6a:	d12b      	bne.n	9ac4 <Pixel_pixelEvaluation+0xb8>
			mod_value = mod->data[ position_iter++ ];
    9a6c:	443d      	add	r5, r7
    9a6e:	f10b 0202 	add.w	r2, fp, #2
    9a72:	7968      	ldrb	r0, [r5, #5]
    9a74:	b2d5      	uxtb	r5, r2
		switch ( change )
    9a76:	2906      	cmp	r1, #6
    9a78:	f200 8160 	bhi.w	9d3c <Pixel_pixelEvaluation+0x330>
    9a7c:	e8df f011 	tbh	[pc, r1, lsl #1]
    9a80:	00490029 	.word	0x00490029
    9a84:	00d8006e 	.word	0x00d8006e
    9a88:	008e0126 	.word	0x008e0126
    9a8c:	00b3      	.short	0x00b3
				( mod->data[ position_iter + 2 ] << 8 );
    9a8e:	443d      	add	r5, r7
    9a90:	f895 c007 	ldrb.w	ip, [r5, #7]
			mod_value = mod->data[ position_iter + 1 ] |
    9a94:	79a8      	ldrb	r0, [r5, #6]
			position_iter += 2;
    9a96:	f10b 0503 	add.w	r5, fp, #3
			mod_value = mod->data[ position_iter + 1 ] |
    9a9a:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
			position_iter += 4;
    9a9e:	b2ed      	uxtb	r5, r5
			break;
    9aa0:	e7e9      	b.n	9a76 <Pixel_pixelEvaluation+0x6a>
				( mod->data[ position_iter + 2 ] << 8 ) |
    9aa2:	443d      	add	r5, r7
				( mod->data[ position_iter + 3 ] << 16 ) |
    9aa4:	7a28      	ldrb	r0, [r5, #8]
				( mod->data[ position_iter + 2 ] << 8 ) |
    9aa6:	f895 c007 	ldrb.w	ip, [r5, #7]
				( mod->data[ position_iter + 3 ] << 16 ) |
    9aaa:	0400      	lsls	r0, r0, #16
				( mod->data[ position_iter + 2 ] << 8 ) |
    9aac:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
			mod_value = mod->data[ position_iter + 1 ] |
    9ab0:	f895 c006 	ldrb.w	ip, [r5, #6]
				( mod->data[ position_iter + 4 ] << 24 );
    9ab4:	7a6d      	ldrb	r5, [r5, #9]
				( mod->data[ position_iter + 2 ] << 8 ) |
    9ab6:	ea40 000c 	orr.w	r0, r0, ip
				( mod->data[ position_iter + 3 ] << 16 ) |
    9aba:	ea40 6005 	orr.w	r0, r0, r5, lsl #24
			position_iter += 4;
    9abe:	f10b 0505 	add.w	r5, fp, #5
    9ac2:	e7ec      	b.n	9a9e <Pixel_pixelEvaluation+0x92>
			warn_print("Invalid PixelElement width mapping");
    9ac4:	487a      	ldr	r0, [pc, #488]	; (9cb0 <Pixel_pixelEvaluation+0x2a4>)
    9ac6:	9101      	str	r1, [sp, #4]
    9ac8:	f005 fd52 	bl	f570 <_print>
		uint32_t mod_value = 0;
    9acc:	2000      	movs	r0, #0
    9ace:	9901      	ldr	r1, [sp, #4]
			break;
    9ad0:	e7d1      	b.n	9a76 <Pixel_pixelEvaluation+0x6a>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, = );
    9ad2:	7862      	ldrb	r2, [r4, #1]
    9ad4:	2a10      	cmp	r2, #16
    9ad6:	d00a      	beq.n	9aee <Pixel_pixelEvaluation+0xe2>
    9ad8:	2a20      	cmp	r2, #32
    9ada:	d00f      	beq.n	9afc <Pixel_pixelEvaluation+0xf0>
    9adc:	2a08      	cmp	r2, #8
    9ade:	d114      	bne.n	9b0a <Pixel_pixelEvaluation+0xfe>
    9ae0:	8862      	ldrh	r2, [r4, #2]
    9ae2:	eba9 0302 	sub.w	r3, r9, r2
    9ae6:	6862      	ldr	r2, [r4, #4]
    9ae8:	54d0      	strb	r0, [r2, r3]
	uint8_t position_iter = 0;
    9aea:	46ab      	mov	fp, r5
    9aec:	e79e      	b.n	9a2c <Pixel_pixelEvaluation+0x20>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, = );
    9aee:	8862      	ldrh	r2, [r4, #2]
    9af0:	eba9 0302 	sub.w	r3, r9, r2
    9af4:	6862      	ldr	r2, [r4, #4]
    9af6:	f822 0013 	strh.w	r0, [r2, r3, lsl #1]
    9afa:	e7f6      	b.n	9aea <Pixel_pixelEvaluation+0xde>
    9afc:	8862      	ldrh	r2, [r4, #2]
    9afe:	eba9 0302 	sub.w	r3, r9, r2
    9b02:	6862      	ldr	r2, [r4, #4]
    9b04:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
    9b08:	e7ef      	b.n	9aea <Pixel_pixelEvaluation+0xde>
    9b0a:	486a      	ldr	r0, [pc, #424]	; (9cb4 <Pixel_pixelEvaluation+0x2a8>)
			warn_print("Unimplemented pixel modifier");
    9b0c:	f005 fd30 	bl	f570 <_print>
			break;
    9b10:	e7eb      	b.n	9aea <Pixel_pixelEvaluation+0xde>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, += );
    9b12:	7862      	ldrb	r2, [r4, #1]
    9b14:	2a10      	cmp	r2, #16
    9b16:	d00b      	beq.n	9b30 <Pixel_pixelEvaluation+0x124>
    9b18:	2a20      	cmp	r2, #32
    9b1a:	d013      	beq.n	9b44 <Pixel_pixelEvaluation+0x138>
    9b1c:	2a08      	cmp	r2, #8
    9b1e:	d11b      	bne.n	9b58 <Pixel_pixelEvaluation+0x14c>
    9b20:	8862      	ldrh	r2, [r4, #2]
    9b22:	6861      	ldr	r1, [r4, #4]
    9b24:	eba9 0302 	sub.w	r3, r9, r2
    9b28:	5cca      	ldrb	r2, [r1, r3]
    9b2a:	4410      	add	r0, r2
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, -= );
    9b2c:	54c8      	strb	r0, [r1, r3]
    9b2e:	e7dc      	b.n	9aea <Pixel_pixelEvaluation+0xde>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, += );
    9b30:	8862      	ldrh	r2, [r4, #2]
    9b32:	6861      	ldr	r1, [r4, #4]
    9b34:	eba9 0302 	sub.w	r3, r9, r2
    9b38:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    9b3c:	4410      	add	r0, r2
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, -= );
    9b3e:	f821 0013 	strh.w	r0, [r1, r3, lsl #1]
    9b42:	e7d2      	b.n	9aea <Pixel_pixelEvaluation+0xde>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, += );
    9b44:	8862      	ldrh	r2, [r4, #2]
    9b46:	6861      	ldr	r1, [r4, #4]
    9b48:	eba9 0302 	sub.w	r3, r9, r2
    9b4c:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    9b50:	4410      	add	r0, r2
				PixelBuf32( pixbuf, ch_pos ) -= (uint32_t)mod_value;
    9b52:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    9b56:	e7c8      	b.n	9aea <Pixel_pixelEvaluation+0xde>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, += );
    9b58:	4857      	ldr	r0, [pc, #348]	; (9cb8 <Pixel_pixelEvaluation+0x2ac>)
    9b5a:	e7d7      	b.n	9b0c <Pixel_pixelEvaluation+0x100>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, -= );
    9b5c:	7862      	ldrb	r2, [r4, #1]
    9b5e:	2a10      	cmp	r2, #16
    9b60:	d00a      	beq.n	9b78 <Pixel_pixelEvaluation+0x16c>
    9b62:	2a20      	cmp	r2, #32
    9b64:	d010      	beq.n	9b88 <Pixel_pixelEvaluation+0x17c>
    9b66:	2a08      	cmp	r2, #8
    9b68:	d116      	bne.n	9b98 <Pixel_pixelEvaluation+0x18c>
    9b6a:	8862      	ldrh	r2, [r4, #2]
    9b6c:	6861      	ldr	r1, [r4, #4]
    9b6e:	eba9 0302 	sub.w	r3, r9, r2
    9b72:	5cca      	ldrb	r2, [r1, r3]
    9b74:	1a10      	subs	r0, r2, r0
    9b76:	e7d9      	b.n	9b2c <Pixel_pixelEvaluation+0x120>
    9b78:	8862      	ldrh	r2, [r4, #2]
    9b7a:	6861      	ldr	r1, [r4, #4]
    9b7c:	eba9 0302 	sub.w	r3, r9, r2
    9b80:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    9b84:	1a10      	subs	r0, r2, r0
    9b86:	e7da      	b.n	9b3e <Pixel_pixelEvaluation+0x132>
    9b88:	8862      	ldrh	r2, [r4, #2]
    9b8a:	6861      	ldr	r1, [r4, #4]
    9b8c:	eba9 0302 	sub.w	r3, r9, r2
    9b90:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    9b94:	1a10      	subs	r0, r2, r0
    9b96:	e7dc      	b.n	9b52 <Pixel_pixelEvaluation+0x146>
    9b98:	4848      	ldr	r0, [pc, #288]	; (9cbc <Pixel_pixelEvaluation+0x2b0>)
    9b9a:	e7b7      	b.n	9b0c <Pixel_pixelEvaluation+0x100>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, <<= );
    9b9c:	7862      	ldrb	r2, [r4, #1]
    9b9e:	2a10      	cmp	r2, #16
    9ba0:	d00c      	beq.n	9bbc <Pixel_pixelEvaluation+0x1b0>
    9ba2:	2a20      	cmp	r2, #32
    9ba4:	d014      	beq.n	9bd0 <Pixel_pixelEvaluation+0x1c4>
    9ba6:	2a08      	cmp	r2, #8
    9ba8:	d11b      	bne.n	9be2 <Pixel_pixelEvaluation+0x1d6>
    9baa:	8862      	ldrh	r2, [r4, #2]
    9bac:	6861      	ldr	r1, [r4, #4]
    9bae:	eba9 0302 	sub.w	r3, r9, r2
    9bb2:	b2c0      	uxtb	r0, r0
    9bb4:	5cca      	ldrb	r2, [r1, r3]
    9bb6:	fa02 f000 	lsl.w	r0, r2, r0
    9bba:	e7b7      	b.n	9b2c <Pixel_pixelEvaluation+0x120>
    9bbc:	8862      	ldrh	r2, [r4, #2]
    9bbe:	6861      	ldr	r1, [r4, #4]
    9bc0:	eba9 0302 	sub.w	r3, r9, r2
    9bc4:	b280      	uxth	r0, r0
    9bc6:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    9bca:	fa02 f000 	lsl.w	r0, r2, r0
    9bce:	e7b6      	b.n	9b3e <Pixel_pixelEvaluation+0x132>
    9bd0:	8862      	ldrh	r2, [r4, #2]
    9bd2:	6861      	ldr	r1, [r4, #4]
    9bd4:	eba9 0302 	sub.w	r3, r9, r2
    9bd8:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    9bdc:	fa02 f000 	lsl.w	r0, r2, r0
    9be0:	e7b7      	b.n	9b52 <Pixel_pixelEvaluation+0x146>
    9be2:	4837      	ldr	r0, [pc, #220]	; (9cc0 <Pixel_pixelEvaluation+0x2b4>)
    9be4:	e792      	b.n	9b0c <Pixel_pixelEvaluation+0x100>
			PixelChange_Expansion( pixbuf, ch_pos, mod_value, >>= );
    9be6:	7862      	ldrb	r2, [r4, #1]
    9be8:	2a10      	cmp	r2, #16
    9bea:	d00c      	beq.n	9c06 <Pixel_pixelEvaluation+0x1fa>
    9bec:	2a20      	cmp	r2, #32
    9bee:	d014      	beq.n	9c1a <Pixel_pixelEvaluation+0x20e>
    9bf0:	2a08      	cmp	r2, #8
    9bf2:	d11b      	bne.n	9c2c <Pixel_pixelEvaluation+0x220>
    9bf4:	8862      	ldrh	r2, [r4, #2]
    9bf6:	6861      	ldr	r1, [r4, #4]
    9bf8:	eba9 0302 	sub.w	r3, r9, r2
    9bfc:	b2c0      	uxtb	r0, r0
    9bfe:	5cca      	ldrb	r2, [r1, r3]
    9c00:	fa42 f000 	asr.w	r0, r2, r0
    9c04:	e792      	b.n	9b2c <Pixel_pixelEvaluation+0x120>
    9c06:	8862      	ldrh	r2, [r4, #2]
    9c08:	6861      	ldr	r1, [r4, #4]
    9c0a:	eba9 0302 	sub.w	r3, r9, r2
    9c0e:	b280      	uxth	r0, r0
    9c10:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    9c14:	fa42 f000 	asr.w	r0, r2, r0
    9c18:	e791      	b.n	9b3e <Pixel_pixelEvaluation+0x132>
    9c1a:	8862      	ldrh	r2, [r4, #2]
    9c1c:	6861      	ldr	r1, [r4, #4]
    9c1e:	eba9 0302 	sub.w	r3, r9, r2
    9c22:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    9c26:	fa22 f000 	lsr.w	r0, r2, r0
    9c2a:	e792      	b.n	9b52 <Pixel_pixelEvaluation+0x146>
    9c2c:	4825      	ldr	r0, [pc, #148]	; (9cc4 <Pixel_pixelEvaluation+0x2b8>)
    9c2e:	e76d      	b.n	9b0c <Pixel_pixelEvaluation+0x100>
			switch ( pixbuf->width )
    9c30:	7862      	ldrb	r2, [r4, #1]
    9c32:	2a10      	cmp	r2, #16
    9c34:	d015      	beq.n	9c62 <Pixel_pixelEvaluation+0x256>
    9c36:	2a20      	cmp	r2, #32
    9c38:	d028      	beq.n	9c8c <Pixel_pixelEvaluation+0x280>
    9c3a:	2a08      	cmp	r2, #8
    9c3c:	d134      	bne.n	9ca8 <Pixel_pixelEvaluation+0x29c>
				uint8_t prev = PixelBuf8( pixbuf, ch_pos );
    9c3e:	8862      	ldrh	r2, [r4, #2]
    9c40:	6863      	ldr	r3, [r4, #4]
    9c42:	eba9 0202 	sub.w	r2, r9, r2
    9c46:	5c99      	ldrb	r1, [r3, r2]
				PixelBuf8( pixbuf, ch_pos ) += (uint8_t)mod_value;
    9c48:	4408      	add	r0, r1
    9c4a:	5498      	strb	r0, [r3, r2]
				if ( prev > PixelBuf8( pixbuf, ch_pos ) )
    9c4c:	8862      	ldrh	r2, [r4, #2]
    9c4e:	eba9 0302 	sub.w	r3, r9, r2
    9c52:	6862      	ldr	r2, [r4, #4]
    9c54:	5cd0      	ldrb	r0, [r2, r3]
    9c56:	4288      	cmp	r0, r1
    9c58:	f4bf af47 	bcs.w	9aea <Pixel_pixelEvaluation+0xde>
					PixelBuf8( pixbuf, ch_pos ) = 0xFF;
    9c5c:	21ff      	movs	r1, #255	; 0xff
					PixelBuf8( pixbuf, ch_pos ) = 0;
    9c5e:	54d1      	strb	r1, [r2, r3]
    9c60:	e743      	b.n	9aea <Pixel_pixelEvaluation+0xde>
				PixelBuf16( pixbuf, ch_pos ) += (uint16_t)mod_value;
    9c62:	8861      	ldrh	r1, [r4, #2]
    9c64:	6862      	ldr	r2, [r4, #4]
    9c66:	eba9 0101 	sub.w	r1, r9, r1
    9c6a:	f832 c011 	ldrh.w	ip, [r2, r1, lsl #1]
    9c6e:	4460      	add	r0, ip
    9c70:	f822 0011 	strh.w	r0, [r2, r1, lsl #1]
				if ( 0xFF < PixelBuf16( pixbuf, ch_pos ) )
    9c74:	8861      	ldrh	r1, [r4, #2]
    9c76:	eba9 0301 	sub.w	r3, r9, r1
    9c7a:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    9c7e:	29ff      	cmp	r1, #255	; 0xff
    9c80:	f67f af33 	bls.w	9aea <Pixel_pixelEvaluation+0xde>
					PixelBuf16( pixbuf, ch_pos ) = 0xFF;
    9c84:	21ff      	movs	r1, #255	; 0xff
					PixelBuf16( pixbuf, ch_pos ) = 0;
    9c86:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    9c8a:	e72e      	b.n	9aea <Pixel_pixelEvaluation+0xde>
				uint32_t prev = PixelBuf32( pixbuf, ch_pos );
    9c8c:	8862      	ldrh	r2, [r4, #2]
    9c8e:	6861      	ldr	r1, [r4, #4]
    9c90:	eba9 0302 	sub.w	r3, r9, r2
    9c94:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    9c98:	1880      	adds	r0, r0, r2
    9c9a:	f4ff af5a 	bcc.w	9b52 <Pixel_pixelEvaluation+0x146>
					PixelBuf32( pixbuf, ch_pos ) = 0xFFFFFFFF;
    9c9e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    9ca2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    9ca6:	e720      	b.n	9aea <Pixel_pixelEvaluation+0xde>
				warn_print("Invalid width mapping on set");
    9ca8:	4807      	ldr	r0, [pc, #28]	; (9cc8 <Pixel_pixelEvaluation+0x2bc>)
    9caa:	e72f      	b.n	9b0c <Pixel_pixelEvaluation+0x100>
    9cac:	1fff89d0 	.word	0x1fff89d0
    9cb0:	00014b25 	.word	0x00014b25
    9cb4:	00014b5f 	.word	0x00014b5f
    9cb8:	00014b92 	.word	0x00014b92
    9cbc:	00014bc6 	.word	0x00014bc6
    9cc0:	00014bfa 	.word	0x00014bfa
    9cc4:	00014c2f 	.word	0x00014c2f
    9cc8:	00014c64 	.word	0x00014c64
			switch ( pixbuf->width )
    9ccc:	7862      	ldrb	r2, [r4, #1]
    9cce:	2a10      	cmp	r2, #16
    9cd0:	d014      	beq.n	9cfc <Pixel_pixelEvaluation+0x2f0>
    9cd2:	2a20      	cmp	r2, #32
    9cd4:	d026      	beq.n	9d24 <Pixel_pixelEvaluation+0x318>
    9cd6:	2a08      	cmp	r2, #8
    9cd8:	d1e6      	bne.n	9ca8 <Pixel_pixelEvaluation+0x29c>
				uint8_t prev = PixelBuf8( pixbuf, ch_pos );
    9cda:	8862      	ldrh	r2, [r4, #2]
    9cdc:	6863      	ldr	r3, [r4, #4]
    9cde:	eba9 0202 	sub.w	r2, r9, r2
    9ce2:	5c99      	ldrb	r1, [r3, r2]
				PixelBuf8( pixbuf, ch_pos ) -= (uint8_t)mod_value;
    9ce4:	1a08      	subs	r0, r1, r0
    9ce6:	5498      	strb	r0, [r3, r2]
				if ( prev < PixelBuf8( pixbuf, ch_pos ) )
    9ce8:	8862      	ldrh	r2, [r4, #2]
    9cea:	eba9 0302 	sub.w	r3, r9, r2
    9cee:	6862      	ldr	r2, [r4, #4]
    9cf0:	5cd0      	ldrb	r0, [r2, r3]
    9cf2:	4288      	cmp	r0, r1
    9cf4:	f67f aef9 	bls.w	9aea <Pixel_pixelEvaluation+0xde>
					PixelBuf8( pixbuf, ch_pos ) = 0;
    9cf8:	2100      	movs	r1, #0
    9cfa:	e7b0      	b.n	9c5e <Pixel_pixelEvaluation+0x252>
				uint16_t prev = PixelBuf16( pixbuf, ch_pos );
    9cfc:	f8b4 c002 	ldrh.w	ip, [r4, #2]
    9d00:	6862      	ldr	r2, [r4, #4]
    9d02:	eba9 0c0c 	sub.w	ip, r9, ip
    9d06:	f832 101c 	ldrh.w	r1, [r2, ip, lsl #1]
				PixelBuf16( pixbuf, ch_pos ) -= (uint16_t)mod_value;
    9d0a:	1a08      	subs	r0, r1, r0
    9d0c:	f822 001c 	strh.w	r0, [r2, ip, lsl #1]
				if ( prev < PixelBuf16( pixbuf, ch_pos ) )
    9d10:	8860      	ldrh	r0, [r4, #2]
    9d12:	eba9 0300 	sub.w	r3, r9, r0
    9d16:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    9d1a:	4288      	cmp	r0, r1
    9d1c:	f67f aee5 	bls.w	9aea <Pixel_pixelEvaluation+0xde>
					PixelBuf16( pixbuf, ch_pos ) = 0;
    9d20:	2100      	movs	r1, #0
    9d22:	e7b0      	b.n	9c86 <Pixel_pixelEvaluation+0x27a>
				uint32_t prev = PixelBuf32( pixbuf, ch_pos );
    9d24:	8862      	ldrh	r2, [r4, #2]
    9d26:	6861      	ldr	r1, [r4, #4]
    9d28:	eba9 0302 	sub.w	r3, r9, r2
    9d2c:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
    9d30:	1a22      	subs	r2, r4, r0
				PixelBuf32( pixbuf, ch_pos ) -= (uint32_t)mod_value;
    9d32:	4284      	cmp	r4, r0
    9d34:	bf2c      	ite	cs
    9d36:	4610      	movcs	r0, r2
    9d38:	2000      	movcc	r0, #0
    9d3a:	e70a      	b.n	9b52 <Pixel_pixelEvaluation+0x146>
			warn_print("Unimplemented pixel modifier");
    9d3c:	4802      	ldr	r0, [pc, #8]	; (9d48 <Pixel_pixelEvaluation+0x33c>)
    9d3e:	e6e5      	b.n	9b0c <Pixel_pixelEvaluation+0x100>
}
    9d40:	b005      	add	sp, #20
    9d42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9d46:	bf00      	nop
    9d48:	00014c98 	.word	0x00014c98

00009d4c <Pixel_pixelTweenNextPos>:
{
    9d4c:	b513      	push	{r0, r1, r4, lr}
    9d4e:	4c0e      	ldr	r4, [pc, #56]	; (9d88 <Pixel_pixelTweenNextPos+0x3c>)
    9d50:	6823      	ldr	r3, [r4, #0]
    9d52:	9301      	str	r3, [sp, #4]
	if ( elem != 0 )
    9d54:	b158      	cbz	r0, 9d6e <Pixel_pixelTweenNextPos+0x22>
		ret = ( ( elem->width / 8 + sizeof( PixelChange ) ) * elem->channels ) + sizeof( PixelModElement );
    9d56:	7803      	ldrb	r3, [r0, #0]
    9d58:	7840      	ldrb	r0, [r0, #1]
    9d5a:	08db      	lsrs	r3, r3, #3
		ret = ( ( prev->width / 8 + sizeof( PixelChange ) ) * prev->channels ) + sizeof( PixelModElement );
    9d5c:	fb03 0000 	mla	r0, r3, r0, r0
    9d60:	3005      	adds	r0, #5
}
    9d62:	9a01      	ldr	r2, [sp, #4]
    9d64:	6823      	ldr	r3, [r4, #0]
    9d66:	429a      	cmp	r2, r3
    9d68:	d00b      	beq.n	9d82 <Pixel_pixelTweenNextPos+0x36>
    9d6a:	f7f8 fce1 	bl	2730 <__stack_chk_fail>
	if ( prev != 0 )
    9d6e:	b119      	cbz	r1, 9d78 <Pixel_pixelTweenNextPos+0x2c>
		ret = ( ( prev->width / 8 + sizeof( PixelChange ) ) * prev->channels ) + sizeof( PixelModElement );
    9d70:	7808      	ldrb	r0, [r1, #0]
    9d72:	08c3      	lsrs	r3, r0, #3
    9d74:	7848      	ldrb	r0, [r1, #1]
    9d76:	e7f1      	b.n	9d5c <Pixel_pixelTweenNextPos+0x10>
	erro_print("Pixel Tween Bug!");
    9d78:	4804      	ldr	r0, [pc, #16]	; (9d8c <Pixel_pixelTweenNextPos+0x40>)
    9d7a:	f005 fbf9 	bl	f570 <_print>
	return ret;
    9d7e:	200b      	movs	r0, #11
    9d80:	e7ef      	b.n	9d62 <Pixel_pixelTweenNextPos+0x16>
}
    9d82:	b002      	add	sp, #8
    9d84:	bd10      	pop	{r4, pc}
    9d86:	bf00      	nop
    9d88:	1fff89d0 	.word	0x1fff89d0
    9d8c:	00014ccc 	.word	0x00014ccc

00009d90 <Pixel_channelSet>:
{
    9d90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9d92:	4e1c      	ldr	r6, [pc, #112]	; (9e04 <Pixel_channelSet+0x74>)
    9d94:	6833      	ldr	r3, [r6, #0]
    9d96:	9301      	str	r3, [sp, #4]
    9d98:	460f      	mov	r7, r1
    9d9a:	4604      	mov	r4, r0
	PixelBuf *pixbuf = Pixel_bufferMap( channel );
    9d9c:	f7ff fdc2 	bl	9924 <Pixel_bufferMap>
	switch ( pixbuf->width )
    9da0:	7843      	ldrb	r3, [r0, #1]
    9da2:	2b08      	cmp	r3, #8
	PixelBuf *pixbuf = Pixel_bufferMap( channel );
    9da4:	4605      	mov	r5, r0
    9da6:	4631      	mov	r1, r6
	switch ( pixbuf->width )
    9da8:	d01b      	beq.n	9de2 <Pixel_channelSet+0x52>
    9daa:	2b10      	cmp	r3, #16
    9dac:	d023      	beq.n	9df6 <Pixel_channelSet+0x66>
    9dae:	b1e3      	cbz	r3, 9dea <Pixel_channelSet+0x5a>
		warn_msg("ChanSet Unknown width: ");
    9db0:	4815      	ldr	r0, [pc, #84]	; (9e08 <Pixel_channelSet+0x78>)
    9db2:	f005 fbdd 	bl	f570 <_print>
		printInt8( pixbuf->width );
    9db6:	7868      	ldrb	r0, [r5, #1]
    9db8:	f005 fc44 	bl	f644 <printInt8>
		print(" Ch: ");
    9dbc:	4813      	ldr	r0, [pc, #76]	; (9e0c <Pixel_channelSet+0x7c>)
    9dbe:	f005 fbd7 	bl	f570 <_print>
		printHex( channel );
    9dc2:	2101      	movs	r1, #1
    9dc4:	4620      	mov	r0, r4
    9dc6:	f005 fcf9 	bl	f7bc <printHex_op>
		print( NL );
    9dca:	9a01      	ldr	r2, [sp, #4]
    9dcc:	6833      	ldr	r3, [r6, #0]
    9dce:	429a      	cmp	r2, r3
    9dd0:	d001      	beq.n	9dd6 <Pixel_channelSet+0x46>
}
    9dd2:	f7f8 fcad 	bl	2730 <__stack_chk_fail>
		print( NL );
    9dd6:	480e      	ldr	r0, [pc, #56]	; (9e10 <Pixel_channelSet+0x80>)
}
    9dd8:	b003      	add	sp, #12
    9dda:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		print( NL );
    9dde:	f005 bbc7 	b.w	f570 <_print>
		PixelBuf8( pixbuf, channel ) = (uint8_t)value;
    9de2:	8843      	ldrh	r3, [r0, #2]
    9de4:	1ae4      	subs	r4, r4, r3
    9de6:	6843      	ldr	r3, [r0, #4]
    9de8:	551f      	strb	r7, [r3, r4]
}
    9dea:	9a01      	ldr	r2, [sp, #4]
    9dec:	680b      	ldr	r3, [r1, #0]
    9dee:	429a      	cmp	r2, r3
    9df0:	d1ef      	bne.n	9dd2 <Pixel_channelSet+0x42>
    9df2:	b003      	add	sp, #12
    9df4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		PixelBuf16( pixbuf, channel ) = (uint16_t)value;
    9df6:	8843      	ldrh	r3, [r0, #2]
    9df8:	1ae4      	subs	r4, r4, r3
    9dfa:	6843      	ldr	r3, [r0, #4]
    9dfc:	f823 7014 	strh.w	r7, [r3, r4, lsl #1]
}
    9e00:	e7f3      	b.n	9dea <Pixel_channelSet+0x5a>
    9e02:	bf00      	nop
    9e04:	1fff89d0 	.word	0x1fff89d0
    9e08:	000149b5 	.word	0x000149b5
    9e0c:	000149e2 	.word	0x000149e2
    9e10:	00015df4 	.word	0x00015df4

00009e14 <Pixel_channelToggle>:
{
    9e14:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9e16:	4e1f      	ldr	r6, [pc, #124]	; (9e94 <Pixel_channelToggle+0x80>)
    9e18:	6833      	ldr	r3, [r6, #0]
    9e1a:	9301      	str	r3, [sp, #4]
    9e1c:	4604      	mov	r4, r0
	PixelBuf *pixbuf = Pixel_bufferMap( channel );
    9e1e:	f7ff fd81 	bl	9924 <Pixel_bufferMap>
	switch ( pixbuf->width )
    9e22:	7843      	ldrb	r3, [r0, #1]
    9e24:	2b08      	cmp	r3, #8
	PixelBuf *pixbuf = Pixel_bufferMap( channel );
    9e26:	4605      	mov	r5, r0
    9e28:	4631      	mov	r1, r6
	switch ( pixbuf->width )
    9e2a:	d01b      	beq.n	9e64 <Pixel_channelToggle+0x50>
    9e2c:	2b10      	cmp	r3, #16
    9e2e:	d026      	beq.n	9e7e <Pixel_channelToggle+0x6a>
    9e30:	b1fb      	cbz	r3, 9e72 <Pixel_channelToggle+0x5e>
		warn_msg("ChanToggle Unknown width: ");
    9e32:	4819      	ldr	r0, [pc, #100]	; (9e98 <Pixel_channelToggle+0x84>)
    9e34:	f005 fb9c 	bl	f570 <_print>
		printInt8( pixbuf->width );
    9e38:	7868      	ldrb	r0, [r5, #1]
    9e3a:	f005 fc03 	bl	f644 <printInt8>
		print(" Ch: ");
    9e3e:	4817      	ldr	r0, [pc, #92]	; (9e9c <Pixel_channelToggle+0x88>)
    9e40:	f005 fb96 	bl	f570 <_print>
		printHex( channel );
    9e44:	2101      	movs	r1, #1
    9e46:	4620      	mov	r0, r4
    9e48:	f005 fcb8 	bl	f7bc <printHex_op>
		print( NL );
    9e4c:	9a01      	ldr	r2, [sp, #4]
    9e4e:	6833      	ldr	r3, [r6, #0]
    9e50:	429a      	cmp	r2, r3
    9e52:	d001      	beq.n	9e58 <Pixel_channelToggle+0x44>
}
    9e54:	f7f8 fc6c 	bl	2730 <__stack_chk_fail>
		print( NL );
    9e58:	4811      	ldr	r0, [pc, #68]	; (9ea0 <Pixel_channelToggle+0x8c>)
}
    9e5a:	b002      	add	sp, #8
    9e5c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print( NL );
    9e60:	f005 bb86 	b.w	f570 <_print>
		PixelBuf8( pixbuf, channel ) ^= 128;
    9e64:	8843      	ldrh	r3, [r0, #2]
    9e66:	6842      	ldr	r2, [r0, #4]
    9e68:	1ae4      	subs	r4, r4, r3
    9e6a:	5d13      	ldrb	r3, [r2, r4]
    9e6c:	f083 0380 	eor.w	r3, r3, #128	; 0x80
    9e70:	5513      	strb	r3, [r2, r4]
}
    9e72:	9a01      	ldr	r2, [sp, #4]
    9e74:	680b      	ldr	r3, [r1, #0]
    9e76:	429a      	cmp	r2, r3
    9e78:	d1ec      	bne.n	9e54 <Pixel_channelToggle+0x40>
    9e7a:	b002      	add	sp, #8
    9e7c:	bd70      	pop	{r4, r5, r6, pc}
		PixelBuf16( pixbuf, channel ) ^= 128;
    9e7e:	8843      	ldrh	r3, [r0, #2]
    9e80:	6842      	ldr	r2, [r0, #4]
    9e82:	1ae4      	subs	r4, r4, r3
    9e84:	f832 3014 	ldrh.w	r3, [r2, r4, lsl #1]
    9e88:	f083 0380 	eor.w	r3, r3, #128	; 0x80
    9e8c:	f822 3014 	strh.w	r3, [r2, r4, lsl #1]
}
    9e90:	e7ef      	b.n	9e72 <Pixel_channelToggle+0x5e>
    9e92:	bf00      	nop
    9e94:	1fff89d0 	.word	0x1fff89d0
    9e98:	000149e8 	.word	0x000149e8
    9e9c:	000149e2 	.word	0x000149e2
    9ea0:	00015df4 	.word	0x00015df4

00009ea4 <Pixel_pixelSet>:
{
    9ea4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9ea6:	4c0d      	ldr	r4, [pc, #52]	; (9edc <Pixel_pixelSet+0x38>)
    9ea8:	6823      	ldr	r3, [r4, #0]
    9eaa:	9301      	str	r3, [sp, #4]
    9eac:	4605      	mov	r5, r0
    9eae:	460f      	mov	r7, r1
	for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    9eb0:	2300      	movs	r3, #0
    9eb2:	786a      	ldrb	r2, [r5, #1]
    9eb4:	1c5e      	adds	r6, r3, #1
    9eb6:	b2db      	uxtb	r3, r3
    9eb8:	429a      	cmp	r2, r3
    9eba:	d805      	bhi.n	9ec8 <Pixel_pixelSet+0x24>
}
    9ebc:	9a01      	ldr	r2, [sp, #4]
    9ebe:	6823      	ldr	r3, [r4, #0]
    9ec0:	429a      	cmp	r2, r3
    9ec2:	d009      	beq.n	9ed8 <Pixel_pixelSet+0x34>
    9ec4:	f7f8 fc34 	bl	2730 <__stack_chk_fail>
		Pixel_channelSet( elem->indices[ch], value );
    9ec8:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    9ecc:	4639      	mov	r1, r7
    9ece:	8858      	ldrh	r0, [r3, #2]
    9ed0:	f7ff ff5e 	bl	9d90 <Pixel_channelSet>
    9ed4:	4633      	mov	r3, r6
    9ed6:	e7ec      	b.n	9eb2 <Pixel_pixelSet+0xe>
}
    9ed8:	b003      	add	sp, #12
    9eda:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9edc:	1fff89d0 	.word	0x1fff89d0

00009ee0 <Pixel_clearPixels>:
{
    9ee0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9ee2:	4c0a      	ldr	r4, [pc, #40]	; (9f0c <Pixel_clearPixels+0x2c>)
		Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 0 );
    9ee4:	4e0a      	ldr	r6, [pc, #40]	; (9f10 <Pixel_clearPixels+0x30>)
{
    9ee6:	6822      	ldr	r2, [r4, #0]
    9ee8:	9201      	str	r2, [sp, #4]
    9eea:	2500      	movs	r5, #0
		Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 0 );
    9eec:	eb06 00c5 	add.w	r0, r6, r5, lsl #3
    9ef0:	2100      	movs	r1, #0
    9ef2:	3501      	adds	r5, #1
    9ef4:	f7ff ffd6 	bl	9ea4 <Pixel_pixelSet>
	for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    9ef8:	2d26      	cmp	r5, #38	; 0x26
    9efa:	d1f7      	bne.n	9eec <Pixel_clearPixels+0xc>
}
    9efc:	9a01      	ldr	r2, [sp, #4]
    9efe:	6823      	ldr	r3, [r4, #0]
    9f00:	429a      	cmp	r2, r3
    9f02:	d001      	beq.n	9f08 <Pixel_clearPixels+0x28>
    9f04:	f7f8 fc14 	bl	2730 <__stack_chk_fail>
    9f08:	b002      	add	sp, #8
    9f0a:	bd70      	pop	{r4, r5, r6, pc}
    9f0c:	1fff89d0 	.word	0x1fff89d0
    9f10:	00015530 	.word	0x00015530

00009f14 <Pixel_pixelToggle>:
{
    9f14:	b573      	push	{r0, r1, r4, r5, r6, lr}
    9f16:	4c0c      	ldr	r4, [pc, #48]	; (9f48 <Pixel_pixelToggle+0x34>)
    9f18:	6823      	ldr	r3, [r4, #0]
    9f1a:	9301      	str	r3, [sp, #4]
    9f1c:	4605      	mov	r5, r0
	for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    9f1e:	2300      	movs	r3, #0
    9f20:	786a      	ldrb	r2, [r5, #1]
    9f22:	1c5e      	adds	r6, r3, #1
    9f24:	b2db      	uxtb	r3, r3
    9f26:	429a      	cmp	r2, r3
    9f28:	d805      	bhi.n	9f36 <Pixel_pixelToggle+0x22>
}
    9f2a:	9a01      	ldr	r2, [sp, #4]
    9f2c:	6823      	ldr	r3, [r4, #0]
    9f2e:	429a      	cmp	r2, r3
    9f30:	d008      	beq.n	9f44 <Pixel_pixelToggle+0x30>
    9f32:	f7f8 fbfd 	bl	2730 <__stack_chk_fail>
		Pixel_channelToggle( elem->indices[ch] );
    9f36:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    9f3a:	8858      	ldrh	r0, [r3, #2]
    9f3c:	f7ff ff6a 	bl	9e14 <Pixel_channelToggle>
    9f40:	4633      	mov	r3, r6
    9f42:	e7ed      	b.n	9f20 <Pixel_pixelToggle+0xc>
}
    9f44:	b002      	add	sp, #8
    9f46:	bd70      	pop	{r4, r5, r6, pc}
    9f48:	1fff89d0 	.word	0x1fff89d0

00009f4c <cliFunc_pixelXYTest>:
{
    9f4c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    9f50:	4e7d      	ldr	r6, [pc, #500]	; (a148 <cliFunc_pixelXYTest+0x1fc>)
    9f52:	4604      	mov	r4, r0
    9f54:	6833      	ldr	r3, [r6, #0]
	print( NL ); // No \r\n by default after the command is entered
    9f56:	487d      	ldr	r0, [pc, #500]	; (a14c <cliFunc_pixelXYTest+0x200>)
{
    9f58:	9303      	str	r3, [sp, #12]
	print( NL ); // No \r\n by default after the command is entered
    9f5a:	f005 fb09 	bl	f570 <_print>
	char* arg2Ptr = args;
    9f5e:	aa04      	add	r2, sp, #16
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    9f60:	4620      	mov	r0, r4
	char* arg2Ptr = args;
    9f62:	f842 4d08 	str.w	r4, [r2, #-8]!
	CLI_argumentIsolation( curArgs, &arg1Ptr, &arg2Ptr );
    9f66:	a901      	add	r1, sp, #4
    9f68:	f004 fdd4 	bl	eb14 <CLI_argumentIsolation>
	switch ( *arg1Ptr )
    9f6c:	9801      	ldr	r0, [sp, #4]
    9f6e:	7803      	ldrb	r3, [r0, #0]
    9f70:	2b56      	cmp	r3, #86	; 0x56
    9f72:	f000 8089 	beq.w	a088 <cliFunc_pixelXYTest+0x13c>
    9f76:	d85b      	bhi.n	a030 <cliFunc_pixelXYTest+0xe4>
    9f78:	2b48      	cmp	r3, #72	; 0x48
    9f7a:	d060      	beq.n	a03e <cliFunc_pixelXYTest+0xf2>
    9f7c:	d84e      	bhi.n	a01c <cliFunc_pixelXYTest+0xd0>
    9f7e:	2b41      	cmp	r3, #65	; 0x41
    9f80:	f000 80b5 	beq.w	a0ee <cliFunc_pixelXYTest+0x1a2>
    9f84:	4c72      	ldr	r4, [pc, #456]	; (a150 <cliFunc_pixelXYTest+0x204>)
	if ( *arg1Ptr != '\0' )
    9f86:	b11b      	cbz	r3, 9f90 <cliFunc_pixelXYTest+0x44>
		Pixel_testPos = numToInt( arg1Ptr );
    9f88:	f005 fcc2 	bl	f910 <numToInt>
    9f8c:	b280      	uxth	r0, r0
    9f8e:	8020      	strh	r0, [r4, #0]
	uint16_t pixel = Pixel_DisplayMapping[ Pixel_testPos ];
    9f90:	8823      	ldrh	r3, [r4, #0]
    9f92:	4a70      	ldr	r2, [pc, #448]	; (a154 <cliFunc_pixelXYTest+0x208>)
	print( NL );
    9f94:	486d      	ldr	r0, [pc, #436]	; (a14c <cliFunc_pixelXYTest+0x200>)
	uint16_t pixel = Pixel_DisplayMapping[ Pixel_testPos ];
    9f96:	b29b      	uxth	r3, r3
	printInt16( Pixel_testPos % Pixel_DisplayMapping_Cols_KLL );
    9f98:	2711      	movs	r7, #17
	uint16_t pixel = Pixel_DisplayMapping[ Pixel_testPos ];
    9f9a:	f832 5013 	ldrh.w	r5, [r2, r3, lsl #1]
	print( NL );
    9f9e:	f005 fae7 	bl	f570 <_print>
	info_msg("Position (x,y): ");
    9fa2:	486d      	ldr	r0, [pc, #436]	; (a158 <cliFunc_pixelXYTest+0x20c>)
    9fa4:	f005 fae4 	bl	f570 <_print>
	printInt16( Pixel_testPos % Pixel_DisplayMapping_Cols_KLL );
    9fa8:	8820      	ldrh	r0, [r4, #0]
    9faa:	b280      	uxth	r0, r0
    9fac:	fbb0 f3f7 	udiv	r3, r0, r7
    9fb0:	eb03 1303 	add.w	r3, r3, r3, lsl #4
    9fb4:	1ac0      	subs	r0, r0, r3
    9fb6:	b280      	uxth	r0, r0
    9fb8:	f005 fb7a 	bl	f6b0 <printInt16>
	print(",");
    9fbc:	4867      	ldr	r0, [pc, #412]	; (a15c <cliFunc_pixelXYTest+0x210>)
    9fbe:	f005 fad7 	bl	f570 <_print>
	printInt16( Pixel_testPos / Pixel_DisplayMapping_Cols_KLL );
    9fc2:	8820      	ldrh	r0, [r4, #0]
    9fc4:	fbb0 f0f7 	udiv	r0, r0, r7
    9fc8:	f005 fb72 	bl	f6b0 <printInt16>
	print(":");
    9fcc:	4864      	ldr	r0, [pc, #400]	; (a160 <cliFunc_pixelXYTest+0x214>)
	PixelElement *elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    9fce:	4f65      	ldr	r7, [pc, #404]	; (a164 <cliFunc_pixelXYTest+0x218>)
	print(":");
    9fd0:	f005 face 	bl	f570 <_print>
	printInt16( Pixel_testPos );
    9fd4:	8820      	ldrh	r0, [r4, #0]
    9fd6:	f005 fb6b 	bl	f6b0 <printInt16>
	print(" Pixel: ");
    9fda:	4863      	ldr	r0, [pc, #396]	; (a168 <cliFunc_pixelXYTest+0x21c>)
    9fdc:	f005 fac8 	bl	f570 <_print>
	printInt16( pixel );
    9fe0:	4628      	mov	r0, r5
    9fe2:	f005 fb65 	bl	f6b0 <printInt16>
	print(" ");
    9fe6:	4861      	ldr	r0, [pc, #388]	; (a16c <cliFunc_pixelXYTest+0x220>)
    9fe8:	f005 fac2 	bl	f570 <_print>
	PixelElement *elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    9fec:	1e6b      	subs	r3, r5, #1
    9fee:	eb07 07c3 	add.w	r7, r7, r3, lsl #3
	Pixel_showPixelElement( elem );
    9ff2:	4638      	mov	r0, r7
    9ff4:	f7ff fb08 	bl	9608 <Pixel_showPixelElement>
	print( NL );
    9ff8:	4854      	ldr	r0, [pc, #336]	; (a14c <cliFunc_pixelXYTest+0x200>)
    9ffa:	f005 fab9 	bl	f570 <_print>
	Pixel_testPos++;
    9ffe:	8823      	ldrh	r3, [r4, #0]
    a000:	3301      	adds	r3, #1
    a002:	b29b      	uxth	r3, r3
    a004:	8023      	strh	r3, [r4, #0]
	if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    a006:	8823      	ldrh	r3, [r4, #0]
    a008:	2b76      	cmp	r3, #118	; 0x76
		Pixel_testPos = 0;
    a00a:	bf84      	itt	hi
    a00c:	2300      	movhi	r3, #0
    a00e:	8023      	strhhi	r3, [r4, #0]
	if ( pixel == 0 )
    a010:	2d00      	cmp	r5, #0
    a012:	d075      	beq.n	a100 <cliFunc_pixelXYTest+0x1b4>
	Pixel_pixelToggle( elem );
    a014:	4638      	mov	r0, r7
    a016:	f7ff ff7d 	bl	9f14 <Pixel_pixelToggle>
    a01a:	e071      	b.n	a100 <cliFunc_pixelXYTest+0x1b4>
	switch ( *arg1Ptr )
    a01c:	2b52      	cmp	r3, #82	; 0x52
    a01e:	d075      	beq.n	a10c <cliFunc_pixelXYTest+0x1c0>
    a020:	2b53      	cmp	r3, #83	; 0x53
    a022:	d1af      	bne.n	9f84 <cliFunc_pixelXYTest+0x38>
		info_msg("Stopping x,y pixel test");
    a024:	4852      	ldr	r0, [pc, #328]	; (a170 <cliFunc_pixelXYTest+0x224>)
    a026:	f005 faa3 	bl	f570 <_print>
		Pixel_testMode = PixelTest_Off;
    a02a:	4b52      	ldr	r3, [pc, #328]	; (a174 <cliFunc_pixelXYTest+0x228>)
    a02c:	2200      	movs	r2, #0
    a02e:	e066      	b.n	a0fe <cliFunc_pixelXYTest+0x1b2>
	switch ( *arg1Ptr )
    a030:	2b72      	cmp	r3, #114	; 0x72
    a032:	d06b      	beq.n	a10c <cliFunc_pixelXYTest+0x1c0>
    a034:	d823      	bhi.n	a07e <cliFunc_pixelXYTest+0x132>
    a036:	2b61      	cmp	r3, #97	; 0x61
    a038:	d059      	beq.n	a0ee <cliFunc_pixelXYTest+0x1a2>
    a03a:	2b68      	cmp	r3, #104	; 0x68
    a03c:	d1a2      	bne.n	9f84 <cliFunc_pixelXYTest+0x38>
		if ( Pixel_testPos >= Pixel_DisplayMapping_Rows_KLL )
    a03e:	4d44      	ldr	r5, [pc, #272]	; (a150 <cliFunc_pixelXYTest+0x204>)
		info_msg("Horizontal: ");
    a040:	484d      	ldr	r0, [pc, #308]	; (a178 <cliFunc_pixelXYTest+0x22c>)
		if ( Pixel_testPos >= Pixel_DisplayMapping_Rows_KLL )
    a042:	882b      	ldrh	r3, [r5, #0]
			uint16_t pixel = Pixel_DisplayMapping[ pos ];
    a044:	f8df 910c 	ldr.w	r9, [pc, #268]	; a154 <cliFunc_pixelXYTest+0x208>
			print(" ");
    a048:	f8df a120 	ldr.w	sl, [pc, #288]	; a16c <cliFunc_pixelXYTest+0x220>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    a04c:	4f45      	ldr	r7, [pc, #276]	; (a164 <cliFunc_pixelXYTest+0x218>)
		if ( Pixel_testPos >= Pixel_DisplayMapping_Rows_KLL )
    a04e:	2b06      	cmp	r3, #6
			Pixel_testPos = 0;
    a050:	bf84      	itt	hi
    a052:	2300      	movhi	r3, #0
    a054:	802b      	strhhi	r3, [r5, #0]
		info_msg("Horizontal: ");
    a056:	f005 fa8b 	bl	f570 <_print>
		printInt16( Pixel_testPos );
    a05a:	8828      	ldrh	r0, [r5, #0]
    a05c:	f005 fb28 	bl	f6b0 <printInt16>
		for ( uint16_t pos = Pixel_DisplayMapping_Cols_KLL * Pixel_testPos;
    a060:	882c      	ldrh	r4, [r5, #0]
    a062:	eb04 1404 	add.w	r4, r4, r4, lsl #4
    a066:	b2a4      	uxth	r4, r4
			pos < Pixel_DisplayMapping_Cols_KLL * ( Pixel_testPos + 1);
    a068:	882b      	ldrh	r3, [r5, #0]
    a06a:	3301      	adds	r3, #1
    a06c:	eb03 1303 	add.w	r3, r3, r3, lsl #4
		for ( uint16_t pos = Pixel_DisplayMapping_Cols_KLL * Pixel_testPos;
    a070:	429c      	cmp	r4, r3
    a072:	db54      	blt.n	a11e <cliFunc_pixelXYTest+0x1d2>
		Pixel_testPos++;
    a074:	882b      	ldrh	r3, [r5, #0]
    a076:	3301      	adds	r3, #1
    a078:	b29b      	uxth	r3, r3
    a07a:	802b      	strh	r3, [r5, #0]
		return;
    a07c:	e040      	b.n	a100 <cliFunc_pixelXYTest+0x1b4>
	switch ( *arg1Ptr )
    a07e:	2b73      	cmp	r3, #115	; 0x73
    a080:	d0d0      	beq.n	a024 <cliFunc_pixelXYTest+0xd8>
    a082:	2b76      	cmp	r3, #118	; 0x76
    a084:	f47f af7e 	bne.w	9f84 <cliFunc_pixelXYTest+0x38>
		if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL )
    a088:	4c31      	ldr	r4, [pc, #196]	; (a150 <cliFunc_pixelXYTest+0x204>)
		info_msg("Vertical: ");
    a08a:	483c      	ldr	r0, [pc, #240]	; (a17c <cliFunc_pixelXYTest+0x230>)
		if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL )
    a08c:	8823      	ldrh	r3, [r4, #0]
			print(" ");
    a08e:	f8df a0dc 	ldr.w	sl, [pc, #220]	; a16c <cliFunc_pixelXYTest+0x220>
			uint16_t pixel = Pixel_DisplayMapping[ pos_calc ];
    a092:	f8df 90c0 	ldr.w	r9, [pc, #192]	; a154 <cliFunc_pixelXYTest+0x208>
			print(":");
    a096:	f8df 80c8 	ldr.w	r8, [pc, #200]	; a160 <cliFunc_pixelXYTest+0x214>
		if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL )
    a09a:	2b10      	cmp	r3, #16
			Pixel_testPos = 0;
    a09c:	bf84      	itt	hi
    a09e:	2300      	movhi	r3, #0
    a0a0:	8023      	strhhi	r3, [r4, #0]
		info_msg("Vertical: ");
    a0a2:	f005 fa65 	bl	f570 <_print>
		printInt16( Pixel_testPos );
    a0a6:	8820      	ldrh	r0, [r4, #0]
    a0a8:	f005 fb02 	bl	f6b0 <printInt16>
    a0ac:	2500      	movs	r5, #0
			uint16_t pos_calc = pos * Pixel_DisplayMapping_Cols_KLL + Pixel_testPos;
    a0ae:	8827      	ldrh	r7, [r4, #0]
    a0b0:	442f      	add	r7, r5
    a0b2:	b2bf      	uxth	r7, r7
			print(" ");
    a0b4:	4650      	mov	r0, sl
    a0b6:	f005 fa5b 	bl	f570 <_print>
			printInt16( pos_calc );
    a0ba:	4638      	mov	r0, r7
    a0bc:	f005 faf8 	bl	f6b0 <printInt16>
			uint16_t pixel = Pixel_DisplayMapping[ pos_calc ];
    a0c0:	f839 7017 	ldrh.w	r7, [r9, r7, lsl #1]
			print(":");
    a0c4:	4640      	mov	r0, r8
    a0c6:	f005 fa53 	bl	f570 <_print>
			printInt16( pixel );
    a0ca:	4638      	mov	r0, r7
    a0cc:	f005 faf0 	bl	f6b0 <printInt16>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    a0d0:	4824      	ldr	r0, [pc, #144]	; (a164 <cliFunc_pixelXYTest+0x218>)
    a0d2:	3f01      	subs	r7, #1
    a0d4:	3511      	adds	r5, #17
    a0d6:	eb00 00c7 	add.w	r0, r0, r7, lsl #3
    a0da:	b2ad      	uxth	r5, r5
    a0dc:	f7ff ff1a 	bl	9f14 <Pixel_pixelToggle>
		for ( uint16_t pos = 0; pos < Pixel_DisplayMapping_Rows_KLL; pos++ )
    a0e0:	2d77      	cmp	r5, #119	; 0x77
    a0e2:	d1e4      	bne.n	a0ae <cliFunc_pixelXYTest+0x162>
		Pixel_testPos++;
    a0e4:	8823      	ldrh	r3, [r4, #0]
    a0e6:	3301      	adds	r3, #1
    a0e8:	b29b      	uxth	r3, r3
    a0ea:	8023      	strh	r3, [r4, #0]
		return;
    a0ec:	e008      	b.n	a100 <cliFunc_pixelXYTest+0x1b4>
		info_msg("All x,y pixel test");
    a0ee:	4824      	ldr	r0, [pc, #144]	; (a180 <cliFunc_pixelXYTest+0x234>)
    a0f0:	f005 fa3e 	bl	f570 <_print>
		Pixel_testPos = 0;
    a0f4:	4b16      	ldr	r3, [pc, #88]	; (a150 <cliFunc_pixelXYTest+0x204>)
    a0f6:	2200      	movs	r2, #0
    a0f8:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_XY_All;
    a0fa:	4b1e      	ldr	r3, [pc, #120]	; (a174 <cliFunc_pixelXYTest+0x228>)
    a0fc:	220f      	movs	r2, #15
		Pixel_testMode = PixelTest_XY_Roll;
    a0fe:	701a      	strb	r2, [r3, #0]
}
    a100:	9a03      	ldr	r2, [sp, #12]
    a102:	6833      	ldr	r3, [r6, #0]
    a104:	429a      	cmp	r2, r3
    a106:	d01b      	beq.n	a140 <cliFunc_pixelXYTest+0x1f4>
    a108:	f7f8 fb12 	bl	2730 <__stack_chk_fail>
		info_msg("x,y pixel roll test");
    a10c:	481d      	ldr	r0, [pc, #116]	; (a184 <cliFunc_pixelXYTest+0x238>)
    a10e:	f005 fa2f 	bl	f570 <_print>
		Pixel_testPos = 0;
    a112:	4b0f      	ldr	r3, [pc, #60]	; (a150 <cliFunc_pixelXYTest+0x204>)
    a114:	2200      	movs	r2, #0
    a116:	801a      	strh	r2, [r3, #0]
		Pixel_testMode = PixelTest_XY_Roll;
    a118:	4b16      	ldr	r3, [pc, #88]	; (a174 <cliFunc_pixelXYTest+0x228>)
    a11a:	2210      	movs	r2, #16
    a11c:	e7ef      	b.n	a0fe <cliFunc_pixelXYTest+0x1b2>
			uint16_t pixel = Pixel_DisplayMapping[ pos ];
    a11e:	f839 8014 	ldrh.w	r8, [r9, r4, lsl #1]
			print(" ");
    a122:	4650      	mov	r0, sl
    a124:	f005 fa24 	bl	f570 <_print>
			printInt16( pixel );
    a128:	4640      	mov	r0, r8
    a12a:	f005 fac1 	bl	f6b0 <printInt16>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    a12e:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
    a132:	eb07 00c0 	add.w	r0, r7, r0, lsl #3
			pos++
    a136:	3401      	adds	r4, #1
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    a138:	f7ff feec 	bl	9f14 <Pixel_pixelToggle>
			pos++
    a13c:	b2a4      	uxth	r4, r4
    a13e:	e793      	b.n	a068 <cliFunc_pixelXYTest+0x11c>
}
    a140:	b004      	add	sp, #16
    a142:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a146:	bf00      	nop
    a148:	1fff89d0 	.word	0x1fff89d0
    a14c:	00015df4 	.word	0x00015df4
    a150:	1fff9724 	.word	0x1fff9724
    a154:	000153bc 	.word	0x000153bc
    a158:	00015147 	.word	0x00015147
    a15c:	00012bba 	.word	0x00012bba
    a160:	00014d02 	.word	0x00014d02
    a164:	00015530 	.word	0x00015530
    a168:	0001508d 	.word	0x0001508d
    a16c:	00016f5e 	.word	0x00016f5e
    a170:	000150e1 	.word	0x000150e1
    a174:	1fffac98 	.word	0x1fffac98
    a178:	0001510b 	.word	0x0001510b
    a17c:	0001512a 	.word	0x0001512a
    a180:	00015096 	.word	0x00015096
    a184:	000150bb 	.word	0x000150bb

0000a188 <Pixel_SecondaryProcessing_profile_init>:
{
    a188:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a18a:	4a11      	ldr	r2, [pc, #68]	; (a1d0 <Pixel_SecondaryProcessing_profile_init+0x48>)
    a18c:	4911      	ldr	r1, [pc, #68]	; (a1d4 <Pixel_SecondaryProcessing_profile_init+0x4c>)
    a18e:	6813      	ldr	r3, [r2, #0]
			Pixel_pixel_fade_profile[entry.pixels[pxin] - 1] = group + 1;
    a190:	4d11      	ldr	r5, [pc, #68]	; (a1d8 <Pixel_SecondaryProcessing_profile_init+0x50>)
{
    a192:	9301      	str	r3, [sp, #4]
    a194:	2301      	movs	r3, #1
		const PixelLEDGroupEntry entry = Pixel_LED_DefaultFadeGroups[group];
    a196:	f831 6c04 	ldrh.w	r6, [r1, #-4]
    a19a:	680f      	ldr	r7, [r1, #0]
		for ( uint16_t pxin = 0; pxin < entry.size; pxin++ )
    a19c:	2000      	movs	r0, #0
    a19e:	b284      	uxth	r4, r0
    a1a0:	42b4      	cmp	r4, r6
    a1a2:	d30b      	bcc.n	a1bc <Pixel_SecondaryProcessing_profile_init+0x34>
    a1a4:	3301      	adds	r3, #1
    a1a6:	b2db      	uxtb	r3, r3
	for ( uint8_t group = 0; group < 3; group++ )
    a1a8:	2b04      	cmp	r3, #4
    a1aa:	f101 0108 	add.w	r1, r1, #8
    a1ae:	d1f2      	bne.n	a196 <Pixel_SecondaryProcessing_profile_init+0xe>
}
    a1b0:	9901      	ldr	r1, [sp, #4]
    a1b2:	6813      	ldr	r3, [r2, #0]
    a1b4:	4299      	cmp	r1, r3
    a1b6:	d008      	beq.n	a1ca <Pixel_SecondaryProcessing_profile_init+0x42>
    a1b8:	f7f8 faba 	bl	2730 <__stack_chk_fail>
			Pixel_pixel_fade_profile[entry.pixels[pxin] - 1] = group + 1;
    a1bc:	f837 4010 	ldrh.w	r4, [r7, r0, lsl #1]
    a1c0:	442c      	add	r4, r5
    a1c2:	3001      	adds	r0, #1
    a1c4:	f804 3c01 	strb.w	r3, [r4, #-1]
    a1c8:	e7e9      	b.n	a19e <Pixel_SecondaryProcessing_profile_init+0x16>
}
    a1ca:	b003      	add	sp, #12
    a1cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a1ce:	bf00      	nop
    a1d0:	1fff89d0 	.word	0x1fff89d0
    a1d4:	000154fc 	.word	0x000154fc
    a1d8:	1fff96ce 	.word	0x1fff96ce

0000a1dc <Pixel_SecondaryProcessing_setup>:
{
    a1dc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a1e0:	4c1d      	ldr	r4, [pc, #116]	; (a258 <Pixel_SecondaryProcessing_setup+0x7c>)
	memset( Pixel_pixel_fade_profile, 0, Pixel_TotalPixels_KLL );
    a1e2:	481e      	ldr	r0, [pc, #120]	; (a25c <Pixel_SecondaryProcessing_setup+0x80>)
{
    a1e4:	6823      	ldr	r3, [r4, #0]
    a1e6:	9301      	str	r3, [sp, #4]
	memset( Pixel_pixel_fade_profile, 0, Pixel_TotalPixels_KLL );
    a1e8:	2226      	movs	r2, #38	; 0x26
    a1ea:	2100      	movs	r1, #0
    a1ec:	f7f8 faae 	bl	274c <memset>
	Pixel_SecondaryProcessing_profile_init();
    a1f0:	f7ff ffca 	bl	a188 <Pixel_SecondaryProcessing_profile_init>
    a1f4:	4a1a      	ldr	r2, [pc, #104]	; (a260 <Pixel_SecondaryProcessing_setup+0x84>)
			uint8_t period_index = Pixel_LED_FadePeriod_Defaults[pf][pr];
    a1f6:	f8df 806c 	ldr.w	r8, [pc, #108]	; a264 <Pixel_SecondaryProcessing_setup+0x88>
			PixelPeriodConfig conf = Pixel_LED_FadePeriods[period_index];
    a1fa:	f8df 906c 	ldr.w	r9, [pc, #108]	; a268 <Pixel_SecondaryProcessing_setup+0x8c>
	Pixel_SecondaryProcessing_profile_init();
    a1fe:	2100      	movs	r1, #0
    a200:	460d      	mov	r5, r1
    a202:	4694      	mov	ip, r2
			Pixel_pixel_fade_profile_entries[pf].conf[pr].start = conf.start;
    a204:	f04f 0e0c 	mov.w	lr, #12
		Pixel_pixel_fade_profile_entries[pf].pos = 0;
    a208:	460f      	mov	r7, r1
{
    a20a:	2300      	movs	r3, #0
			Pixel_pixel_fade_profile_entries[pf].conf[pr].start = conf.start;
    a20c:	fb0e c605 	mla	r6, lr, r5, ip
			uint8_t period_index = Pixel_LED_FadePeriod_Defaults[pf][pr];
    a210:	eb03 0008 	add.w	r0, r3, r8
			PixelPeriodConfig conf = Pixel_LED_FadePeriods[period_index];
    a214:	5c40      	ldrb	r0, [r0, r1]
    a216:	f819 0000 	ldrb.w	r0, [r9, r0]
    a21a:	ea4f 1a10 	mov.w	sl, r0, lsr #4
    a21e:	f3c0 0b03 	ubfx	fp, r0, #0, #4
			Pixel_pixel_fade_profile_entries[pf].conf[pr].start = conf.start;
    a222:	5cf0      	ldrb	r0, [r6, r3]
    a224:	f36b 0003 	bfi	r0, fp, #0, #4
			Pixel_pixel_fade_profile_entries[pf].conf[pr].end = conf.end;
    a228:	f36a 1007 	bfi	r0, sl, #4, #4
    a22c:	54f0      	strb	r0, [r6, r3]
    a22e:	3301      	adds	r3, #1
		for ( uint8_t pr = 0; pr < 4; pr++ )
    a230:	2b04      	cmp	r3, #4
    a232:	d1ed      	bne.n	a210 <Pixel_SecondaryProcessing_setup+0x34>
    a234:	3501      	adds	r5, #1
	for ( uint8_t pf = 0; pf < 4; pf++ )
    a236:	2d04      	cmp	r5, #4
		Pixel_pixel_fade_profile_entries[pf].pos = 0;
    a238:	6057      	str	r7, [r2, #4]
		Pixel_pixel_fade_profile_entries[pf].period_conf = PixelPeriodIndex_Off_to_On;
    a23a:	7217      	strb	r7, [r2, #8]
    a23c:	f101 0104 	add.w	r1, r1, #4
    a240:	f102 020c 	add.w	r2, r2, #12
	for ( uint8_t pf = 0; pf < 4; pf++ )
    a244:	d1e1      	bne.n	a20a <Pixel_SecondaryProcessing_setup+0x2e>
}
    a246:	9a01      	ldr	r2, [sp, #4]
    a248:	6823      	ldr	r3, [r4, #0]
    a24a:	429a      	cmp	r2, r3
    a24c:	d001      	beq.n	a252 <Pixel_SecondaryProcessing_setup+0x76>
    a24e:	f7f8 fa6f 	bl	2730 <__stack_chk_fail>
    a252:	b003      	add	sp, #12
    a254:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a258:	1fff89d0 	.word	0x1fff89d0
    a25c:	1fff96ce 	.word	0x1fff96ce
    a260:	1fff96f4 	.word	0x1fff96f4
    a264:	00015510 	.word	0x00015510
    a268:	00015520 	.word	0x00015520

0000a26c <Pixel_SecondaryProcessing>:
{
    a26c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a270:	4c76      	ldr	r4, [pc, #472]	; (a44c <Pixel_SecondaryProcessing+0x1e0>)
    a272:	4f77      	ldr	r7, [pc, #476]	; (a450 <Pixel_SecondaryProcessing+0x1e4>)
    a274:	6823      	ldr	r3, [r4, #0]
    a276:	9301      	str	r3, [sp, #4]
			Pixel_Buffers[buf].size * ( Pixel_Buffers[buf].width >> 3 ) // Size may not be multiples bytes
    a278:	4b76      	ldr	r3, [pc, #472]	; (a454 <Pixel_SecondaryProcessing+0x1e8>)
    a27a:	785a      	ldrb	r2, [r3, #1]
    a27c:	7819      	ldrb	r1, [r3, #0]
    a27e:	08d2      	lsrs	r2, r2, #3
		memcpy(
    a280:	434a      	muls	r2, r1
    a282:	6859      	ldr	r1, [r3, #4]
    a284:	4b74      	ldr	r3, [pc, #464]	; (a458 <Pixel_SecondaryProcessing+0x1ec>)
    a286:	6858      	ldr	r0, [r3, #4]
    a288:	f7f8 fa76 	bl	2778 <memcpy>
    a28c:	2600      	movs	r6, #0
    a28e:	46a1      	mov	r9, r4
		uint8_t profile_in = Pixel_pixel_fade_profile[pxin];
    a290:	4b72      	ldr	r3, [pc, #456]	; (a45c <Pixel_SecondaryProcessing+0x1f0>)
    a292:	5cf4      	ldrb	r4, [r6, r3]
		if ( profile_in == 0 )
    a294:	b9a4      	cbnz	r4, a2c0 <Pixel_SecondaryProcessing+0x54>
    a296:	3601      	adds	r6, #1
	for ( uint16_t pxin = 0; pxin < Pixel_TotalPixels_KLL; pxin++ )
    a298:	2e26      	cmp	r6, #38	; 0x26
    a29a:	f107 0708 	add.w	r7, r7, #8
    a29e:	d1f7      	bne.n	a290 <Pixel_SecondaryProcessing+0x24>
    a2a0:	4b6f      	ldr	r3, [pc, #444]	; (a460 <Pixel_SecondaryProcessing+0x1f4>)
    a2a2:	2200      	movs	r2, #0
    a2a4:	4618      	mov	r0, r3
			if ( profile->pos >= (1 << period->end) )
    a2a6:	250c      	movs	r5, #12
				profile->pos = (1 << profile->conf[PixelPeriodIndex_Off_to_On].start) - 1;
    a2a8:	2401      	movs	r4, #1
				profile->period_conf = PixelPeriodIndex_Off_to_On;
    a2aa:	4616      	mov	r6, r2
				profile->period_conf = PixelPeriodIndex_Off;
    a2ac:	2703      	movs	r7, #3
				profile->period_conf = PixelPeriodIndex_On_to_Off;
    a2ae:	f04f 0c02 	mov.w	ip, #2
		switch ( profile->period_conf )
    a2b2:	7a19      	ldrb	r1, [r3, #8]
    a2b4:	2903      	cmp	r1, #3
    a2b6:	d874      	bhi.n	a3a2 <Pixel_SecondaryProcessing+0x136>
    a2b8:	e8df f001 	tbb	[pc, r1]
    a2bc:	ad947f5c 	.word	0xad947f5c
		PixelPeriodConfig *period = &profile->conf[profile->period_conf];
    a2c0:	4a67      	ldr	r2, [pc, #412]	; (a460 <Pixel_SecondaryProcessing+0x1f4>)
		PixelFadeProfile *profile = &Pixel_pixel_fade_profile_entries[profile_in - 1];
    a2c2:	3c01      	subs	r4, #1
		PixelPeriodConfig *period = &profile->conf[profile->period_conf];
    a2c4:	230c      	movs	r3, #12
    a2c6:	fb03 2404 	mla	r4, r3, r4, r2
		for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    a2ca:	f04f 0800 	mov.w	r8, #0
		PixelPeriodConfig *period = &profile->conf[profile->period_conf];
    a2ce:	f894 a008 	ldrb.w	sl, [r4, #8]
		for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    a2d2:	7878      	ldrb	r0, [r7, #1]
    a2d4:	fa5f f388 	uxtb.w	r3, r8
    a2d8:	4298      	cmp	r0, r3
    a2da:	d9dc      	bls.n	a296 <Pixel_SecondaryProcessing+0x2a>
			uint16_t chan = elem->indices[ch];
    a2dc:	4a5c      	ldr	r2, [pc, #368]	; (a450 <Pixel_SecondaryProcessing+0x1e4>)
    a2de:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    a2e2:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    a2e6:	885d      	ldrh	r5, [r3, #2]
			PixelBuf *buf = LED_bufferMap( chan );
    a2e8:	4628      	mov	r0, r5
    a2ea:	f7ff fb55 	bl	9998 <LED_bufferMap>
    a2ee:	4683      	mov	fp, r0
			PixelBuf *bufin = Pixel_bufferMap( chan );
    a2f0:	4628      	mov	r0, r5
    a2f2:	f7ff fb17 	bl	9924 <Pixel_bufferMap>
			switch (buf->width)
    a2f6:	f89b 3001 	ldrb.w	r3, [fp, #1]
    a2fa:	2b10      	cmp	r3, #16
    a2fc:	d136      	bne.n	a36c <Pixel_SecondaryProcessing+0x100>
				switch ( profile->period_conf )
    a2fe:	7a23      	ldrb	r3, [r4, #8]
    a300:	2b02      	cmp	r3, #2
    a302:	d002      	beq.n	a30a <Pixel_SecondaryProcessing+0x9e>
    a304:	2b03      	cmp	r3, #3
    a306:	d017      	beq.n	a338 <Pixel_SecondaryProcessing+0xcc>
    a308:	b99b      	cbnz	r3, a332 <Pixel_SecondaryProcessing+0xc6>
					if ( period->end == 0 && period->start == 0 )
    a30a:	f814 200a 	ldrb.w	r2, [r4, sl]
    a30e:	b182      	cbz	r2, a332 <Pixel_SecondaryProcessing+0xc6>
					val = (uint8_t)((uint16_t*)bufin->data)[chan - buf->offset];
    a310:	f8bb 3002 	ldrh.w	r3, [fp, #2]
    a314:	1aed      	subs	r5, r5, r3
    a316:	6843      	ldr	r3, [r0, #4]
    a318:	f813 0015 	ldrb.w	r0, [r3, r5, lsl #1]
					val *= profile->pos;
    a31c:	6863      	ldr	r3, [r4, #4]
					val >>= period->end;
    a31e:	ea4f 1c12 	mov.w	ip, r2, lsr #4
					val *= profile->pos;
    a322:	4343      	muls	r3, r0
					((uint16_t*)buf->data)[chan - buf->offset] = (uint8_t)val;
    a324:	f8db 0004 	ldr.w	r0, [fp, #4]
					val >>= period->end;
    a328:	fa23 f30c 	lsr.w	r3, r3, ip
					((uint16_t*)buf->data)[chan - buf->offset] = (uint8_t)val;
    a32c:	b2db      	uxtb	r3, r3
    a32e:	f820 3015 	strh.w	r3, [r0, r5, lsl #1]
    a332:	f108 0801 	add.w	r8, r8, #1
    a336:	e7cc      	b.n	a2d2 <Pixel_SecondaryProcessing+0x66>
					if ( prev->start == 0 && prev->end == 0 )
    a338:	78a2      	ldrb	r2, [r4, #2]
    a33a:	2a00      	cmp	r2, #0
    a33c:	d0f9      	beq.n	a332 <Pixel_SecondaryProcessing+0xc6>
    a33e:	f8bb 3002 	ldrh.w	r3, [fp, #2]
    a342:	1aed      	subs	r5, r5, r3
					if ( prev->start != 0 )
    a344:	f012 030f 	ands.w	r3, r2, #15
    a348:	d00d      	beq.n	a366 <Pixel_SecondaryProcessing+0xfa>
						val = (uint8_t)((uint16_t*)bufin->data)[chan - buf->offset];
    a34a:	6843      	ldr	r3, [r0, #4]
						val *= (1 << prev->start) - 1;
    a34c:	f002 0e0f 	and.w	lr, r2, #15
    a350:	2001      	movs	r0, #1
						val = (uint8_t)((uint16_t*)bufin->data)[chan - buf->offset];
    a352:	f813 3015 	ldrb.w	r3, [r3, r5, lsl #1]
						val *= (1 << prev->start) - 1;
    a356:	fa00 f00e 	lsl.w	r0, r0, lr
    a35a:	3801      	subs	r0, #1
    a35c:	4343      	muls	r3, r0
						val >>= prev->end;
    a35e:	ea4f 1c12 	mov.w	ip, r2, lsr #4
    a362:	fa23 f30c 	lsr.w	r3, r3, ip
					((uint16_t*)buf->data)[chan - buf->offset] = (uint8_t)val;
    a366:	f8db 0004 	ldr.w	r0, [fp, #4]
    a36a:	e7df      	b.n	a32c <Pixel_SecondaryProcessing+0xc0>
				erro_print("Unsupported buffer width");
    a36c:	483d      	ldr	r0, [pc, #244]	; (a464 <Pixel_SecondaryProcessing+0x1f8>)
    a36e:	f005 f8ff 	bl	f570 <_print>
				break;
    a372:	e7de      	b.n	a332 <Pixel_SecondaryProcessing+0xc6>
			profile->pos++;
    a374:	6859      	ldr	r1, [r3, #4]
			if ( profile->pos >= (1 << period->end) )
    a376:	fb05 fe02 	mul.w	lr, r5, r2
			profile->pos++;
    a37a:	3101      	adds	r1, #1
    a37c:	6059      	str	r1, [r3, #4]
			if ( profile->pos >= (1 << period->end) )
    a37e:	eb00 080e 	add.w	r8, r0, lr
    a382:	f810 e00e 	ldrb.w	lr, [r0, lr]
    a386:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
    a38a:	fa31 f10e 	lsrs.w	r1, r1, lr
    a38e:	d008      	beq.n	a3a2 <Pixel_SecondaryProcessing+0x136>
				profile->pos = (1 << profile->conf[PixelPeriodIndex_On].start) - 1;
    a390:	f898 1001 	ldrb.w	r1, [r8, #1]
				profile->period_conf = PixelPeriodIndex_On;
    a394:	721c      	strb	r4, [r3, #8]
				profile->pos = (1 << profile->conf[PixelPeriodIndex_On].start) - 1;
    a396:	f001 010f 	and.w	r1, r1, #15
    a39a:	fa04 f101 	lsl.w	r1, r4, r1
    a39e:	3901      	subs	r1, #1
    a3a0:	6059      	str	r1, [r3, #4]
    a3a2:	3201      	adds	r2, #1
	for ( uint8_t proin = 0; proin < 4; proin++ )
    a3a4:	2a04      	cmp	r2, #4
    a3a6:	f103 030c 	add.w	r3, r3, #12
    a3aa:	d182      	bne.n	a2b2 <Pixel_SecondaryProcessing+0x46>
}
    a3ac:	9a01      	ldr	r2, [sp, #4]
    a3ae:	f8d9 3000 	ldr.w	r3, [r9]
    a3b2:	429a      	cmp	r2, r3
    a3b4:	d047      	beq.n	a446 <Pixel_SecondaryProcessing+0x1da>
    a3b6:	f7f8 f9bb 	bl	2730 <__stack_chk_fail>
			profile->pos++;
    a3ba:	6859      	ldr	r1, [r3, #4]
			if ( profile->pos >= (1 << period->end) )
    a3bc:	fb05 0802 	mla	r8, r5, r2, r0
			profile->pos++;
    a3c0:	3101      	adds	r1, #1
    a3c2:	6059      	str	r1, [r3, #4]
			if ( profile->pos >= (1 << period->end) )
    a3c4:	f898 e001 	ldrb.w	lr, [r8, #1]
    a3c8:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
    a3cc:	fa31 f10e 	lsrs.w	r1, r1, lr
    a3d0:	d0e7      	beq.n	a3a2 <Pixel_SecondaryProcessing+0x136>
				profile->pos = (1 << profile->conf[PixelPeriodIndex_On_to_Off].end);
    a3d2:	f898 1002 	ldrb.w	r1, [r8, #2]
				profile->period_conf = PixelPeriodIndex_On_to_Off;
    a3d6:	f883 c008 	strb.w	ip, [r3, #8]
				profile->pos = (1 << profile->conf[PixelPeriodIndex_On_to_Off].end);
    a3da:	0909      	lsrs	r1, r1, #4
    a3dc:	fa04 f101 	lsl.w	r1, r4, r1
    a3e0:	6059      	str	r1, [r3, #4]
    a3e2:	e7de      	b.n	a3a2 <Pixel_SecondaryProcessing+0x136>
			profile->pos--;
    a3e4:	6859      	ldr	r1, [r3, #4]
			if ( profile->pos == (1 << period->start) - 1 )
    a3e6:	fb05 0802 	mla	r8, r5, r2, r0
			profile->pos--;
    a3ea:	3901      	subs	r1, #1
    a3ec:	6059      	str	r1, [r3, #4]
			if ( profile->pos == (1 << period->start) - 1 )
    a3ee:	f898 e002 	ldrb.w	lr, [r8, #2]
    a3f2:	f00e 0e0f 	and.w	lr, lr, #15
    a3f6:	fa04 fe0e 	lsl.w	lr, r4, lr
    a3fa:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
    a3fe:	4571      	cmp	r1, lr
    a400:	d1cf      	bne.n	a3a2 <Pixel_SecondaryProcessing+0x136>
				profile->pos = (1 << profile->conf[PixelPeriodIndex_Off].start) - 1;
    a402:	f898 1003 	ldrb.w	r1, [r8, #3]
				profile->period_conf = PixelPeriodIndex_Off;
    a406:	721f      	strb	r7, [r3, #8]
				profile->pos = (1 << profile->conf[PixelPeriodIndex_Off].start) - 1;
    a408:	f001 010f 	and.w	r1, r1, #15
    a40c:	fa04 f101 	lsl.w	r1, r4, r1
    a410:	3901      	subs	r1, #1
    a412:	6059      	str	r1, [r3, #4]
    a414:	e7c5      	b.n	a3a2 <Pixel_SecondaryProcessing+0x136>
			profile->pos++;
    a416:	6859      	ldr	r1, [r3, #4]
			if ( profile->pos >= (1 << period->end) )
    a418:	fb05 f802 	mul.w	r8, r5, r2
			profile->pos++;
    a41c:	3101      	adds	r1, #1
			if ( profile->pos >= (1 << period->end) )
    a41e:	eb00 0e08 	add.w	lr, r0, r8
			profile->pos++;
    a422:	6059      	str	r1, [r3, #4]
			if ( profile->pos >= (1 << period->end) )
    a424:	f89e e003 	ldrb.w	lr, [lr, #3]
    a428:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
    a42c:	fa31 f10e 	lsrs.w	r1, r1, lr
    a430:	d0b7      	beq.n	a3a2 <Pixel_SecondaryProcessing+0x136>
				profile->pos = (1 << profile->conf[PixelPeriodIndex_Off_to_On].start) - 1;
    a432:	f810 1008 	ldrb.w	r1, [r0, r8]
				profile->period_conf = PixelPeriodIndex_Off_to_On;
    a436:	721e      	strb	r6, [r3, #8]
				profile->pos = (1 << profile->conf[PixelPeriodIndex_Off_to_On].start) - 1;
    a438:	f001 010f 	and.w	r1, r1, #15
    a43c:	fa04 f101 	lsl.w	r1, r4, r1
    a440:	3901      	subs	r1, #1
    a442:	6059      	str	r1, [r3, #4]
    a444:	e7ad      	b.n	a3a2 <Pixel_SecondaryProcessing+0x136>
}
    a446:	b003      	add	sp, #12
    a448:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a44c:	1fff89d0 	.word	0x1fff89d0
    a450:	00015530 	.word	0x00015530
    a454:	1fff8e34 	.word	0x1fff8e34
    a458:	1fff8e28 	.word	0x1fff8e28
    a45c:	1fff96ce 	.word	0x1fff96ce
    a460:	1fff96f4 	.word	0x1fff96f4
    a464:	000148e8 	.word	0x000148e8

0000a468 <Pixel_determineLastTriggerScanCode>:
{
    a468:	b537      	push	{r0, r1, r2, r4, r5, lr}
    a46a:	490d      	ldr	r1, [pc, #52]	; (a4a0 <Pixel_determineLastTriggerScanCode+0x38>)
    a46c:	680a      	ldr	r2, [r1, #0]
    a46e:	9201      	str	r2, [sp, #4]
	if ( trigger == 0 )
    a470:	b170      	cbz	r0, a490 <Pixel_determineLastTriggerScanCode+0x28>
		uint8_t comboLength = trigger->guide[ pos ] * TriggerGuideSize;
    a472:	6805      	ldr	r5, [r0, #0]
	for ( var_uint_t pos = 0; ; pos += trigger->guide[ pos ] * TriggerGuideSize + 1 )
    a474:	2200      	movs	r2, #0
		uint8_t comboLength = trigger->guide[ pos ] * TriggerGuideSize;
    a476:	5cab      	ldrb	r3, [r5, r2]
		curScanCode = guide->scanCode;
    a478:	18ac      	adds	r4, r5, r2
		uint8_t comboLength = trigger->guide[ pos ] * TriggerGuideSize;
    a47a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
		curScanCode = guide->scanCode;
    a47e:	78e0      	ldrb	r0, [r4, #3]
		if ( trigger->guide[ pos + comboLength + 1 ] == 0 )
    a480:	fa54 f483 	uxtab	r4, r4, r3
    a484:	7864      	ldrb	r4, [r4, #1]
    a486:	b11c      	cbz	r4, a490 <Pixel_determineLastTriggerScanCode+0x28>
	for ( var_uint_t pos = 0; ; pos += trigger->guide[ pos ] * TriggerGuideSize + 1 )
    a488:	3301      	adds	r3, #1
    a48a:	4413      	add	r3, r2
    a48c:	b29a      	uxth	r2, r3
    a48e:	e7f2      	b.n	a476 <Pixel_determineLastTriggerScanCode+0xe>
}
    a490:	9a01      	ldr	r2, [sp, #4]
    a492:	680b      	ldr	r3, [r1, #0]
    a494:	429a      	cmp	r2, r3
    a496:	d001      	beq.n	a49c <Pixel_determineLastTriggerScanCode+0x34>
    a498:	f7f8 f94a 	bl	2730 <__stack_chk_fail>
    a49c:	b003      	add	sp, #12
    a49e:	bd30      	pop	{r4, r5, pc}
    a4a0:	1fff89d0 	.word	0x1fff89d0

0000a4a4 <Pixel_fillPixelLookup>:
{
    a4a4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    a4a8:	4e8e      	ldr	r6, [pc, #568]	; (a6e4 <Pixel_fillPixelLookup+0x240>)
    a4aa:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    a4ae:	4614      	mov	r4, r2
    a4b0:	6832      	ldr	r2, [r6, #0]
    a4b2:	9201      	str	r2, [sp, #4]
	*valid = 0;
    a4b4:	2200      	movs	r2, #0
    a4b6:	f8a8 2000 	strh.w	r2, [r8]
	*elem = 0;
    a4ba:	600a      	str	r2, [r1, #0]
	switch ( mod->type )
    a4bc:	7802      	ldrb	r2, [r0, #0]
    a4be:	3a01      	subs	r2, #1
{
    a4c0:	4681      	mov	r9, r0
    a4c2:	460f      	mov	r7, r1
	switch ( mod->type )
    a4c4:	2a08      	cmp	r2, #8
    a4c6:	d812      	bhi.n	a4ee <Pixel_fillPixelLookup+0x4a>
    a4c8:	e8df f012 	tbh	[pc, r2, lsl #1]
    a4cc:	00130009 	.word	0x00130009
    a4d0:	0063003d 	.word	0x0063003d
    a4d4:	00110074 	.word	0x00110074
    a4d8:	00b0008e 	.word	0x00b0008e
    a4dc:	00d9      	.short	0x00d9
		*elem = (PixelElement*)&Pixel_Mapping[mod->index] - 1;
    a4de:	f8d0 2001 	ldr.w	r2, [r0, #1]
    a4e2:	4b81      	ldr	r3, [pc, #516]	; (a6e8 <Pixel_fillPixelLookup+0x244>)
		if ( mod->index <= Pixel_TotalPixels_KLL )
    a4e4:	2a26      	cmp	r2, #38	; 0x26
		*elem = (PixelElement*)&Pixel_Mapping[mod->index] - 1;
    a4e6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    a4ea:	603b      	str	r3, [r7, #0]
		if ( mod->index <= Pixel_TotalPixels_KLL )
    a4ec:	dd27      	ble.n	a53e <Pixel_fillPixelLookup+0x9a>
	return 0;
    a4ee:	2400      	movs	r4, #0
    a4f0:	e047      	b.n	a582 <Pixel_fillPixelLookup+0xde>
		if ( mod->rect.col >= Pixel_DisplayMapping_Cols_KLL
    a4f2:	f9b0 2001 	ldrsh.w	r2, [r0, #1]
    a4f6:	f9b0 3003 	ldrsh.w	r3, [r0, #3]
    a4fa:	2a10      	cmp	r2, #16
    a4fc:	b219      	sxth	r1, r3
    a4fe:	dd13      	ble.n	a528 <Pixel_fillPixelLookup+0x84>
			&& mod->rect.row >= Pixel_DisplayMapping_Rows_KLL )
    a500:	2906      	cmp	r1, #6
    a502:	dd11      	ble.n	a528 <Pixel_fillPixelLookup+0x84>
			erro_msg("Invalid row,column index: ");
    a504:	4879      	ldr	r0, [pc, #484]	; (a6ec <Pixel_fillPixelLookup+0x248>)
    a506:	f005 f833 	bl	f570 <_print>
			printInt16( mod->rect.row );
    a50a:	f8b9 0003 	ldrh.w	r0, [r9, #3]
    a50e:	f005 f8cf 	bl	f6b0 <printInt16>
			print(",");
    a512:	4877      	ldr	r0, [pc, #476]	; (a6f0 <Pixel_fillPixelLookup+0x24c>)
    a514:	f005 f82c 	bl	f570 <_print>
			printInt16( mod->rect.col );
    a518:	f8b9 0001 	ldrh.w	r0, [r9, #1]
			printInt16( position );
    a51c:	f005 f8c8 	bl	f6b0 <printInt16>
			print( NL );
    a520:	4874      	ldr	r0, [pc, #464]	; (a6f4 <Pixel_fillPixelLookup+0x250>)
    a522:	f005 f825 	bl	f570 <_print>
    a526:	e7e2      	b.n	a4ee <Pixel_fillPixelLookup+0x4a>
				mod->rect.row * Pixel_DisplayMapping_Cols_KLL + mod->rect.col
    a528:	2111      	movs	r1, #17
    a52a:	fb13 2301 	smlabb	r3, r3, r1, r2
			Pixel_DisplayMapping[
    a52e:	4a72      	ldr	r2, [pc, #456]	; (a6f8 <Pixel_fillPixelLookup+0x254>)
    a530:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
			] - 1
    a534:	1e5a      	subs	r2, r3, #1
		*elem = (PixelElement*)&Pixel_Mapping[
    a536:	4b71      	ldr	r3, [pc, #452]	; (a6fc <Pixel_fillPixelLookup+0x258>)
    a538:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    a53c:	603b      	str	r3, [r7, #0]
		*valid = 1;
    a53e:	2301      	movs	r3, #1
    a540:	f8a8 3000 	strh.w	r3, [r8]
    a544:	e7d3      	b.n	a4ee <Pixel_fillPixelLookup+0x4a>
    a546:	f9b0 0001 	ldrsh.w	r0, [r0, #1]
    a54a:	eb04 1304 	add.w	r3, r4, r4, lsl #4
    a54e:	4403      	add	r3, r0
    a550:	4869      	ldr	r0, [pc, #420]	; (a6f8 <Pixel_fillPixelLookup+0x254>)
			index = Pixel_DisplayMapping[ cur * Pixel_DisplayMapping_Cols_KLL + mod->rect.col ];
    a552:	2100      	movs	r1, #0
    a554:	eb00 0043 	add.w	r0, r0, r3, lsl #1
    a558:	2222      	movs	r2, #34	; 0x22
    a55a:	fb02 f301 	mul.w	r3, r2, r1
			if ( cur >= Pixel_DisplayMapping_Rows_KLL )
    a55e:	2c06      	cmp	r4, #6
			index = Pixel_DisplayMapping[ cur * Pixel_DisplayMapping_Cols_KLL + mod->rect.col ];
    a560:	5ac3      	ldrh	r3, [r0, r3]
			if ( cur >= Pixel_DisplayMapping_Rows_KLL )
    a562:	d8c4      	bhi.n	a4ee <Pixel_fillPixelLookup+0x4a>
			cur++;
    a564:	3401      	adds	r4, #1
    a566:	b2a4      	uxth	r4, r4
    a568:	3101      	adds	r1, #1
		} while ( index == 0 );
    a56a:	2b00      	cmp	r3, #0
    a56c:	d0f5      	beq.n	a55a <Pixel_fillPixelLookup+0xb6>
		if ( index <= Pixel_TotalPixels_KLL )
    a56e:	2b26      	cmp	r3, #38	; 0x26
			*valid = 1;
    a570:	bf9c      	itt	ls
    a572:	2201      	movls	r2, #1
    a574:	f8a8 2000 	strhls.w	r2, [r8]
		*elem = (PixelElement*)&Pixel_Mapping[ index - 1 ];
    a578:	4a60      	ldr	r2, [pc, #384]	; (a6fc <Pixel_fillPixelLookup+0x258>)
    a57a:	3b01      	subs	r3, #1
    a57c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    a580:	603b      	str	r3, [r7, #0]
}
    a582:	9a01      	ldr	r2, [sp, #4]
    a584:	6833      	ldr	r3, [r6, #0]
    a586:	429a      	cmp	r2, r3
    a588:	4620      	mov	r0, r4
    a58a:	f000 80a8 	beq.w	a6de <Pixel_fillPixelLookup+0x23a>
    a58e:	f7f8 f8cf 	bl	2730 <__stack_chk_fail>
			index = Pixel_DisplayMapping[ mod->rect.row * Pixel_DisplayMapping_Cols_KLL + cur ];
    a592:	f9b0 1003 	ldrsh.w	r1, [r0, #3]
    a596:	2311      	movs	r3, #17
    a598:	fb11 4303 	smlabb	r3, r1, r3, r4
    a59c:	4958      	ldr	r1, [pc, #352]	; (a700 <Pixel_fillPixelLookup+0x25c>)
    a59e:	eb01 0143 	add.w	r1, r1, r3, lsl #1
			if ( cur >= Pixel_DisplayMapping_Cols_KLL )
    a5a2:	2c10      	cmp	r4, #16
			index = Pixel_DisplayMapping[ mod->rect.row * Pixel_DisplayMapping_Cols_KLL + cur ];
    a5a4:	f831 3f02 	ldrh.w	r3, [r1, #2]!
			if ( cur >= Pixel_DisplayMapping_Cols_KLL )
    a5a8:	d8a1      	bhi.n	a4ee <Pixel_fillPixelLookup+0x4a>
			cur++;
    a5aa:	3401      	adds	r4, #1
    a5ac:	b2a4      	uxth	r4, r4
		} while ( index == 0 );
    a5ae:	2b00      	cmp	r3, #0
    a5b0:	d0f7      	beq.n	a5a2 <Pixel_fillPixelLookup+0xfe>
    a5b2:	e7dc      	b.n	a56e <Pixel_fillPixelLookup+0xca>
		if ( mod->index > MaxScanCode_KLL )
    a5b4:	f8d0 3001 	ldr.w	r3, [r0, #1]
    a5b8:	2b5a      	cmp	r3, #90	; 0x5a
    a5ba:	dd06      	ble.n	a5ca <Pixel_fillPixelLookup+0x126>
			erro_msg("Invalid ScanCode: ");
    a5bc:	4851      	ldr	r0, [pc, #324]	; (a704 <Pixel_fillPixelLookup+0x260>)
    a5be:	f004 ffd7 	bl	f570 <_print>
			printInt16( mod->index );
    a5c2:	f8d9 0001 	ldr.w	r0, [r9, #1]
    a5c6:	b280      	uxth	r0, r0
    a5c8:	e7a8      	b.n	a51c <Pixel_fillPixelLookup+0x78>
		*valid = 1;
    a5ca:	2301      	movs	r3, #1
    a5cc:	f8a8 3000 	strh.w	r3, [r8]
		uint16_t pixel = Pixel_ScanCodeToPixel[ mod->index - 1 ];
    a5d0:	f8d0 3001 	ldr.w	r3, [r0, #1]
		*elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    a5d4:	4a4c      	ldr	r2, [pc, #304]	; (a708 <Pixel_fillPixelLookup+0x264>)
		uint16_t pixel = Pixel_ScanCodeToPixel[ mod->index - 1 ];
    a5d6:	3b01      	subs	r3, #1
		*elem = (PixelElement*)&Pixel_Mapping[ pixel - 1 ];
    a5d8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    a5dc:	1e5a      	subs	r2, r3, #1
    a5de:	4b47      	ldr	r3, [pc, #284]	; (a6fc <Pixel_fillPixelLookup+0x258>)
    a5e0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
			*elem = (PixelElement*)&Pixel_Mapping[ index - 1 ];
    a5e4:	603b      	str	r3, [r7, #0]
    a5e6:	e782      	b.n	a4ee <Pixel_fillPixelLookup+0x4a>
		uint8_t scan_code = Pixel_determineLastTriggerScanCode( stack_elem->trigger );
    a5e8:	6818      	ldr	r0, [r3, #0]
    a5ea:	f7ff ff3d 	bl	a468 <Pixel_determineLastTriggerScanCode>
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    a5ee:	4b47      	ldr	r3, [pc, #284]	; (a70c <Pixel_fillPixelLookup+0x268>)
		position += (int16_t)mod->rect.row * Pixel_DisplayMapping_Cols_KLL + (int16_t)mod->rect.col;
    a5f0:	f9b9 2003 	ldrsh.w	r2, [r9, #3]
    a5f4:	f9b9 1001 	ldrsh.w	r1, [r9, #1]
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    a5f8:	3801      	subs	r0, #1
		position += (int16_t)mod->rect.row * Pixel_DisplayMapping_Cols_KLL + (int16_t)mod->rect.col;
    a5fa:	eb02 1202 	add.w	r2, r2, r2, lsl #4
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    a5fe:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
		position += (int16_t)mod->rect.row * Pixel_DisplayMapping_Cols_KLL + (int16_t)mod->rect.col;
    a602:	440a      	add	r2, r1
    a604:	4413      	add	r3, r2
    a606:	b29b      	uxth	r3, r3
		if ( position >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    a608:	2b76      	cmp	r3, #118	; 0x76
    a60a:	f63f af70 	bhi.w	a4ee <Pixel_fillPixelLookup+0x4a>
		index = Pixel_DisplayMapping[ position ];
    a60e:	4a3a      	ldr	r2, [pc, #232]	; (a6f8 <Pixel_fillPixelLookup+0x254>)
    a610:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
		if ( index <= Pixel_TotalPixels_KLL && index != 0 )
    a614:	3b01      	subs	r3, #1
    a616:	b29a      	uxth	r2, r3
    a618:	2a25      	cmp	r2, #37	; 0x25
    a61a:	f63f af68 	bhi.w	a4ee <Pixel_fillPixelLookup+0x4a>
			*valid = 1;
    a61e:	2201      	movs	r2, #1
    a620:	f8a8 2000 	strh.w	r2, [r8]
			*elem = (PixelElement*)&Pixel_Mapping[ index - 1 ];
    a624:	4a35      	ldr	r2, [pc, #212]	; (a6fc <Pixel_fillPixelLookup+0x258>)
    a626:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    a62a:	e7db      	b.n	a5e4 <Pixel_fillPixelLookup+0x140>
		uint8_t scan_code = Pixel_determineLastTriggerScanCode( stack_elem->trigger );
    a62c:	6818      	ldr	r0, [r3, #0]
    a62e:	f7ff ff1b 	bl	a468 <Pixel_determineLastTriggerScanCode>
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    a632:	4b36      	ldr	r3, [pc, #216]	; (a70c <Pixel_fillPixelLookup+0x268>)
    a634:	3801      	subs	r0, #1
    a636:	f833 5010 	ldrh.w	r5, [r3, r0, lsl #1]
		position += (int16_t)mod->rect.col;
    a63a:	f9b9 3001 	ldrsh.w	r3, [r9, #1]
    a63e:	441d      	add	r5, r3
    a640:	b2ad      	uxth	r5, r5
		if ( position >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    a642:	2d76      	cmp	r5, #118	; 0x76
    a644:	d904      	bls.n	a650 <Pixel_fillPixelLookup+0x1ac>
			erro_msg("Invalid position index (relcol): ");
    a646:	4832      	ldr	r0, [pc, #200]	; (a710 <Pixel_fillPixelLookup+0x26c>)
			erro_msg("Invalid position index (relrow): ");
    a648:	f004 ff92 	bl	f570 <_print>
			printInt16( position );
    a64c:	4628      	mov	r0, r5
    a64e:	e765      	b.n	a51c <Pixel_fillPixelLookup+0x78>
		position %= Pixel_DisplayMapping_Cols_KLL;
    a650:	2311      	movs	r3, #17
    a652:	fbb5 f3f3 	udiv	r3, r5, r3
    a656:	eb03 1303 	add.w	r3, r3, r3, lsl #4
    a65a:	1aed      	subs	r5, r5, r3
    a65c:	eb04 1304 	add.w	r3, r4, r4, lsl #4
    a660:	441d      	add	r5, r3
			index = Pixel_DisplayMapping[ curpos ];
    a662:	4925      	ldr	r1, [pc, #148]	; (a6f8 <Pixel_fillPixelLookup+0x254>)
    a664:	b2ad      	uxth	r5, r5
			uint16_t curpos = cur++ * Pixel_DisplayMapping_Cols_KLL + position;
    a666:	3401      	adds	r4, #1
			if ( curpos >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    a668:	2d76      	cmp	r5, #118	; 0x76
			uint16_t curpos = cur++ * Pixel_DisplayMapping_Cols_KLL + position;
    a66a:	b2a4      	uxth	r4, r4
			if ( curpos >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    a66c:	f63f af3f 	bhi.w	a4ee <Pixel_fillPixelLookup+0x4a>
			index = Pixel_DisplayMapping[ curpos ];
    a670:	f831 3015 	ldrh.w	r3, [r1, r5, lsl #1]
    a674:	3511      	adds	r5, #17
    a676:	b2ad      	uxth	r5, r5
		} while ( index == 0 );
    a678:	2b00      	cmp	r3, #0
    a67a:	d0f4      	beq.n	a666 <Pixel_fillPixelLookup+0x1c2>
    a67c:	e777      	b.n	a56e <Pixel_fillPixelLookup+0xca>
		uint8_t scan_code = Pixel_determineLastTriggerScanCode( stack_elem->trigger );
    a67e:	6818      	ldr	r0, [r3, #0]
    a680:	f7ff fef2 	bl	a468 <Pixel_determineLastTriggerScanCode>
		uint16_t position = Pixel_ScanCodeToDisplay[ scan_code - 1 ];
    a684:	4b21      	ldr	r3, [pc, #132]	; (a70c <Pixel_fillPixelLookup+0x268>)
    a686:	3801      	subs	r0, #1
    a688:	f833 5010 	ldrh.w	r5, [r3, r0, lsl #1]
		position += (int16_t)mod->rect.row * Pixel_DisplayMapping_Rows_KLL;
    a68c:	f9b9 3003 	ldrsh.w	r3, [r9, #3]
    a690:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    a694:	441d      	add	r5, r3
    a696:	b2ad      	uxth	r5, r5
		if ( position >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    a698:	2d76      	cmp	r5, #118	; 0x76
    a69a:	d901      	bls.n	a6a0 <Pixel_fillPixelLookup+0x1fc>
			erro_msg("Invalid position index (relrow): ");
    a69c:	481d      	ldr	r0, [pc, #116]	; (a714 <Pixel_fillPixelLookup+0x270>)
    a69e:	e7d3      	b.n	a648 <Pixel_fillPixelLookup+0x1a4>
		position /= Pixel_DisplayMapping_Cols_KLL;
    a6a0:	2311      	movs	r3, #17
			index = Pixel_DisplayMapping[ curpos ];
    a6a2:	4915      	ldr	r1, [pc, #84]	; (a6f8 <Pixel_fillPixelLookup+0x254>)
		position /= Pixel_DisplayMapping_Cols_KLL;
    a6a4:	fbb5 f5f3 	udiv	r5, r5, r3
			uint16_t curpos = cur++ + Pixel_DisplayMapping_Cols_KLL * position;
    a6a8:	eb05 1505 	add.w	r5, r5, r5, lsl #4
    a6ac:	b2ad      	uxth	r5, r5
	uint16_t cur = prev;
    a6ae:	4623      	mov	r3, r4
			uint16_t curpos = cur++ + Pixel_DisplayMapping_Cols_KLL * position;
    a6b0:	3401      	adds	r4, #1
    a6b2:	b2a4      	uxth	r4, r4
    a6b4:	442b      	add	r3, r5
			if ( cur >= Pixel_DisplayMapping_Cols_KLL )
    a6b6:	2c10      	cmp	r4, #16
    a6b8:	b29b      	uxth	r3, r3
    a6ba:	f63f af18 	bhi.w	a4ee <Pixel_fillPixelLookup+0x4a>
			index = Pixel_DisplayMapping[ curpos ];
    a6be:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
    a6c2:	4623      	mov	r3, r4
		} while ( index == 0 );
    a6c4:	2a00      	cmp	r2, #0
    a6c6:	d0f3      	beq.n	a6b0 <Pixel_fillPixelLookup+0x20c>
		if ( index <= Pixel_TotalPixels_KLL )
    a6c8:	2a26      	cmp	r2, #38	; 0x26
			*valid = 1;
    a6ca:	bf9c      	itt	ls
    a6cc:	2301      	movls	r3, #1
    a6ce:	f8a8 3000 	strhls.w	r3, [r8]
		*elem = (PixelElement*)&Pixel_Mapping[ index - 1 ];
    a6d2:	4b0a      	ldr	r3, [pc, #40]	; (a6fc <Pixel_fillPixelLookup+0x258>)
    a6d4:	3a01      	subs	r2, #1
    a6d6:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    a6da:	603a      	str	r2, [r7, #0]
		return cur;
    a6dc:	e751      	b.n	a582 <Pixel_fillPixelLookup+0xde>
}
    a6de:	b003      	add	sp, #12
    a6e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    a6e4:	1fff89d0 	.word	0x1fff89d0
    a6e8:	00015528 	.word	0x00015528
    a6ec:	00014a1f 	.word	0x00014a1f
    a6f0:	00012bba 	.word	0x00012bba
    a6f4:	00015df4 	.word	0x00015df4
    a6f8:	000153bc 	.word	0x000153bc
    a6fc:	00015530 	.word	0x00015530
    a700:	000153ba 	.word	0x000153ba
    a704:	00014a4f 	.word	0x00014a4f
    a708:	000156ba 	.word	0x000156ba
    a70c:	00015660 	.word	0x00015660
    a710:	00014a77 	.word	0x00014a77
    a714:	00014aae 	.word	0x00014aae

0000a718 <Pixel_pixelTweenStandard>:
{
    a718:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a71c:	4d19      	ldr	r5, [pc, #100]	; (a784 <Pixel_pixelTweenStandard+0x6c>)
    a71e:	b089      	sub	sp, #36	; 0x24
    a720:	682b      	ldr	r3, [r5, #0]
    a722:	9307      	str	r3, [sp, #28]
	uint16_t pos = 0;
    a724:	2400      	movs	r4, #0
{
    a726:	4607      	mov	r7, r0
    a728:	4689      	mov	r9, r1
	PixelModElement *mod = (PixelModElement*)&frame[pos];
    a72a:	4606      	mov	r6, r0
		uint16_t valid = 0;
    a72c:	46a0      	mov	r8, r4
			next = Pixel_fillPixelLookup( mod, &elem, next, stack_elem, &valid );
    a72e:	f10d 0a16 	add.w	sl, sp, #22
	while ( mod->type != PixelAddressType_End )
    a732:	7833      	ldrb	r3, [r6, #0]
    a734:	b92b      	cbnz	r3, a742 <Pixel_pixelTweenStandard+0x2a>
}
    a736:	9a07      	ldr	r2, [sp, #28]
    a738:	682b      	ldr	r3, [r5, #0]
    a73a:	429a      	cmp	r2, r3
    a73c:	d01f      	beq.n	a77e <Pixel_pixelTweenStandard+0x66>
    a73e:	f7f7 fff7 	bl	2730 <__stack_chk_fail>
		uint16_t valid = 0;
    a742:	f8ad 8016 	strh.w	r8, [sp, #22]
		PixelElement *elem = 0;
    a746:	f8cd 8018 	str.w	r8, [sp, #24]
		uint16_t next = 0;
    a74a:	2200      	movs	r2, #0
			next = Pixel_fillPixelLookup( mod, &elem, next, stack_elem, &valid );
    a74c:	464b      	mov	r3, r9
    a74e:	a906      	add	r1, sp, #24
    a750:	f8cd a000 	str.w	sl, [sp]
    a754:	4630      	mov	r0, r6
			prev_pixel_elem = elem;
    a756:	f8dd b018 	ldr.w	fp, [sp, #24]
			next = Pixel_fillPixelLookup( mod, &elem, next, stack_elem, &valid );
    a75a:	f7ff fea3 	bl	a4a4 <Pixel_fillPixelLookup>
			Pixel_pixelEvaluation( mod, elem );
    a75e:	9906      	ldr	r1, [sp, #24]
			next = Pixel_fillPixelLookup( mod, &elem, next, stack_elem, &valid );
    a760:	9003      	str	r0, [sp, #12]
			Pixel_pixelEvaluation( mod, elem );
    a762:	4630      	mov	r0, r6
    a764:	f7ff f952 	bl	9a0c <Pixel_pixelEvaluation>
		} while ( next );
    a768:	9a03      	ldr	r2, [sp, #12]
    a76a:	2a00      	cmp	r2, #0
    a76c:	d1ee      	bne.n	a74c <Pixel_pixelTweenStandard+0x34>
		pos += Pixel_pixelTweenNextPos( elem, prev_pixel_elem );
    a76e:	4659      	mov	r1, fp
    a770:	9806      	ldr	r0, [sp, #24]
    a772:	f7ff faeb 	bl	9d4c <Pixel_pixelTweenNextPos>
    a776:	4404      	add	r4, r0
    a778:	b2a4      	uxth	r4, r4
		mod = (PixelModElement*)&frame[pos];
    a77a:	193e      	adds	r6, r7, r4
    a77c:	e7d9      	b.n	a732 <Pixel_pixelTweenStandard+0x1a>
}
    a77e:	b009      	add	sp, #36	; 0x24
    a780:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a784:	1fff89d0 	.word	0x1fff89d0

0000a788 <Pixel_pixelTweenInterpolation>:
{
    a788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a78c:	4b8b      	ldr	r3, [pc, #556]	; (a9bc <Pixel_pixelTweenInterpolation+0x234>)
    a78e:	b091      	sub	sp, #68	; 0x44
    a790:	681b      	ldr	r3, [r3, #0]
    a792:	9004      	str	r0, [sp, #16]
	PixelModElement *prev = 0;
    a794:	2400      	movs	r4, #0
{
    a796:	4689      	mov	r9, r1
    a798:	930f      	str	r3, [sp, #60]	; 0x3c
	PixelModElement *mod = (PixelModElement*)&frame[pos];
    a79a:	4680      	mov	r8, r0
	uint16_t pos = 0;
    a79c:	9402      	str	r4, [sp, #8]
	while ( mod->type != PixelAddressType_End )
    a79e:	f898 3000 	ldrb.w	r3, [r8]
    a7a2:	b93b      	cbnz	r3, a7b4 <Pixel_pixelTweenInterpolation+0x2c>
}
    a7a4:	4b85      	ldr	r3, [pc, #532]	; (a9bc <Pixel_pixelTweenInterpolation+0x234>)
    a7a6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    a7a8:	681b      	ldr	r3, [r3, #0]
    a7aa:	429a      	cmp	r2, r3
    a7ac:	f000 8103 	beq.w	a9b6 <Pixel_pixelTweenInterpolation+0x22e>
    a7b0:	f7f7 ffbe 	bl	2730 <__stack_chk_fail>
		switch ( mod->type )
    a7b4:	3b01      	subs	r3, #1
		int32_t start = mod->index;
    a7b6:	f8d8 6001 	ldr.w	r6, [r8, #1]
    a7ba:	af06      	add	r7, sp, #24
		switch ( mod->type )
    a7bc:	2b04      	cmp	r3, #4
    a7be:	d874      	bhi.n	a8aa <Pixel_pixelTweenInterpolation+0x122>
    a7c0:	e8df f003 	tbb	[pc, r3]
    a7c4:	16031e37 	.word	0x16031e37
    a7c8:	37          	.byte	0x37
    a7c9:	00          	.byte	0x00
    a7ca:	f9b8 6001 	ldrsh.w	r6, [r8, #1]
			start = prev != 0 ? prev->rect.col : mod->rect.col;
    a7ce:	2c00      	cmp	r4, #0
    a7d0:	f000 80e7 	beq.w	a9a2 <Pixel_pixelTweenInterpolation+0x21a>
    a7d4:	f9b4 5001 	ldrsh.w	r5, [r4, #1]
		PixelElement *prev_elem = 0;
    a7d8:	2300      	movs	r3, #0
    a7da:	9307      	str	r3, [sp, #28]
		uint16_t valid = 0;
    a7dc:	f8ad 3018 	strh.w	r3, [sp, #24]
			Pixel_fillPixelLookup( prev, &prev_elem, 0, stack_elem, &valid );
    a7e0:	9700      	str	r7, [sp, #0]
    a7e2:	464b      	mov	r3, r9
    a7e4:	2200      	movs	r2, #0
    a7e6:	a907      	add	r1, sp, #28
    a7e8:	4620      	mov	r0, r4
    a7ea:	f7ff fe5b 	bl	a4a4 <Pixel_fillPixelLookup>
    a7ee:	e02a      	b.n	a846 <Pixel_pixelTweenInterpolation+0xbe>
    a7f0:	f9b8 6003 	ldrsh.w	r6, [r8, #3]
			start = prev != 0 ? prev->rect.row : mod->rect.row;
    a7f4:	2c00      	cmp	r4, #0
    a7f6:	f000 80d4 	beq.w	a9a2 <Pixel_pixelTweenInterpolation+0x21a>
    a7fa:	f9b4 5003 	ldrsh.w	r5, [r4, #3]
    a7fe:	e7eb      	b.n	a7d8 <Pixel_pixelTweenInterpolation+0x50>
    a800:	f9b8 5001 	ldrsh.w	r5, [r8, #1]
			if ( prev != 0 )
    a804:	2c00      	cmp	r4, #0
    a806:	f000 80d1 	beq.w	a9ac <Pixel_pixelTweenInterpolation+0x224>
				if ( prev->rect.col != mod->rect.col )
    a80a:	f9b4 3001 	ldrsh.w	r3, [r4, #1]
				if ( prev->rect.row != mod->rect.row )
    a80e:	f9b8 1003 	ldrsh.w	r1, [r8, #3]
					start = prev->rect.col;
    a812:	42ab      	cmp	r3, r5
    a814:	bf18      	it	ne
    a816:	461e      	movne	r6, r3
		PixelElement *prev_elem = 0;
    a818:	2200      	movs	r2, #0
				if ( prev->rect.row != mod->rect.row )
    a81a:	f9b4 3003 	ldrsh.w	r3, [r4, #3]
		PixelElement *prev_elem = 0;
    a81e:	9207      	str	r2, [sp, #28]
		uint16_t valid = 0;
    a820:	f8ad 2018 	strh.w	r2, [sp, #24]
    a824:	462a      	mov	r2, r5
    a826:	4299      	cmp	r1, r3
    a828:	bf0c      	ite	eq
    a82a:	4635      	moveq	r5, r6
    a82c:	461d      	movne	r5, r3
			end = mod->rect.col;
    a82e:	4616      	mov	r6, r2
    a830:	e7d6      	b.n	a7e0 <Pixel_pixelTweenInterpolation+0x58>
			start = prev != 0 ? prev->index : mod->index;
    a832:	2c00      	cmp	r4, #0
    a834:	d039      	beq.n	a8aa <Pixel_pixelTweenInterpolation+0x122>
    a836:	f8d4 5001 	ldr.w	r5, [r4, #1]
		PixelElement *prev_elem = 0;
    a83a:	2300      	movs	r3, #0
    a83c:	9307      	str	r3, [sp, #28]
		uint16_t valid = 0;
    a83e:	f8ad 3018 	strh.w	r3, [sp, #24]
		if ( prev != 0 )
    a842:	2c00      	cmp	r4, #0
    a844:	d1cc      	bne.n	a7e0 <Pixel_pixelTweenInterpolation+0x58>
		PixelElement *mod_elem = 0;
    a846:	a910      	add	r1, sp, #64	; 0x40
    a848:	f04f 0b00 	mov.w	fp, #0
    a84c:	f841 bd20 	str.w	fp, [r1, #-32]!
		Pixel_fillPixelLookup( mod, &mod_elem, 0, stack_elem, &valid );
    a850:	464b      	mov	r3, r9
    a852:	9700      	str	r7, [sp, #0]
    a854:	465a      	mov	r2, fp
    a856:	4640      	mov	r0, r8
    a858:	f7ff fe24 	bl	a4a4 <Pixel_fillPixelLookup>
		if ( mod_elem == 0 )
    a85c:	9b08      	ldr	r3, [sp, #32]
    a85e:	b1b3      	cbz	r3, a88e <Pixel_pixelTweenInterpolation+0x106>
		memcpy( interp_mod, mod, sizeof( interp_data ) );
    a860:	2214      	movs	r2, #20
    a862:	4641      	mov	r1, r8
    a864:	a80a      	add	r0, sp, #40	; 0x28
		PixelElement *elem = 0;
    a866:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
		memcpy( interp_mod, mod, sizeof( interp_data ) );
    a86a:	f7f7 ff85 	bl	2778 <memcpy>
    a86e:	eba6 0b05 	sub.w	fp, r6, r5
		uint16_t slice = prev != 0 ? 256 / (end - start + 1) : 0;
    a872:	b1e4      	cbz	r4, a8ae <Pixel_pixelTweenInterpolation+0x126>
    a874:	f10b 0201 	add.w	r2, fp, #1
    a878:	f44f 7380 	mov.w	r3, #256	; 0x100
    a87c:	fb93 f3f2 	sdiv	r3, r3, r2
    a880:	b29b      	uxth	r3, r3
    a882:	9303      	str	r3, [sp, #12]
		for ( int32_t cur = 0; cur < end - start + 1; cur++ )
    a884:	2600      	movs	r6, #0
		PixelElement *prev_pixel_elem = 0;
    a886:	46b2      	mov	sl, r6
			uint16_t valid = 0;
    a888:	4637      	mov	r7, r6
		for ( int32_t cur = 0; cur < end - start + 1; cur++ )
    a88a:	455e      	cmp	r6, fp
    a88c:	dd11      	ble.n	a8b2 <Pixel_pixelTweenInterpolation+0x12a>
		pos += Pixel_pixelTweenNextPos( elem, prev_pixel_elem );
    a88e:	4651      	mov	r1, sl
    a890:	9809      	ldr	r0, [sp, #36]	; 0x24
    a892:	f7ff fa5b 	bl	9d4c <Pixel_pixelTweenNextPos>
    a896:	9b02      	ldr	r3, [sp, #8]
    a898:	4403      	add	r3, r0
    a89a:	b29b      	uxth	r3, r3
    a89c:	9302      	str	r3, [sp, #8]
		mod = (PixelModElement*)&frame[pos];
    a89e:	9a02      	ldr	r2, [sp, #8]
    a8a0:	9b04      	ldr	r3, [sp, #16]
    a8a2:	4644      	mov	r4, r8
    a8a4:	eb03 0802 	add.w	r8, r3, r2
    a8a8:	e779      	b.n	a79e <Pixel_pixelTweenInterpolation+0x16>
			start = prev != 0 ? prev->index : mod->index;
    a8aa:	4635      	mov	r5, r6
    a8ac:	e7c5      	b.n	a83a <Pixel_pixelTweenInterpolation+0xb2>
		uint16_t slice = prev != 0 ? 256 / (end - start + 1) : 0;
    a8ae:	9403      	str	r4, [sp, #12]
    a8b0:	e7e8      	b.n	a884 <Pixel_pixelTweenInterpolation+0xfc>
			switch ( mod->type )
    a8b2:	f898 3000 	ldrb.w	r3, [r8]
    a8b6:	3b01      	subs	r3, #1
    a8b8:	2b04      	cmp	r3, #4
    a8ba:	d862      	bhi.n	a982 <Pixel_pixelTweenInterpolation+0x1fa>
    a8bc:	e8df f003 	tbb	[pc, r3]
    a8c0:	0b031164 	.word	0x0b031164
    a8c4:	58          	.byte	0x58
    a8c5:	00          	.byte	0x00
				interp_mod->rect.col = start + cur;
    a8c6:	19ab      	adds	r3, r5, r6
    a8c8:	b29b      	uxth	r3, r3
    a8ca:	f8ad 3029 	strh.w	r3, [sp, #41]	; 0x29
				if ( interp_mod->rect.col >= Pixel_DisplayMapping_Cols_KLL || interp_mod->rect.col < 0 )
    a8ce:	2b10      	cmp	r3, #16
				if ( interp_mod->rect.row >= Pixel_DisplayMapping_Rows_KLL || interp_mod->rect.row < 0 )
    a8d0:	d957      	bls.n	a982 <Pixel_pixelTweenInterpolation+0x1fa>
		for ( int32_t cur = 0; cur < end - start + 1; cur++ )
    a8d2:	3601      	adds	r6, #1
    a8d4:	e7d9      	b.n	a88a <Pixel_pixelTweenInterpolation+0x102>
				interp_mod->rect.row = start + cur;
    a8d6:	19ab      	adds	r3, r5, r6
    a8d8:	b29b      	uxth	r3, r3
    a8da:	f8ad 302b 	strh.w	r3, [sp, #43]	; 0x2b
				if ( interp_mod->rect.row >= Pixel_DisplayMapping_Rows_KLL || interp_mod->rect.row < 0 )
    a8de:	2b06      	cmp	r3, #6
    a8e0:	e7f6      	b.n	a8d0 <Pixel_pixelTweenInterpolation+0x148>
				interp_mod->rect.col = 0;
    a8e2:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
    a8e6:	f88d 702a 	strb.w	r7, [sp, #42]	; 0x2a
				interp_mod->rect.row = 0;
    a8ea:	f88d 702b 	strb.w	r7, [sp, #43]	; 0x2b
    a8ee:	f88d 702c 	strb.w	r7, [sp, #44]	; 0x2c
				if ( prev != 0 )
    a8f2:	b9cc      	cbnz	r4, a928 <Pixel_pixelTweenInterpolation+0x1a0>
			uint16_t valid = 0;
    a8f4:	f8ad 701a 	strh.w	r7, [sp, #26]
			uint16_t next = 0;
    a8f8:	2200      	movs	r2, #0
				next = Pixel_fillPixelLookup( interp_mod, &elem, next, stack_elem, &valid );
    a8fa:	f10d 031a 	add.w	r3, sp, #26
    a8fe:	9300      	str	r3, [sp, #0]
    a900:	a909      	add	r1, sp, #36	; 0x24
    a902:	464b      	mov	r3, r9
    a904:	a80a      	add	r0, sp, #40	; 0x28
				prev_pixel_elem = elem;
    a906:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
				next = Pixel_fillPixelLookup( interp_mod, &elem, next, stack_elem, &valid );
    a90a:	f7ff fdcb 	bl	a4a4 <Pixel_fillPixelLookup>
				if ( valid )
    a90e:	f8bd 301a 	ldrh.w	r3, [sp, #26]
				next = Pixel_fillPixelLookup( interp_mod, &elem, next, stack_elem, &valid );
    a912:	4602      	mov	r2, r0
				if ( valid )
    a914:	b12b      	cbz	r3, a922 <Pixel_pixelTweenInterpolation+0x19a>
    a916:	9005      	str	r0, [sp, #20]
					Pixel_pixelEvaluation( interp_mod, elem );
    a918:	9909      	ldr	r1, [sp, #36]	; 0x24
    a91a:	a80a      	add	r0, sp, #40	; 0x28
    a91c:	f7ff f876 	bl	9a0c <Pixel_pixelEvaluation>
    a920:	9a05      	ldr	r2, [sp, #20]
			} while ( next );
    a922:	2a00      	cmp	r2, #0
    a924:	d1e9      	bne.n	a8fa <Pixel_pixelTweenInterpolation+0x172>
    a926:	e7d4      	b.n	a8d2 <Pixel_pixelTweenInterpolation+0x14a>
					interp_mod->rect.col = prev->rect.col + cur;
    a928:	f9b4 3001 	ldrsh.w	r3, [r4, #1]
    a92c:	4433      	add	r3, r6
    a92e:	f8ad 3029 	strh.w	r3, [sp, #41]	; 0x29
				int32_t distance = slice * cur;
    a932:	9b03      	ldr	r3, [sp, #12]
    a934:	fb06 f203 	mul.w	r2, r6, r3
				for ( uint8_t ch = 0; ch < mod_elem->channels; ch++ )
    a938:	9b08      	ldr	r3, [sp, #32]
    a93a:	b2d2      	uxtb	r2, r2
    a93c:	f893 c001 	ldrb.w	ip, [r3, #1]
    a940:	2000      	movs	r0, #0
	return (start * (256 - dist) + end * dist) >> 8;
    a942:	f5c2 7e80 	rsb	lr, r2, #256	; 0x100
    a946:	b2c3      	uxtb	r3, r0
				for ( uint8_t ch = 0; ch < mod_elem->channels; ch++ )
    a948:	4563      	cmp	r3, ip
    a94a:	d2d3      	bcs.n	a8f4 <Pixel_pixelTweenInterpolation+0x16c>
					interp_mod->data[pos] = Pixel_8bitInterpolation(
    a94c:	005b      	lsls	r3, r3, #1
    a94e:	3301      	adds	r3, #1
    a950:	b2db      	uxtb	r3, r3
    a952:	a910      	add	r1, sp, #64	; 0x40
    a954:	eb01 0a03 	add.w	sl, r1, r3
    a958:	18e1      	adds	r1, r4, r3
    a95a:	4443      	add	r3, r8
	return (start * (256 - dist) + end * dist) >> 8;
    a95c:	7949      	ldrb	r1, [r1, #5]
    a95e:	795b      	ldrb	r3, [r3, #5]
    a960:	4353      	muls	r3, r2
    a962:	fb0e 3101 	mla	r1, lr, r1, r3
    a966:	1209      	asrs	r1, r1, #8
    a968:	f80a 1c13 	strb.w	r1, [sl, #-19]
    a96c:	3001      	adds	r0, #1
    a96e:	e7ea      	b.n	a946 <Pixel_pixelTweenInterpolation+0x1be>
				interp_mod->index = start + cur;
    a970:	1973      	adds	r3, r6, r5
    a972:	f8cd 3029 	str.w	r3, [sp, #41]	; 0x29
				if ( Pixel_ScanCodeToDisplay[interp_mod->index - 1] == 0 )
    a976:	4a12      	ldr	r2, [pc, #72]	; (a9c0 <Pixel_pixelTweenInterpolation+0x238>)
    a978:	3b01      	subs	r3, #1
    a97a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
				if ( Pixel_Mapping[interp_mod->index - 1].width == 0 || Pixel_Mapping[interp_mod->index - 1].channels == 0 )
    a97e:	2b00      	cmp	r3, #0
    a980:	d0a7      	beq.n	a8d2 <Pixel_pixelTweenInterpolation+0x14a>
			if ( prev != 0 )
    a982:	2c00      	cmp	r4, #0
    a984:	d0b6      	beq.n	a8f4 <Pixel_pixelTweenInterpolation+0x16c>
    a986:	e7d4      	b.n	a932 <Pixel_pixelTweenInterpolation+0x1aa>
				interp_mod->index = start + cur;
    a988:	1973      	adds	r3, r6, r5
    a98a:	f8cd 3029 	str.w	r3, [sp, #41]	; 0x29
				if ( Pixel_Mapping[interp_mod->index - 1].width == 0 || Pixel_Mapping[interp_mod->index - 1].channels == 0 )
    a98e:	490d      	ldr	r1, [pc, #52]	; (a9c4 <Pixel_pixelTweenInterpolation+0x23c>)
    a990:	3b01      	subs	r3, #1
    a992:	f811 2033 	ldrb.w	r2, [r1, r3, lsl #3]
    a996:	2a00      	cmp	r2, #0
    a998:	d09b      	beq.n	a8d2 <Pixel_pixelTweenInterpolation+0x14a>
    a99a:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
    a99e:	785b      	ldrb	r3, [r3, #1]
    a9a0:	e7ed      	b.n	a97e <Pixel_pixelTweenInterpolation+0x1f6>
		PixelElement *prev_elem = 0;
    a9a2:	9407      	str	r4, [sp, #28]
		uint16_t valid = 0;
    a9a4:	f8ad 4018 	strh.w	r4, [sp, #24]
			start = prev != 0 ? prev->rect.row : mod->rect.row;
    a9a8:	4635      	mov	r5, r6
    a9aa:	e74c      	b.n	a846 <Pixel_pixelTweenInterpolation+0xbe>
		PixelElement *prev_elem = 0;
    a9ac:	9407      	str	r4, [sp, #28]
		uint16_t valid = 0;
    a9ae:	f8ad 4018 	strh.w	r4, [sp, #24]
			end = mod->rect.col;
    a9b2:	462e      	mov	r6, r5
    a9b4:	e747      	b.n	a846 <Pixel_pixelTweenInterpolation+0xbe>
}
    a9b6:	b011      	add	sp, #68	; 0x44
    a9b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a9bc:	1fff89d0 	.word	0x1fff89d0
    a9c0:	00015660 	.word	0x00015660
    a9c4:	00015530 	.word	0x00015530

0000a9c8 <Pixel_frameTweenStandard>:
{
    a9c8:	b507      	push	{r0, r1, r2, lr}
    a9ca:	4b14      	ldr	r3, [pc, #80]	; (aa1c <Pixel_frameTweenStandard+0x54>)
    a9cc:	681a      	ldr	r2, [r3, #0]
    a9ce:	9201      	str	r2, [sp, #4]
	if ( elem->subpos != 0 )
    a9d0:	7a0a      	ldrb	r2, [r1, #8]
    a9d2:	b112      	cbz	r2, a9da <Pixel_frameTweenStandard+0x12>
		if ( !( elem->frameoption & PixelFrameOption_FrameStretch ) )
    a9d4:	7aca      	ldrb	r2, [r1, #11]
    a9d6:	07d2      	lsls	r2, r2, #31
    a9d8:	d519      	bpl.n	aa0e <Pixel_frameTweenStandard+0x46>
	switch ( elem->pfunc )
    a9da:	7b4a      	ldrb	r2, [r1, #13]
    a9dc:	2a01      	cmp	r2, #1
    a9de:	d00b      	beq.n	a9f8 <Pixel_frameTweenStandard+0x30>
    a9e0:	d301      	bcc.n	a9e6 <Pixel_frameTweenStandard+0x1e>
    a9e2:	2a02      	cmp	r2, #2
    a9e4:	d113      	bne.n	aa0e <Pixel_frameTweenStandard+0x46>
		Pixel_pixelTweenStandard( data, elem );
    a9e6:	9a01      	ldr	r2, [sp, #4]
    a9e8:	681b      	ldr	r3, [r3, #0]
    a9ea:	429a      	cmp	r2, r3
    a9ec:	d108      	bne.n	aa00 <Pixel_frameTweenStandard+0x38>
}
    a9ee:	b003      	add	sp, #12
    a9f0:	f85d eb04 	ldr.w	lr, [sp], #4
		Pixel_pixelTweenStandard( data, elem );
    a9f4:	f7ff be90 	b.w	a718 <Pixel_pixelTweenStandard>
		Pixel_pixelTweenInterpolation( data, elem );
    a9f8:	9a01      	ldr	r2, [sp, #4]
    a9fa:	681b      	ldr	r3, [r3, #0]
    a9fc:	429a      	cmp	r2, r3
    a9fe:	d001      	beq.n	aa04 <Pixel_frameTweenStandard+0x3c>
}
    aa00:	f7f7 fe96 	bl	2730 <__stack_chk_fail>
    aa04:	b003      	add	sp, #12
    aa06:	f85d eb04 	ldr.w	lr, [sp], #4
		Pixel_pixelTweenInterpolation( data, elem );
    aa0a:	f7ff bebd 	b.w	a788 <Pixel_pixelTweenInterpolation>
}
    aa0e:	9a01      	ldr	r2, [sp, #4]
    aa10:	681b      	ldr	r3, [r3, #0]
    aa12:	429a      	cmp	r2, r3
    aa14:	d1f4      	bne.n	aa00 <Pixel_frameTweenStandard+0x38>
    aa16:	b003      	add	sp, #12
    aa18:	f85d fb04 	ldr.w	pc, [sp], #4
    aa1c:	1fff89d0 	.word	0x1fff89d0

0000aa20 <Pixel_animationProcess>:
{
    aa20:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    aa24:	4d26      	ldr	r5, [pc, #152]	; (aac0 <Pixel_animationProcess+0xa0>)
	const uint8_t *data = Pixel_Animations[elem->index][elem->pos];
    aa26:	f8df 809c 	ldr.w	r8, [pc, #156]	; aac4 <Pixel_animationProcess+0xa4>
{
    aa2a:	682b      	ldr	r3, [r5, #0]
    aa2c:	9301      	str	r3, [sp, #4]
    aa2e:	4604      	mov	r4, r0
	if ( elem->index == 0xFFFF )
    aa30:	f64f 76ff 	movw	r6, #65535	; 0xffff
		elem->state = AnimationPlayState_Pause;
    aa34:	2701      	movs	r7, #1
	if ( elem->index == 0xFFFF )
    aa36:	88a2      	ldrh	r2, [r4, #4]
    aa38:	42b2      	cmp	r2, r6
    aa3a:	d009      	beq.n	aa50 <Pixel_animationProcess+0x30>
	switch ( elem->state )
    aa3c:	7be3      	ldrb	r3, [r4, #15]
    aa3e:	2b02      	cmp	r3, #2
    aa40:	d005      	beq.n	aa4e <Pixel_animationProcess+0x2e>
    aa42:	2b03      	cmp	r3, #3
    aa44:	d006      	beq.n	aa54 <Pixel_animationProcess+0x34>
    aa46:	2b01      	cmp	r3, #1
    aa48:	d105      	bne.n	aa56 <Pixel_animationProcess+0x36>
		return 1;
    aa4a:	4618      	mov	r0, r3
    aa4c:	e019      	b.n	aa82 <Pixel_animationProcess+0x62>
		elem->index = 0xFFFF;
    aa4e:	80a6      	strh	r6, [r4, #4]
		return 0;
    aa50:	2000      	movs	r0, #0
    aa52:	e016      	b.n	aa82 <Pixel_animationProcess+0x62>
		elem->state = AnimationPlayState_Pause;
    aa54:	73e7      	strb	r7, [r4, #15]
	const uint8_t *data = Pixel_Animations[elem->index][elem->pos];
    aa56:	88e1      	ldrh	r1, [r4, #6]
    aa58:	f858 3022 	ldr.w	r3, [r8, r2, lsl #2]
    aa5c:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
	if ( data == 0 )
    aa60:	b9a8      	cbnz	r0, aa8e <Pixel_animationProcess+0x6e>
		if ( elem->loops == 0 || elem->loops-- > 1 )
    aa62:	7a63      	ldrb	r3, [r4, #9]
    aa64:	b933      	cbnz	r3, aa74 <Pixel_animationProcess+0x54>
			elem->pos = 0;
    aa66:	2300      	movs	r3, #0
    aa68:	80e3      	strh	r3, [r4, #6]
			Macro_animationState( elem->index, ScheduleType_Repeat );
    aa6a:	2107      	movs	r1, #7
    aa6c:	4610      	mov	r0, r2
    aa6e:	f7fc ffed 	bl	7a4c <Macro_animationState>
			return Pixel_animationProcess( elem );
    aa72:	e7e0      	b.n	aa36 <Pixel_animationProcess+0x16>
		if ( elem->loops == 0 || elem->loops-- > 1 )
    aa74:	1e59      	subs	r1, r3, #1
    aa76:	2b01      	cmp	r3, #1
    aa78:	7261      	strb	r1, [r4, #9]
    aa7a:	d8f4      	bhi.n	aa66 <Pixel_animationProcess+0x46>
			elem->index = 0xFFFF;
    aa7c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    aa80:	80a3      	strh	r3, [r4, #4]
}
    aa82:	9a01      	ldr	r2, [sp, #4]
    aa84:	682b      	ldr	r3, [r5, #0]
    aa86:	429a      	cmp	r2, r3
    aa88:	d017      	beq.n	aaba <Pixel_animationProcess+0x9a>
    aa8a:	f7f7 fe51 	bl	2730 <__stack_chk_fail>
	switch ( elem->ffunc )
    aa8e:	7b23      	ldrb	r3, [r4, #12]
    aa90:	b10b      	cbz	r3, aa96 <Pixel_animationProcess+0x76>
    aa92:	2b02      	cmp	r3, #2
    aa94:	d102      	bne.n	aa9c <Pixel_animationProcess+0x7c>
		Pixel_frameTweenStandard( data, elem );
    aa96:	4621      	mov	r1, r4
    aa98:	f7ff ff96 	bl	a9c8 <Pixel_frameTweenStandard>
	if ( elem->framedelay > 0 )
    aa9c:	7aa2      	ldrb	r2, [r4, #10]
    aa9e:	b122      	cbz	r2, aaaa <Pixel_animationProcess+0x8a>
		if ( elem->subpos == elem->framedelay )
    aaa0:	7a23      	ldrb	r3, [r4, #8]
    aaa2:	429a      	cmp	r2, r3
    aaa4:	d105      	bne.n	aab2 <Pixel_animationProcess+0x92>
			elem->subpos = 0;
    aaa6:	2300      	movs	r3, #0
    aaa8:	7223      	strb	r3, [r4, #8]
		elem->pos++;
    aaaa:	88e3      	ldrh	r3, [r4, #6]
    aaac:	3301      	adds	r3, #1
    aaae:	80e3      	strh	r3, [r4, #6]
    aab0:	e001      	b.n	aab6 <Pixel_animationProcess+0x96>
			elem->subpos++;
    aab2:	3301      	adds	r3, #1
    aab4:	7223      	strb	r3, [r4, #8]
	return 1;
    aab6:	2001      	movs	r0, #1
    aab8:	e7e3      	b.n	aa82 <Pixel_animationProcess+0x62>
}
    aaba:	b002      	add	sp, #8
    aabc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    aac0:	1fff89d0 	.word	0x1fff89d0
    aac4:	1fff8e30 	.word	0x1fff8e30

0000aac8 <Pixel_stackProcess>:
{
    aac8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    aacc:	4d17      	ldr	r5, [pc, #92]	; (ab2c <Pixel_stackProcess+0x64>)
	uint16_t size = Pixel_AnimationStack.size;
    aace:	4c18      	ldr	r4, [pc, #96]	; (ab30 <Pixel_stackProcess+0x68>)
{
    aad0:	682b      	ldr	r3, [r5, #0]
    aad2:	9301      	str	r3, [sp, #4]
	Pixel_AnimationStack.size = 0;
    aad4:	2300      	movs	r3, #0
	uint16_t size = Pixel_AnimationStack.size;
    aad6:	8827      	ldrh	r7, [r4, #0]
	Pixel_AnimationStack.size = 0;
    aad8:	8023      	strh	r3, [r4, #0]
	for ( ; pos < size; pos++ )
    aada:	2601      	movs	r6, #1
		if ( elem->index == 0xFFFF )
    aadc:	f64f 78ff 	movw	r8, #65535	; 0xffff
	for ( ; pos < size; pos++ )
    aae0:	1e73      	subs	r3, r6, #1
    aae2:	b29b      	uxth	r3, r3
    aae4:	429f      	cmp	r7, r3
    aae6:	d805      	bhi.n	aaf4 <Pixel_stackProcess+0x2c>
}
    aae8:	9a01      	ldr	r2, [sp, #4]
    aaea:	682b      	ldr	r3, [r5, #0]
    aaec:	429a      	cmp	r2, r3
    aaee:	d019      	beq.n	ab24 <Pixel_stackProcess+0x5c>
    aaf0:	f7f7 fe1e 	bl	2730 <__stack_chk_fail>
		AnimationStackElement *elem = Pixel_AnimationStack.stack[pos];
    aaf4:	f854 9026 	ldr.w	r9, [r4, r6, lsl #2]
		if ( elem->index == 0xFFFF )
    aaf8:	f8b9 a004 	ldrh.w	sl, [r9, #4]
    aafc:	45c2      	cmp	sl, r8
    aafe:	d00a      	beq.n	ab16 <Pixel_stackProcess+0x4e>
		if ( Pixel_animationProcess( elem ) )
    ab00:	4648      	mov	r0, r9
    ab02:	f7ff ff8d 	bl	aa20 <Pixel_animationProcess>
    ab06:	b140      	cbz	r0, ab1a <Pixel_stackProcess+0x52>
			Pixel_AnimationStack.stack[Pixel_AnimationStack.size++] = elem;
    ab08:	8823      	ldrh	r3, [r4, #0]
    ab0a:	1c5a      	adds	r2, r3, #1
    ab0c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    ab10:	8022      	strh	r2, [r4, #0]
    ab12:	f8c3 9004 	str.w	r9, [r3, #4]
    ab16:	3601      	adds	r6, #1
    ab18:	e7e2      	b.n	aae0 <Pixel_stackProcess+0x18>
			Macro_animationState( cur_index, ScheduleType_Done );
    ab1a:	2106      	movs	r1, #6
    ab1c:	4650      	mov	r0, sl
    ab1e:	f7fc ff95 	bl	7a4c <Macro_animationState>
    ab22:	e7f8      	b.n	ab16 <Pixel_stackProcess+0x4e>
}
    ab24:	b002      	add	sp, #8
    ab26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ab2a:	bf00      	nop
    ab2c:	1fff89d0 	.word	0x1fff89d0
    ab30:	1fffab00 	.word	0x1fffab00

0000ab34 <Pixel_setAnimationControl>:
{
    ab34:	b507      	push	{r0, r1, r2, lr}
    ab36:	4b07      	ldr	r3, [pc, #28]	; (ab54 <Pixel_setAnimationControl+0x20>)
    ab38:	681a      	ldr	r2, [r3, #0]
    ab3a:	9201      	str	r2, [sp, #4]
	Pixel_animationControl = control;
    ab3c:	4a06      	ldr	r2, [pc, #24]	; (ab58 <Pixel_setAnimationControl+0x24>)
    ab3e:	7010      	strb	r0, [r2, #0]
}
    ab40:	9a01      	ldr	r2, [sp, #4]
    ab42:	681b      	ldr	r3, [r3, #0]
    ab44:	429a      	cmp	r2, r3
    ab46:	d001      	beq.n	ab4c <Pixel_setAnimationControl+0x18>
    ab48:	f7f7 fdf2 	bl	2730 <__stack_chk_fail>
    ab4c:	b003      	add	sp, #12
    ab4e:	f85d fb04 	ldr.w	pc, [sp], #4
    ab52:	bf00      	nop
    ab54:	1fff89d0 	.word	0x1fff89d0
    ab58:	1fffab54 	.word	0x1fffab54

0000ab5c <Pixel_initializeStartAnimations>:
{
    ab5c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    ab5e:	4c13      	ldr	r4, [pc, #76]	; (abac <Pixel_initializeStartAnimations+0x50>)
    ab60:	6823      	ldr	r3, [r4, #0]
    ab62:	9301      	str	r3, [sp, #4]
		if ( Pixel_AnimationSettings[ index ].state == AnimationPlayState_Start )
    ab64:	4b12      	ldr	r3, [pc, #72]	; (abb0 <Pixel_initializeStartAnimations+0x54>)
    ab66:	7bd8      	ldrb	r0, [r3, #15]
    ab68:	4626      	mov	r6, r4
    ab6a:	b9c0      	cbnz	r0, ab9e <Pixel_initializeStartAnimations+0x42>
			if ( (uintptr_t)(Pixel_AnimationSettings[ index ].trigger) == 1 )
    ab6c:	681b      	ldr	r3, [r3, #0]
    ab6e:	2b01      	cmp	r3, #1
    ab70:	d115      	bne.n	ab9e <Pixel_initializeStartAnimations+0x42>
				if ( Pixel_addDefaultAnimation( index ) == 0 )
    ab72:	f7fe feab 	bl	98cc <Pixel_addDefaultAnimation>
    ab76:	4605      	mov	r5, r0
    ab78:	b988      	cbnz	r0, ab9e <Pixel_initializeStartAnimations+0x42>
					warn_msg("Failed to start starting animation index: ");
    ab7a:	480e      	ldr	r0, [pc, #56]	; (abb4 <Pixel_initializeStartAnimations+0x58>)
    ab7c:	f004 fcf8 	bl	f570 <_print>
					printInt32( index );
    ab80:	4628      	mov	r0, r5
    ab82:	f004 fdcb 	bl	f71c <printInt32>
					print( NL );
    ab86:	9a01      	ldr	r2, [sp, #4]
    ab88:	6823      	ldr	r3, [r4, #0]
    ab8a:	429a      	cmp	r2, r3
    ab8c:	d001      	beq.n	ab92 <Pixel_initializeStartAnimations+0x36>
}
    ab8e:	f7f7 fdcf 	bl	2730 <__stack_chk_fail>
					print( NL );
    ab92:	4809      	ldr	r0, [pc, #36]	; (abb8 <Pixel_initializeStartAnimations+0x5c>)
}
    ab94:	b002      	add	sp, #8
    ab96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					print( NL );
    ab9a:	f004 bce9 	b.w	f570 <_print>
}
    ab9e:	9a01      	ldr	r2, [sp, #4]
    aba0:	6833      	ldr	r3, [r6, #0]
    aba2:	429a      	cmp	r2, r3
    aba4:	d1f3      	bne.n	ab8e <Pixel_initializeStartAnimations+0x32>
    aba6:	b002      	add	sp, #8
    aba8:	bd70      	pop	{r4, r5, r6, pc}
    abaa:	bf00      	nop
    abac:	1fff89d0 	.word	0x1fff89d0
    abb0:	000153ac 	.word	0x000153ac
    abb4:	00014ae5 	.word	0x00014ae5
    abb8:	00015df4 	.word	0x00015df4

0000abbc <Pixel_process>:
{
    abbc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    abc0:	4daa      	ldr	r5, [pc, #680]	; (ae6c <Pixel_process+0x2b0>)
	Latency_start_time( pixelLatencyResource );
    abc2:	4fab      	ldr	r7, [pc, #684]	; (ae70 <Pixel_process+0x2b4>)
	switch( Pixel_FrameState )
    abc4:	4cab      	ldr	r4, [pc, #684]	; (ae74 <Pixel_process+0x2b8>)
{
    abc6:	682b      	ldr	r3, [r5, #0]
	Latency_start_time( pixelLatencyResource );
    abc8:	7838      	ldrb	r0, [r7, #0]
{
    abca:	9301      	str	r3, [sp, #4]
	Latency_start_time( pixelLatencyResource );
    abcc:	f004 fbfe 	bl	f3cc <Latency_start_time>
	switch( Pixel_FrameState )
    abd0:	7823      	ldrb	r3, [r4, #0]
    abd2:	3b02      	subs	r3, #2
    abd4:	2b01      	cmp	r3, #1
    abd6:	46a8      	mov	r8, r5
    abd8:	d848      	bhi.n	ac6c <Pixel_process+0xb0>
	switch ( Pixel_animationControl )
    abda:	4da7      	ldr	r5, [pc, #668]	; (ae78 <Pixel_process+0x2bc>)
    abdc:	782b      	ldrb	r3, [r5, #0]
    abde:	2b06      	cmp	r3, #6
    abe0:	d842      	bhi.n	ac68 <Pixel_process+0xac>
    abe2:	e8df f003 	tbb	[pc, r3]
    abe6:	0404      	.short	0x0404
    abe8:	32271e41 	.word	0x32271e41
    abec:	3c          	.byte	0x3c
    abed:	00          	.byte	0x00
		Pixel_FrameState = FrameState_Update;
    abee:	2302      	movs	r3, #2
    abf0:	7023      	strb	r3, [r4, #0]
	switch ( Pixel_testMode )
    abf2:	4ea2      	ldr	r6, [pc, #648]	; (ae7c <Pixel_process+0x2c0>)
    abf4:	7833      	ldrb	r3, [r6, #0]
    abf6:	3b01      	subs	r3, #1
    abf8:	2b0f      	cmp	r3, #15
    abfa:	f200 8129 	bhi.w	ae50 <Pixel_process+0x294>
    abfe:	e8df f013 	tbh	[pc, r3, lsl #1]
    ac02:	003d      	.short	0x003d
    ac04:	004d005b 	.word	0x004d005b
    ac08:	006c0063 	.word	0x006c0063
    ac0c:	008c0075 	.word	0x008c0075
    ac10:	009c007e 	.word	0x009c007e
    ac14:	00ba00ab 	.word	0x00ba00ab
    ac18:	00d300ec 	.word	0x00d300ec
    ac1c:	01100127 	.word	0x01100127
    ac20:	0103      	.short	0x0103
		Pixel_FrameState = FrameState_Update;
    ac22:	2302      	movs	r3, #2
    ac24:	7023      	strb	r3, [r4, #0]
		Pixel_clearAnimations();
    ac26:	f7fe fd29 	bl	967c <Pixel_clearAnimations>
		Pixel_clearPixels();
    ac2a:	f7ff f959 	bl	9ee0 <Pixel_clearPixels>
		Pixel_animationControl = AnimationControl_Forward;
    ac2e:	2300      	movs	r3, #0
    ac30:	702b      	strb	r3, [r5, #0]
		break;
    ac32:	e7de      	b.n	abf2 <Pixel_process+0x36>
		Pixel_FrameState = FrameState_Update;
    ac34:	2302      	movs	r3, #2
    ac36:	7023      	strb	r3, [r4, #0]
		Pixel_clearAnimations();
    ac38:	f7fe fd20 	bl	967c <Pixel_clearAnimations>
		Pixel_clearPixels();
    ac3c:	f7ff f950 	bl	9ee0 <Pixel_clearPixels>
		Pixel_animationControl = AnimationControl_Forward;
    ac40:	2300      	movs	r3, #0
    ac42:	702b      	strb	r3, [r5, #0]
		Pixel_initializeStartAnimations();
    ac44:	f7ff ff8a 	bl	ab5c <Pixel_initializeStartAnimations>
		break;
    ac48:	e7d3      	b.n	abf2 <Pixel_process+0x36>
		Pixel_animationControl = AnimationControl_Pause; // Update one more time
    ac4a:	2302      	movs	r3, #2
    ac4c:	702b      	strb	r3, [r5, #0]
		Pixel_clearPixels();
    ac4e:	f7ff f947 	bl	9ee0 <Pixel_clearPixels>
	__disable_irq();
    ac52:	b672      	cpsid	i
	Pixel_SecondaryProcessing();
    ac54:	f7ff fb0a 	bl	a26c <Pixel_SecondaryProcessing>
	__enable_irq();
    ac58:	b662      	cpsie	i
	Pixel_FrameState = FrameState_Ready;
    ac5a:	2300      	movs	r3, #0
    ac5c:	e005      	b.n	ac6a <Pixel_process+0xae>
		Pixel_FrameState = FrameState_Update;
    ac5e:	2302      	movs	r3, #2
    ac60:	7023      	strb	r3, [r4, #0]
		Pixel_clearPixels();
    ac62:	f7ff f93d 	bl	9ee0 <Pixel_clearPixels>
		break;
    ac66:	e7c4      	b.n	abf2 <Pixel_process+0x36>
		Pixel_FrameState = FrameState_Pause;
    ac68:	2303      	movs	r3, #3
	Pixel_FrameState = FrameState_Ready;
    ac6a:	7023      	strb	r3, [r4, #0]
	Latency_end_time( pixelLatencyResource );
    ac6c:	9a01      	ldr	r2, [sp, #4]
    ac6e:	f8d8 3000 	ldr.w	r3, [r8]
    ac72:	429a      	cmp	r2, r3
    ac74:	f000 80f4 	beq.w	ae60 <Pixel_process+0x2a4>
    ac78:	f7f7 fd5a 	bl	2730 <__stack_chk_fail>
		Pixel_channelToggle( Pixel_testPos );
    ac7c:	4d80      	ldr	r5, [pc, #512]	; (ae80 <Pixel_process+0x2c4>)
    ac7e:	8828      	ldrh	r0, [r5, #0]
    ac80:	f7ff f8c8 	bl	9e14 <Pixel_channelToggle>
		Pixel_testPos++;
    ac84:	882b      	ldrh	r3, [r5, #0]
    ac86:	3301      	adds	r3, #1
    ac88:	b29b      	uxth	r3, r3
    ac8a:	802b      	strh	r3, [r5, #0]
		if ( Pixel_testPos >= Pixel_TotalChannels_KLL )
    ac8c:	882b      	ldrh	r3, [r5, #0]
    ac8e:	2b8f      	cmp	r3, #143	; 0x8f
    ac90:	d901      	bls.n	ac96 <Pixel_process+0xda>
			Pixel_testPos = 0;
    ac92:	2300      	movs	r3, #0
    ac94:	802b      	strh	r3, [r5, #0]
		Pixel_testMode = PixelTest_Off;
    ac96:	2300      	movs	r3, #0
    ac98:	7033      	strb	r3, [r6, #0]
		goto pixel_process_done;
    ac9a:	e7da      	b.n	ac52 <Pixel_process+0x96>
		Pixel_channelToggle( Pixel_testPos );
    ac9c:	4d78      	ldr	r5, [pc, #480]	; (ae80 <Pixel_process+0x2c4>)
    ac9e:	8828      	ldrh	r0, [r5, #0]
    aca0:	f7ff f8b8 	bl	9e14 <Pixel_channelToggle>
		Pixel_testPos++;
    aca4:	882b      	ldrh	r3, [r5, #0]
    aca6:	3301      	adds	r3, #1
    aca8:	b29b      	uxth	r3, r3
    acaa:	802b      	strh	r3, [r5, #0]
		if ( Pixel_testPos >= Pixel_TotalChannels_KLL )
    acac:	882b      	ldrh	r3, [r5, #0]
    acae:	2b8f      	cmp	r3, #143	; 0x8f
		if ( Pixel_testPos >= Pixel_TotalPixels_KLL )
    acb0:	d9cf      	bls.n	ac52 <Pixel_process+0x96>
			Pixel_testPos = 0;
    acb2:	2300      	movs	r3, #0
    acb4:	802b      	strh	r3, [r5, #0]
    acb6:	e7cc      	b.n	ac52 <Pixel_process+0x96>
	switch ( Pixel_testMode )
    acb8:	2500      	movs	r5, #0
			Pixel_channelToggle( ch );
    acba:	b2a8      	uxth	r0, r5
    acbc:	3501      	adds	r5, #1
    acbe:	f7ff f8a9 	bl	9e14 <Pixel_channelToggle>
		for ( uint16_t ch = 0; ch < Pixel_TotalChannels_KLL; ch++ )
    acc2:	2d90      	cmp	r5, #144	; 0x90
    acc4:	d1f9      	bne.n	acba <Pixel_process+0xfe>
    acc6:	e7c4      	b.n	ac52 <Pixel_process+0x96>
	switch ( Pixel_testMode )
    acc8:	2500      	movs	r5, #0
			Pixel_channelSet( ch, 255 );
    acca:	b2a8      	uxth	r0, r5
    accc:	21ff      	movs	r1, #255	; 0xff
    acce:	3501      	adds	r5, #1
    acd0:	f7ff f85e 	bl	9d90 <Pixel_channelSet>
		for ( uint16_t ch = 0; ch < Pixel_TotalChannels_KLL; ch++ )
    acd4:	2d90      	cmp	r5, #144	; 0x90
    acd6:	d1f8      	bne.n	acca <Pixel_process+0x10e>
    acd8:	e7bb      	b.n	ac52 <Pixel_process+0x96>
	switch ( Pixel_testMode )
    acda:	2500      	movs	r5, #0
			Pixel_channelSet( ch, 0 );
    acdc:	b2a8      	uxth	r0, r5
    acde:	2100      	movs	r1, #0
    ace0:	3501      	adds	r5, #1
    ace2:	f7ff f855 	bl	9d90 <Pixel_channelSet>
		for ( uint16_t ch = 0; ch < Pixel_TotalChannels_KLL; ch++ )
    ace6:	2d90      	cmp	r5, #144	; 0x90
    ace8:	d1f8      	bne.n	acdc <Pixel_process+0x120>
    acea:	e7b2      	b.n	ac52 <Pixel_process+0x96>
		Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ Pixel_testPos - 1 ] );
    acec:	4d64      	ldr	r5, [pc, #400]	; (ae80 <Pixel_process+0x2c4>)
    acee:	4865      	ldr	r0, [pc, #404]	; (ae84 <Pixel_process+0x2c8>)
    acf0:	882b      	ldrh	r3, [r5, #0]
    acf2:	3b01      	subs	r3, #1
    acf4:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    acf8:	f7ff f90c 	bl	9f14 <Pixel_pixelToggle>
    acfc:	e7c2      	b.n	ac84 <Pixel_process+0xc8>
		Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ Pixel_testPos ] );
    acfe:	4d60      	ldr	r5, [pc, #384]	; (ae80 <Pixel_process+0x2c4>)
    ad00:	4b60      	ldr	r3, [pc, #384]	; (ae84 <Pixel_process+0x2c8>)
    ad02:	8828      	ldrh	r0, [r5, #0]
    ad04:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    ad08:	f7ff f904 	bl	9f14 <Pixel_pixelToggle>
		Pixel_testPos++;
    ad0c:	882b      	ldrh	r3, [r5, #0]
    ad0e:	3301      	adds	r3, #1
    ad10:	b29b      	uxth	r3, r3
    ad12:	802b      	strh	r3, [r5, #0]
		if ( Pixel_testPos >= Pixel_TotalPixels_KLL )
    ad14:	882b      	ldrh	r3, [r5, #0]
    ad16:	2b25      	cmp	r3, #37	; 0x25
    ad18:	e7ca      	b.n	acb0 <Pixel_process+0xf4>
		for ( uint16_t px = Pixel_testPos; px < Pixel_TotalPixels_KLL; px++ )
    ad1a:	4b59      	ldr	r3, [pc, #356]	; (ae80 <Pixel_process+0x2c4>)
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ px ] );
    ad1c:	f8df 9164 	ldr.w	r9, [pc, #356]	; ae84 <Pixel_process+0x2c8>
		for ( uint16_t px = Pixel_testPos; px < Pixel_TotalPixels_KLL; px++ )
    ad20:	881e      	ldrh	r6, [r3, #0]
    ad22:	2500      	movs	r5, #0
    ad24:	b2b6      	uxth	r6, r6
    ad26:	1970      	adds	r0, r6, r5
    ad28:	b283      	uxth	r3, r0
    ad2a:	2b25      	cmp	r3, #37	; 0x25
    ad2c:	d891      	bhi.n	ac52 <Pixel_process+0x96>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ px ] );
    ad2e:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
    ad32:	f7ff f8ef 	bl	9f14 <Pixel_pixelToggle>
    ad36:	3501      	adds	r5, #1
    ad38:	e7f5      	b.n	ad26 <Pixel_process+0x16a>
	switch ( Pixel_testMode )
    ad3a:	2500      	movs	r5, #0
			Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 255 );
    ad3c:	f8df a144 	ldr.w	sl, [pc, #324]	; ae84 <Pixel_process+0x2c8>
			Pixel_testMode = PixelTest_Off;
    ad40:	46a9      	mov	r9, r5
			Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 255 );
    ad42:	eb0a 00c5 	add.w	r0, sl, r5, lsl #3
    ad46:	21ff      	movs	r1, #255	; 0xff
    ad48:	3501      	adds	r5, #1
    ad4a:	f7ff f8ab 	bl	9ea4 <Pixel_pixelSet>
		for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    ad4e:	2d26      	cmp	r5, #38	; 0x26
			Pixel_testMode = PixelTest_Off;
    ad50:	f886 9000 	strb.w	r9, [r6]
		for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    ad54:	d1f5      	bne.n	ad42 <Pixel_process+0x186>
    ad56:	e77c      	b.n	ac52 <Pixel_process+0x96>
	switch ( Pixel_testMode )
    ad58:	2500      	movs	r5, #0
			Pixel_pixelSet( (PixelElement*)&Pixel_Mapping[ px ], 0 );
    ad5a:	f8df a128 	ldr.w	sl, [pc, #296]	; ae84 <Pixel_process+0x2c8>
    ad5e:	46a9      	mov	r9, r5
    ad60:	eb0a 00c5 	add.w	r0, sl, r5, lsl #3
    ad64:	2100      	movs	r1, #0
    ad66:	3501      	adds	r5, #1
    ad68:	f7ff f89c 	bl	9ea4 <Pixel_pixelSet>
		for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    ad6c:	2d26      	cmp	r5, #38	; 0x26
			Pixel_testMode = PixelTest_Off;
    ad6e:	f886 9000 	strb.w	r9, [r6]
		for ( uint16_t px = 0; px < Pixel_TotalPixels_KLL; px++ )
    ad72:	d1f5      	bne.n	ad60 <Pixel_process+0x1a4>
    ad74:	e76d      	b.n	ac52 <Pixel_process+0x96>
		uint16_t pixel = Pixel_ScanCodeToPixel[ Pixel_testPos ];
    ad76:	4b42      	ldr	r3, [pc, #264]	; (ae80 <Pixel_process+0x2c4>)
    ad78:	4943      	ldr	r1, [pc, #268]	; (ae88 <Pixel_process+0x2cc>)
    ad7a:	881a      	ldrh	r2, [r3, #0]
    ad7c:	b292      	uxth	r2, r2
    ad7e:	f831 0012 	ldrh.w	r0, [r1, r2, lsl #1]
		Pixel_testPos++;
    ad82:	881a      	ldrh	r2, [r3, #0]
    ad84:	3201      	adds	r2, #1
    ad86:	b292      	uxth	r2, r2
    ad88:	801a      	strh	r2, [r3, #0]
		if ( Pixel_testPos >= MaxScanCode_KLL )
    ad8a:	881a      	ldrh	r2, [r3, #0]
    ad8c:	2a59      	cmp	r2, #89	; 0x59
			Pixel_testPos = 0;
    ad8e:	bf84      	itt	hi
    ad90:	2200      	movhi	r2, #0
    ad92:	801a      	strhhi	r2, [r3, #0]
		if ( pixel == 0 )
    ad94:	2800      	cmp	r0, #0
    ad96:	f43f af69 	beq.w	ac6c <Pixel_process+0xb0>
		Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    ad9a:	4b3a      	ldr	r3, [pc, #232]	; (ae84 <Pixel_process+0x2c8>)
    ad9c:	3801      	subs	r0, #1
    ad9e:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    ada2:	f7ff f8b7 	bl	9f14 <Pixel_pixelToggle>
    ada6:	e776      	b.n	ac96 <Pixel_process+0xda>
		uint16_t pixel = Pixel_ScanCodeToPixel[ Pixel_testPos ];
    ada8:	4b35      	ldr	r3, [pc, #212]	; (ae80 <Pixel_process+0x2c4>)
    adaa:	4937      	ldr	r1, [pc, #220]	; (ae88 <Pixel_process+0x2cc>)
    adac:	881a      	ldrh	r2, [r3, #0]
    adae:	b292      	uxth	r2, r2
    adb0:	f831 0012 	ldrh.w	r0, [r1, r2, lsl #1]
		Pixel_testPos++;
    adb4:	881a      	ldrh	r2, [r3, #0]
    adb6:	3201      	adds	r2, #1
    adb8:	b292      	uxth	r2, r2
    adba:	801a      	strh	r2, [r3, #0]
		if ( Pixel_testPos >= MaxScanCode_KLL )
    adbc:	881a      	ldrh	r2, [r3, #0]
    adbe:	2a59      	cmp	r2, #89	; 0x59
			Pixel_testPos = 0;
    adc0:	bf84      	itt	hi
    adc2:	2200      	movhi	r2, #0
    adc4:	801a      	strhhi	r2, [r3, #0]
		if ( pixel == 0 )
    adc6:	2800      	cmp	r0, #0
    adc8:	f43f af50 	beq.w	ac6c <Pixel_process+0xb0>
		Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    adcc:	4b2d      	ldr	r3, [pc, #180]	; (ae84 <Pixel_process+0x2c8>)
    adce:	3801      	subs	r0, #1
    add0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    add4:	f7ff f89e 	bl	9f14 <Pixel_pixelToggle>
		goto pixel_process_done;
    add8:	e73b      	b.n	ac52 <Pixel_process+0x96>
		for ( uint16_t px = Pixel_testPos; px < MaxScanCode_KLL; px++ )
    adda:	4b29      	ldr	r3, [pc, #164]	; (ae80 <Pixel_process+0x2c4>)
			uint16_t pixel = Pixel_ScanCodeToPixel[ px ];
    addc:	f8df 90a8 	ldr.w	r9, [pc, #168]	; ae88 <Pixel_process+0x2cc>
		for ( uint16_t px = Pixel_testPos; px < MaxScanCode_KLL; px++ )
    ade0:	881e      	ldrh	r6, [r3, #0]
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    ade2:	f8df a0a0 	ldr.w	sl, [pc, #160]	; ae84 <Pixel_process+0x2c8>
		for ( uint16_t px = Pixel_testPos; px < MaxScanCode_KLL; px++ )
    ade6:	b2b6      	uxth	r6, r6
    ade8:	2500      	movs	r5, #0
    adea:	1973      	adds	r3, r6, r5
    adec:	b29a      	uxth	r2, r3
    adee:	2a59      	cmp	r2, #89	; 0x59
    adf0:	f63f af2f 	bhi.w	ac52 <Pixel_process+0x96>
			uint16_t pixel = Pixel_ScanCodeToPixel[ px ];
    adf4:	f839 0013 	ldrh.w	r0, [r9, r3, lsl #1]
			if ( pixel == 0 )
    adf8:	b120      	cbz	r0, ae04 <Pixel_process+0x248>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    adfa:	3801      	subs	r0, #1
    adfc:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
    ae00:	f7ff f888 	bl	9f14 <Pixel_pixelToggle>
    ae04:	3501      	adds	r5, #1
    ae06:	e7f0      	b.n	adea <Pixel_process+0x22e>
		uint16_t pixel = Pixel_DisplayMapping[ Pixel_testPos ];
    ae08:	4b1d      	ldr	r3, [pc, #116]	; (ae80 <Pixel_process+0x2c4>)
    ae0a:	4920      	ldr	r1, [pc, #128]	; (ae8c <Pixel_process+0x2d0>)
    ae0c:	881a      	ldrh	r2, [r3, #0]
    ae0e:	b292      	uxth	r2, r2
    ae10:	f831 0012 	ldrh.w	r0, [r1, r2, lsl #1]
		Pixel_testPos++;
    ae14:	881a      	ldrh	r2, [r3, #0]
    ae16:	3201      	adds	r2, #1
    ae18:	b292      	uxth	r2, r2
    ae1a:	801a      	strh	r2, [r3, #0]
		if ( Pixel_testPos >= Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL )
    ae1c:	881a      	ldrh	r2, [r3, #0]
    ae1e:	2a76      	cmp	r2, #118	; 0x76
    ae20:	e7ce      	b.n	adc0 <Pixel_process+0x204>
		for ( uint16_t px = Pixel_testPos; px < Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL; px++ )
    ae22:	4b17      	ldr	r3, [pc, #92]	; (ae80 <Pixel_process+0x2c4>)
			uint16_t pixel = Pixel_DisplayMapping[ px ];
    ae24:	f8df 9064 	ldr.w	r9, [pc, #100]	; ae8c <Pixel_process+0x2d0>
		for ( uint16_t px = Pixel_testPos; px < Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL; px++ )
    ae28:	881e      	ldrh	r6, [r3, #0]
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    ae2a:	f8df a058 	ldr.w	sl, [pc, #88]	; ae84 <Pixel_process+0x2c8>
		for ( uint16_t px = Pixel_testPos; px < Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL; px++ )
    ae2e:	b2b6      	uxth	r6, r6
    ae30:	2500      	movs	r5, #0
    ae32:	1973      	adds	r3, r6, r5
    ae34:	b29a      	uxth	r2, r3
    ae36:	2a76      	cmp	r2, #118	; 0x76
    ae38:	f63f af0b 	bhi.w	ac52 <Pixel_process+0x96>
			uint16_t pixel = Pixel_DisplayMapping[ px ];
    ae3c:	f839 0013 	ldrh.w	r0, [r9, r3, lsl #1]
			if ( pixel == 0 )
    ae40:	b120      	cbz	r0, ae4c <Pixel_process+0x290>
			Pixel_pixelToggle( (PixelElement*)&Pixel_Mapping[ pixel - 1 ] );
    ae42:	3801      	subs	r0, #1
    ae44:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
    ae48:	f7ff f864 	bl	9f14 <Pixel_pixelToggle>
    ae4c:	3501      	adds	r5, #1
    ae4e:	e7f0      	b.n	ae32 <Pixel_process+0x276>
	Pixel_stackProcess();
    ae50:	f7ff fe3a 	bl	aac8 <Pixel_stackProcess>
	switch( Pixel_animationControl )
    ae54:	782b      	ldrb	r3, [r5, #0]
    ae56:	2b01      	cmp	r3, #1
		Pixel_animationControl = AnimationControl_Pause;
    ae58:	bf04      	itt	eq
    ae5a:	2302      	moveq	r3, #2
    ae5c:	702b      	strbeq	r3, [r5, #0]
		break;
    ae5e:	e6f8      	b.n	ac52 <Pixel_process+0x96>
	Latency_end_time( pixelLatencyResource );
    ae60:	7838      	ldrb	r0, [r7, #0]
}
    ae62:	b002      	add	sp, #8
    ae64:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	Latency_end_time( pixelLatencyResource );
    ae68:	f004 bace 	b.w	f408 <Latency_end_time>
    ae6c:	1fff89d0 	.word	0x1fff89d0
    ae70:	1fff9726 	.word	0x1fff9726
    ae74:	1fffab55 	.word	0x1fffab55
    ae78:	1fffab54 	.word	0x1fffab54
    ae7c:	1fffac98 	.word	0x1fffac98
    ae80:	1fff9724 	.word	0x1fff9724
    ae84:	00015530 	.word	0x00015530
    ae88:	000156ba 	.word	0x000156ba
    ae8c:	000153bc 	.word	0x000153bc

0000ae90 <Pixel_setup>:
{
    ae90:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ae92:	4d11      	ldr	r5, [pc, #68]	; (aed8 <Pixel_setup+0x48>)
	CLI_registerDictionary( pixelCLIDict, pixelCLIDictName );
    ae94:	4911      	ldr	r1, [pc, #68]	; (aedc <Pixel_setup+0x4c>)
    ae96:	4812      	ldr	r0, [pc, #72]	; (aee0 <Pixel_setup+0x50>)
{
    ae98:	682b      	ldr	r3, [r5, #0]
    ae9a:	9301      	str	r3, [sp, #4]
	CLI_registerDictionary( pixelCLIDict, pixelCLIDictName );
    ae9c:	f003 fef8 	bl	ec90 <CLI_registerDictionary>
	Pixel_FrameState = FrameState_Update;
    aea0:	4b10      	ldr	r3, [pc, #64]	; (aee4 <Pixel_setup+0x54>)
    aea2:	2202      	movs	r2, #2
    aea4:	701a      	strb	r2, [r3, #0]
	Pixel_testMode = Pixel_Test_Mode_define;
    aea6:	4b10      	ldr	r3, [pc, #64]	; (aee8 <Pixel_setup+0x58>)
    aea8:	2400      	movs	r4, #0
    aeaa:	701c      	strb	r4, [r3, #0]
	Pixel_clearAnimations();
    aeac:	f7fe fbe6 	bl	967c <Pixel_clearAnimations>
	Pixel_animationControl = AnimationControl_Forward;
    aeb0:	4b0e      	ldr	r3, [pc, #56]	; (aeec <Pixel_setup+0x5c>)
    aeb2:	701c      	strb	r4, [r3, #0]
	Pixel_initializeStartAnimations();
    aeb4:	f7ff fe52 	bl	ab5c <Pixel_initializeStartAnimations>
	Pixel_SecondaryProcessing_setup();
    aeb8:	f7ff f990 	bl	a1dc <Pixel_SecondaryProcessing_setup>
	pixelLatencyResource = Latency_add_resource("PixelMap", LatencyOption_Ticks);
    aebc:	4621      	mov	r1, r4
    aebe:	480c      	ldr	r0, [pc, #48]	; (aef0 <Pixel_setup+0x60>)
    aec0:	f004 fa0c 	bl	f2dc <Latency_add_resource>
    aec4:	4b0b      	ldr	r3, [pc, #44]	; (aef4 <Pixel_setup+0x64>)
}
    aec6:	9a01      	ldr	r2, [sp, #4]
	pixelLatencyResource = Latency_add_resource("PixelMap", LatencyOption_Ticks);
    aec8:	7018      	strb	r0, [r3, #0]
}
    aeca:	682b      	ldr	r3, [r5, #0]
    aecc:	429a      	cmp	r2, r3
    aece:	d001      	beq.n	aed4 <Pixel_setup+0x44>
    aed0:	f7f7 fc2e 	bl	2730 <__stack_chk_fail>
    aed4:	b003      	add	sp, #12
    aed6:	bd30      	pop	{r4, r5, pc}
    aed8:	1fff89d0 	.word	0x1fff89d0
    aedc:	000151e4 	.word	0x000151e4
    aee0:	0001516c 	.word	0x0001516c
    aee4:	1fffab55 	.word	0x1fffab55
    aee8:	1fffac98 	.word	0x1fffac98
    aeec:	1fffab54 	.word	0x1fffab54
    aef0:	00014cf4 	.word	0x00014cf4
    aef4:	1fff9726 	.word	0x1fff9726

0000aef8 <Pixel_dispBuffer>:

void Pixel_dispBuffer()
{
    aef8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aefc:	4f29      	ldr	r7, [pc, #164]	; (afa4 <Pixel_dispBuffer+0xac>)
			PixelElement *elem = (PixelElement*)&Pixel_Mapping[ Pixel_DisplayMapping[px] - 1 ];

			// Lookup channel data
			// TODO account for different channel size mappings
			print("\033[48;2");
			for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    aefe:	f8df 80c8 	ldr.w	r8, [pc, #200]	; afc8 <Pixel_dispBuffer+0xd0>
{
    af02:	683b      	ldr	r3, [r7, #0]
    af04:	9301      	str	r3, [sp, #4]
    af06:	2500      	movs	r5, #0
	uint8_t col = 0;
    af08:	462c      	mov	r4, r5
		if ( Pixel_DisplayMapping[px] == 0 )
    af0a:	4b27      	ldr	r3, [pc, #156]	; (afa8 <Pixel_dispBuffer+0xb0>)
    af0c:	f833 6015 	ldrh.w	r6, [r3, r5, lsl #1]
    af10:	b9a6      	cbnz	r6, af3c <Pixel_dispBuffer+0x44>
			print("+");
    af12:	4826      	ldr	r0, [pc, #152]	; (afac <Pixel_dispBuffer+0xb4>)
				PixelBuf *pixbuf = Pixel_bufferMap( ch_pos );
				printInt8( PixelBuf16( pixbuf, ch_pos ) );
			}
			print("m");
			print(" ");
			print("\033[0m");
    af14:	f004 fb2c 	bl	f570 <_print>
		}

		// Determine what to increment next
		if ( col >= Pixel_DisplayMapping_Cols_KLL - 1 )
    af18:	2c0f      	cmp	r4, #15
    af1a:	d93c      	bls.n	af96 <Pixel_dispBuffer+0x9e>
		{
			col = 0;
			row++;
			print(" ");
    af1c:	4824      	ldr	r0, [pc, #144]	; (afb0 <Pixel_dispBuffer+0xb8>)
    af1e:	f004 fb27 	bl	f570 <_print>
			print(NL);
    af22:	4824      	ldr	r0, [pc, #144]	; (afb4 <Pixel_dispBuffer+0xbc>)
    af24:	f004 fb24 	bl	f570 <_print>
			col = 0;
    af28:	2400      	movs	r4, #0
    af2a:	3501      	adds	r5, #1
	for ( uint16_t px = 0; px < Pixel_DisplayMapping_Cols_KLL * Pixel_DisplayMapping_Rows_KLL; px++ )
    af2c:	2d77      	cmp	r5, #119	; 0x77
    af2e:	d1ec      	bne.n	af0a <Pixel_dispBuffer+0x12>
		else
		{
			col++;
		}
	}
}
    af30:	9a01      	ldr	r2, [sp, #4]
    af32:	683b      	ldr	r3, [r7, #0]
    af34:	429a      	cmp	r2, r3
    af36:	d031      	beq.n	af9c <Pixel_dispBuffer+0xa4>
    af38:	f7f7 fbfa 	bl	2730 <__stack_chk_fail>
			PixelElement *elem = (PixelElement*)&Pixel_Mapping[ Pixel_DisplayMapping[px] - 1 ];
    af3c:	3e01      	subs	r6, #1
			print("\033[48;2");
    af3e:	481e      	ldr	r0, [pc, #120]	; (afb8 <Pixel_dispBuffer+0xc0>)
    af40:	f004 fb16 	bl	f570 <_print>
			for ( uint8_t ch = 0; ch < elem->channels; ch++ )
    af44:	eb08 02c6 	add.w	r2, r8, r6, lsl #3
    af48:	2300      	movs	r3, #0
    af4a:	f892 9001 	ldrb.w	r9, [r2, #1]
    af4e:	fa5f fb83 	uxtb.w	fp, r3
    af52:	45d9      	cmp	r9, fp
    af54:	f103 0a01 	add.w	sl, r3, #1
    af58:	d807      	bhi.n	af6a <Pixel_dispBuffer+0x72>
			print("m");
    af5a:	4818      	ldr	r0, [pc, #96]	; (afbc <Pixel_dispBuffer+0xc4>)
    af5c:	f004 fb08 	bl	f570 <_print>
			print(" ");
    af60:	4813      	ldr	r0, [pc, #76]	; (afb0 <Pixel_dispBuffer+0xb8>)
    af62:	f004 fb05 	bl	f570 <_print>
			print("\033[0m");
    af66:	4816      	ldr	r0, [pc, #88]	; (afc0 <Pixel_dispBuffer+0xc8>)
    af68:	e7d4      	b.n	af14 <Pixel_dispBuffer+0x1c>
				print(";");
    af6a:	4816      	ldr	r0, [pc, #88]	; (afc4 <Pixel_dispBuffer+0xcc>)
    af6c:	f004 fb00 	bl	f570 <_print>
				uint16_t ch_pos = elem->indices[ch];
    af70:	eb0b 0386 	add.w	r3, fp, r6, lsl #2
    af74:	eb08 0343 	add.w	r3, r8, r3, lsl #1
    af78:	f8b3 b002 	ldrh.w	fp, [r3, #2]
				PixelBuf *pixbuf = Pixel_bufferMap( ch_pos );
    af7c:	4658      	mov	r0, fp
    af7e:	f7fe fcd1 	bl	9924 <Pixel_bufferMap>
				printInt8( PixelBuf16( pixbuf, ch_pos ) );
    af82:	8843      	ldrh	r3, [r0, #2]
    af84:	ebab 0b03 	sub.w	fp, fp, r3
    af88:	6843      	ldr	r3, [r0, #4]
    af8a:	f813 001b 	ldrb.w	r0, [r3, fp, lsl #1]
    af8e:	f004 fb59 	bl	f644 <printInt8>
    af92:	4653      	mov	r3, sl
    af94:	e7db      	b.n	af4e <Pixel_dispBuffer+0x56>
			col++;
    af96:	3401      	adds	r4, #1
    af98:	b2e4      	uxtb	r4, r4
    af9a:	e7c6      	b.n	af2a <Pixel_dispBuffer+0x32>
}
    af9c:	b003      	add	sp, #12
    af9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    afa2:	bf00      	nop
    afa4:	1fff89d0 	.word	0x1fff89d0
    afa8:	000153bc 	.word	0x000153bc
    afac:	00010bae 	.word	0x00010bae
    afb0:	00016f5e 	.word	0x00016f5e
    afb4:	00015df4 	.word	0x00015df4
    afb8:	00014a18 	.word	0x00014a18
    afbc:	0001205f 	.word	0x0001205f
    afc0:	0001205c 	.word	0x0001205c
    afc4:	00012be6 	.word	0x00012be6
    afc8:	00015530 	.word	0x00015530

0000afcc <cliFunc_rectDisp>:

void cliFunc_rectDisp( char* args )
{
    afcc:	b513      	push	{r0, r1, r4, lr}
    afce:	4c08      	ldr	r4, [pc, #32]	; (aff0 <cliFunc_rectDisp+0x24>)
	print( NL ); // No \r\n by default after the command is entered
    afd0:	4808      	ldr	r0, [pc, #32]	; (aff4 <cliFunc_rectDisp+0x28>)
{
    afd2:	6823      	ldr	r3, [r4, #0]
    afd4:	9301      	str	r3, [sp, #4]
	print( NL ); // No \r\n by default after the command is entered
    afd6:	f004 facb 	bl	f570 <_print>

	// TODO move to own function, use this func to control startup/args
	Pixel_dispBuffer();
    afda:	9a01      	ldr	r2, [sp, #4]
    afdc:	6823      	ldr	r3, [r4, #0]
    afde:	429a      	cmp	r2, r3
    afe0:	d001      	beq.n	afe6 <cliFunc_rectDisp+0x1a>
    afe2:	f7f7 fba5 	bl	2730 <__stack_chk_fail>
}
    afe6:	b002      	add	sp, #8
    afe8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Pixel_dispBuffer();
    afec:	f7ff bf84 	b.w	aef8 <Pixel_dispBuffer>
    aff0:	1fff89d0 	.word	0x1fff89d0
    aff4:	00015df4 	.word	0x00015df4

0000aff8 <HIDIO_supported_0_call>:
	// TODO
}

// Supported Ids call
HIDIO_Return HIDIO_supported_0_call( uint16_t buf_pos, uint8_t irq )
{
    aff8:	b507      	push	{r0, r1, r2, lr}
    affa:	4b07      	ldr	r3, [pc, #28]	; (b018 <HIDIO_supported_0_call+0x20>)
    affc:	681a      	ldr	r2, [r3, #0]
    affe:	9201      	str	r2, [sp, #4]
	// TODO
	return HIDIO_Return__Ok;
}
    b000:	9a01      	ldr	r2, [sp, #4]
    b002:	681b      	ldr	r3, [r3, #0]
    b004:	429a      	cmp	r2, r3
    b006:	f04f 0000 	mov.w	r0, #0
    b00a:	d001      	beq.n	b010 <HIDIO_supported_0_call+0x18>
    b00c:	f7f7 fb90 	bl	2730 <__stack_chk_fail>
    b010:	b003      	add	sp, #12
    b012:	f85d fb04 	ldr.w	pc, [sp], #4
    b016:	bf00      	nop
    b018:	1fff89d0 	.word	0x1fff89d0

0000b01c <HIDIO_supported_0_reply>:

// Supported Ids reply
HIDIO_Return HIDIO_supported_0_reply( HIDIO_Buffer_Entry *buf, uint8_t irq )
{
    b01c:	b507      	push	{r0, r1, r2, lr}
    b01e:	4b07      	ldr	r3, [pc, #28]	; (b03c <HIDIO_supported_0_reply+0x20>)
    b020:	681a      	ldr	r2, [r3, #0]
    b022:	9201      	str	r2, [sp, #4]
	// TODO
	return HIDIO_Return__Ok;
}
    b024:	9a01      	ldr	r2, [sp, #4]
    b026:	681b      	ldr	r3, [r3, #0]
    b028:	429a      	cmp	r2, r3
    b02a:	f04f 0000 	mov.w	r0, #0
    b02e:	d001      	beq.n	b034 <HIDIO_supported_0_reply+0x18>
    b030:	f7f7 fb7e 	bl	2730 <__stack_chk_fail>
    b034:	b003      	add	sp, #12
    b036:	f85d fb04 	ldr.w	pc, [sp], #4
    b03a:	bf00      	nop
    b03c:	1fff89d0 	.word	0x1fff89d0

0000b040 <HIDIO_test_2_reply>:
	return HIDIO_Return__Ok;
}

// Test reply
HIDIO_Return HIDIO_test_2_reply( HIDIO_Buffer_Entry *buf, uint8_t irq )
{
    b040:	b537      	push	{r0, r1, r2, r4, r5, lr}
    b042:	4b11      	ldr	r3, [pc, #68]	; (b088 <HIDIO_test_2_reply+0x48>)
    b044:	681a      	ldr	r2, [r3, #0]
    b046:	9201      	str	r2, [sp, #4]
	// TODO (HaaTa) - Add option to process optionally inside irqs
	if ( irq )
    b048:	b9d1      	cbnz	r1, b080 <HIDIO_test_2_reply+0x40>
	{
		return HIDIO_Return__Delay;
	}

	// Make sure entry is ready
	if ( !buf->done )
    b04a:	7982      	ldrb	r2, [r0, #6]
    b04c:	b1c2      	cbz	r2, b080 <HIDIO_test_2_reply+0x40>
    b04e:	8884      	ldrh	r4, [r0, #4]
    b050:	f100 0208 	add.w	r2, r0, #8
    b054:	4414      	add	r4, r2
	{
		return HIDIO_Return__Delay;
	}

	// Get size and iterate through payload, start after id
	uint16_t transitions = 0;
    b056:	4608      	mov	r0, r1
	uint8_t last_byte = 0;
	for ( uint16_t pos = 0; pos < buf->size; pos++ )
    b058:	42a2      	cmp	r2, r4
    b05a:	d109      	bne.n	b070 <HIDIO_test_2_reply+0x30>
		return HIDIO_Return__Delay;
    b05c:	2801      	cmp	r0, #1
    b05e:	bf94      	ite	ls
    b060:	2000      	movls	r0, #0
    b062:	2001      	movhi	r0, #1
		return HIDIO_Return__InBuffer_Fail;
	}

	// Buffer is automatically released for us
	return HIDIO_Return__Ok;
}
    b064:	9a01      	ldr	r2, [sp, #4]
    b066:	681b      	ldr	r3, [r3, #0]
    b068:	429a      	cmp	r2, r3
    b06a:	d00b      	beq.n	b084 <HIDIO_test_2_reply+0x44>
    b06c:	f7f7 fb60 	bl	2730 <__stack_chk_fail>
		uint8_t byte = buf->data[ pos ];
    b070:	f812 5b01 	ldrb.w	r5, [r2], #1
		if ( byte != last_byte )
    b074:	428d      	cmp	r5, r1
			transitions++;
    b076:	bf1c      	itt	ne
    b078:	3001      	addne	r0, #1
    b07a:	b280      	uxthne	r0, r0
		uint8_t byte = buf->data[ pos ];
    b07c:	4629      	mov	r1, r5
    b07e:	e7eb      	b.n	b058 <HIDIO_test_2_reply+0x18>
		return HIDIO_Return__Delay;
    b080:	2003      	movs	r0, #3
    b082:	e7ef      	b.n	b064 <HIDIO_test_2_reply+0x24>
}
    b084:	b003      	add	sp, #12
    b086:	bd30      	pop	{r4, r5, pc}
    b088:	1fff89d0 	.word	0x1fff89d0

0000b08c <HIDIO_info_1_reply>:
    b08c:	b507      	push	{r0, r1, r2, lr}
    b08e:	4b07      	ldr	r3, [pc, #28]	; (b0ac <HIDIO_info_1_reply+0x20>)
    b090:	681a      	ldr	r2, [r3, #0]
    b092:	9201      	str	r2, [sp, #4]
    b094:	9a01      	ldr	r2, [sp, #4]
    b096:	681b      	ldr	r3, [r3, #0]
    b098:	429a      	cmp	r2, r3
    b09a:	f04f 0000 	mov.w	r0, #0
    b09e:	d001      	beq.n	b0a4 <HIDIO_info_1_reply+0x18>
    b0a0:	f7f7 fb46 	bl	2730 <__stack_chk_fail>
    b0a4:	b003      	add	sp, #12
    b0a6:	f85d fb04 	ldr.w	pc, [sp], #4
    b0aa:	bf00      	nop
    b0ac:	1fff89d0 	.word	0x1fff89d0

0000b0b0 <HIDIO_info_1_call>:
    b0b0:	b507      	push	{r0, r1, r2, lr}
    b0b2:	4b07      	ldr	r3, [pc, #28]	; (b0d0 <HIDIO_info_1_call+0x20>)
    b0b4:	681a      	ldr	r2, [r3, #0]
    b0b6:	9201      	str	r2, [sp, #4]
    b0b8:	9a01      	ldr	r2, [sp, #4]
    b0ba:	681b      	ldr	r3, [r3, #0]
    b0bc:	429a      	cmp	r2, r3
    b0be:	f04f 0000 	mov.w	r0, #0
    b0c2:	d001      	beq.n	b0c8 <HIDIO_info_1_call+0x18>
    b0c4:	f7f7 fb34 	bl	2730 <__stack_chk_fail>
    b0c8:	b003      	add	sp, #12
    b0ca:	f85d fb04 	ldr.w	pc, [sp], #4
    b0ce:	bf00      	nop
    b0d0:	1fff89d0 	.word	0x1fff89d0

0000b0d4 <HIDIO_buffer_munch>:
{
    b0d4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    b0d8:	460d      	mov	r5, r1
    b0da:	4611      	mov	r1, r2
    b0dc:	4a12      	ldr	r2, [pc, #72]	; (b128 <HIDIO_buffer_munch+0x54>)
	if ( buf_pos + len < buffer->len )
    b0de:	8904      	ldrh	r4, [r0, #8]
{
    b0e0:	461f      	mov	r7, r3
    b0e2:	6813      	ldr	r3, [r2, #0]
    b0e4:	9301      	str	r3, [sp, #4]
	if ( buf_pos + len < buffer->len )
    b0e6:	19cb      	adds	r3, r1, r7
    b0e8:	42a3      	cmp	r3, r4
{
    b0ea:	4606      	mov	r6, r0
    b0ec:	4690      	mov	r8, r2
    b0ee:	68c0      	ldr	r0, [r0, #12]
	if ( buf_pos + len < buffer->len )
    b0f0:	da07      	bge.n	b102 <HIDIO_buffer_munch+0x2e>
		return &(buffer->data[ buf_pos ]);
    b0f2:	4408      	add	r0, r1
}
    b0f4:	9a01      	ldr	r2, [sp, #4]
    b0f6:	f8d8 3000 	ldr.w	r3, [r8]
    b0fa:	429a      	cmp	r2, r3
    b0fc:	d011      	beq.n	b122 <HIDIO_buffer_munch+0x4e>
    b0fe:	f7f7 fb17 	bl	2730 <__stack_chk_fail>
	if ( len == 1 )
    b102:	2f01      	cmp	r7, #1
    b104:	d0f6      	beq.n	b0f4 <HIDIO_buffer_munch+0x20>
	uint16_t cur_len = buffer->len - buf_pos;
    b106:	1a64      	subs	r4, r4, r1
    b108:	b2a4      	uxth	r4, r4
	memcpy( buf, &(buffer->data[ buf_pos ]), cur_len );
    b10a:	4401      	add	r1, r0
    b10c:	4622      	mov	r2, r4
    b10e:	4628      	mov	r0, r5
    b110:	f7f7 fb32 	bl	2778 <memcpy>
	memcpy( &buf[ cur_len ], buffer->data, len - cur_len );
    b114:	1b3a      	subs	r2, r7, r4
    b116:	68f1      	ldr	r1, [r6, #12]
    b118:	1928      	adds	r0, r5, r4
    b11a:	f7f7 fb2d 	bl	2778 <memcpy>
	return buf;
    b11e:	4628      	mov	r0, r5
    b120:	e7e8      	b.n	b0f4 <HIDIO_buffer_munch+0x20>
}
    b122:	b002      	add	sp, #8
    b124:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b128:	1fff89d0 	.word	0x1fff89d0

0000b12c <HIDIO_buffer_push_byte>:
{
    b12c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    b12e:	4b0b      	ldr	r3, [pc, #44]	; (b15c <HIDIO_buffer_push_byte+0x30>)
	if ( buffer->tail == buffer->len )
    b130:	8844      	ldrh	r4, [r0, #2]
{
    b132:	681a      	ldr	r2, [r3, #0]
    b134:	9201      	str	r2, [sp, #4]
	if ( buffer->tail == buffer->len )
    b136:	8902      	ldrh	r2, [r0, #8]
    b138:	4294      	cmp	r4, r2
		buffer->tail = 0;
    b13a:	bf04      	itt	eq
    b13c:	2200      	moveq	r2, #0
    b13e:	8042      	strheq	r2, [r0, #2]
	buffer->data[ buffer->tail++ ] = byte;
    b140:	8842      	ldrh	r2, [r0, #2]
    b142:	68c4      	ldr	r4, [r0, #12]
    b144:	1c55      	adds	r5, r2, #1
    b146:	8045      	strh	r5, [r0, #2]
    b148:	54a1      	strb	r1, [r4, r2]
}
    b14a:	9a01      	ldr	r2, [sp, #4]
    b14c:	681b      	ldr	r3, [r3, #0]
    b14e:	429a      	cmp	r2, r3
    b150:	d001      	beq.n	b156 <HIDIO_buffer_push_byte+0x2a>
    b152:	f7f7 faed 	bl	2730 <__stack_chk_fail>
    b156:	b003      	add	sp, #12
    b158:	bd30      	pop	{r4, r5, pc}
    b15a:	bf00      	nop
    b15c:	1fff89d0 	.word	0x1fff89d0

0000b160 <HIDIO_modify_buffer>:
{
    b160:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    b162:	4f0f      	ldr	r7, [pc, #60]	; (b1a0 <HIDIO_modify_buffer+0x40>)
    b164:	b296      	uxth	r6, r2
    b166:	683d      	ldr	r5, [r7, #0]
    b168:	9501      	str	r5, [sp, #4]
    b16a:	1b89      	subs	r1, r1, r6
    b16c:	b294      	uxth	r4, r2
	for ( uint16_t c = 0; c < len; c++ )
    b16e:	1ba5      	subs	r5, r4, r6
    b170:	b2ad      	uxth	r5, r5
    b172:	42ab      	cmp	r3, r5
    b174:	d805      	bhi.n	b182 <HIDIO_modify_buffer+0x22>
}
    b176:	9a01      	ldr	r2, [sp, #4]
    b178:	683b      	ldr	r3, [r7, #0]
    b17a:	429a      	cmp	r2, r3
    b17c:	d00e      	beq.n	b19c <HIDIO_modify_buffer+0x3c>
    b17e:	f7f7 fad7 	bl	2730 <__stack_chk_fail>
		if ( pos >= buffer->len )
    b182:	8905      	ldrh	r5, [r0, #8]
		buffer->data[pos] = data[c];
    b184:	f812 cb01 	ldrb.w	ip, [r2], #1
    b188:	440c      	add	r4, r1
    b18a:	b2a4      	uxth	r4, r4
		if ( pos >= buffer->len )
    b18c:	42a5      	cmp	r5, r4
			pos -= buffer->len;
    b18e:	bf9c      	itt	ls
    b190:	1b64      	subls	r4, r4, r5
    b192:	b2a4      	uxthls	r4, r4
		buffer->data[pos] = data[c];
    b194:	68c5      	ldr	r5, [r0, #12]
    b196:	f805 c004 	strb.w	ip, [r5, r4]
    b19a:	e7e7      	b.n	b16c <HIDIO_modify_buffer+0xc>
}
    b19c:	b003      	add	sp, #12
    b19e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b1a0:	1fff89d0 	.word	0x1fff89d0

0000b1a4 <HIDIO_buffer_pop_bytes>:
{
    b1a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    b1a6:	4604      	mov	r4, r0
    b1a8:	4d13      	ldr	r5, [pc, #76]	; (b1f8 <HIDIO_buffer_pop_bytes+0x54>)
	if ( len > buffer->len )
    b1aa:	8900      	ldrh	r0, [r0, #8]
{
    b1ac:	682a      	ldr	r2, [r5, #0]
    b1ae:	9201      	str	r2, [sp, #4]
	if ( len > buffer->len )
    b1b0:	4288      	cmp	r0, r1
{
    b1b2:	460e      	mov	r6, r1
	if ( len > buffer->len )
    b1b4:	d215      	bcs.n	b1e2 <HIDIO_buffer_pop_bytes+0x3e>
		erro_msg("Requested HIDIO buffer pop larger than entire buffer: ");
    b1b6:	4811      	ldr	r0, [pc, #68]	; (b1fc <HIDIO_buffer_pop_bytes+0x58>)
    b1b8:	f004 f9da 	bl	f570 <_print>
		printInt16( len );
    b1bc:	4630      	mov	r0, r6
    b1be:	f004 fa77 	bl	f6b0 <printInt16>
		print(":");
    b1c2:	480f      	ldr	r0, [pc, #60]	; (b200 <HIDIO_buffer_pop_bytes+0x5c>)
    b1c4:	f004 f9d4 	bl	f570 <_print>
		printInt16( buffer->len );
    b1c8:	8920      	ldrh	r0, [r4, #8]
    b1ca:	f004 fa71 	bl	f6b0 <printInt16>
		print(NL);
    b1ce:	480d      	ldr	r0, [pc, #52]	; (b204 <HIDIO_buffer_pop_bytes+0x60>)
    b1d0:	f004 f9ce 	bl	f570 <_print>
    b1d4:	2000      	movs	r0, #0
}
    b1d6:	9a01      	ldr	r2, [sp, #4]
    b1d8:	682b      	ldr	r3, [r5, #0]
    b1da:	429a      	cmp	r2, r3
    b1dc:	d00a      	beq.n	b1f4 <HIDIO_buffer_pop_bytes+0x50>
    b1de:	f7f7 faa7 	bl	2730 <__stack_chk_fail>
	if ( len + buffer->head > buffer->len )
    b1e2:	8822      	ldrh	r2, [r4, #0]
    b1e4:	1851      	adds	r1, r2, r1
    b1e6:	b28b      	uxth	r3, r1
    b1e8:	4281      	cmp	r1, r0
		buffer->head = len + buffer->head - buffer->len;
    b1ea:	bfc8      	it	gt
    b1ec:	1a1b      	subgt	r3, r3, r0
		buffer->head += len;
    b1ee:	8023      	strh	r3, [r4, #0]
	return 1;
    b1f0:	2001      	movs	r0, #1
    b1f2:	e7f0      	b.n	b1d6 <HIDIO_buffer_pop_bytes+0x32>
}
    b1f4:	b002      	add	sp, #8
    b1f6:	bd70      	pop	{r4, r5, r6, pc}
    b1f8:	1fff89d0 	.word	0x1fff89d0
    b1fc:	00015788 	.word	0x00015788
    b200:	00014d02 	.word	0x00014d02
    b204:	00015df4 	.word	0x00015df4

0000b208 <HIDIO_buffer_free_bytes>:
{
    b208:	b507      	push	{r0, r1, r2, lr}
    b20a:	4a0a      	ldr	r2, [pc, #40]	; (b234 <HIDIO_buffer_free_bytes+0x2c>)
	if ( buffer->head <= buffer->tail )
    b20c:	8841      	ldrh	r1, [r0, #2]
{
    b20e:	6813      	ldr	r3, [r2, #0]
    b210:	9301      	str	r3, [sp, #4]
	if ( buffer->head <= buffer->tail )
    b212:	8803      	ldrh	r3, [r0, #0]
    b214:	428b      	cmp	r3, r1
		return buffer->len - (buffer->tail - buffer->head);
    b216:	bf9b      	ittet	ls
    b218:	8900      	ldrhls	r0, [r0, #8]
    b21a:	18c0      	addls	r0, r0, r3
		return buffer->head - buffer->tail;
    b21c:	1a58      	subhi	r0, r3, r1
		return buffer->len - (buffer->tail - buffer->head);
    b21e:	1a40      	subls	r0, r0, r1
}
    b220:	9901      	ldr	r1, [sp, #4]
    b222:	6813      	ldr	r3, [r2, #0]
    b224:	4299      	cmp	r1, r3
		return buffer->head - buffer->tail;
    b226:	b280      	uxth	r0, r0
}
    b228:	d001      	beq.n	b22e <HIDIO_buffer_free_bytes+0x26>
    b22a:	f7f7 fa81 	bl	2730 <__stack_chk_fail>
    b22e:	b003      	add	sp, #12
    b230:	f85d fb04 	ldr.w	pc, [sp], #4
    b234:	1fff89d0 	.word	0x1fff89d0

0000b238 <HIDIO_buffer_position>:
{
    b238:	b513      	push	{r0, r1, r4, lr}
    b23a:	4c0a      	ldr	r4, [pc, #40]	; (b264 <HIDIO_buffer_position+0x2c>)
    b23c:	6823      	ldr	r3, [r4, #0]
    b23e:	9301      	str	r3, [sp, #4]
	if ( cur_pos + distance >= buffer->len )
    b240:	8903      	ldrh	r3, [r0, #8]
    b242:	1888      	adds	r0, r1, r2
    b244:	4298      	cmp	r0, r3
		return buffer->len - (cur_pos + distance);
    b246:	bfa4      	itt	ge
    b248:	1a9b      	subge	r3, r3, r2
    b24a:	1a59      	subge	r1, r3, r1
}
    b24c:	9a01      	ldr	r2, [sp, #4]
    b24e:	6823      	ldr	r3, [r4, #0]
		return buffer->len - (cur_pos + distance);
    b250:	bfac      	ite	ge
    b252:	b288      	uxthge	r0, r1
		return cur_pos + distance;
    b254:	b280      	uxthlt	r0, r0
}
    b256:	429a      	cmp	r2, r3
    b258:	d001      	beq.n	b25e <HIDIO_buffer_position+0x26>
    b25a:	f7f7 fa69 	bl	2730 <__stack_chk_fail>
    b25e:	b002      	add	sp, #8
    b260:	bd10      	pop	{r4, pc}
    b262:	bf00      	nop
    b264:	1fff89d0 	.word	0x1fff89d0

0000b268 <HIDIO_buffer_id>:
{
    b268:	b507      	push	{r0, r1, r2, lr}
    b26a:	4b09      	ldr	r3, [pc, #36]	; (b290 <HIDIO_buffer_id+0x28>)
    b26c:	681a      	ldr	r2, [r3, #0]
    b26e:	9201      	str	r2, [sp, #4]
	if ( packet->id_width == 0 )
    b270:	7802      	ldrb	r2, [r0, #0]
    b272:	06d2      	lsls	r2, r2, #27
}
    b274:	9a01      	ldr	r2, [sp, #4]
    b276:	681b      	ldr	r3, [r3, #0]
		id = pkt->id;
    b278:	bf54      	ite	pl
    b27a:	8840      	ldrhpl	r0, [r0, #2]
		id = pkt->id;
    b27c:	f8d0 0002 	ldrmi.w	r0, [r0, #2]
}
    b280:	429a      	cmp	r2, r3
    b282:	d001      	beq.n	b288 <HIDIO_buffer_id+0x20>
    b284:	f7f7 fa54 	bl	2730 <__stack_chk_fail>
    b288:	b003      	add	sp, #12
    b28a:	f85d fb04 	ldr.w	pc, [sp], #4
    b28e:	bf00      	nop
    b290:	1fff89d0 	.word	0x1fff89d0

0000b294 <HIDIO_payload_start>:
{
    b294:	b507      	push	{r0, r1, r2, lr}
    b296:	4b08      	ldr	r3, [pc, #32]	; (b2b8 <HIDIO_payload_start+0x24>)
    b298:	681a      	ldr	r2, [r3, #0]
    b29a:	9201      	str	r2, [sp, #4]
	if ( packet->id_width == 0 )
    b29c:	7802      	ldrb	r2, [r0, #0]
    b29e:	06d2      	lsls	r2, r2, #27
}
    b2a0:	9a01      	ldr	r2, [sp, #4]
    b2a2:	681b      	ldr	r3, [r3, #0]
		data = pkt->data;
    b2a4:	bf54      	ite	pl
    b2a6:	3004      	addpl	r0, #4
		data = pkt->data;
    b2a8:	3006      	addmi	r0, #6
}
    b2aa:	429a      	cmp	r2, r3
    b2ac:	d001      	beq.n	b2b2 <HIDIO_payload_start+0x1e>
    b2ae:	f7f7 fa3f 	bl	2730 <__stack_chk_fail>
    b2b2:	b003      	add	sp, #12
    b2b4:	f85d fb04 	ldr.w	pc, [sp], #4
    b2b8:	1fff89d0 	.word	0x1fff89d0

0000b2bc <HIDIO_buffer_generate_packet>:
{
    b2bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b2c0:	b08d      	sub	sp, #52	; 0x34
    b2c2:	460c      	mov	r4, r1
    b2c4:	9301      	str	r3, [sp, #4]
    b2c6:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
    b2ca:	9302      	str	r3, [sp, #8]
    b2cc:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
    b2d0:	9303      	str	r3, [sp, #12]
    b2d2:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
    b2d6:	4b6f      	ldr	r3, [pc, #444]	; (b494 <HIDIO_buffer_generate_packet+0x1d8>)
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    b2d8:	496f      	ldr	r1, [pc, #444]	; (b498 <HIDIO_buffer_generate_packet+0x1dc>)
{
    b2da:	681b      	ldr	r3, [r3, #0]
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    b2dc:	f8b1 a000 	ldrh.w	sl, [r1]
{
    b2e0:	930b      	str	r3, [sp, #44]	; 0x2c
		width = 2;
    b2e2:	f5bb 3f80 	cmp.w	fp, #65536	; 0x10000
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    b2e6:	bf2c      	ite	cs
    b2e8:	2304      	movcs	r3, #4
    b2ea:	2302      	movcc	r3, #2
    b2ec:	ebaa 0a03 	sub.w	sl, sl, r3
    b2f0:	fa1f fa8a 	uxth.w	sl, sl
    b2f4:	f1aa 0902 	sub.w	r9, sl, #2
{
    b2f8:	4607      	mov	r7, r0
	return HIDIO_Packet_Size - sizeof(HIDIO_Packet) - id_width;
    b2fa:	fa1f f989 	uxth.w	r9, r9
	if ( payload_len != 0 )
    b2fe:	4690      	mov	r8, r2
    b300:	2a00      	cmp	r2, #0
    b302:	d031      	beq.n	b368 <HIDIO_buffer_generate_packet+0xac>
		packet_count = payload_len / max_payload;
    b304:	fbb2 f2f9 	udiv	r2, r2, r9
		cur_packet = pos / max_payload;
    b308:	fbb4 f6f9 	udiv	r6, r4, r9
		packet_count += payload_len % max_payload != 0 ? 1 : 0;
    b30c:	fb09 8112 	mls	r1, r9, r2, r8
    b310:	b289      	uxth	r1, r1
    b312:	2900      	cmp	r1, #0
    b314:	bf18      	it	ne
    b316:	3201      	addne	r2, #1
    b318:	b292      	uxth	r2, r2
    b31a:	9200      	str	r2, [sp, #0]
		cur_packet += pos % max_payload != 0 ? 1 : 0;
    b31c:	fb09 4216 	mls	r2, r9, r6, r4
    b320:	b292      	uxth	r2, r2
    b322:	2a00      	cmp	r2, #0
    b324:	bf18      	it	ne
    b326:	3601      	addne	r6, #1
    b328:	b2b6      	uxth	r6, r6
    b32a:	9304      	str	r3, [sp, #16]
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    b32c:	9b00      	ldr	r3, [sp, #0]
    b32e:	eba8 0204 	sub.w	r2, r8, r4
    b332:	1b9d      	subs	r5, r3, r6
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    b334:	4638      	mov	r0, r7
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    b336:	eb02 0545 	add.w	r5, r2, r5, lsl #1
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    b33a:	f7ff ff65 	bl	b208 <HIDIO_buffer_free_bytes>
	uint16_t requested = payload_len - pos + sizeof(HIDIO_Packet) * ( packet_count - cur_packet );
    b33e:	b2ad      	uxth	r5, r5
	if ( requested > HIDIO_buffer_free_bytes( buf ) )
    b340:	42a8      	cmp	r0, r5
    b342:	d315      	bcc.n	b370 <HIDIO_buffer_generate_packet+0xb4>
			uint16_t packet_len = bytes_left + width;
    b344:	9b04      	ldr	r3, [sp, #16]
    b346:	eb09 0203 	add.w	r2, r9, r3
    b34a:	b292      	uxth	r2, r2
			uint16_t cur_payload_len = payload_len - pos + width;
    b34c:	4443      	add	r3, r8
			uint16_t packet_len = bytes_left + width;
    b34e:	9204      	str	r2, [sp, #16]
			uint16_t cur_payload_len = payload_len - pos + width;
    b350:	9305      	str	r3, [sp, #20]
	for ( ; pos < payload_len || payload_len == 0; pos++ )
    b352:	4544      	cmp	r4, r8
    b354:	d32f      	bcc.n	b3b6 <HIDIO_buffer_generate_packet+0xfa>
    b356:	f1b8 0f00 	cmp.w	r8, #0
    b35a:	d02c      	beq.n	b3b6 <HIDIO_buffer_generate_packet+0xfa>
	if ( pos == payload_len )
    b35c:	4544      	cmp	r4, r8
		buf->packets_ready++;
    b35e:	bf02      	ittt	eq
    b360:	897b      	ldrheq	r3, [r7, #10]
    b362:	3301      	addeq	r3, #1
    b364:	817b      	strheq	r3, [r7, #10]
    b366:	e01e      	b.n	b3a6 <HIDIO_buffer_generate_packet+0xea>
	uint16_t cur_packet = 0;
    b368:	4616      	mov	r6, r2
	uint16_t packet_count = 1;
    b36a:	2201      	movs	r2, #1
    b36c:	9200      	str	r2, [sp, #0]
    b36e:	e7dc      	b.n	b32a <HIDIO_buffer_generate_packet+0x6e>
		erro_msg("Not enough bytes in HIDIO buffer: ");
    b370:	484a      	ldr	r0, [pc, #296]	; (b49c <HIDIO_buffer_generate_packet+0x1e0>)
    b372:	f004 f8fd 	bl	f570 <_print>
		printInt16( HIDIO_buffer_free_bytes( buf ) );
    b376:	4638      	mov	r0, r7
    b378:	f7ff ff46 	bl	b208 <HIDIO_buffer_free_bytes>
    b37c:	f004 f998 	bl	f6b0 <printInt16>
		print(" bytes left, ");
    b380:	4847      	ldr	r0, [pc, #284]	; (b4a0 <HIDIO_buffer_generate_packet+0x1e4>)
    b382:	f004 f8f5 	bl	f570 <_print>
		printInt16( buf->len );
    b386:	8938      	ldrh	r0, [r7, #8]
    b388:	f004 f992 	bl	f6b0 <printInt16>
		print(" bytes total ");
    b38c:	4845      	ldr	r0, [pc, #276]	; (b4a4 <HIDIO_buffer_generate_packet+0x1e8>)
    b38e:	f004 f8ef 	bl	f570 <_print>
		printInt16( requested );
    b392:	4628      	mov	r0, r5
    b394:	f004 f98c 	bl	f6b0 <printInt16>
		print(" bytes requested");
    b398:	4843      	ldr	r0, [pc, #268]	; (b4a8 <HIDIO_buffer_generate_packet+0x1ec>)
    b39a:	f004 f8e9 	bl	f570 <_print>
		print(NL);
    b39e:	4843      	ldr	r0, [pc, #268]	; (b4ac <HIDIO_buffer_generate_packet+0x1f0>)
    b3a0:	f004 f8e6 	bl	f570 <_print>
		return payload_len;
    b3a4:	4644      	mov	r4, r8
}
    b3a6:	4b3b      	ldr	r3, [pc, #236]	; (b494 <HIDIO_buffer_generate_packet+0x1d8>)
    b3a8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    b3aa:	681b      	ldr	r3, [r3, #0]
    b3ac:	429a      	cmp	r2, r3
    b3ae:	4620      	mov	r0, r4
    b3b0:	d06c      	beq.n	b48c <HIDIO_buffer_generate_packet+0x1d0>
    b3b2:	f7f7 f9bd 	bl	2730 <__stack_chk_fail>
		uint16_t bytes_left = pos % max_payload;
    b3b6:	fbb4 f5f9 	udiv	r5, r4, r9
    b3ba:	fb09 4515 	mls	r5, r9, r5, r4
    b3be:	b2ad      	uxth	r5, r5
		if ( bytes_left == 0 )
    b3c0:	2d00      	cmp	r5, #0
    b3c2:	d135      	bne.n	b430 <HIDIO_buffer_generate_packet+0x174>
			if ( pos != 0 )
    b3c4:	b114      	cbz	r4, b3cc <HIDIO_buffer_generate_packet+0x110>
				buf->packets_ready++;
    b3c6:	897b      	ldrh	r3, [r7, #10]
    b3c8:	3301      	adds	r3, #1
    b3ca:	817b      	strh	r3, [r7, #10]
			uint16_t cur_payload_len = payload_len - pos + width;
    b3cc:	9b05      	ldr	r3, [sp, #20]
			uint8_t p_cont = cur_packet == packet_count ? 0 : 1;
    b3ce:	9900      	ldr	r1, [sp, #0]
			uint16_t cur_payload_len = payload_len - pos + width;
    b3d0:	1b1a      	subs	r2, r3, r4
    b3d2:	9b04      	ldr	r3, [sp, #16]
    b3d4:	b292      	uxth	r2, r2
			cur_packet++;
    b3d6:	3601      	adds	r6, #1
    b3d8:	429a      	cmp	r2, r3
    b3da:	b2b6      	uxth	r6, r6
    b3dc:	bf28      	it	cs
    b3de:	461a      	movcs	r2, r3
			uint8_t p_type = cur_packet == 1 ? type : HIDIO_Packet_Type__Continued;
    b3e0:	2e01      	cmp	r6, #1
    b3e2:	9b03      	ldr	r3, [sp, #12]
    b3e4:	bf18      	it	ne
    b3e6:	2304      	movne	r3, #4
			uint8_t p_cont = cur_packet == packet_count ? 0 : 1;
    b3e8:	1b88      	subs	r0, r1, r6
    b3ea:	bf18      	it	ne
    b3ec:	2001      	movne	r0, #1
    b3ee:	f003 0307 	and.w	r3, r3, #7
			if ( id <= 0xFFFF )
    b3f2:	f5bb 3f80 	cmp.w	fp, #65536	; 0x10000
    b3f6:	f3c2 2101 	ubfx	r1, r2, #8, #2
				HIDIO_Packet16 packet = {
    b3fa:	ea43 03c0 	orr.w	r3, r3, r0, lsl #3
    b3fe:	b2d2      	uxtb	r2, r2
    b400:	f04f 0500 	mov.w	r5, #0
			if ( id <= 0xFFFF )
    b404:	d22b      	bcs.n	b45e <HIDIO_buffer_generate_packet+0x1a2>
				HIDIO_Packet16 packet = {
    b406:	f361 1387 	bfi	r3, r1, #6, #2
    b40a:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    b40e:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
					.id = (uint16_t)id,
    b412:	f8ad b026 	strh.w	fp, [sp, #38]	; 0x26
					HIDIO_buffer_push_byte( buf, ((uint8_t*)&packet)[ byte ] );
    b416:	ab09      	add	r3, sp, #36	; 0x24
    b418:	5d59      	ldrb	r1, [r3, r5]
    b41a:	9306      	str	r3, [sp, #24]
    b41c:	4638      	mov	r0, r7
    b41e:	3501      	adds	r5, #1
    b420:	f7ff fe84 	bl	b12c <HIDIO_buffer_push_byte>
				for ( uint8_t byte = 0; byte < sizeof(HIDIO_Packet16); byte++ )
    b424:	2d04      	cmp	r5, #4
    b426:	9b06      	ldr	r3, [sp, #24]
    b428:	d1f6      	bne.n	b418 <HIDIO_buffer_generate_packet+0x15c>
				bytes_left -= sizeof(HIDIO_Packet16);
    b42a:	f1aa 0506 	sub.w	r5, sl, #6
				bytes_left -= sizeof(HIDIO_Packet32);
    b42e:	b2ad      	uxth	r5, r5
    b430:	9b02      	ldr	r3, [sp, #8]
    b432:	18e2      	adds	r2, r4, r3
		for ( ; byte < data_len && bytes_left > 0; byte++, pos++, bytes_left-- )
    b434:	9b01      	ldr	r3, [sp, #4]
    b436:	441d      	add	r5, r3
    b438:	b292      	uxth	r2, r2
    b43a:	b2ad      	uxth	r5, r5
    b43c:	42a2      	cmp	r2, r4
    b43e:	d08d      	beq.n	b35c <HIDIO_buffer_generate_packet+0xa0>
    b440:	b299      	uxth	r1, r3
    b442:	3401      	adds	r4, #1
    b444:	428d      	cmp	r5, r1
    b446:	b2a4      	uxth	r4, r4
    b448:	d083      	beq.n	b352 <HIDIO_buffer_generate_packet+0x96>
			HIDIO_buffer_push_byte( buf, data[ byte ] );
    b44a:	f813 1b01 	ldrb.w	r1, [r3], #1
    b44e:	9207      	str	r2, [sp, #28]
    b450:	4638      	mov	r0, r7
    b452:	9306      	str	r3, [sp, #24]
    b454:	f7ff fe6a 	bl	b12c <HIDIO_buffer_push_byte>
    b458:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
    b45c:	e7ee      	b.n	b43c <HIDIO_buffer_generate_packet+0x180>
				HIDIO_Packet32 packet = {
    b45e:	f043 0310 	orr.w	r3, r3, #16
    b462:	f361 1387 	bfi	r3, r1, #6, #2
    b466:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    b46a:	f88d 2025 	strb.w	r2, [sp, #37]	; 0x25
    b46e:	f8cd b026 	str.w	fp, [sp, #38]	; 0x26
					HIDIO_buffer_push_byte( buf, ((uint8_t*)&packet)[ byte ] );
    b472:	ab09      	add	r3, sp, #36	; 0x24
    b474:	5d59      	ldrb	r1, [r3, r5]
    b476:	9306      	str	r3, [sp, #24]
    b478:	4638      	mov	r0, r7
    b47a:	3501      	adds	r5, #1
    b47c:	f7ff fe56 	bl	b12c <HIDIO_buffer_push_byte>
				for ( uint8_t byte = 0; byte < sizeof(HIDIO_Packet32); byte++ )
    b480:	2d06      	cmp	r5, #6
    b482:	9b06      	ldr	r3, [sp, #24]
    b484:	d1f6      	bne.n	b474 <HIDIO_buffer_generate_packet+0x1b8>
				bytes_left -= sizeof(HIDIO_Packet32);
    b486:	f1aa 0508 	sub.w	r5, sl, #8
    b48a:	e7d0      	b.n	b42e <HIDIO_buffer_generate_packet+0x172>
}
    b48c:	b00d      	add	sp, #52	; 0x34
    b48e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b492:	bf00      	nop
    b494:	1fff89d0 	.word	0x1fff89d0
    b498:	1fffaf34 	.word	0x1fffaf34
    b49c:	00015723 	.word	0x00015723
    b4a0:	0001575b 	.word	0x0001575b
    b4a4:	00015769 	.word	0x00015769
    b4a8:	00015777 	.word	0x00015777
    b4ac:	00015df4 	.word	0x00015df4

0000b4b0 <HIDIO_test_2_call>:
{
    b4b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b4b4:	4b2c      	ldr	r3, [pc, #176]	; (b568 <HIDIO_test_2_call+0xb8>)
    b4b6:	b08b      	sub	sp, #44	; 0x2c
    b4b8:	681a      	ldr	r2, [r3, #0]
    b4ba:	9209      	str	r2, [sp, #36]	; 0x24
    b4bc:	4605      	mov	r5, r0
	if ( irq )
    b4be:	460c      	mov	r4, r1
    b4c0:	4698      	mov	r8, r3
    b4c2:	2900      	cmp	r1, #0
    b4c4:	d14b      	bne.n	b55e <HIDIO_test_2_call+0xae>
	uint8_t *buf = HIDIO_buffer_munch( &HIDIO_assembly_buf, (uint8_t*)&tmpbuf, buf_pos, sizeof(HIDIO_Buffer_Entry) );
    b4c6:	4e29      	ldr	r6, [pc, #164]	; (b56c <HIDIO_test_2_call+0xbc>)
    b4c8:	2308      	movs	r3, #8
    b4ca:	4602      	mov	r2, r0
    b4cc:	a907      	add	r1, sp, #28
    b4ce:	4630      	mov	r0, r6
    b4d0:	f7ff fe00 	bl	b0d4 <HIDIO_buffer_munch>
	if ( !entry->done )
    b4d4:	7983      	ldrb	r3, [r0, #6]
	uint8_t *buf = HIDIO_buffer_munch( &HIDIO_assembly_buf, (uint8_t*)&tmpbuf, buf_pos, sizeof(HIDIO_Buffer_Entry) );
    b4d6:	4681      	mov	r9, r0
	if ( !entry->done )
    b4d8:	2b00      	cmp	r3, #0
    b4da:	d040      	beq.n	b55e <HIDIO_test_2_call+0xae>
	uint8_t last_byte = 0;
    b4dc:	f88d 401b 	strb.w	r4, [sp, #27]
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    b4e0:	3508      	adds	r5, #8
	for ( uint16_t pos = 0; pos < entry->size; pos++ )
    b4e2:	f8b0 b004 	ldrh.w	fp, [r0, #4]
	if ( buf_pos + len < buffer->len )
    b4e6:	8933      	ldrh	r3, [r6, #8]
		return &(buffer->data[0]);
    b4e8:	f8d6 a00c 	ldr.w	sl, [r6, #12]
	uint16_t transitions = 0;
    b4ec:	4627      	mov	r7, r4
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    b4ee:	b2ad      	uxth	r5, r5
    b4f0:	b2a2      	uxth	r2, r4
	for ( uint16_t pos = 0; pos < entry->size; pos++ )
    b4f2:	455a      	cmp	r2, fp
    b4f4:	d310      	bcc.n	b518 <HIDIO_test_2_call+0x68>
	if ( transitions > 1 )
    b4f6:	2f01      	cmp	r7, #1
    b4f8:	d82f      	bhi.n	b55a <HIDIO_test_2_call+0xaa>
		pos = HIDIO_buffer_generate_packet(
    b4fa:	4d1d      	ldr	r5, [pc, #116]	; (b570 <HIDIO_test_2_call+0xc0>)
	uint16_t pos = 0;
    b4fc:	2100      	movs	r1, #0
		pos = HIDIO_buffer_generate_packet(
    b4fe:	2402      	movs	r4, #2
	while ( pos < entry->size )
    b500:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    b504:	4291      	cmp	r1, r2
    b506:	d31d      	bcc.n	b544 <HIDIO_test_2_call+0x94>
	return HIDIO_Return__Ok;
    b508:	2000      	movs	r0, #0
}
    b50a:	9a09      	ldr	r2, [sp, #36]	; 0x24
    b50c:	f8d8 3000 	ldr.w	r3, [r8]
    b510:	429a      	cmp	r2, r3
    b512:	d026      	beq.n	b562 <HIDIO_test_2_call+0xb2>
    b514:	f7f7 f90c 	bl	2730 <__stack_chk_fail>
		uint16_t calc_buf_pos = HIDIO_buffer_position( &HIDIO_assembly_buf, buf_pos + sizeof(HIDIO_Buffer_Entry), pos );
    b518:	4629      	mov	r1, r5
    b51a:	4630      	mov	r0, r6
    b51c:	9305      	str	r3, [sp, #20]
    b51e:	f7ff fe8b 	bl	b238 <HIDIO_buffer_position>
	if ( buf_pos + len < buffer->len )
    b522:	9b05      	ldr	r3, [sp, #20]
		if ( *byte != last_byte )
    b524:	f89d 101b 	ldrb.w	r1, [sp, #27]
	if ( buf_pos + len < buffer->len )
    b528:	1c42      	adds	r2, r0, #1
    b52a:	429a      	cmp	r2, r3
		return &(buffer->data[ buf_pos ]);
    b52c:	bfb4      	ite	lt
    b52e:	4450      	addlt	r0, sl
		return &(buffer->data[0]);
    b530:	4650      	movge	r0, sl
    b532:	3401      	adds	r4, #1
		if ( *byte != last_byte )
    b534:	7802      	ldrb	r2, [r0, #0]
    b536:	4291      	cmp	r1, r2
			transitions++;
    b538:	bf1e      	ittt	ne
    b53a:	3701      	addne	r7, #1
    b53c:	b2bf      	uxthne	r7, r7
			last_byte = *byte;
    b53e:	f88d 201b 	strbne.w	r2, [sp, #27]
    b542:	e7d5      	b.n	b4f0 <HIDIO_test_2_call+0x40>
		pos = HIDIO_buffer_generate_packet(
    b544:	2301      	movs	r3, #1
    b546:	e9cd 3300 	strd	r3, r3, [sp]
    b54a:	9402      	str	r4, [sp, #8]
    b54c:	f10d 031b 	add.w	r3, sp, #27
    b550:	4628      	mov	r0, r5
    b552:	f7ff feb3 	bl	b2bc <HIDIO_buffer_generate_packet>
    b556:	4601      	mov	r1, r0
    b558:	e7d2      	b.n	b500 <HIDIO_test_2_call+0x50>
		return HIDIO_Return__InBuffer_Fail;
    b55a:	2001      	movs	r0, #1
    b55c:	e7d5      	b.n	b50a <HIDIO_test_2_call+0x5a>
		return HIDIO_Return__Delay;
    b55e:	2003      	movs	r0, #3
    b560:	e7d3      	b.n	b50a <HIDIO_test_2_call+0x5a>
}
    b562:	b00b      	add	sp, #44	; 0x2c
    b564:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b568:	1fff89d0 	.word	0x1fff89d0
    b56c:	1fffb1dc 	.word	0x1fffb1dc
    b570:	1fffb0dc 	.word	0x1fffb0dc

0000b574 <HIDIO_nopayload_ack>:
{
    b574:	b510      	push	{r4, lr}
    b576:	4c0b      	ldr	r4, [pc, #44]	; (b5a4 <HIDIO_nopayload_ack+0x30>)
    b578:	b086      	sub	sp, #24
    b57a:	6823      	ldr	r3, [r4, #0]
    b57c:	9305      	str	r3, [sp, #20]
	HIDIO_buffer_generate_packet(
    b57e:	2201      	movs	r2, #1
    b580:	2300      	movs	r3, #0
    b582:	e9cd 3200 	strd	r3, r2, [sp]
    b586:	9002      	str	r0, [sp, #8]
    b588:	461a      	mov	r2, r3
    b58a:	4619      	mov	r1, r3
    b58c:	4806      	ldr	r0, [pc, #24]	; (b5a8 <HIDIO_nopayload_ack+0x34>)
    b58e:	f7ff fe95 	bl	b2bc <HIDIO_buffer_generate_packet>
}
    b592:	9a05      	ldr	r2, [sp, #20]
    b594:	6823      	ldr	r3, [r4, #0]
    b596:	429a      	cmp	r2, r3
    b598:	d001      	beq.n	b59e <HIDIO_nopayload_ack+0x2a>
    b59a:	f7f7 f8c9 	bl	2730 <__stack_chk_fail>
    b59e:	b006      	add	sp, #24
    b5a0:	bd10      	pop	{r4, pc}
    b5a2:	bf00      	nop
    b5a4:	1fff89d0 	.word	0x1fff89d0
    b5a8:	1fffb0dc 	.word	0x1fffb0dc

0000b5ac <HIDIO_register_id>:
// ----- Functions -----

// Register HID-IO callbacks
// If an Id is not registered, it is ignored and automatically NAK'd
void HIDIO_register_id( uint32_t id, void* incoming_call_func, void* incoming_reply_func )
{
    b5ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
    b5ae:	4c14      	ldr	r4, [pc, #80]	; (b600 <HIDIO_register_id+0x54>)
    b5b0:	6823      	ldr	r3, [r4, #0]
    b5b2:	9301      	str	r3, [sp, #4]
	// Check if there is any room left in the list
	if ( HIDIO_Id_List_Size >= HIDIO_Id_List_MaxSize )
    b5b4:	4b13      	ldr	r3, [pc, #76]	; (b604 <HIDIO_register_id+0x58>)
{
    b5b6:	4606      	mov	r6, r0
	if ( HIDIO_Id_List_Size >= HIDIO_Id_List_MaxSize )
    b5b8:	6818      	ldr	r0, [r3, #0]
    b5ba:	2813      	cmp	r0, #19
    b5bc:	d911      	bls.n	b5e2 <HIDIO_register_id+0x36>
	{
		erro_msg("HIDIO_Id_List is full, cannot register Id: ");
    b5be:	4812      	ldr	r0, [pc, #72]	; (b608 <HIDIO_register_id+0x5c>)
    b5c0:	f003 ffd6 	bl	f570 <_print>
		printInt32( id );
    b5c4:	4630      	mov	r0, r6
    b5c6:	f004 f8a9 	bl	f71c <printInt32>
		print( NL );
    b5ca:	9a01      	ldr	r2, [sp, #4]
    b5cc:	6823      	ldr	r3, [r4, #0]
    b5ce:	429a      	cmp	r2, r3
    b5d0:	d001      	beq.n	b5d6 <HIDIO_register_id+0x2a>
	// Add id to unsorted list (no reason to sort, as Ids may not be contiguous)
	HIDIO_Id_Entry *entry = &HIDIO_Id_List[ HIDIO_Id_List_Size++ ];
	entry->id = id;
	entry->call_func = incoming_call_func;
	entry->reply_func = incoming_reply_func;
}
    b5d2:	f7f7 f8ad 	bl	2730 <__stack_chk_fail>
		print( NL );
    b5d6:	480d      	ldr	r0, [pc, #52]	; (b60c <HIDIO_register_id+0x60>)
}
    b5d8:	b002      	add	sp, #8
    b5da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print( NL );
    b5de:	f003 bfc7 	b.w	f570 <_print>
	HIDIO_Id_Entry *entry = &HIDIO_Id_List[ HIDIO_Id_List_Size++ ];
    b5e2:	1c45      	adds	r5, r0, #1
    b5e4:	601d      	str	r5, [r3, #0]
	entry->id = id;
    b5e6:	4d0a      	ldr	r5, [pc, #40]	; (b610 <HIDIO_register_id+0x64>)
    b5e8:	230c      	movs	r3, #12
    b5ea:	4343      	muls	r3, r0
    b5ec:	18e8      	adds	r0, r5, r3
    b5ee:	50ee      	str	r6, [r5, r3]
	entry->reply_func = incoming_reply_func;
    b5f0:	e9c0 1201 	strd	r1, r2, [r0, #4]
}
    b5f4:	9a01      	ldr	r2, [sp, #4]
    b5f6:	6823      	ldr	r3, [r4, #0]
    b5f8:	429a      	cmp	r2, r3
    b5fa:	d1ea      	bne.n	b5d2 <HIDIO_register_id+0x26>
    b5fc:	b002      	add	sp, #8
    b5fe:	bd70      	pop	{r4, r5, r6, pc}
    b600:	1fff89d0 	.word	0x1fff89d0
    b604:	1fffaf30 	.word	0x1fffaf30
    b608:	000158a3 	.word	0x000158a3
    b60c:	00015df4 	.word	0x00015df4
    b610:	1fffb0ec 	.word	0x1fffb0ec

0000b614 <HIDIO_call_id>:
// Initiate registered call function
// id - Function id
// buf_pos - Index in ring buffer
// irq - Set to 1 if called from an IRQ
HIDIO_Return HIDIO_call_id( uint32_t id, uint16_t buf_pos, uint8_t irq )
{
    b614:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b618:	4e24      	ldr	r6, [pc, #144]	; (b6ac <HIDIO_call_id+0x98>)
	HIDIO_Return retval = HIDIO_Return__Unknown;

	// Find id
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    b61a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; b6bc <HIDIO_call_id+0xa8>
{
    b61e:	6833      	ldr	r3, [r6, #0]
	{
		// Match id
		if ( HIDIO_Id_List[ pos ].id == id )
    b620:	4f23      	ldr	r7, [pc, #140]	; (b6b0 <HIDIO_call_id+0x9c>)
{
    b622:	b087      	sub	sp, #28
    b624:	4693      	mov	fp, r2
    b626:	4681      	mov	r9, r0
    b628:	468a      	mov	sl, r1
    b62a:	9305      	str	r3, [sp, #20]
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    b62c:	2400      	movs	r4, #0
	HIDIO_Return retval = HIDIO_Return__Unknown;
    b62e:	2504      	movs	r5, #4
		if ( HIDIO_Id_List[ pos ].id == id )
    b630:	220c      	movs	r2, #12
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    b632:	f8d8 1000 	ldr.w	r1, [r8]
    b636:	b2a3      	uxth	r3, r4
    b638:	4299      	cmp	r1, r3
    b63a:	d809      	bhi.n	b650 <HIDIO_call_id+0x3c>
	// Enough space to store header
	uint8_t tmpdata[sizeof(HIDIO_Buffer_Entry)];
	uint16_t datasize;
	HIDIO_Buffer_Entry *entry;

	switch ( retval )
    b63c:	b1b5      	cbz	r5, b66c <HIDIO_call_id+0x58>
    b63e:	2d01      	cmp	r5, #1
    b640:	d02c      	beq.n	b69c <HIDIO_call_id+0x88>
	default:
		break;
	}

	return retval;
}
    b642:	9a05      	ldr	r2, [sp, #20]
    b644:	6833      	ldr	r3, [r6, #0]
    b646:	429a      	cmp	r2, r3
    b648:	4628      	mov	r0, r5
    b64a:	d02b      	beq.n	b6a4 <HIDIO_call_id+0x90>
    b64c:	f7f7 f870 	bl	2730 <__stack_chk_fail>
		if ( HIDIO_Id_List[ pos ].id == id )
    b650:	4353      	muls	r3, r2
    b652:	18f9      	adds	r1, r7, r3
    b654:	58fb      	ldr	r3, [r7, r3]
    b656:	454b      	cmp	r3, r9
    b658:	d106      	bne.n	b668 <HIDIO_call_id+0x54>
			retval = func( buf_pos, irq );
    b65a:	684b      	ldr	r3, [r1, #4]
    b65c:	9201      	str	r2, [sp, #4]
    b65e:	4659      	mov	r1, fp
    b660:	4650      	mov	r0, sl
    b662:	4798      	blx	r3
    b664:	9a01      	ldr	r2, [sp, #4]
    b666:	4605      	mov	r5, r0
    b668:	3401      	adds	r4, #1
    b66a:	e7e2      	b.n	b632 <HIDIO_call_id+0x1e>
		entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch( &HIDIO_assembly_buf, tmpdata, HIDIO_assembly_buf.head, sizeof(tmpdata) );
    b66c:	4c11      	ldr	r4, [pc, #68]	; (b6b4 <HIDIO_call_id+0xa0>)
    b66e:	2308      	movs	r3, #8
    b670:	8822      	ldrh	r2, [r4, #0]
    b672:	a903      	add	r1, sp, #12
    b674:	4620      	mov	r0, r4
    b676:	f7ff fd2d 	bl	b0d4 <HIDIO_buffer_munch>
		datasize = sizeof(HIDIO_Buffer_Entry) + entry->size;
    b67a:	8881      	ldrh	r1, [r0, #4]
    b67c:	3108      	adds	r1, #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_assembly_buf, datasize ) )
    b67e:	b289      	uxth	r1, r1
    b680:	4620      	mov	r0, r4
    b682:	f7ff fd8f 	bl	b1a4 <HIDIO_buffer_pop_bytes>
    b686:	4623      	mov	r3, r4
    b688:	b128      	cbz	r0, b696 <HIDIO_call_id+0x82>
			HIDIO_assembly_buf.packets_ready--;
    b68a:	8962      	ldrh	r2, [r4, #10]
    b68c:	3a01      	subs	r2, #1
    b68e:	8162      	strh	r2, [r4, #10]
		HIDIO_assembly_buf.waiting = 0;
    b690:	2200      	movs	r2, #0
    b692:	719a      	strb	r2, [r3, #6]
    b694:	e7d5      	b.n	b642 <HIDIO_call_id+0x2e>
			HIDIO_assembly_buf.packets_ready = 0;
    b696:	8165      	strh	r5, [r4, #10]
			HIDIO_assembly_buf.head = 0;
    b698:	6025      	str	r5, [r4, #0]
    b69a:	e7f9      	b.n	b690 <HIDIO_call_id+0x7c>
		print("FAIL"NL);
    b69c:	4806      	ldr	r0, [pc, #24]	; (b6b8 <HIDIO_call_id+0xa4>)
    b69e:	f003 ff67 	bl	f570 <_print>
		break;
    b6a2:	e7ce      	b.n	b642 <HIDIO_call_id+0x2e>
}
    b6a4:	b007      	add	sp, #28
    b6a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b6aa:	bf00      	nop
    b6ac:	1fff89d0 	.word	0x1fff89d0
    b6b0:	1fffb0ec 	.word	0x1fffb0ec
    b6b4:	1fffb1dc 	.word	0x1fffb1dc
    b6b8:	000157d4 	.word	0x000157d4
    b6bc:	1fffaf30 	.word	0x1fffaf30

0000b6c0 <HIDIO_reply_id>:
// Initiate registered reply function
// id - Function id
// buf - Pointer to the ack buffer
// irq - Set to 1 if called from an IRQ
HIDIO_Return HIDIO_reply_id( uint32_t id, uint8_t *buf, uint8_t irq )
{
    b6c0:	b5f0      	push	{r4, r5, r6, r7, lr}
    b6c2:	4e24      	ldr	r6, [pc, #144]	; (b754 <HIDIO_reply_id+0x94>)

	// Find id
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
	{
		// Match id
		if ( HIDIO_Id_List[ pos ].id == id )
    b6c4:	4d24      	ldr	r5, [pc, #144]	; (b758 <HIDIO_reply_id+0x98>)
{
    b6c6:	6833      	ldr	r3, [r6, #0]
    b6c8:	b085      	sub	sp, #20
    b6ca:	468c      	mov	ip, r1
    b6cc:	9303      	str	r3, [sp, #12]
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    b6ce:	4b23      	ldr	r3, [pc, #140]	; (b75c <HIDIO_reply_id+0x9c>)
    b6d0:	681f      	ldr	r7, [r3, #0]
    b6d2:	2400      	movs	r4, #0
		if ( HIDIO_Id_List[ pos ].id == id )
    b6d4:	210c      	movs	r1, #12
	for ( uint16_t pos = 0; pos < HIDIO_Id_List_Size; pos++ )
    b6d6:	b2a3      	uxth	r3, r4
    b6d8:	429f      	cmp	r7, r3
    b6da:	d801      	bhi.n	b6e0 <HIDIO_reply_id+0x20>
	HIDIO_Return retval = HIDIO_Return__Unknown;
    b6dc:	2504      	movs	r5, #4
    b6de:	e010      	b.n	b702 <HIDIO_reply_id+0x42>
		if ( HIDIO_Id_List[ pos ].id == id )
    b6e0:	434b      	muls	r3, r1
    b6e2:	eb05 0e03 	add.w	lr, r5, r3
    b6e6:	58eb      	ldr	r3, [r5, r3]
    b6e8:	4283      	cmp	r3, r0
    b6ea:	f104 0401 	add.w	r4, r4, #1
    b6ee:	d1f2      	bne.n	b6d6 <HIDIO_reply_id+0x16>
			// Map function pointer
			HIDIO_Return (*func)(HIDIO_Buffer_Entry*, uint8_t) = \
				(HIDIO_Return(*)(HIDIO_Buffer_Entry*, uint8_t))(HIDIO_Id_List[ pos ].reply_func);

			// Call function
			retval = func( (HIDIO_Buffer_Entry*)buf, irq );
    b6f0:	f8de 3008 	ldr.w	r3, [lr, #8]
    b6f4:	4611      	mov	r1, r2
    b6f6:	4660      	mov	r0, ip
    b6f8:	4798      	blx	r3
	// Enough space to store header
	uint8_t tmpdata[6];
	uint16_t datasize;
	HIDIO_Packet *packet;

	switch ( retval )
    b6fa:	4605      	mov	r5, r0
    b6fc:	b140      	cbz	r0, b710 <HIDIO_reply_id+0x50>
    b6fe:	2801      	cmp	r0, #1
    b700:	d021      	beq.n	b746 <HIDIO_reply_id+0x86>
	default:
		break;
	}

	return retval;
}
    b702:	9a03      	ldr	r2, [sp, #12]
    b704:	6833      	ldr	r3, [r6, #0]
    b706:	429a      	cmp	r2, r3
    b708:	4628      	mov	r0, r5
    b70a:	d020      	beq.n	b74e <HIDIO_reply_id+0x8e>
    b70c:	f7f7 f810 	bl	2730 <__stack_chk_fail>
		packet = (HIDIO_Packet*)HIDIO_buffer_munch( &HIDIO_tx_buf, tmpdata, HIDIO_tx_buf.head, sizeof(tmpdata) );
    b710:	4c13      	ldr	r4, [pc, #76]	; (b760 <HIDIO_reply_id+0xa0>)
    b712:	2306      	movs	r3, #6
    b714:	8822      	ldrh	r2, [r4, #0]
    b716:	a901      	add	r1, sp, #4
    b718:	4620      	mov	r0, r4
    b71a:	f7ff fcdb 	bl	b0d4 <HIDIO_buffer_munch>
		datasize = (packet->upper_len << 8) | packet->len;
    b71e:	7801      	ldrb	r1, [r0, #0]
    b720:	098b      	lsrs	r3, r1, #6
    b722:	7841      	ldrb	r1, [r0, #1]
    b724:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_tx_buf, datasize + 2 ) )
    b728:	3102      	adds	r1, #2
    b72a:	4620      	mov	r0, r4
    b72c:	f7ff fd3a 	bl	b1a4 <HIDIO_buffer_pop_bytes>
    b730:	4623      	mov	r3, r4
    b732:	b128      	cbz	r0, b740 <HIDIO_reply_id+0x80>
			HIDIO_tx_buf.packets_ready--;
    b734:	8962      	ldrh	r2, [r4, #10]
    b736:	3a01      	subs	r2, #1
    b738:	8162      	strh	r2, [r4, #10]
		HIDIO_tx_buf.waiting = 0;
    b73a:	2200      	movs	r2, #0
    b73c:	719a      	strb	r2, [r3, #6]
    b73e:	e7e0      	b.n	b702 <HIDIO_reply_id+0x42>
			HIDIO_tx_buf.packets_ready = 0;
    b740:	8165      	strh	r5, [r4, #10]
			HIDIO_tx_buf.head = 0;
    b742:	6025      	str	r5, [r4, #0]
    b744:	e7f9      	b.n	b73a <HIDIO_reply_id+0x7a>
		print("FAIL"NL);
    b746:	4807      	ldr	r0, [pc, #28]	; (b764 <HIDIO_reply_id+0xa4>)
    b748:	f003 ff12 	bl	f570 <_print>
		break;
    b74c:	e7d9      	b.n	b702 <HIDIO_reply_id+0x42>
}
    b74e:	b005      	add	sp, #20
    b750:	bdf0      	pop	{r4, r5, r6, r7, pc}
    b752:	bf00      	nop
    b754:	1fff89d0 	.word	0x1fff89d0
    b758:	1fffb0ec 	.word	0x1fffb0ec
    b75c:	1fffaf30 	.word	0x1fffaf30
    b760:	1fffb1ec 	.word	0x1fffb1ec
    b764:	000157d4 	.word	0x000157d4

0000b768 <HIDIO_setup>:
	print("YAY");
}

// HID-IO Module Setup
inline void HIDIO_setup()
{
    b768:	b537      	push	{r0, r1, r2, r4, r5, lr}
    b76a:	4d26      	ldr	r5, [pc, #152]	; (b804 <HIDIO_setup+0x9c>)
	HIDIO_assembly_buf.tail = 0;
	HIDIO_assembly_buf.cur_buf_head = 0;
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
	HIDIO_assembly_buf.packets_ready = 0;
	HIDIO_assembly_buf.waiting = 0;
	HIDIO_assembly_buf.data = HIDIO_assembly_buf_data;
    b76c:	4926      	ldr	r1, [pc, #152]	; (b808 <HIDIO_setup+0xa0>)
{
    b76e:	682b      	ldr	r3, [r5, #0]
    b770:	9301      	str	r3, [sp, #4]
	HIDIO_Packet_Size = 8;
    b772:	4b26      	ldr	r3, [pc, #152]	; (b80c <HIDIO_setup+0xa4>)
	HIDIO_tx_buf.packets_ready = 0;
	HIDIO_tx_buf.waiting = 0;
	HIDIO_tx_buf.data = HIDIO_tx_buf_data;

	// Register Output CLI dictionary
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    b774:	4826      	ldr	r0, [pc, #152]	; (b810 <HIDIO_setup+0xa8>)
	HIDIO_Packet_Size = 8;
    b776:	2208      	movs	r2, #8
    b778:	801a      	strh	r2, [r3, #0]
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    b77a:	4b26      	ldr	r3, [pc, #152]	; (b814 <HIDIO_setup+0xac>)
	HIDIO_assembly_buf.head = 0;
    b77c:	2400      	movs	r4, #0
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    b77e:	22d0      	movs	r2, #208	; 0xd0
	HIDIO_assembly_buf.head = 0;
    b780:	601c      	str	r4, [r3, #0]
	HIDIO_assembly_buf.tail = 0;
    b782:	809c      	strh	r4, [r3, #4]
	HIDIO_assembly_buf.len = sizeof(HIDIO_assembly_buf_data);
    b784:	609a      	str	r2, [r3, #8]
	HIDIO_assembly_buf.cur_buf_head = 0;
    b786:	719c      	strb	r4, [r3, #6]
	HIDIO_assembly_buf.data = HIDIO_assembly_buf_data;
    b788:	60d9      	str	r1, [r3, #12]
	HIDIO_ack_buf = (HIDIO_Buffer_Entry*)HIDIO_ack_buf_data;
    b78a:	4b23      	ldr	r3, [pc, #140]	; (b818 <HIDIO_setup+0xb0>)
    b78c:	4923      	ldr	r1, [pc, #140]	; (b81c <HIDIO_setup+0xb4>)
	HIDIO_ack_buf->id = 0;
    b78e:	701c      	strb	r4, [r3, #0]
    b790:	705c      	strb	r4, [r3, #1]
    b792:	709c      	strb	r4, [r3, #2]
    b794:	70dc      	strb	r4, [r3, #3]
	HIDIO_ack_buf->size = 0;
    b796:	711c      	strb	r4, [r3, #4]
    b798:	715c      	strb	r4, [r3, #5]
	HIDIO_ack_buf->done = 0;
    b79a:	719c      	strb	r4, [r3, #6]
	HIDIO_ack_buf = (HIDIO_Buffer_Entry*)HIDIO_ack_buf_data;
    b79c:	600b      	str	r3, [r1, #0]
	HIDIO_ack_send_buf.len = sizeof(HIDIO_ack_send_data);
    b79e:	4b20      	ldr	r3, [pc, #128]	; (b820 <HIDIO_setup+0xb8>)
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    b7a0:	4920      	ldr	r1, [pc, #128]	; (b824 <HIDIO_setup+0xbc>)
	HIDIO_ack_send_buf.len = sizeof(HIDIO_ack_send_data);
    b7a2:	609a      	str	r2, [r3, #8]
	HIDIO_ack_send_buf.data = HIDIO_ack_send_data;
    b7a4:	4a20      	ldr	r2, [pc, #128]	; (b828 <HIDIO_setup+0xc0>)
    b7a6:	60da      	str	r2, [r3, #12]
	HIDIO_ack_send_buf.head = 0;
    b7a8:	601c      	str	r4, [r3, #0]
	HIDIO_ack_send_buf.tail = 0;
    b7aa:	809c      	strh	r4, [r3, #4]
	HIDIO_ack_send_buf.cur_buf_head = 0;
    b7ac:	719c      	strb	r4, [r3, #6]
	HIDIO_tx_buf.len = sizeof(HIDIO_tx_buf_data);
    b7ae:	4b1f      	ldr	r3, [pc, #124]	; (b82c <HIDIO_setup+0xc4>)
    b7b0:	22ca      	movs	r2, #202	; 0xca
    b7b2:	609a      	str	r2, [r3, #8]
	HIDIO_tx_buf.head = 0;
    b7b4:	601c      	str	r4, [r3, #0]
	HIDIO_tx_buf.data = HIDIO_tx_buf_data;
    b7b6:	4a1e      	ldr	r2, [pc, #120]	; (b830 <HIDIO_setup+0xc8>)
	HIDIO_tx_buf.tail = 0;
    b7b8:	809c      	strh	r4, [r3, #4]
	HIDIO_tx_buf.cur_buf_head = 0;
    b7ba:	719c      	strb	r4, [r3, #6]
	HIDIO_tx_buf.data = HIDIO_tx_buf_data;
    b7bc:	60da      	str	r2, [r3, #12]
	CLI_registerDictionary( hidioCLIDict, hidioCLIDictName );
    b7be:	f003 fa67 	bl	ec90 <CLI_registerDictionary>

	// Allocate latency resource
	hidioLatencyResource = Latency_add_resource("HID-IO", LatencyOption_Ticks);
    b7c2:	4621      	mov	r1, r4
    b7c4:	481b      	ldr	r0, [pc, #108]	; (b834 <HIDIO_setup+0xcc>)
    b7c6:	f003 fd89 	bl	f2dc <Latency_add_resource>
    b7ca:	4b1b      	ldr	r3, [pc, #108]	; (b838 <HIDIO_setup+0xd0>)

	// Reset internal id list
	HIDIO_Id_List_Size = 0;

	// Register internal Ids
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    b7cc:	4a1b      	ldr	r2, [pc, #108]	; (b83c <HIDIO_setup+0xd4>)
	hidioLatencyResource = Latency_add_resource("HID-IO", LatencyOption_Ticks);
    b7ce:	7018      	strb	r0, [r3, #0]
	HIDIO_Id_List_Size = 0;
    b7d0:	4b1b      	ldr	r3, [pc, #108]	; (b840 <HIDIO_setup+0xd8>)
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    b7d2:	491c      	ldr	r1, [pc, #112]	; (b844 <HIDIO_setup+0xdc>)
	HIDIO_Id_List_Size = 0;
    b7d4:	601c      	str	r4, [r3, #0]
	HIDIO_register_id( 0, (void*)HIDIO_supported_0_call, (void*)HIDIO_supported_0_reply );
    b7d6:	4620      	mov	r0, r4
    b7d8:	f7ff fee8 	bl	b5ac <HIDIO_register_id>
	HIDIO_register_id( 1, (void*)HIDIO_info_1_call, (void*)HIDIO_info_1_reply );
    b7dc:	4a1a      	ldr	r2, [pc, #104]	; (b848 <HIDIO_setup+0xe0>)
    b7de:	491b      	ldr	r1, [pc, #108]	; (b84c <HIDIO_setup+0xe4>)
    b7e0:	2001      	movs	r0, #1
    b7e2:	f7ff fee3 	bl	b5ac <HIDIO_register_id>
	HIDIO_register_id( 2, (void*)HIDIO_test_2_call, (void*)HIDIO_test_2_reply );
    b7e6:	9a01      	ldr	r2, [sp, #4]
    b7e8:	682b      	ldr	r3, [r5, #0]
    b7ea:	429a      	cmp	r2, r3
    b7ec:	d001      	beq.n	b7f2 <HIDIO_setup+0x8a>
    b7ee:	f7f6 ff9f 	bl	2730 <__stack_chk_fail>
    b7f2:	4a17      	ldr	r2, [pc, #92]	; (b850 <HIDIO_setup+0xe8>)
    b7f4:	4917      	ldr	r1, [pc, #92]	; (b854 <HIDIO_setup+0xec>)
    b7f6:	2002      	movs	r0, #2
}
    b7f8:	b003      	add	sp, #12
    b7fa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	HIDIO_register_id( 2, (void*)HIDIO_test_2_call, (void*)HIDIO_test_2_reply );
    b7fe:	f7ff bed5 	b.w	b5ac <HIDIO_register_id>
    b802:	bf00      	nop
    b804:	1fff89d0 	.word	0x1fff89d0
    b808:	1fffaf36 	.word	0x1fffaf36
    b80c:	1fffaf34 	.word	0x1fffaf34
    b810:	000158ec 	.word	0x000158ec
    b814:	1fffb1dc 	.word	0x1fffb1dc
    b818:	1fffaee0 	.word	0x1fffaee0
    b81c:	1fffb008 	.word	0x1fffb008
    b820:	1fffb0dc 	.word	0x1fffb0dc
    b824:	000158f8 	.word	0x000158f8
    b828:	1fffb00c 	.word	0x1fffb00c
    b82c:	1fffb1ec 	.word	0x1fffb1ec
    b830:	1fffb1fc 	.word	0x1fffb1fc
    b834:	000158e4 	.word	0x000158e4
    b838:	1fff9727 	.word	0x1fff9727
    b83c:	0000b01d 	.word	0x0000b01d
    b840:	1fffaf30 	.word	0x1fffaf30
    b844:	0000aff9 	.word	0x0000aff9
    b848:	0000b08d 	.word	0x0000b08d
    b84c:	0000b0b1 	.word	0x0000b0b1
    b850:	0000b041 	.word	0x0000b041
    b854:	0000b4b1 	.word	0x0000b4b1

0000b858 <HIDIO_process_incoming_packet>:

// HID-IO Process Packet
void HIDIO_process_incoming_packet( uint8_t *buf, uint8_t irq )
{
    b858:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b85c:	b08f      	sub	sp, #60	; 0x3c
    b85e:	4680      	mov	r8, r0
    b860:	9105      	str	r1, [sp, #20]
    b862:	4980      	ldr	r1, [pc, #512]	; (ba64 <HIDIO_process_incoming_packet+0x20c>)
    b864:	9106      	str	r1, [sp, #24]
    b866:	680b      	ldr	r3, [r1, #0]
    b868:	930d      	str	r3, [sp, #52]	; 0x34
	// Map structure to packet data
	HIDIO_Packet *packet = (HIDIO_Packet*)buf;

	// Check header packet type to see if a valid packet
	if ( packet->type > HIDIO_Packet_Type__Continued )
    b86a:	7803      	ldrb	r3, [r0, #0]
    b86c:	f3c3 0b02 	ubfx	fp, r3, #0, #3
    b870:	fa5f f48b 	uxtb.w	r4, fp
    b874:	2c04      	cmp	r4, #4
    b876:	f200 80c4 	bhi.w	ba02 <HIDIO_process_incoming_packet+0x1aa>
		return;

	// Check if the length is valid
	uint16_t packet_len = (packet->upper_len << 8) | packet->len;
    b87a:	7841      	ldrb	r1, [r0, #1]
    b87c:	099e      	lsrs	r6, r3, #6
    b87e:	ea41 2606 	orr.w	r6, r1, r6, lsl #8
	if ( packet_len > HIDIO_Packet_Size )
    b882:	4979      	ldr	r1, [pc, #484]	; (ba68 <HIDIO_process_incoming_packet+0x210>)
    b884:	8809      	ldrh	r1, [r1, #0]
    b886:	42b1      	cmp	r1, r6
    b888:	f0c0 80bb 	bcc.w	ba02 <HIDIO_process_incoming_packet+0x1aa>
	return id_width ? 4 : 2;
    b88c:	f013 0f10 	tst.w	r3, #16
    b890:	bf14      	ite	ne
    b892:	2104      	movne	r1, #4
    b894:	2102      	moveq	r1, #2
	uint16_t payload_len = packet_len - id_width_len;

	// Check if valid Id
	uint32_t id = 0;
	uint8_t *data = 0;
	switch ( type )
    b896:	2c03      	cmp	r4, #3
    b898:	d02a      	beq.n	b8f0 <HIDIO_process_incoming_packet+0x98>
    b89a:	2c04      	cmp	r4, #4
    b89c:	d02d      	beq.n	b8fa <HIDIO_process_incoming_packet+0xa2>
		// Modify type so we know what to do with the payload
		type = HIDIO_ack_buf->done ? HIDIO_Packet_Type__Data : HIDIO_Packet_Type__ACK;

	// Most packet types
	default:
		id = HIDIO_buffer_id( packet );
    b89e:	4640      	mov	r0, r8
    b8a0:	9307      	str	r3, [sp, #28]
	uint16_t payload_len = packet_len - id_width_len;
    b8a2:	1a76      	subs	r6, r6, r1
		id = HIDIO_buffer_id( packet );
    b8a4:	f7ff fce0 	bl	b268 <HIDIO_buffer_id>
    b8a8:	4607      	mov	r7, r0

		// Data start
		data = HIDIO_payload_start( packet );
    b8aa:	4640      	mov	r0, r8
    b8ac:	f7ff fcf2 	bl	b294 <HIDIO_payload_start>
	uint16_t payload_len = packet_len - id_width_len;
    b8b0:	b2b6      	uxth	r6, r6
		data = HIDIO_payload_start( packet );
    b8b2:	4682      	mov	sl, r0
		break;
	}

	// Process packet
	switch ( type )
    b8b4:	9b07      	ldr	r3, [sp, #28]
    b8b6:	b33c      	cbz	r4, b908 <HIDIO_process_incoming_packet+0xb0>
    b8b8:	2c02      	cmp	r4, #2
    b8ba:	d81c      	bhi.n	b8f6 <HIDIO_process_incoming_packet+0x9e>

	case HIDIO_Packet_Type__ACK:
	case HIDIO_Packet_Type__NAK:
		// ACK/NAK packets have their own assembly buffer
		// Setup entry
		HIDIO_ack_buf->id = id;
    b8bc:	4c6b      	ldr	r4, [pc, #428]	; (ba6c <HIDIO_process_incoming_packet+0x214>)
		HIDIO_ack_buf->size = payload_len;
		HIDIO_ack_buf->done = packet->cont ? 0 : 1;
    b8be:	f083 0308 	eor.w	r3, r3, #8
		HIDIO_ack_buf->id = id;
    b8c2:	6820      	ldr	r0, [r4, #0]
		HIDIO_ack_buf->done = packet->cont ? 0 : 1;
    b8c4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    b8c8:	7183      	strb	r3, [r0, #6]
		HIDIO_ack_buf->id = id;
    b8ca:	6007      	str	r7, [r0, #0]
		HIDIO_ack_buf->size = payload_len;
    b8cc:	8086      	strh	r6, [r0, #4]
		HIDIO_ack_buf->type = packet->type;
    b8ce:	f880 b007 	strb.w	fp, [r0, #7]

		// Copy to buffer
		memcpy( &(HIDIO_ack_buf->data[0]), data, payload_len );
    b8d2:	4651      	mov	r1, sl
    b8d4:	4632      	mov	r2, r6
    b8d6:	3008      	adds	r0, #8
    b8d8:	f7f6 ff4e 	bl	2778 <memcpy>

		// If finished, send to appropriate registered callback
		if ( HIDIO_ack_buf->done )
    b8dc:	6821      	ldr	r1, [r4, #0]
    b8de:	798b      	ldrb	r3, [r1, #6]
    b8e0:	2b00      	cmp	r3, #0
    b8e2:	f000 808e 	beq.w	ba02 <HIDIO_process_incoming_packet+0x1aa>
		{
			HIDIO_reply_id( id, (uint8_t*)HIDIO_ack_buf, irq );
    b8e6:	9a05      	ldr	r2, [sp, #20]
    b8e8:	4638      	mov	r0, r7
    b8ea:	f7ff fee9 	bl	b6c0 <HIDIO_reply_id>
    b8ee:	e088      	b.n	ba02 <HIDIO_process_incoming_packet+0x1aa>
		print("SYNC");
    b8f0:	485f      	ldr	r0, [pc, #380]	; (ba70 <HIDIO_process_incoming_packet+0x218>)
    b8f2:	f003 fe3d 	bl	f570 <_print>
		break;
		break;

	default:
		// TODO (HaaTa)
		print("TODO!"NL);
    b8f6:	485f      	ldr	r0, [pc, #380]	; (ba74 <HIDIO_process_incoming_packet+0x21c>)
    b8f8:	e012      	b.n	b920 <HIDIO_process_incoming_packet+0xc8>
		type = HIDIO_ack_buf->done ? HIDIO_Packet_Type__Data : HIDIO_Packet_Type__ACK;
    b8fa:	485c      	ldr	r0, [pc, #368]	; (ba6c <HIDIO_process_incoming_packet+0x214>)
    b8fc:	6800      	ldr	r0, [r0, #0]
    b8fe:	7984      	ldrb	r4, [r0, #6]
    b900:	fab4 f484 	clz	r4, r4
    b904:	0964      	lsrs	r4, r4, #5
    b906:	e7ca      	b.n	b89e <HIDIO_process_incoming_packet+0x46>
		if ( !HIDIO_assembly_buf.waiting )
    b908:	f8df 918c 	ldr.w	r9, [pc, #396]	; ba98 <HIDIO_process_incoming_packet+0x240>
    b90c:	f899 1006 	ldrb.w	r1, [r9, #6]
    b910:	464d      	mov	r5, r9
    b912:	2900      	cmp	r1, #0
    b914:	d17c      	bne.n	ba10 <HIDIO_process_incoming_packet+0x1b8>
			if ( packet->type == HIDIO_Packet_Type__Continued )
    b916:	f003 0107 	and.w	r1, r3, #7
    b91a:	2904      	cmp	r1, #4
    b91c:	d103      	bne.n	b926 <HIDIO_process_incoming_packet+0xce>
				warn_print("Dropping incoming Continued Data packet...");
    b91e:	4856      	ldr	r0, [pc, #344]	; (ba78 <HIDIO_process_incoming_packet+0x220>)
		print("TODO!"NL);
    b920:	f003 fe26 	bl	f570 <_print>
    b924:	e06d      	b.n	ba02 <HIDIO_process_incoming_packet+0x1aa>
			if ( HIDIO_buffer_free_bytes( &HIDIO_assembly_buf ) < sizeof(HIDIO_Buffer_Entry) + payload_len )
    b926:	4648      	mov	r0, r9
    b928:	9307      	str	r3, [sp, #28]
    b92a:	f7ff fc6d 	bl	b208 <HIDIO_buffer_free_bytes>
    b92e:	f106 0108 	add.w	r1, r6, #8
    b932:	4288      	cmp	r0, r1
    b934:	9b07      	ldr	r3, [sp, #28]
    b936:	d222      	bcs.n	b97e <HIDIO_process_incoming_packet+0x126>
				warn_print("Dropping incoming Data packet, not enough buffer space...");
    b938:	4850      	ldr	r0, [pc, #320]	; (ba7c <HIDIO_process_incoming_packet+0x224>)
    b93a:	9105      	str	r1, [sp, #20]
    b93c:	f003 fe18 	bl	f570 <_print>
				print("head: ");
    b940:	484f      	ldr	r0, [pc, #316]	; (ba80 <HIDIO_process_incoming_packet+0x228>)
    b942:	f003 fe15 	bl	f570 <_print>
				printInt16( HIDIO_assembly_buf.head );
    b946:	f8b9 0000 	ldrh.w	r0, [r9]
    b94a:	f003 feb1 	bl	f6b0 <printInt16>
				print(" tail: ");
    b94e:	484d      	ldr	r0, [pc, #308]	; (ba84 <HIDIO_process_incoming_packet+0x22c>)
    b950:	f003 fe0e 	bl	f570 <_print>
				printInt16( HIDIO_assembly_buf.tail );
    b954:	f8b9 0002 	ldrh.w	r0, [r9, #2]
    b958:	f003 feaa 	bl	f6b0 <printInt16>
				print(" bytes_left: ");
    b95c:	484a      	ldr	r0, [pc, #296]	; (ba88 <HIDIO_process_incoming_packet+0x230>)
    b95e:	f003 fe07 	bl	f570 <_print>
				printInt16( HIDIO_buffer_free_bytes( &HIDIO_assembly_buf ) );
    b962:	4648      	mov	r0, r9
    b964:	f7ff fc50 	bl	b208 <HIDIO_buffer_free_bytes>
    b968:	f003 fea2 	bl	f6b0 <printInt16>
				print(" request: ");
    b96c:	4847      	ldr	r0, [pc, #284]	; (ba8c <HIDIO_process_incoming_packet+0x234>)
    b96e:	f003 fdff 	bl	f570 <_print>
				printInt16( sizeof(HIDIO_Buffer_Entry) + payload_len );
    b972:	9905      	ldr	r1, [sp, #20]
    b974:	b288      	uxth	r0, r1
    b976:	f003 fe9b 	bl	f6b0 <printInt16>
				print(NL);
    b97a:	4845      	ldr	r0, [pc, #276]	; (ba90 <HIDIO_process_incoming_packet+0x238>)
    b97c:	e7d0      	b.n	b920 <HIDIO_process_incoming_packet+0xc8>
			entry.done = packet->cont ? 0 : 1;
    b97e:	f083 0308 	eor.w	r3, r3, #8
    b982:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    b986:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
			HIDIO_assembly_buf.cur_buf_head = HIDIO_assembly_buf.tail;
    b98a:	f8b9 3002 	ldrh.w	r3, [r9, #2]
			entry.type = packet->type;
    b98e:	f88d b02b 	strb.w	fp, [sp, #43]	; 0x2b
			entry.id = id;
    b992:	9709      	str	r7, [sp, #36]	; 0x24
			entry.size = payload_len;
    b994:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
			HIDIO_assembly_buf.cur_buf_head = HIDIO_assembly_buf.tail;
    b998:	f8a9 3004 	strh.w	r3, [r9, #4]
				HIDIO_buffer_push_byte( &HIDIO_assembly_buf, ((uint8_t*)&entry)[c] );
    b99c:	f10d 0b24 	add.w	fp, sp, #36	; 0x24
    b9a0:	f81b 1004 	ldrb.w	r1, [fp, r4]
    b9a4:	4648      	mov	r0, r9
    b9a6:	3401      	adds	r4, #1
    b9a8:	f7ff fbc0 	bl	b12c <HIDIO_buffer_push_byte>
			for ( uint8_t c = 0; c < sizeof(HIDIO_Buffer_Entry); c++ )
    b9ac:	2c08      	cmp	r4, #8
    b9ae:	d1f7      	bne.n	b9a0 <HIDIO_process_incoming_packet+0x148>
		HIDIO_assembly_buf.waiting = packet->cont;
    b9b0:	f898 3000 	ldrb.w	r3, [r8]
			HIDIO_buffer_push_byte( &HIDIO_assembly_buf, data[c] );
    b9b4:	f8df 80e0 	ldr.w	r8, [pc, #224]	; ba98 <HIDIO_process_incoming_packet+0x240>
		HIDIO_assembly_buf.waiting = packet->cont;
    b9b8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    b9bc:	71ab      	strb	r3, [r5, #6]
		for ( uint16_t c = 0; c < payload_len; c++ )
    b9be:	4654      	mov	r4, sl
    b9c0:	eba4 030a 	sub.w	r3, r4, sl
    b9c4:	b29b      	uxth	r3, r3
    b9c6:	42b3      	cmp	r3, r6
    b9c8:	d33e      	bcc.n	ba48 <HIDIO_process_incoming_packet+0x1f0>
		HIDIO_assembly_buf.packets_ready++;
    b9ca:	896b      	ldrh	r3, [r5, #10]
		if ( !HIDIO_assembly_buf.waiting )
    b9cc:	79ac      	ldrb	r4, [r5, #6]
		HIDIO_assembly_buf.packets_ready++;
    b9ce:	3301      	adds	r3, #1
    b9d0:	816b      	strh	r3, [r5, #10]
		if ( !HIDIO_assembly_buf.waiting )
    b9d2:	2c00      	cmp	r4, #0
    b9d4:	d13e      	bne.n	ba54 <HIDIO_process_incoming_packet+0x1fc>
			HIDIO_Return retval = HIDIO_call_id( id, HIDIO_assembly_buf.cur_buf_head, irq );
    b9d6:	9a05      	ldr	r2, [sp, #20]
    b9d8:	88a9      	ldrh	r1, [r5, #4]
    b9da:	4638      	mov	r0, r7
    b9dc:	f7ff fe1a 	bl	b614 <HIDIO_call_id>
			switch ( retval )
    b9e0:	2804      	cmp	r0, #4
    b9e2:	d10e      	bne.n	ba02 <HIDIO_process_incoming_packet+0x1aa>
				HIDIO_assembly_buf.packets_ready--;
    b9e4:	896b      	ldrh	r3, [r5, #10]
				HIDIO_buffer_generate_packet(
    b9e6:	482b      	ldr	r0, [pc, #172]	; (ba94 <HIDIO_process_incoming_packet+0x23c>)
				HIDIO_assembly_buf.packets_ready--;
    b9e8:	3b01      	subs	r3, #1
    b9ea:	816b      	strh	r3, [r5, #10]
				HIDIO_assembly_buf.head = HIDIO_assembly_buf.tail;
    b9ec:	886b      	ldrh	r3, [r5, #2]
    b9ee:	802b      	strh	r3, [r5, #0]
				HIDIO_buffer_generate_packet(
    b9f0:	2302      	movs	r3, #2
    b9f2:	e9cd 4300 	strd	r4, r3, [sp]
    b9f6:	9702      	str	r7, [sp, #8]
    b9f8:	4623      	mov	r3, r4
    b9fa:	4622      	mov	r2, r4
    b9fc:	4621      	mov	r1, r4
    b9fe:	f7ff fc5d 	bl	b2bc <HIDIO_buffer_generate_packet>
	{
		printChar( (char)(data[ pos ]) );
	}
	print( NL );
	*/
}
    ba02:	9b06      	ldr	r3, [sp, #24]
    ba04:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    ba06:	681b      	ldr	r3, [r3, #0]
    ba08:	429a      	cmp	r2, r3
    ba0a:	d027      	beq.n	ba5c <HIDIO_process_incoming_packet+0x204>
    ba0c:	f7f6 fe90 	bl	2730 <__stack_chk_fail>
			HIDIO_Buffer_Entry *entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch(
    ba10:	ac0b      	add	r4, sp, #44	; 0x2c
    ba12:	2308      	movs	r3, #8
    ba14:	f8b9 2004 	ldrh.w	r2, [r9, #4]
    ba18:	4621      	mov	r1, r4
    ba1a:	4648      	mov	r0, r9
    ba1c:	f7ff fb5a 	bl	b0d4 <HIDIO_buffer_munch>
			entry->size += payload_len;
    ba20:	8883      	ldrh	r3, [r0, #4]
    ba22:	4433      	add	r3, r6
    ba24:	8083      	strh	r3, [r0, #4]
			entry->done = packet->cont ? 0 : 1;
    ba26:	f898 3000 	ldrb.w	r3, [r8]
    ba2a:	f083 0308 	eor.w	r3, r3, #8
    ba2e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
			if ( tmpbuf == (uint8_t*)entry )
    ba32:	42a0      	cmp	r0, r4
			HIDIO_Buffer_Entry *entry = (HIDIO_Buffer_Entry*)HIDIO_buffer_munch(
    ba34:	4602      	mov	r2, r0
			entry->done = packet->cont ? 0 : 1;
    ba36:	7183      	strb	r3, [r0, #6]
			if ( tmpbuf == (uint8_t*)entry )
    ba38:	d1ba      	bne.n	b9b0 <HIDIO_process_incoming_packet+0x158>
				HIDIO_modify_buffer(
    ba3a:	2308      	movs	r3, #8
    ba3c:	f8b9 1004 	ldrh.w	r1, [r9, #4]
    ba40:	4648      	mov	r0, r9
    ba42:	f7ff fb8d 	bl	b160 <HIDIO_modify_buffer>
    ba46:	e7b3      	b.n	b9b0 <HIDIO_process_incoming_packet+0x158>
			HIDIO_buffer_push_byte( &HIDIO_assembly_buf, data[c] );
    ba48:	f814 1b01 	ldrb.w	r1, [r4], #1
    ba4c:	4640      	mov	r0, r8
    ba4e:	f7ff fb6d 	bl	b12c <HIDIO_buffer_push_byte>
    ba52:	e7b5      	b.n	b9c0 <HIDIO_process_incoming_packet+0x168>
			HIDIO_nopayload_ack( id );
    ba54:	4638      	mov	r0, r7
    ba56:	f7ff fd8d 	bl	b574 <HIDIO_nopayload_ack>
    ba5a:	e7d2      	b.n	ba02 <HIDIO_process_incoming_packet+0x1aa>
}
    ba5c:	b00f      	add	sp, #60	; 0x3c
    ba5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ba62:	bf00      	nop
    ba64:	1fff89d0 	.word	0x1fff89d0
    ba68:	1fffaf34 	.word	0x1fffaf34
    ba6c:	1fffb008 	.word	0x1fffb008
    ba70:	000157db 	.word	0x000157db
    ba74:	0001589b 	.word	0x0001589b
    ba78:	000157e0 	.word	0x000157e0
    ba7c:	00015822 	.word	0x00015822
    ba80:	00015873 	.word	0x00015873
    ba84:	0001587a 	.word	0x0001587a
    ba88:	00015882 	.word	0x00015882
    ba8c:	00015890 	.word	0x00015890
    ba90:	00015df4 	.word	0x00015df4
    ba94:	1fffb0dc 	.word	0x1fffb0dc
    ba98:	1fffb1dc 	.word	0x1fffb1dc

0000ba9c <HIDIO_process>:

// HID-IO Processing Loop
inline void HIDIO_process()
{
    ba9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    baa0:	4d28      	ldr	r5, [pc, #160]	; (bb44 <HIDIO_process+0xa8>)
	// Start latency measurement
	Latency_start_time( hidioLatencyResource );
    baa2:	4e29      	ldr	r6, [pc, #164]	; (bb48 <HIDIO_process+0xac>)
{
    baa4:	682b      	ldr	r3, [r5, #0]
	Latency_start_time( hidioLatencyResource );
    baa6:	7830      	ldrb	r0, [r6, #0]
{
    baa8:	b092      	sub	sp, #72	; 0x48
    baaa:	9311      	str	r3, [sp, #68]	; 0x44
	Latency_start_time( hidioLatencyResource );
    baac:	f003 fc8e 	bl	f3cc <Latency_start_time>

	// TODO (HaaTa): Handle timeouts and lost packets

	// Retrieve incoming packets
	while ( Output_rawio_availablechar() )
    bab0:	f000 f9e8 	bl	be84 <Output_rawio_availablechar>
    bab4:	b9e0      	cbnz	r0, baf0 <HIDIO_process+0x54>
		// Process Packet, regular process (no interrupt)
		HIDIO_process_incoming_packet( tmpdata, 0 );
	}

	// Send all ACK packets
	while ( HIDIO_ack_send_buf.packets_ready > 0 )
    bab6:	4c25      	ldr	r4, [pc, #148]	; (bb4c <HIDIO_process+0xb0>)
	{
		// Prepare 64 byte packet
		// TODO (HaaTa): Handle internal max size
		uint8_t tmpdata[64];
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_ack_send_buf, tmpdata, HIDIO_ack_send_buf.head, HIDIO_Packet_Size );
    bab8:	4f25      	ldr	r7, [pc, #148]	; (bb50 <HIDIO_process+0xb4>)
	while ( HIDIO_ack_send_buf.packets_ready > 0 )
    baba:	8963      	ldrh	r3, [r4, #10]
    babc:	bb03      	cbnz	r3, bb00 <HIDIO_process+0x64>
		}
	}

	// Send outgoing packet, we can only send one at a time
	// and the next one can only be sent after an ACK is recieved
	if ( HIDIO_tx_buf.packets_ready > 0 && HIDIO_tx_buf.waiting == 0 )
    babe:	4c25      	ldr	r4, [pc, #148]	; (bb54 <HIDIO_process+0xb8>)
    bac0:	8963      	ldrh	r3, [r4, #10]
    bac2:	b163      	cbz	r3, bade <HIDIO_process+0x42>
    bac4:	79a3      	ldrb	r3, [r4, #6]
    bac6:	b953      	cbnz	r3, bade <HIDIO_process+0x42>
	{
		// Prepare 64 byte packet
		// TODO (HaaTa): Handle internal max size
		uint8_t tmpdata[64];
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_tx_buf, tmpdata, HIDIO_tx_buf.head, HIDIO_Packet_Size );
    bac8:	4b21      	ldr	r3, [pc, #132]	; (bb50 <HIDIO_process+0xb4>)
    baca:	8822      	ldrh	r2, [r4, #0]
    bacc:	881b      	ldrh	r3, [r3, #0]
    bace:	a901      	add	r1, sp, #4
    bad0:	4620      	mov	r0, r4
    bad2:	f7ff faff 	bl	b0d4 <HIDIO_buffer_munch>
		HIDIO_Packet *packet = (HIDIO_Packet*)buf;

		// Send packet
		// TODO (HaaTa): Check error?
		Output_rawio_sendbuffer( (char*)packet );
    bad6:	f000 f9f9 	bl	becc <Output_rawio_sendbuffer>

		// Indicate waiting for ACK packet
		// Once ACK has been received (or NAK) the packet will be released
		HIDIO_tx_buf.waiting = 1;
    bada:	2301      	movs	r3, #1
    badc:	71a3      	strb	r3, [r4, #6]
	}

	// End latency measurement
	Latency_end_time( hidioLatencyResource );
    bade:	7830      	ldrb	r0, [r6, #0]
    bae0:	f003 fc92 	bl	f408 <Latency_end_time>
}
    bae4:	9a11      	ldr	r2, [sp, #68]	; 0x44
    bae6:	682b      	ldr	r3, [r5, #0]
    bae8:	429a      	cmp	r2, r3
    baea:	d027      	beq.n	bb3c <HIDIO_process+0xa0>
    baec:	f7f6 fe20 	bl	2730 <__stack_chk_fail>
		Output_rawio_getbuffer( (char*)&tmpdata );
    baf0:	a801      	add	r0, sp, #4
    baf2:	f000 f9d9 	bl	bea8 <Output_rawio_getbuffer>
		HIDIO_process_incoming_packet( tmpdata, 0 );
    baf6:	2100      	movs	r1, #0
    baf8:	a801      	add	r0, sp, #4
    bafa:	f7ff fead 	bl	b858 <HIDIO_process_incoming_packet>
    bafe:	e7d7      	b.n	bab0 <HIDIO_process+0x14>
		uint8_t *buf = HIDIO_buffer_munch( &HIDIO_ack_send_buf, tmpdata, HIDIO_ack_send_buf.head, HIDIO_Packet_Size );
    bb00:	883b      	ldrh	r3, [r7, #0]
    bb02:	8822      	ldrh	r2, [r4, #0]
    bb04:	a901      	add	r1, sp, #4
    bb06:	4620      	mov	r0, r4
    bb08:	f7ff fae4 	bl	b0d4 <HIDIO_buffer_munch>
    bb0c:	4680      	mov	r8, r0
		Output_rawio_sendbuffer( (char*)buf );
    bb0e:	f000 f9dd 	bl	becc <Output_rawio_sendbuffer>
		HIDIO_ack_send_buf.waiting = 1;
    bb12:	2301      	movs	r3, #1
    bb14:	71a3      	strb	r3, [r4, #6]
		uint16_t datasize = (packet->upper_len << 8) | packet->len;
    bb16:	f898 1000 	ldrb.w	r1, [r8]
    bb1a:	098b      	lsrs	r3, r1, #6
    bb1c:	f898 1001 	ldrb.w	r1, [r8, #1]
    bb20:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
		if ( HIDIO_buffer_pop_bytes( &HIDIO_ack_send_buf, datasize + 2 ) )
    bb24:	3102      	adds	r1, #2
    bb26:	4620      	mov	r0, r4
    bb28:	f7ff fb3c 	bl	b1a4 <HIDIO_buffer_pop_bytes>
    bb2c:	b118      	cbz	r0, bb36 <HIDIO_process+0x9a>
			HIDIO_ack_send_buf.packets_ready--;
    bb2e:	8963      	ldrh	r3, [r4, #10]
    bb30:	3b01      	subs	r3, #1
    bb32:	8163      	strh	r3, [r4, #10]
    bb34:	e7c1      	b.n	baba <HIDIO_process+0x1e>
			HIDIO_ack_send_buf.packets_ready = 0;
    bb36:	8160      	strh	r0, [r4, #10]
			HIDIO_ack_send_buf.head = 0;
    bb38:	6020      	str	r0, [r4, #0]
    bb3a:	e7be      	b.n	baba <HIDIO_process+0x1e>
}
    bb3c:	b012      	add	sp, #72	; 0x48
    bb3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    bb42:	bf00      	nop
    bb44:	1fff89d0 	.word	0x1fff89d0
    bb48:	1fff9727 	.word	0x1fff9727
    bb4c:	1fffb0dc 	.word	0x1fffb0dc
    bb50:	1fffaf34 	.word	0x1fffaf34
    bb54:	1fffb1ec 	.word	0x1fffb1ec

0000bb58 <cliFunc_outputDebug>:
	print(" mA");
}


void cliFunc_outputDebug( char* args )
{
    bb58:	b530      	push	{r4, r5, lr}
    bb5a:	4c0e      	ldr	r4, [pc, #56]	; (bb94 <cliFunc_outputDebug+0x3c>)
	char* arg1Ptr;
	char* arg2Ptr;
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );

	// Default to 1 if no argument is given
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    bb5c:	4d0e      	ldr	r5, [pc, #56]	; (bb98 <cliFunc_outputDebug+0x40>)
{
    bb5e:	6823      	ldr	r3, [r4, #0]
    bb60:	b085      	sub	sp, #20
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    bb62:	aa02      	add	r2, sp, #8
    bb64:	a901      	add	r1, sp, #4
{
    bb66:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    bb68:	f002 ffd4 	bl	eb14 <CLI_argumentIsolation>
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    bb6c:	782b      	ldrb	r3, [r5, #0]

	if ( arg1Ptr[0] != '\0' )
    bb6e:	9801      	ldr	r0, [sp, #4]
	Output_DebugMode = Output_DebugMode ? 0 : 1;
    bb70:	fab3 f383 	clz	r3, r3
    bb74:	095b      	lsrs	r3, r3, #5
    bb76:	702b      	strb	r3, [r5, #0]
	if ( arg1Ptr[0] != '\0' )
    bb78:	7803      	ldrb	r3, [r0, #0]
    bb7a:	b113      	cbz	r3, bb82 <cliFunc_outputDebug+0x2a>
	{
		Output_DebugMode = (uint16_t)numToInt( arg1Ptr );
    bb7c:	f003 fec8 	bl	f910 <numToInt>
    bb80:	7028      	strb	r0, [r5, #0]
	}
}
    bb82:	9a03      	ldr	r2, [sp, #12]
    bb84:	6823      	ldr	r3, [r4, #0]
    bb86:	429a      	cmp	r2, r3
    bb88:	d001      	beq.n	bb8e <cliFunc_outputDebug+0x36>
    bb8a:	f7f6 fdd1 	bl	2730 <__stack_chk_fail>
    bb8e:	b005      	add	sp, #20
    bb90:	bd30      	pop	{r4, r5, pc}
    bb92:	bf00      	nop
    bb94:	1fff89d0 	.word	0x1fff89d0
    bb98:	1fffb2c6 	.word	0x1fffb2c6

0000bb9c <Output_flashMode_capability>:
{
    bb9c:	b507      	push	{r0, r1, r2, lr}
    bb9e:	4b0e      	ldr	r3, [pc, #56]	; (bbd8 <Output_flashMode_capability+0x3c>)
    bba0:	6818      	ldr	r0, [r3, #0]
    bba2:	9001      	str	r0, [sp, #4]
	if ( stateType == 0xFF && state == 0xFF )
    bba4:	2aff      	cmp	r2, #255	; 0xff
    bba6:	4618      	mov	r0, r3
		print("Output_flashMode()");
    bba8:	9a01      	ldr	r2, [sp, #4]
	if ( stateType == 0xFF && state == 0xFF )
    bbaa:	d10c      	bne.n	bbc6 <Output_flashMode_capability+0x2a>
    bbac:	29ff      	cmp	r1, #255	; 0xff
    bbae:	d10a      	bne.n	bbc6 <Output_flashMode_capability+0x2a>
		print("Output_flashMode()");
    bbb0:	681b      	ldr	r3, [r3, #0]
    bbb2:	429a      	cmp	r2, r3
    bbb4:	d001      	beq.n	bbba <Output_flashMode_capability+0x1e>
	Output_firmwareReload();
    bbb6:	f7f6 fdbb 	bl	2730 <__stack_chk_fail>
		print("Output_flashMode()");
    bbba:	4808      	ldr	r0, [pc, #32]	; (bbdc <Output_flashMode_capability+0x40>)
}
    bbbc:	b003      	add	sp, #12
    bbbe:	f85d eb04 	ldr.w	lr, [sp], #4
		print("Output_flashMode()");
    bbc2:	f003 bcd5 	b.w	f570 <_print>
	Output_firmwareReload();
    bbc6:	6803      	ldr	r3, [r0, #0]
    bbc8:	429a      	cmp	r2, r3
    bbca:	d1f4      	bne.n	bbb6 <Output_flashMode_capability+0x1a>
}
    bbcc:	b003      	add	sp, #12
    bbce:	f85d eb04 	ldr.w	lr, [sp], #4
	Output_firmwareReload();
    bbd2:	f000 b8fd 	b.w	bdd0 <Output_firmwareReload>
    bbd6:	bf00      	nop
    bbd8:	1fff89d0 	.word	0x1fff89d0
    bbdc:	0001590f 	.word	0x0001590f

0000bbe0 <OutputGen_setup>:
{
    bbe0:	b513      	push	{r0, r1, r4, lr}
    bbe2:	4c0c      	ldr	r4, [pc, #48]	; (bc14 <OutputGen_setup+0x34>)
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    bbe4:	490c      	ldr	r1, [pc, #48]	; (bc18 <OutputGen_setup+0x38>)
{
    bbe6:	6823      	ldr	r3, [r4, #0]
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    bbe8:	480c      	ldr	r0, [pc, #48]	; (bc1c <OutputGen_setup+0x3c>)
{
    bbea:	9301      	str	r3, [sp, #4]
	CLI_registerDictionary( outputCLIDict, outputCLIDictName );
    bbec:	f003 f850 	bl	ec90 <CLI_registerDictionary>
	Output_Available = 0;
    bbf0:	4a0b      	ldr	r2, [pc, #44]	; (bc20 <OutputGen_setup+0x40>)
    bbf2:	2300      	movs	r3, #0
    bbf4:	7013      	strb	r3, [r2, #0]
	Output_DebugMode = 0;
    bbf6:	4a0b      	ldr	r2, [pc, #44]	; (bc24 <OutputGen_setup+0x44>)
    bbf8:	7013      	strb	r3, [r2, #0]
	Output_ExtCurrent_Available = 0;
    bbfa:	4a0b      	ldr	r2, [pc, #44]	; (bc28 <OutputGen_setup+0x48>)
    bbfc:	8013      	strh	r3, [r2, #0]
	Output_USBCurrent_Available = 0;
    bbfe:	4a0b      	ldr	r2, [pc, #44]	; (bc2c <OutputGen_setup+0x4c>)
    bc00:	8013      	strh	r3, [r2, #0]
}
    bc02:	9a01      	ldr	r2, [sp, #4]
    bc04:	6823      	ldr	r3, [r4, #0]
    bc06:	429a      	cmp	r2, r3
    bc08:	d001      	beq.n	bc0e <OutputGen_setup+0x2e>
    bc0a:	f7f6 fd91 	bl	2730 <__stack_chk_fail>
    bc0e:	b002      	add	sp, #8
    bc10:	bd10      	pop	{r4, pc}
    bc12:	bf00      	nop
    bc14:	1fff89d0 	.word	0x1fff89d0
    bc18:	000159e4 	.word	0x000159e4
    bc1c:	000159c0 	.word	0x000159c0
    bc20:	1fffb2ca 	.word	0x1fffb2ca
    bc24:	1fffb2c6 	.word	0x1fffb2c6
    bc28:	1fffb2c8 	.word	0x1fffb2c8
    bc2c:	1fffb2cc 	.word	0x1fffb2cc

0000bc30 <Output_current_available>:
{
    bc30:	b507      	push	{r0, r1, r2, lr}
    bc32:	4b09      	ldr	r3, [pc, #36]	; (bc58 <Output_current_available+0x28>)
    bc34:	681a      	ldr	r2, [r3, #0]
    bc36:	9201      	str	r2, [sp, #4]
	total_current += Output_USBCurrent_Available;
    bc38:	4a08      	ldr	r2, [pc, #32]	; (bc5c <Output_current_available+0x2c>)
    bc3a:	8810      	ldrh	r0, [r2, #0]
	total_current += Output_ExtCurrent_Available;
    bc3c:	4a08      	ldr	r2, [pc, #32]	; (bc60 <Output_current_available+0x30>)
    bc3e:	8812      	ldrh	r2, [r2, #0]
		total_current = 100;
    bc40:	1880      	adds	r0, r0, r2
}
    bc42:	9a01      	ldr	r2, [sp, #4]
    bc44:	681b      	ldr	r3, [r3, #0]
    bc46:	bf08      	it	eq
    bc48:	2064      	moveq	r0, #100	; 0x64
    bc4a:	429a      	cmp	r2, r3
    bc4c:	d001      	beq.n	bc52 <Output_current_available+0x22>
    bc4e:	f7f6 fd6f 	bl	2730 <__stack_chk_fail>
    bc52:	b003      	add	sp, #12
    bc54:	f85d fb04 	ldr.w	pc, [sp], #4
    bc58:	1fff89d0 	.word	0x1fff89d0
    bc5c:	1fffb2cc 	.word	0x1fffb2cc
    bc60:	1fffb2c8 	.word	0x1fffb2c8

0000bc64 <Output_update_usb_current>:
{
    bc64:	b513      	push	{r0, r1, r4, lr}
    bc66:	4c0d      	ldr	r4, [pc, #52]	; (bc9c <Output_update_usb_current+0x38>)
    bc68:	6823      	ldr	r3, [r4, #0]
    bc6a:	9301      	str	r3, [sp, #4]
	if ( current == Output_USBCurrent_Available )
    bc6c:	4b0c      	ldr	r3, [pc, #48]	; (bca0 <Output_update_usb_current+0x3c>)
    bc6e:	881a      	ldrh	r2, [r3, #0]
    bc70:	4282      	cmp	r2, r0
    bc72:	d00d      	beq.n	bc90 <Output_update_usb_current+0x2c>
	Output_USBCurrent_Available = current;
    bc74:	8018      	strh	r0, [r3, #0]
	Scan_currentChange( Output_current_available() );
    bc76:	f7ff ffdb 	bl	bc30 <Output_current_available>
    bc7a:	9a01      	ldr	r2, [sp, #4]
    bc7c:	6823      	ldr	r3, [r4, #0]
    bc7e:	429a      	cmp	r2, r3
    bc80:	d001      	beq.n	bc86 <Output_update_usb_current+0x22>
}
    bc82:	f7f6 fd55 	bl	2730 <__stack_chk_fail>
    bc86:	b002      	add	sp, #8
    bc88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	Scan_currentChange( Output_current_available() );
    bc8c:	f7fa bd10 	b.w	66b0 <Scan_currentChange>
}
    bc90:	9a01      	ldr	r2, [sp, #4]
    bc92:	6823      	ldr	r3, [r4, #0]
    bc94:	429a      	cmp	r2, r3
    bc96:	d1f4      	bne.n	bc82 <Output_update_usb_current+0x1e>
    bc98:	b002      	add	sp, #8
    bc9a:	bd10      	pop	{r4, pc}
    bc9c:	1fff89d0 	.word	0x1fff89d0
    bca0:	1fffb2cc 	.word	0x1fffb2cc

0000bca4 <Output_update_external_current>:
{
    bca4:	b537      	push	{r0, r1, r2, r4, r5, lr}
    bca6:	4c13      	ldr	r4, [pc, #76]	; (bcf4 <Output_update_external_current+0x50>)
    bca8:	6823      	ldr	r3, [r4, #0]
    bcaa:	9301      	str	r3, [sp, #4]
	if ( current == Output_ExtCurrent_Available )
    bcac:	4b12      	ldr	r3, [pc, #72]	; (bcf8 <Output_update_external_current+0x54>)
    bcae:	881a      	ldrh	r2, [r3, #0]
    bcb0:	4282      	cmp	r2, r0
    bcb2:	d019      	beq.n	bce8 <Output_update_external_current+0x44>
	Output_ExtCurrent_Available = current;
    bcb4:	8018      	strh	r0, [r3, #0]
	unsigned int total_current = Output_current_available();
    bcb6:	f7ff ffbb 	bl	bc30 <Output_current_available>
    bcba:	4605      	mov	r5, r0
	info_msg("External Available Current Changed. Total Available: ");
    bcbc:	480f      	ldr	r0, [pc, #60]	; (bcfc <Output_update_external_current+0x58>)
    bcbe:	f003 fc57 	bl	f570 <_print>
	printInt32( total_current );
    bcc2:	4628      	mov	r0, r5
    bcc4:	f003 fd2a 	bl	f71c <printInt32>
	print(" mA" NL);
    bcc8:	480d      	ldr	r0, [pc, #52]	; (bd00 <Output_update_external_current+0x5c>)
    bcca:	f003 fc51 	bl	f570 <_print>
	Scan_currentChange( Output_current_available() );
    bcce:	f7ff ffaf 	bl	bc30 <Output_current_available>
    bcd2:	9a01      	ldr	r2, [sp, #4]
    bcd4:	6823      	ldr	r3, [r4, #0]
    bcd6:	429a      	cmp	r2, r3
    bcd8:	d001      	beq.n	bcde <Output_update_external_current+0x3a>
}
    bcda:	f7f6 fd29 	bl	2730 <__stack_chk_fail>
    bcde:	b003      	add	sp, #12
    bce0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	Scan_currentChange( Output_current_available() );
    bce4:	f7fa bce4 	b.w	66b0 <Scan_currentChange>
}
    bce8:	9a01      	ldr	r2, [sp, #4]
    bcea:	6823      	ldr	r3, [r4, #0]
    bcec:	429a      	cmp	r2, r3
    bcee:	d1f4      	bne.n	bcda <Output_update_external_current+0x36>
    bcf0:	b003      	add	sp, #12
    bcf2:	bd30      	pop	{r4, r5, pc}
    bcf4:	1fff89d0 	.word	0x1fff89d0
    bcf8:	1fffb2c8 	.word	0x1fffb2c8
    bcfc:	00015922 	.word	0x00015922
    bd00:	0001596a 	.word	0x0001596a

0000bd04 <cliFunc_current>:
{
    bd04:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    bd06:	4c12      	ldr	r4, [pc, #72]	; (bd50 <cliFunc_current+0x4c>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    bd08:	aa02      	add	r2, sp, #8
{
    bd0a:	6823      	ldr	r3, [r4, #0]
    bd0c:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    bd0e:	a901      	add	r1, sp, #4
    bd10:	f002 ff00 	bl	eb14 <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    bd14:	9801      	ldr	r0, [sp, #4]
    bd16:	7803      	ldrb	r3, [r0, #0]
    bd18:	b11b      	cbz	r3, bd22 <cliFunc_current+0x1e>
		Output_update_external_current( (unsigned int)numToInt( arg1Ptr ) );
    bd1a:	f003 fdf9 	bl	f910 <numToInt>
    bd1e:	f7ff ffc1 	bl	bca4 <Output_update_external_current>
	print( NL );
    bd22:	480c      	ldr	r0, [pc, #48]	; (bd54 <cliFunc_current+0x50>)
    bd24:	f003 fc24 	bl	f570 <_print>
	info_msg("Current available: ");
    bd28:	480b      	ldr	r0, [pc, #44]	; (bd58 <cliFunc_current+0x54>)
    bd2a:	f003 fc21 	bl	f570 <_print>
	printInt16( Output_current_available() );
    bd2e:	f7ff ff7f 	bl	bc30 <Output_current_available>
    bd32:	b280      	uxth	r0, r0
    bd34:	f003 fcbc 	bl	f6b0 <printInt16>
	print(" mA");
    bd38:	4808      	ldr	r0, [pc, #32]	; (bd5c <cliFunc_current+0x58>)
    bd3a:	f003 fc19 	bl	f570 <_print>
}
    bd3e:	9a03      	ldr	r2, [sp, #12]
    bd40:	6823      	ldr	r3, [r4, #0]
    bd42:	429a      	cmp	r2, r3
    bd44:	d001      	beq.n	bd4a <cliFunc_current+0x46>
    bd46:	f7f6 fcf3 	bl	2730 <__stack_chk_fail>
    bd4a:	b004      	add	sp, #16
    bd4c:	bd10      	pop	{r4, pc}
    bd4e:	bf00      	nop
    bd50:	1fff89d0 	.word	0x1fff89d0
    bd54:	00015df4 	.word	0x00015df4
    bd58:	00015970 	.word	0x00015970
    bd5c:	00015996 	.word	0x00015996

0000bd60 <Output_setup>:

// ----- Functions -----

// Output Module Setup
inline void Output_setup()
{
    bd60:	b513      	push	{r0, r1, r4, lr}
    bd62:	4c08      	ldr	r4, [pc, #32]	; (bd84 <Output_setup+0x24>)
    bd64:	6823      	ldr	r3, [r4, #0]
    bd66:	9301      	str	r3, [sp, #4]
	// Initialize Interface module
	OutputGen_setup();
    bd68:	f7ff ff3a 	bl	bbe0 <OutputGen_setup>

	// Initialize the USB module
	USB_setup();
    bd6c:	9a01      	ldr	r2, [sp, #4]
    bd6e:	6823      	ldr	r3, [r4, #0]
    bd70:	429a      	cmp	r2, r3
    bd72:	d001      	beq.n	bd78 <Output_setup+0x18>
    bd74:	f7f6 fcdc 	bl	2730 <__stack_chk_fail>
}
    bd78:	b002      	add	sp, #8
    bd7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USB_setup();
    bd7e:	f000 bcf5 	b.w	c76c <USB_setup>
    bd82:	bf00      	nop
    bd84:	1fff89d0 	.word	0x1fff89d0

0000bd88 <Output_poll>:


// Output Module Data Poll
inline void Output_poll()
{
    bd88:	b507      	push	{r0, r1, r2, lr}
    bd8a:	4b07      	ldr	r3, [pc, #28]	; (bda8 <Output_poll+0x20>)
    bd8c:	681a      	ldr	r2, [r3, #0]
    bd8e:	9201      	str	r2, [sp, #4]
	USB_poll();
    bd90:	9a01      	ldr	r2, [sp, #4]
    bd92:	681b      	ldr	r3, [r3, #0]
    bd94:	429a      	cmp	r2, r3
    bd96:	d001      	beq.n	bd9c <Output_poll+0x14>
    bd98:	f7f6 fcca 	bl	2730 <__stack_chk_fail>
}
    bd9c:	b003      	add	sp, #12
    bd9e:	f85d eb04 	ldr.w	lr, [sp], #4
	USB_poll();
    bda2:	f000 bd41 	b.w	c828 <USB_poll>
    bda6:	bf00      	nop
    bda8:	1fff89d0 	.word	0x1fff89d0

0000bdac <Output_periodic>:


// Output Module Data Periodic
inline void Output_periodic()
{
    bdac:	b507      	push	{r0, r1, r2, lr}
    bdae:	4b07      	ldr	r3, [pc, #28]	; (bdcc <Output_periodic+0x20>)
    bdb0:	681a      	ldr	r2, [r3, #0]
    bdb2:	9201      	str	r2, [sp, #4]
	USB_periodic();
    bdb4:	9a01      	ldr	r2, [sp, #4]
    bdb6:	681b      	ldr	r3, [r3, #0]
    bdb8:	429a      	cmp	r2, r3
    bdba:	d001      	beq.n	bdc0 <Output_periodic+0x14>
    bdbc:	f7f6 fcb8 	bl	2730 <__stack_chk_fail>
}
    bdc0:	b003      	add	sp, #12
    bdc2:	f85d eb04 	ldr.w	lr, [sp], #4
	USB_periodic();
    bdc6:	f000 bd95 	b.w	c8f4 <USB_periodic>
    bdca:	bf00      	nop
    bdcc:	1fff89d0 	.word	0x1fff89d0

0000bdd0 <Output_firmwareReload>:


// Sets the device into firmware reload mode
inline void Output_firmwareReload()
{
    bdd0:	b507      	push	{r0, r1, r2, lr}
    bdd2:	4b07      	ldr	r3, [pc, #28]	; (bdf0 <Output_firmwareReload+0x20>)
    bdd4:	681a      	ldr	r2, [r3, #0]
    bdd6:	9201      	str	r2, [sp, #4]
	USB_firmwareReload();
    bdd8:	9a01      	ldr	r2, [sp, #4]
    bdda:	681b      	ldr	r3, [r3, #0]
    bddc:	429a      	cmp	r2, r3
    bdde:	d001      	beq.n	bde4 <Output_firmwareReload+0x14>
    bde0:	f7f6 fca6 	bl	2730 <__stack_chk_fail>
}
    bde4:	b003      	add	sp, #12
    bde6:	f85d eb04 	ldr.w	lr, [sp], #4
	USB_firmwareReload();
    bdea:	f000 bea7 	b.w	cb3c <USB_firmwareReload>
    bdee:	bf00      	nop
    bdf0:	1fff89d0 	.word	0x1fff89d0

0000bdf4 <Output_softReset>:


// Soft Chip Reset
inline void Output_softReset()
{
    bdf4:	b507      	push	{r0, r1, r2, lr}
    bdf6:	4b07      	ldr	r3, [pc, #28]	; (be14 <Output_softReset+0x20>)
    bdf8:	681a      	ldr	r2, [r3, #0]
    bdfa:	9201      	str	r2, [sp, #4]
	USB_softReset();
    bdfc:	9a01      	ldr	r2, [sp, #4]
    bdfe:	681b      	ldr	r3, [r3, #0]
    be00:	429a      	cmp	r2, r3
    be02:	d001      	beq.n	be08 <Output_softReset+0x14>
    be04:	f7f6 fc94 	bl	2730 <__stack_chk_fail>
}
    be08:	b003      	add	sp, #12
    be0a:	f85d eb04 	ldr.w	lr, [sp], #4
	USB_softReset();
    be0e:	f000 bea7 	b.w	cb60 <USB_softReset>
    be12:	bf00      	nop
    be14:	1fff89d0 	.word	0x1fff89d0

0000be18 <Output_availablechar>:


// USB Input buffer available
inline unsigned int Output_availablechar()
{
    be18:	b507      	push	{r0, r1, r2, lr}
    be1a:	4b07      	ldr	r3, [pc, #28]	; (be38 <Output_availablechar+0x20>)
    be1c:	681a      	ldr	r2, [r3, #0]
    be1e:	9201      	str	r2, [sp, #4]
	return USB_availablechar();
    be20:	9a01      	ldr	r2, [sp, #4]
    be22:	681b      	ldr	r3, [r3, #0]
    be24:	429a      	cmp	r2, r3
    be26:	d001      	beq.n	be2c <Output_availablechar+0x14>
    be28:	f7f6 fc82 	bl	2730 <__stack_chk_fail>
}
    be2c:	b003      	add	sp, #12
    be2e:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_availablechar();
    be32:	f000 beab 	b.w	cb8c <USB_availablechar>
    be36:	bf00      	nop
    be38:	1fff89d0 	.word	0x1fff89d0

0000be3c <Output_getchar>:


// USB Get Character from input buffer
inline int Output_getchar()
{
    be3c:	b507      	push	{r0, r1, r2, lr}
    be3e:	4b07      	ldr	r3, [pc, #28]	; (be5c <Output_getchar+0x20>)
    be40:	681a      	ldr	r2, [r3, #0]
    be42:	9201      	str	r2, [sp, #4]
	return USB_getchar();
    be44:	9a01      	ldr	r2, [sp, #4]
    be46:	681b      	ldr	r3, [r3, #0]
    be48:	429a      	cmp	r2, r3
    be4a:	d001      	beq.n	be50 <Output_getchar+0x14>
    be4c:	f7f6 fc70 	bl	2730 <__stack_chk_fail>
}
    be50:	b003      	add	sp, #12
    be52:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_getchar();
    be56:	f000 beab 	b.w	cbb0 <USB_getchar>
    be5a:	bf00      	nop
    be5c:	1fff89d0 	.word	0x1fff89d0

0000be60 <Output_putstr>:
}


// USB Send String to output buffer, null terminated
inline int Output_putstr( char* str )
{
    be60:	b507      	push	{r0, r1, r2, lr}
    be62:	4b07      	ldr	r3, [pc, #28]	; (be80 <Output_putstr+0x20>)
    be64:	681a      	ldr	r2, [r3, #0]
    be66:	9201      	str	r2, [sp, #4]
	return USB_putstr( str );
    be68:	9a01      	ldr	r2, [sp, #4]
    be6a:	681b      	ldr	r3, [r3, #0]
    be6c:	429a      	cmp	r2, r3
    be6e:	d001      	beq.n	be74 <Output_putstr+0x14>
    be70:	f7f6 fc5e 	bl	2730 <__stack_chk_fail>
}
    be74:	b003      	add	sp, #12
    be76:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_putstr( str );
    be7a:	f000 beab 	b.w	cbd4 <USB_putstr>
    be7e:	bf00      	nop
    be80:	1fff89d0 	.word	0x1fff89d0

0000be84 <Output_rawio_availablechar>:


// USB RawIO buffer available
unsigned int Output_rawio_availablechar()
{
    be84:	b507      	push	{r0, r1, r2, lr}
    be86:	4b07      	ldr	r3, [pc, #28]	; (bea4 <Output_rawio_availablechar+0x20>)
    be88:	681a      	ldr	r2, [r3, #0]
    be8a:	9201      	str	r2, [sp, #4]
	return USB_rawio_availablechar();
    be8c:	9a01      	ldr	r2, [sp, #4]
    be8e:	681b      	ldr	r3, [r3, #0]
    be90:	429a      	cmp	r2, r3
    be92:	d001      	beq.n	be98 <Output_rawio_availablechar+0x14>
    be94:	f7f6 fc4c 	bl	2730 <__stack_chk_fail>
}
    be98:	b003      	add	sp, #12
    be9a:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_rawio_availablechar();
    be9e:	f000 beb1 	b.w	cc04 <USB_rawio_availablechar>
    bea2:	bf00      	nop
    bea4:	1fff89d0 	.word	0x1fff89d0

0000bea8 <Output_rawio_getbuffer>:


// USB RawIO get buffer
int Output_rawio_getbuffer( char* buffer )
{
    bea8:	b507      	push	{r0, r1, r2, lr}
    beaa:	4b07      	ldr	r3, [pc, #28]	; (bec8 <Output_rawio_getbuffer+0x20>)
    beac:	681a      	ldr	r2, [r3, #0]
    beae:	9201      	str	r2, [sp, #4]
	return USB_rawio_getbuffer( buffer );
    beb0:	9a01      	ldr	r2, [sp, #4]
    beb2:	681b      	ldr	r3, [r3, #0]
    beb4:	429a      	cmp	r2, r3
    beb6:	d001      	beq.n	bebc <Output_rawio_getbuffer+0x14>
    beb8:	f7f6 fc3a 	bl	2730 <__stack_chk_fail>
}
    bebc:	b003      	add	sp, #12
    bebe:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_rawio_getbuffer( buffer );
    bec2:	f000 beb1 	b.w	cc28 <USB_rawio_getbuffer>
    bec6:	bf00      	nop
    bec8:	1fff89d0 	.word	0x1fff89d0

0000becc <Output_rawio_sendbuffer>:


// USB RawIO send buffer
int Output_rawio_sendbuffer( char* buffer )
{
    becc:	b507      	push	{r0, r1, r2, lr}
    bece:	4b07      	ldr	r3, [pc, #28]	; (beec <Output_rawio_sendbuffer+0x20>)
    bed0:	681a      	ldr	r2, [r3, #0]
    bed2:	9201      	str	r2, [sp, #4]
	return USB_rawio_sendbuffer( buffer );
    bed4:	9a01      	ldr	r2, [sp, #4]
    bed6:	681b      	ldr	r3, [r3, #0]
    bed8:	429a      	cmp	r2, r3
    beda:	d001      	beq.n	bee0 <Output_rawio_sendbuffer+0x14>
    bedc:	f7f6 fc28 	bl	2730 <__stack_chk_fail>
}
    bee0:	b003      	add	sp, #12
    bee2:	f85d eb04 	ldr.w	lr, [sp], #4
	return USB_rawio_sendbuffer( buffer );
    bee6:	f000 beb1 	b.w	cc4c <USB_rawio_sendbuffer>
    beea:	bf00      	nop
    beec:	1fff89d0 	.word	0x1fff89d0

0000bef0 <cliFunc_readLEDs>:
	}
}


void cliFunc_readLEDs( char* args )
{
    bef0:	b513      	push	{r0, r1, r4, lr}
    bef2:	4c0b      	ldr	r4, [pc, #44]	; (bf20 <cliFunc_readLEDs+0x30>)
	print( NL );
    bef4:	480b      	ldr	r0, [pc, #44]	; (bf24 <cliFunc_readLEDs+0x34>)
{
    bef6:	6823      	ldr	r3, [r4, #0]
    bef8:	9301      	str	r3, [sp, #4]
	print( NL );
    befa:	f003 fb39 	bl	f570 <_print>
	info_msg("LED State: ");
    befe:	480a      	ldr	r0, [pc, #40]	; (bf28 <cliFunc_readLEDs+0x38>)
    bf00:	f003 fb36 	bl	f570 <_print>
	printInt8( USBKeys_LEDs );
    bf04:	4b09      	ldr	r3, [pc, #36]	; (bf2c <cliFunc_readLEDs+0x3c>)
    bf06:	7818      	ldrb	r0, [r3, #0]
    bf08:	9a01      	ldr	r2, [sp, #4]
    bf0a:	6823      	ldr	r3, [r4, #0]
    bf0c:	429a      	cmp	r2, r3
    bf0e:	b2c0      	uxtb	r0, r0
    bf10:	d001      	beq.n	bf16 <cliFunc_readLEDs+0x26>
    bf12:	f7f6 fc0d 	bl	2730 <__stack_chk_fail>
}
    bf16:	b002      	add	sp, #8
    bf18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( USBKeys_LEDs );
    bf1c:	f003 bb92 	b.w	f644 <printInt8>
    bf20:	1fff89d0 	.word	0x1fff89d0
    bf24:	00015df4 	.word	0x00015df4
    bf28:	00015e95 	.word	0x00015e95
    bf2c:	1fffb32b 	.word	0x1fffb32b

0000bf30 <cliFunc_usbAddr>:


void cliFunc_usbAddr( char* args )
{
    bf30:	b513      	push	{r0, r1, r4, lr}
    bf32:	4c0b      	ldr	r4, [pc, #44]	; (bf60 <cliFunc_usbAddr+0x30>)
	print(NL);
    bf34:	480b      	ldr	r0, [pc, #44]	; (bf64 <cliFunc_usbAddr+0x34>)
{
    bf36:	6823      	ldr	r3, [r4, #0]
    bf38:	9301      	str	r3, [sp, #4]
	print(NL);
    bf3a:	f003 fb19 	bl	f570 <_print>
	info_msg("USB Address: ");
    bf3e:	480a      	ldr	r0, [pc, #40]	; (bf68 <cliFunc_usbAddr+0x38>)
    bf40:	f003 fb16 	bl	f570 <_print>
	printInt8( USBDev_Address );
    bf44:	4b09      	ldr	r3, [pc, #36]	; (bf6c <cliFunc_usbAddr+0x3c>)
    bf46:	7818      	ldrb	r0, [r3, #0]
    bf48:	9a01      	ldr	r2, [sp, #4]
    bf4a:	6823      	ldr	r3, [r4, #0]
    bf4c:	429a      	cmp	r2, r3
    bf4e:	b2c0      	uxtb	r0, r0
    bf50:	d001      	beq.n	bf56 <cliFunc_usbAddr+0x26>
    bf52:	f7f6 fbed 	bl	2730 <__stack_chk_fail>
}
    bf56:	b002      	add	sp, #8
    bf58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( USBDev_Address );
    bf5c:	f003 bb72 	b.w	f644 <printInt8>
    bf60:	1fff89d0 	.word	0x1fff89d0
    bf64:	00015df4 	.word	0x00015df4
    bf68:	00015eb3 	.word	0x00015eb3
    bf6c:	1fffb302 	.word	0x1fffb302

0000bf70 <cliFunc_idle>:
{
    bf70:	b530      	push	{r4, r5, lr}
    bf72:	4c15      	ldr	r4, [pc, #84]	; (bfc8 <cliFunc_idle+0x58>)
    bf74:	b085      	sub	sp, #20
    bf76:	6823      	ldr	r3, [r4, #0]
    bf78:	9303      	str	r3, [sp, #12]
    bf7a:	4605      	mov	r5, r0
	print( NL );
    bf7c:	4813      	ldr	r0, [pc, #76]	; (bfcc <cliFunc_idle+0x5c>)
    bf7e:	f003 faf7 	bl	f570 <_print>
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    bf82:	4628      	mov	r0, r5
    bf84:	aa02      	add	r2, sp, #8
    bf86:	a901      	add	r1, sp, #4
    bf88:	f002 fdc4 	bl	eb14 <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    bf8c:	9801      	ldr	r0, [sp, #4]
    bf8e:	4d10      	ldr	r5, [pc, #64]	; (bfd0 <cliFunc_idle+0x60>)
    bf90:	7803      	ldrb	r3, [r0, #0]
    bf92:	b11b      	cbz	r3, bf9c <cliFunc_idle+0x2c>
		uint8_t idle = (uint8_t)numToInt( arg1Ptr );
    bf94:	f003 fcbc 	bl	f910 <numToInt>
    bf98:	b2c0      	uxtb	r0, r0
		USBKeys_Idle_Config = idle;
    bf9a:	7028      	strb	r0, [r5, #0]
	info_msg("USB Idle Config: ");
    bf9c:	480d      	ldr	r0, [pc, #52]	; (bfd4 <cliFunc_idle+0x64>)
    bf9e:	f003 fae7 	bl	f570 <_print>
	printInt16( 4 * USBKeys_Idle_Config );
    bfa2:	7828      	ldrb	r0, [r5, #0]
    bfa4:	0080      	lsls	r0, r0, #2
    bfa6:	f003 fb83 	bl	f6b0 <printInt16>
	print(" ms - ");
    bfaa:	480b      	ldr	r0, [pc, #44]	; (bfd8 <cliFunc_idle+0x68>)
    bfac:	f003 fae0 	bl	f570 <_print>
	printInt8( USBKeys_Idle_Config );
    bfb0:	7828      	ldrb	r0, [r5, #0]
    bfb2:	f003 fb47 	bl	f644 <printInt8>
}
    bfb6:	9a03      	ldr	r2, [sp, #12]
    bfb8:	6823      	ldr	r3, [r4, #0]
    bfba:	429a      	cmp	r2, r3
    bfbc:	d001      	beq.n	bfc2 <cliFunc_idle+0x52>
    bfbe:	f7f6 fbb7 	bl	2730 <__stack_chk_fail>
    bfc2:	b005      	add	sp, #20
    bfc4:	bd30      	pop	{r4, r5, pc}
    bfc6:	bf00      	nop
    bfc8:	1fff89d0 	.word	0x1fff89d0
    bfcc:	00015df4 	.word	0x00015df4
    bfd0:	1fff9728 	.word	0x1fff9728
    bfd4:	00015e13 	.word	0x00015e13
    bfd8:	00015e37 	.word	0x00015e37

0000bfdc <cliFunc_usbConf>:


void cliFunc_usbConf( char* args )
{
    bfdc:	b513      	push	{r0, r1, r4, lr}
    bfde:	4c0b      	ldr	r4, [pc, #44]	; (c00c <cliFunc_usbConf+0x30>)
	print(NL);
    bfe0:	480b      	ldr	r0, [pc, #44]	; (c010 <cliFunc_usbConf+0x34>)
{
    bfe2:	6823      	ldr	r3, [r4, #0]
    bfe4:	9301      	str	r3, [sp, #4]
	print(NL);
    bfe6:	f003 fac3 	bl	f570 <_print>
	info_msg("USB Configured: ");
    bfea:	480a      	ldr	r0, [pc, #40]	; (c014 <cliFunc_usbConf+0x38>)
    bfec:	f003 fac0 	bl	f570 <_print>
#if !defined(_host_)
	printInt8( usb_configured() );
    bff0:	f001 fd98 	bl	db24 <usb_configured>
    bff4:	9a01      	ldr	r2, [sp, #4]
    bff6:	6823      	ldr	r3, [r4, #0]
    bff8:	429a      	cmp	r2, r3
    bffa:	d001      	beq.n	c000 <cliFunc_usbConf+0x24>
    bffc:	f7f6 fb98 	bl	2730 <__stack_chk_fail>
#endif
}
    c000:	b002      	add	sp, #8
    c002:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printInt8( usb_configured() );
    c006:	f003 bb1d 	b.w	f644 <printInt8>
    c00a:	bf00      	nop
    c00c:	1fff89d0 	.word	0x1fff89d0
    c010:	00015df4 	.word	0x00015df4
    c014:	00015ed3 	.word	0x00015ed3

0000c018 <cliFunc_usbInitTime>:


void cliFunc_usbInitTime( char* args )
{
    c018:	b513      	push	{r0, r1, r4, lr}
    c01a:	4c11      	ldr	r4, [pc, #68]	; (c060 <cliFunc_usbInitTime+0x48>)
	// Calculate overall USB initialization time
	// XXX A protocol analyzer will be more accurate, however, this is built-in and easier to collect data
	print(NL);
    c01c:	4811      	ldr	r0, [pc, #68]	; (c064 <cliFunc_usbInitTime+0x4c>)
{
    c01e:	6823      	ldr	r3, [r4, #0]
    c020:	9301      	str	r3, [sp, #4]
	print(NL);
    c022:	f003 faa5 	bl	f570 <_print>
	info_msg("USB Init Time: ");
    c026:	4810      	ldr	r0, [pc, #64]	; (c068 <cliFunc_usbInitTime+0x50>)
    c028:	f003 faa2 	bl	f570 <_print>
	printInt32( USBInit_TimeEnd - USBInit_TimeStart );
    c02c:	4b0f      	ldr	r3, [pc, #60]	; (c06c <cliFunc_usbInitTime+0x54>)
    c02e:	6818      	ldr	r0, [r3, #0]
    c030:	4b0f      	ldr	r3, [pc, #60]	; (c070 <cliFunc_usbInitTime+0x58>)
    c032:	681b      	ldr	r3, [r3, #0]
    c034:	1ac0      	subs	r0, r0, r3
    c036:	f003 fb71 	bl	f71c <printInt32>
	print(" ms - ");
    c03a:	480e      	ldr	r0, [pc, #56]	; (c074 <cliFunc_usbInitTime+0x5c>)
    c03c:	f003 fa98 	bl	f570 <_print>
	printInt16( USBInit_Ticks );
    c040:	4b0d      	ldr	r3, [pc, #52]	; (c078 <cliFunc_usbInitTime+0x60>)
    c042:	8818      	ldrh	r0, [r3, #0]
    c044:	f003 fb34 	bl	f6b0 <printInt16>
	print(" ticks");
    c048:	9a01      	ldr	r2, [sp, #4]
    c04a:	6823      	ldr	r3, [r4, #0]
    c04c:	429a      	cmp	r2, r3
    c04e:	d001      	beq.n	c054 <cliFunc_usbInitTime+0x3c>
    c050:	f7f6 fb6e 	bl	2730 <__stack_chk_fail>
    c054:	4809      	ldr	r0, [pc, #36]	; (c07c <cliFunc_usbInitTime+0x64>)
}
    c056:	b002      	add	sp, #8
    c058:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print(" ticks");
    c05c:	f003 ba88 	b.w	f570 <_print>
    c060:	1fff89d0 	.word	0x1fff89d0
    c064:	00015df4 	.word	0x00015df4
    c068:	00015ef6 	.word	0x00015ef6
    c06c:	1fffb2d4 	.word	0x1fffb2d4
    c070:	1fffb334 	.word	0x1fffb334
    c074:	00015e37 	.word	0x00015e37
    c078:	1fffb2de 	.word	0x1fffb2de
    c07c:	0000fb91 	.word	0x0000fb91

0000c080 <cliFunc_kbdProtocol>:
{
    c080:	b530      	push	{r4, r5, lr}
    c082:	4c15      	ldr	r4, [pc, #84]	; (c0d8 <cliFunc_kbdProtocol+0x58>)
    c084:	b085      	sub	sp, #20
    c086:	6823      	ldr	r3, [r4, #0]
    c088:	9303      	str	r3, [sp, #12]
    c08a:	4605      	mov	r5, r0
	print( NL );
    c08c:	4813      	ldr	r0, [pc, #76]	; (c0dc <cliFunc_kbdProtocol+0x5c>)
    c08e:	f003 fa6f 	bl	f570 <_print>
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    c092:	4628      	mov	r0, r5
    c094:	aa02      	add	r2, sp, #8
    c096:	a901      	add	r1, sp, #4
    c098:	f002 fd3c 	bl	eb14 <CLI_argumentIsolation>
	if ( arg1Ptr[0] != '\0' )
    c09c:	9801      	ldr	r0, [sp, #4]
    c09e:	7803      	ldrb	r3, [r0, #0]
    c0a0:	b1b3      	cbz	r3, c0d0 <cliFunc_kbdProtocol+0x50>
		uint8_t mode = (uint8_t)numToInt( arg1Ptr );
    c0a2:	f003 fc35 	bl	f910 <numToInt>
    c0a6:	b2c0      	uxtb	r0, r0
		if ( mode == 0 || mode == 1 )
    c0a8:	2801      	cmp	r0, #1
    c0aa:	d80b      	bhi.n	c0c4 <cliFunc_kbdProtocol+0x44>
			USBKeys_Protocol_New = mode;
    c0ac:	4b0c      	ldr	r3, [pc, #48]	; (c0e0 <cliFunc_kbdProtocol+0x60>)
    c0ae:	7018      	strb	r0, [r3, #0]
			USBKeys_Protocol_Change = 1;
    c0b0:	4b0c      	ldr	r3, [pc, #48]	; (c0e4 <cliFunc_kbdProtocol+0x64>)
			info_msg("Setting Keyboard Protocol to: ");
    c0b2:	480d      	ldr	r0, [pc, #52]	; (c0e8 <cliFunc_kbdProtocol+0x68>)
			USBKeys_Protocol_Change = 1;
    c0b4:	2201      	movs	r2, #1
    c0b6:	701a      	strb	r2, [r3, #0]
		info_msg("Keyboard Protocol: ");
    c0b8:	f003 fa5a 	bl	f570 <_print>
		printInt8( USBKeys_Protocol );
    c0bc:	4b0b      	ldr	r3, [pc, #44]	; (c0ec <cliFunc_kbdProtocol+0x6c>)
    c0be:	7818      	ldrb	r0, [r3, #0]
    c0c0:	f003 fac0 	bl	f644 <printInt8>
}
    c0c4:	9a03      	ldr	r2, [sp, #12]
    c0c6:	6823      	ldr	r3, [r4, #0]
    c0c8:	429a      	cmp	r2, r3
    c0ca:	d003      	beq.n	c0d4 <cliFunc_kbdProtocol+0x54>
    c0cc:	f7f6 fb30 	bl	2730 <__stack_chk_fail>
		info_msg("Keyboard Protocol: ");
    c0d0:	4807      	ldr	r0, [pc, #28]	; (c0f0 <cliFunc_kbdProtocol+0x70>)
    c0d2:	e7f1      	b.n	c0b8 <cliFunc_kbdProtocol+0x38>
}
    c0d4:	b005      	add	sp, #20
    c0d6:	bd30      	pop	{r4, r5, pc}
    c0d8:	1fff89d0 	.word	0x1fff89d0
    c0dc:	00015df4 	.word	0x00015df4
    c0e0:	1fff8e45 	.word	0x1fff8e45
    c0e4:	1fffb330 	.word	0x1fffb330
    c0e8:	00015e3e 	.word	0x00015e3e
    c0ec:	1fff8e44 	.word	0x1fff8e44
    c0f0:	00015e6f 	.word	0x00015e6f

0000c0f4 <Output_consCtrlSend_capability>:
{
    c0f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    c0f6:	4d20      	ldr	r5, [pc, #128]	; (c178 <Output_consCtrlSend_capability+0x84>)
    c0f8:	4608      	mov	r0, r1
    c0fa:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c0fc:	4611      	mov	r1, r2
{
    c0fe:	682b      	ldr	r3, [r5, #0]
    c100:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c102:	f7fa fb1d 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    c106:	2802      	cmp	r0, #2
    c108:	462e      	mov	r6, r5
    c10a:	d025      	beq.n	c158 <Output_consCtrlSend_capability+0x64>
    c10c:	d807      	bhi.n	c11e <Output_consCtrlSend_capability+0x2a>
    c10e:	2801      	cmp	r0, #1
    c110:	d018      	beq.n	c144 <Output_consCtrlSend_capability+0x50>
}
    c112:	9a01      	ldr	r2, [sp, #4]
    c114:	6833      	ldr	r3, [r6, #0]
    c116:	429a      	cmp	r2, r3
    c118:	d112      	bne.n	c140 <Output_consCtrlSend_capability+0x4c>
    c11a:	b002      	add	sp, #8
    c11c:	bd70      	pop	{r4, r5, r6, pc}
	switch ( cstate )
    c11e:	2803      	cmp	r0, #3
    c120:	d017      	beq.n	c152 <Output_consCtrlSend_capability+0x5e>
    c122:	28ff      	cmp	r0, #255	; 0xff
    c124:	d1f5      	bne.n	c112 <Output_consCtrlSend_capability+0x1e>
		print("Output_consCtrlSend(consCode)");
    c126:	4815      	ldr	r0, [pc, #84]	; (c17c <Output_consCtrlSend_capability+0x88>)
    c128:	f003 fa22 	bl	f570 <_print>
		if ( args != 0 )
    c12c:	2c00      	cmp	r4, #0
    c12e:	d0f0      	beq.n	c112 <Output_consCtrlSend_capability+0x1e>
			print(" -> ");
    c130:	4813      	ldr	r0, [pc, #76]	; (c180 <Output_consCtrlSend_capability+0x8c>)
			uint16_t key = *(uint16_t*)(&args[0]);
    c132:	8824      	ldrh	r4, [r4, #0]
			print(" -> ");
    c134:	f003 fa1c 	bl	f570 <_print>
			printInt16( key );
    c138:	9a01      	ldr	r2, [sp, #4]
    c13a:	682b      	ldr	r3, [r5, #0]
    c13c:	429a      	cmp	r2, r3
    c13e:	d015      	beq.n	c16c <Output_consCtrlSend_capability+0x78>
}
    c140:	f7f6 faf6 	bl	2730 <__stack_chk_fail>
		USBKeys_primary.changed |= USBKeyChangeState_Consumer;
    c144:	4a0f      	ldr	r2, [pc, #60]	; (c184 <Output_consCtrlSend_capability+0x90>)
    c146:	f892 3020 	ldrb.w	r3, [r2, #32]
    c14a:	f043 0308 	orr.w	r3, r3, #8
    c14e:	f882 3020 	strb.w	r3, [r2, #32]
	USBKeys_primary.cons_ctrl = *(uint16_t*)(&args[0]);
    c152:	8822      	ldrh	r2, [r4, #0]
    c154:	4b0b      	ldr	r3, [pc, #44]	; (c184 <Output_consCtrlSend_capability+0x90>)
    c156:	e007      	b.n	c168 <Output_consCtrlSend_capability+0x74>
		USBKeys_primary.changed |= USBKeyChangeState_Consumer;
    c158:	4b0a      	ldr	r3, [pc, #40]	; (c184 <Output_consCtrlSend_capability+0x90>)
    c15a:	f893 2020 	ldrb.w	r2, [r3, #32]
    c15e:	f042 0208 	orr.w	r2, r2, #8
    c162:	f883 2020 	strb.w	r2, [r3, #32]
		USBKeys_primary.cons_ctrl = 0;
    c166:	2200      	movs	r2, #0
	USBKeys_primary.cons_ctrl = *(uint16_t*)(&args[0]);
    c168:	83da      	strh	r2, [r3, #30]
    c16a:	e7d2      	b.n	c112 <Output_consCtrlSend_capability+0x1e>
			printInt16( key );
    c16c:	4620      	mov	r0, r4
}
    c16e:	b002      	add	sp, #8
    c170:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt16( key );
    c174:	f003 ba9c 	b.w	f6b0 <printInt16>
    c178:	1fff89d0 	.word	0x1fff89d0
    c17c:	00015be7 	.word	0x00015be7
    c180:	00010c65 	.word	0x00010c65
    c184:	1fffb306 	.word	0x1fffb306

0000c188 <Output_noneSend_capability>:
{
    c188:	b513      	push	{r0, r1, r4, lr}
    c18a:	4c0c      	ldr	r4, [pc, #48]	; (c1bc <Output_noneSend_capability+0x34>)
    c18c:	4608      	mov	r0, r1
    c18e:	6823      	ldr	r3, [r4, #0]
    c190:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c192:	4611      	mov	r1, r2
    c194:	f7fa fad4 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    c198:	28ff      	cmp	r0, #255	; 0xff
		print("Output_noneSend()");
    c19a:	9a01      	ldr	r2, [sp, #4]
    c19c:	6823      	ldr	r3, [r4, #0]
	switch ( cstate )
    c19e:	d109      	bne.n	c1b4 <Output_noneSend_capability+0x2c>
		print("Output_noneSend()");
    c1a0:	429a      	cmp	r2, r3
    c1a2:	d001      	beq.n	c1a8 <Output_noneSend_capability+0x20>
}
    c1a4:	f7f6 fac4 	bl	2730 <__stack_chk_fail>
		print("Output_noneSend()");
    c1a8:	4805      	ldr	r0, [pc, #20]	; (c1c0 <Output_noneSend_capability+0x38>)
}
    c1aa:	b002      	add	sp, #8
    c1ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		print("Output_noneSend()");
    c1b0:	f003 b9de 	b.w	f570 <_print>
}
    c1b4:	429a      	cmp	r2, r3
    c1b6:	d1f5      	bne.n	c1a4 <Output_noneSend_capability+0x1c>
    c1b8:	b002      	add	sp, #8
    c1ba:	bd10      	pop	{r4, pc}
    c1bc:	1fff89d0 	.word	0x1fff89d0
    c1c0:	00015c37 	.word	0x00015c37

0000c1c4 <Output_sysCtrlSend_capability>:
{
    c1c4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    c1c6:	4d20      	ldr	r5, [pc, #128]	; (c248 <Output_sysCtrlSend_capability+0x84>)
    c1c8:	4608      	mov	r0, r1
    c1ca:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c1cc:	4611      	mov	r1, r2
{
    c1ce:	682b      	ldr	r3, [r5, #0]
    c1d0:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c1d2:	f7fa fab5 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    c1d6:	2802      	cmp	r0, #2
    c1d8:	462e      	mov	r6, r5
    c1da:	d025      	beq.n	c228 <Output_sysCtrlSend_capability+0x64>
    c1dc:	d807      	bhi.n	c1ee <Output_sysCtrlSend_capability+0x2a>
    c1de:	2801      	cmp	r0, #1
    c1e0:	d018      	beq.n	c214 <Output_sysCtrlSend_capability+0x50>
}
    c1e2:	9a01      	ldr	r2, [sp, #4]
    c1e4:	6833      	ldr	r3, [r6, #0]
    c1e6:	429a      	cmp	r2, r3
    c1e8:	d112      	bne.n	c210 <Output_sysCtrlSend_capability+0x4c>
    c1ea:	b002      	add	sp, #8
    c1ec:	bd70      	pop	{r4, r5, r6, pc}
	switch ( cstate )
    c1ee:	2803      	cmp	r0, #3
    c1f0:	d017      	beq.n	c222 <Output_sysCtrlSend_capability+0x5e>
    c1f2:	28ff      	cmp	r0, #255	; 0xff
    c1f4:	d1f5      	bne.n	c1e2 <Output_sysCtrlSend_capability+0x1e>
		print("Output_sysCtrlSend(sysCode)");
    c1f6:	4815      	ldr	r0, [pc, #84]	; (c24c <Output_sysCtrlSend_capability+0x88>)
    c1f8:	f003 f9ba 	bl	f570 <_print>
		if ( args != 0 )
    c1fc:	2c00      	cmp	r4, #0
    c1fe:	d0f0      	beq.n	c1e2 <Output_sysCtrlSend_capability+0x1e>
			print(" -> ");
    c200:	4813      	ldr	r0, [pc, #76]	; (c250 <Output_sysCtrlSend_capability+0x8c>)
			uint8_t key = args[0];
    c202:	7824      	ldrb	r4, [r4, #0]
			print(" -> ");
    c204:	f003 f9b4 	bl	f570 <_print>
			printInt8( key );
    c208:	9a01      	ldr	r2, [sp, #4]
    c20a:	682b      	ldr	r3, [r5, #0]
    c20c:	429a      	cmp	r2, r3
    c20e:	d015      	beq.n	c23c <Output_sysCtrlSend_capability+0x78>
}
    c210:	f7f6 fa8e 	bl	2730 <__stack_chk_fail>
		USBKeys_primary.changed |= USBKeyChangeState_System;
    c214:	4a0f      	ldr	r2, [pc, #60]	; (c254 <Output_sysCtrlSend_capability+0x90>)
    c216:	f892 3020 	ldrb.w	r3, [r2, #32]
    c21a:	f043 0304 	orr.w	r3, r3, #4
    c21e:	f882 3020 	strb.w	r3, [r2, #32]
	USBKeys_primary.sys_ctrl = args[0];
    c222:	7822      	ldrb	r2, [r4, #0]
    c224:	4b0b      	ldr	r3, [pc, #44]	; (c254 <Output_sysCtrlSend_capability+0x90>)
    c226:	e007      	b.n	c238 <Output_sysCtrlSend_capability+0x74>
		USBKeys_primary.changed |= USBKeyChangeState_System;
    c228:	4b0a      	ldr	r3, [pc, #40]	; (c254 <Output_sysCtrlSend_capability+0x90>)
    c22a:	f893 2020 	ldrb.w	r2, [r3, #32]
    c22e:	f042 0204 	orr.w	r2, r2, #4
    c232:	f883 2020 	strb.w	r2, [r3, #32]
		USBKeys_primary.sys_ctrl = 0;
    c236:	2200      	movs	r2, #0
	USBKeys_primary.sys_ctrl = args[0];
    c238:	775a      	strb	r2, [r3, #29]
    c23a:	e7d2      	b.n	c1e2 <Output_sysCtrlSend_capability+0x1e>
			printInt8( key );
    c23c:	4620      	mov	r0, r4
}
    c23e:	b002      	add	sp, #8
    c240:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			printInt8( key );
    c244:	f003 b9fe 	b.w	f644 <printInt8>
    c248:	1fff89d0 	.word	0x1fff89d0
    c24c:	00015c49 	.word	0x00015c49
    c250:	00010c65 	.word	0x00010c65
    c254:	1fffb306 	.word	0x1fffb306

0000c258 <Output_usbCodeSend_capability>:
{
    c258:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    c25a:	4e80      	ldr	r6, [pc, #512]	; (c45c <Output_usbCodeSend_capability+0x204>)
    c25c:	4608      	mov	r0, r1
    c25e:	461c      	mov	r4, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c260:	4611      	mov	r1, r2
{
    c262:	6833      	ldr	r3, [r6, #0]
    c264:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c266:	f7fa fa6b 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    c26a:	2802      	cmp	r0, #2
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c26c:	4607      	mov	r7, r0
    c26e:	4635      	mov	r5, r6
	switch ( cstate )
    c270:	d019      	beq.n	c2a6 <Output_usbCodeSend_capability+0x4e>
    c272:	28ff      	cmp	r0, #255	; 0xff
    c274:	d003      	beq.n	c27e <Output_usbCodeSend_capability+0x26>
    c276:	2801      	cmp	r0, #1
    c278:	d132      	bne.n	c2e0 <Output_usbCodeSend_capability+0x88>
		keyPress = 1;
    c27a:	4606      	mov	r6, r0
    c27c:	e014      	b.n	c2a8 <Output_usbCodeSend_capability+0x50>
		print("Output_usbCodeSend(usbCode)");
    c27e:	4878      	ldr	r0, [pc, #480]	; (c460 <Output_usbCodeSend_capability+0x208>)
    c280:	f003 f976 	bl	f570 <_print>
		if ( args != 0 )
    c284:	b364      	cbz	r4, c2e0 <Output_usbCodeSend_capability+0x88>
			print(" -> ");
    c286:	4877      	ldr	r0, [pc, #476]	; (c464 <Output_usbCodeSend_capability+0x20c>)
			uint8_t key = args[0];
    c288:	7824      	ldrb	r4, [r4, #0]
			print(" -> ");
    c28a:	f003 f971 	bl	f570 <_print>
			printInt8( key );
    c28e:	9a01      	ldr	r2, [sp, #4]
    c290:	6833      	ldr	r3, [r6, #0]
    c292:	429a      	cmp	r2, r3
    c294:	d001      	beq.n	c29a <Output_usbCodeSend_capability+0x42>
}
    c296:	f7f6 fa4b 	bl	2730 <__stack_chk_fail>
			printInt8( key );
    c29a:	4620      	mov	r0, r4
}
    c29c:	b003      	add	sp, #12
    c29e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			printInt8( key );
    c2a2:	f003 b9cf 	b.w	f644 <printInt8>
	uint8_t keyPress = 0; // Default to key release
    c2a6:	2600      	movs	r6, #0
	if ( Output_DebugMode > 1 )
    c2a8:	4b6f      	ldr	r3, [pc, #444]	; (c468 <Output_usbCodeSend_capability+0x210>)
	uint8_t key = args[0];
    c2aa:	7824      	ldrb	r4, [r4, #0]
	if ( Output_DebugMode > 1 )
    c2ac:	781b      	ldrb	r3, [r3, #0]
    c2ae:	2b01      	cmp	r3, #1
    c2b0:	d90f      	bls.n	c2d2 <Output_usbCodeSend_capability+0x7a>
		print("\033[1;34mUSB\033[0m ");
    c2b2:	486e      	ldr	r0, [pc, #440]	; (c46c <Output_usbCodeSend_capability+0x214>)
    c2b4:	f003 f95c 	bl	f570 <_print>
		printInt8( key );
    c2b8:	4620      	mov	r0, r4
    c2ba:	f003 f9c3 	bl	f644 <printInt8>
		print(" ");
    c2be:	486c      	ldr	r0, [pc, #432]	; (c470 <Output_usbCodeSend_capability+0x218>)
    c2c0:	f003 f956 	bl	f570 <_print>
		switch ( cstate )
    c2c4:	2f01      	cmp	r7, #1
    c2c6:	d011      	beq.n	c2ec <Output_usbCodeSend_capability+0x94>
    c2c8:	2f02      	cmp	r7, #2
    c2ca:	d013      	beq.n	c2f4 <Output_usbCodeSend_capability+0x9c>
		print( NL );
    c2cc:	4869      	ldr	r0, [pc, #420]	; (c474 <Output_usbCodeSend_capability+0x21c>)
    c2ce:	f003 f94f 	bl	f570 <_print>
	switch ( USBKeys_Protocol )
    c2d2:	4b69      	ldr	r3, [pc, #420]	; (c478 <Output_usbCodeSend_capability+0x220>)
    c2d4:	781b      	ldrb	r3, [r3, #0]
    c2d6:	f003 07ff 	and.w	r7, r3, #255	; 0xff
    c2da:	b16b      	cbz	r3, c2f8 <Output_usbCodeSend_capability+0xa0>
    c2dc:	2f01      	cmp	r7, #1
    c2de:	d06f      	beq.n	c3c0 <Output_usbCodeSend_capability+0x168>
}
    c2e0:	9a01      	ldr	r2, [sp, #4]
    c2e2:	682b      	ldr	r3, [r5, #0]
    c2e4:	429a      	cmp	r2, r3
    c2e6:	d1d6      	bne.n	c296 <Output_usbCodeSend_capability+0x3e>
    c2e8:	b003      	add	sp, #12
    c2ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
			print("\033[1;33mP\033[0m");
    c2ec:	4863      	ldr	r0, [pc, #396]	; (c47c <Output_usbCodeSend_capability+0x224>)
			print("\033[1;35mR\033[0m");
    c2ee:	f003 f93f 	bl	f570 <_print>
			break;
    c2f2:	e7eb      	b.n	c2cc <Output_usbCodeSend_capability+0x74>
			print("\033[1;35mR\033[0m");
    c2f4:	4862      	ldr	r0, [pc, #392]	; (c480 <Output_usbCodeSend_capability+0x228>)
    c2f6:	e7fa      	b.n	c2ee <Output_usbCodeSend_capability+0x96>
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    c2f8:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    c2fc:	2be0      	cmp	r3, #224	; 0xe0
    c2fe:	d14a      	bne.n	c396 <Output_usbCodeSend_capability+0x13e>
    c300:	f084 01e0 	eor.w	r1, r4, #224	; 0xe0
    c304:	4b5f      	ldr	r3, [pc, #380]	; (c484 <Output_usbCodeSend_capability+0x22c>)
    c306:	2401      	movs	r4, #1
    c308:	408c      	lsls	r4, r1
    c30a:	b264      	sxtb	r4, r4
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    c30c:	781a      	ldrb	r2, [r3, #0]
			if ( keyPress )
    c30e:	b14e      	cbz	r6, c324 <Output_usbCodeSend_capability+0xcc>
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    c310:	4314      	orrs	r4, r2
    c312:	b2e4      	uxtb	r4, r4
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    c314:	701c      	strb	r4, [r3, #0]
			USBKeys_primary.changed |= USBKeyChangeState_Modifiers;
    c316:	f893 2020 	ldrb.w	r2, [r3, #32]
    c31a:	f042 0201 	orr.w	r2, r2, #1
    c31e:	f883 2020 	strb.w	r2, [r3, #32]
			break;
    c322:	e7dd      	b.n	c2e0 <Output_usbCodeSend_capability+0x88>
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    c324:	ea22 0404 	bic.w	r4, r2, r4
    c328:	e7f4      	b.n	c314 <Output_usbCodeSend_capability+0xbc>
				if ( keyPress && USBKeys_primary.keys[newkey] == key )
    c32a:	b12e      	cbz	r6, c338 <Output_usbCodeSend_capability+0xe0>
    c32c:	4413      	add	r3, r2
    c32e:	785b      	ldrb	r3, [r3, #1]
    c330:	42a3      	cmp	r3, r4
    c332:	d128      	bne.n	c386 <Output_usbCodeSend_capability+0x12e>
					keyFound = 1;
    c334:	4633      	mov	r3, r6
    c336:	e011      	b.n	c35c <Output_usbCodeSend_capability+0x104>
				if ( !keyPress && USBKeys_primary.keys[newkey] == key )
    c338:	eb02 0c03 	add.w	ip, r2, r3
    c33c:	f89c c001 	ldrb.w	ip, [ip, #1]
    c340:	45a4      	cmp	ip, r4
    c342:	d120      	bne.n	c386 <Output_usbCodeSend_capability+0x12e>
					for ( uint8_t pos = newkey; pos < USBKeys_Sent - 1; pos++ )
    c344:	7801      	ldrb	r1, [r0, #0]
    c346:	3901      	subs	r1, #1
    c348:	428b      	cmp	r3, r1
    c34a:	db14      	blt.n	c376 <Output_usbCodeSend_capability+0x11e>
					USBKeys_Sent--;
    c34c:	7803      	ldrb	r3, [r0, #0]
    c34e:	3b01      	subs	r3, #1
    c350:	b2db      	uxtb	r3, r3
    c352:	7003      	strb	r3, [r0, #0]
					USBKeys_primary.changed = USBKeyChangeState_Keys;
    c354:	2302      	movs	r3, #2
    c356:	f882 3020 	strb.w	r3, [r2, #32]
					keyFound = 1;
    c35a:	2301      	movs	r3, #1
			if ( USBKeys_Sent >= USB_BOOT_MAX_KEYS )
    c35c:	7802      	ldrb	r2, [r0, #0]
    c35e:	2a05      	cmp	r2, #5
    c360:	d91e      	bls.n	c3a0 <Output_usbCodeSend_capability+0x148>
				warn_print("USB Key limit reached");
    c362:	9a01      	ldr	r2, [sp, #4]
    c364:	682b      	ldr	r3, [r5, #0]
    c366:	429a      	cmp	r2, r3
    c368:	d195      	bne.n	c296 <Output_usbCodeSend_capability+0x3e>
    c36a:	4847      	ldr	r0, [pc, #284]	; (c488 <Output_usbCodeSend_capability+0x230>)
}
    c36c:	b003      	add	sp, #12
    c36e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			print( NL );
    c372:	f003 b8fd 	b.w	f570 <_print>
						USBKeys_primary.keys[pos] = USBKeys_primary.keys[pos + 1];
    c376:	1c5f      	adds	r7, r3, #1
    c378:	19d1      	adds	r1, r2, r7
    c37a:	4413      	add	r3, r2
    c37c:	7849      	ldrb	r1, [r1, #1]
    c37e:	b2c9      	uxtb	r1, r1
    c380:	7059      	strb	r1, [r3, #1]
					for ( uint8_t pos = newkey; pos < USBKeys_Sent - 1; pos++ )
    c382:	b2fb      	uxtb	r3, r7
    c384:	e7de      	b.n	c344 <Output_usbCodeSend_capability+0xec>
    c386:	3101      	adds	r1, #1
			for ( uint8_t newkey = 0; newkey < USBKeys_Sent; newkey++ )
    c388:	f897 c000 	ldrb.w	ip, [r7]
    c38c:	b2cb      	uxtb	r3, r1
    c38e:	459c      	cmp	ip, r3
    c390:	d8cb      	bhi.n	c32a <Output_usbCodeSend_capability+0xd2>
			uint8_t keyFound = 0;
    c392:	2300      	movs	r3, #0
    c394:	e7e2      	b.n	c35c <Output_usbCodeSend_capability+0x104>
    c396:	4639      	mov	r1, r7
			for ( uint8_t newkey = 0; newkey < USBKeys_Sent; newkey++ )
    c398:	4f3c      	ldr	r7, [pc, #240]	; (c48c <Output_usbCodeSend_capability+0x234>)
    c39a:	4a3a      	ldr	r2, [pc, #232]	; (c484 <Output_usbCodeSend_capability+0x22c>)
    c39c:	4638      	mov	r0, r7
    c39e:	e7f3      	b.n	c388 <Output_usbCodeSend_capability+0x130>
			if ( keyPress && !keyFound )
    c3a0:	2e00      	cmp	r6, #0
    c3a2:	d09d      	beq.n	c2e0 <Output_usbCodeSend_capability+0x88>
    c3a4:	2b00      	cmp	r3, #0
    c3a6:	d19b      	bne.n	c2e0 <Output_usbCodeSend_capability+0x88>
				USBKeys_primary.keys[USBKeys_Sent++] = key;
    c3a8:	7803      	ldrb	r3, [r0, #0]
    c3aa:	b2db      	uxtb	r3, r3
    c3ac:	1c5a      	adds	r2, r3, #1
    c3ae:	b2d2      	uxtb	r2, r2
    c3b0:	7002      	strb	r2, [r0, #0]
    c3b2:	4a34      	ldr	r2, [pc, #208]	; (c484 <Output_usbCodeSend_capability+0x22c>)
    c3b4:	4413      	add	r3, r2
    c3b6:	705c      	strb	r4, [r3, #1]
				USBKeys_primary.changed = USBKeyChangeState_Keys;
    c3b8:	2302      	movs	r3, #2
			USBKeys_primary.changed |= USBKeyChangeState_Keys;
    c3ba:	f882 3020 	strb.w	r3, [r2, #32]
			break;
    c3be:	e78f      	b.n	c2e0 <Output_usbCodeSend_capability+0x88>
		if ( (key & 0xE0) == 0xE0 ) // AND with 0xE0 (Left Ctrl, first modifier)
    c3c0:	f004 03e0 	and.w	r3, r4, #224	; 0xe0
    c3c4:	2be0      	cmp	r3, #224	; 0xe0
    c3c6:	d10e      	bne.n	c3e6 <Output_usbCodeSend_capability+0x18e>
    c3c8:	f084 04e0 	eor.w	r4, r4, #224	; 0xe0
    c3cc:	4b2d      	ldr	r3, [pc, #180]	; (c484 <Output_usbCodeSend_capability+0x22c>)
    c3ce:	fa07 f104 	lsl.w	r1, r7, r4
    c3d2:	b249      	sxtb	r1, r1
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    c3d4:	781c      	ldrb	r4, [r3, #0]
			if ( keyPress )
    c3d6:	b11e      	cbz	r6, c3e0 <Output_usbCodeSend_capability+0x188>
				USBKeys_primary.modifiers |= 1 << (key ^ 0xE0); // Left shift 1 by key XOR 0xE0
    c3d8:	4321      	orrs	r1, r4
    c3da:	b2c9      	uxtb	r1, r1
				USBKeys_primary.modifiers &= ~(1 << (key ^ 0xE0)); // Left shift 1 by key XOR 0xE0
    c3dc:	7019      	strb	r1, [r3, #0]
    c3de:	e79a      	b.n	c316 <Output_usbCodeSend_capability+0xbe>
    c3e0:	ea24 0101 	bic.w	r1, r4, r1
    c3e4:	e7fa      	b.n	c3dc <Output_usbCodeSend_capability+0x184>
		else if ( key >= 1 && key <= 221 )
    c3e6:	1e62      	subs	r2, r4, #1
    c3e8:	b2d2      	uxtb	r2, r2
    c3ea:	2adc      	cmp	r2, #220	; 0xdc
    c3ec:	d819      	bhi.n	c422 <Output_usbCodeSend_capability+0x1ca>
    c3ee:	4b28      	ldr	r3, [pc, #160]	; (c490 <Output_usbCodeSend_capability+0x238>)
    c3f0:	4826      	ldr	r0, [pc, #152]	; (c48c <Output_usbCodeSend_capability+0x234>)
    c3f2:	5c9c      	ldrb	r4, [r3, r2]
    c3f4:	4b27      	ldr	r3, [pc, #156]	; (c494 <Output_usbCodeSend_capability+0x23c>)
    c3f6:	5c9b      	ldrb	r3, [r3, r2]
			USBKeys_primary.changed |= USBKeyChangeState_Keys;
    c3f8:	4a22      	ldr	r2, [pc, #136]	; (c484 <Output_usbCodeSend_capability+0x22c>)
    c3fa:	f892 1020 	ldrb.w	r1, [r2, #32]
    c3fe:	f041 0102 	orr.w	r1, r1, #2
    c402:	f882 1020 	strb.w	r1, [r2, #32]
    c406:	fa07 f103 	lsl.w	r1, r7, r3
    c40a:	b249      	sxtb	r1, r1
    c40c:	1913      	adds	r3, r2, r4
		if ( keyPress )
    c40e:	b1ee      	cbz	r6, c44c <Output_usbCodeSend_capability+0x1f4>
			USBKeys_primary.keys[bytePosition] |= (1 << byteShift);
    c410:	785a      	ldrb	r2, [r3, #1]
    c412:	4311      	orrs	r1, r2
    c414:	b2c9      	uxtb	r1, r1
    c416:	7059      	strb	r1, [r3, #1]
			USBKeys_Sent--;
    c418:	7803      	ldrb	r3, [r0, #0]
    c41a:	3b01      	subs	r3, #1
			USBKeys_Sent++;
    c41c:	b2db      	uxtb	r3, r3
    c41e:	7003      	strb	r3, [r0, #0]
    c420:	e75e      	b.n	c2e0 <Output_usbCodeSend_capability+0x88>
		else if ( key == 0x00 )
    c422:	b92c      	cbnz	r4, c430 <Output_usbCodeSend_capability+0x1d8>
			USBKeys_primary.changed |= USBKeyChangeState_Keys;
    c424:	4a17      	ldr	r2, [pc, #92]	; (c484 <Output_usbCodeSend_capability+0x22c>)
    c426:	f892 3020 	ldrb.w	r3, [r2, #32]
    c42a:	f043 0302 	orr.w	r3, r3, #2
    c42e:	e7c4      	b.n	c3ba <Output_usbCodeSend_capability+0x162>
			warn_msg("USB Code not within 4-155 (0x4-0x9B), 157-164 (0x9D-0xA4), 176-221 (0xB0-0xDD) or 224-231 (0xE0-0xE7) NKRO Mode: ");
    c430:	4819      	ldr	r0, [pc, #100]	; (c498 <Output_usbCodeSend_capability+0x240>)
    c432:	f003 f89d 	bl	f570 <_print>
			printHex( key );
    c436:	4639      	mov	r1, r7
    c438:	4620      	mov	r0, r4
    c43a:	f003 f9bf 	bl	f7bc <printHex_op>
			print( NL );
    c43e:	9a01      	ldr	r2, [sp, #4]
    c440:	682b      	ldr	r3, [r5, #0]
    c442:	429a      	cmp	r2, r3
    c444:	f47f af27 	bne.w	c296 <Output_usbCodeSend_capability+0x3e>
    c448:	480a      	ldr	r0, [pc, #40]	; (c474 <Output_usbCodeSend_capability+0x21c>)
    c44a:	e78f      	b.n	c36c <Output_usbCodeSend_capability+0x114>
			USBKeys_primary.keys[bytePosition] &= ~(1 << byteShift);
    c44c:	785a      	ldrb	r2, [r3, #1]
    c44e:	ea22 0101 	bic.w	r1, r2, r1
    c452:	7059      	strb	r1, [r3, #1]
			USBKeys_Sent++;
    c454:	7803      	ldrb	r3, [r0, #0]
    c456:	3301      	adds	r3, #1
    c458:	e7e0      	b.n	c41c <Output_usbCodeSend_capability+0x1c4>
    c45a:	bf00      	nop
    c45c:	1fff89d0 	.word	0x1fff89d0
    c460:	00015c80 	.word	0x00015c80
    c464:	00010c65 	.word	0x00010c65
    c468:	1fffb2c6 	.word	0x1fffb2c6
    c46c:	00015c9c 	.word	0x00015c9c
    c470:	00016f5e 	.word	0x00016f5e
    c474:	00015df4 	.word	0x00015df4
    c478:	1fff8e44 	.word	0x1fff8e44
    c47c:	0000fda7 	.word	0x0000fda7
    c480:	0000fdc1 	.word	0x0000fdc1
    c484:	1fffb306 	.word	0x1fffb306
    c488:	00015cac 	.word	0x00015cac
    c48c:	1fffb303 	.word	0x1fffb303
    c490:	00015a29 	.word	0x00015a29
    c494:	00015b08 	.word	0x00015b08
    c498:	00015cd9 	.word	0x00015cd9

0000c49c <Output_usbMouse_capability>:
{
    c49c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    c49e:	4f29      	ldr	r7, [pc, #164]	; (c544 <Output_usbMouse_capability+0xa8>)
    c4a0:	461c      	mov	r4, r3
    c4a2:	4608      	mov	r0, r1
    c4a4:	683b      	ldr	r3, [r7, #0]
    c4a6:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c4a8:	4611      	mov	r1, r2
    c4aa:	f7fa f949 	bl	6740 <KLL_CapabilityState>
	uint16_t mouse_button = *(uint16_t*)(&args[0]);
    c4ae:	8822      	ldrh	r2, [r4, #0]
	int16_t mouse_x = *(int16_t*)(&args[2]);
    c4b0:	f9b4 5002 	ldrsh.w	r5, [r4, #2]
	int16_t mouse_y = *(int16_t*)(&args[4]);
    c4b4:	f9b4 4004 	ldrsh.w	r4, [r4, #4]
	uint16_t mouse_button_shift = mouse_button - 1;
    c4b8:	1e53      	subs	r3, r2, #1
	switch ( cstate )
    c4ba:	2802      	cmp	r0, #2
	uint16_t mouse_button_shift = mouse_button - 1;
    c4bc:	b299      	uxth	r1, r3
    c4be:	463e      	mov	r6, r7
	switch ( cstate )
    c4c0:	d02a      	beq.n	c518 <Output_usbMouse_capability+0x7c>
    c4c2:	d807      	bhi.n	c4d4 <Output_usbMouse_capability+0x38>
    c4c4:	2801      	cmp	r0, #1
    c4c6:	d00f      	beq.n	c4e8 <Output_usbMouse_capability+0x4c>
}
    c4c8:	9a01      	ldr	r2, [sp, #4]
    c4ca:	6833      	ldr	r3, [r6, #0]
    c4cc:	429a      	cmp	r2, r3
    c4ce:	d109      	bne.n	c4e4 <Output_usbMouse_capability+0x48>
    c4d0:	b003      	add	sp, #12
    c4d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch ( cstate )
    c4d4:	2803      	cmp	r0, #3
    c4d6:	d007      	beq.n	c4e8 <Output_usbMouse_capability+0x4c>
    c4d8:	28ff      	cmp	r0, #255	; 0xff
    c4da:	d1f5      	bne.n	c4c8 <Output_usbMouse_capability+0x2c>
		print("Output_usbMouse(mouseButton,relX,relY)");
    c4dc:	9a01      	ldr	r2, [sp, #4]
    c4de:	683b      	ldr	r3, [r7, #0]
    c4e0:	429a      	cmp	r2, r3
    c4e2:	d028      	beq.n	c536 <Output_usbMouse_capability+0x9a>
}
    c4e4:	f7f6 f924 	bl	2730 <__stack_chk_fail>
		if ( mouse_button )
    c4e8:	b132      	cbz	r2, c4f8 <Output_usbMouse_capability+0x5c>
			USBMouse_Buttons |= (1 << mouse_button_shift);
    c4ea:	4817      	ldr	r0, [pc, #92]	; (c548 <Output_usbMouse_capability+0xac>)
    c4ec:	2301      	movs	r3, #1
    c4ee:	8807      	ldrh	r7, [r0, #0]
    c4f0:	408b      	lsls	r3, r1
    c4f2:	433b      	orrs	r3, r7
    c4f4:	b29b      	uxth	r3, r3
    c4f6:	8003      	strh	r3, [r0, #0]
		if ( mouse_x )
    c4f8:	b10d      	cbz	r5, c4fe <Output_usbMouse_capability+0x62>
			USBMouse_Relative_x = mouse_x;
    c4fa:	4b14      	ldr	r3, [pc, #80]	; (c54c <Output_usbMouse_capability+0xb0>)
    c4fc:	801d      	strh	r5, [r3, #0]
		if ( mouse_y )
    c4fe:	b10c      	cbz	r4, c504 <Output_usbMouse_capability+0x68>
			USBMouse_Relative_y = mouse_y;
    c500:	4b13      	ldr	r3, [pc, #76]	; (c550 <Output_usbMouse_capability+0xb4>)
    c502:	801c      	strh	r4, [r3, #0]
	if ( mouse_button )
    c504:	b98a      	cbnz	r2, c52a <Output_usbMouse_capability+0x8e>
	if ( mouse_x || mouse_y )
    c506:	b90d      	cbnz	r5, c50c <Output_usbMouse_capability+0x70>
    c508:	2c00      	cmp	r4, #0
    c50a:	d0dd      	beq.n	c4c8 <Output_usbMouse_capability+0x2c>
		USBMouse_Changed |= USBMouseChangeState_Relative;
    c50c:	4a11      	ldr	r2, [pc, #68]	; (c554 <Output_usbMouse_capability+0xb8>)
    c50e:	7813      	ldrb	r3, [r2, #0]
    c510:	f043 0302 	orr.w	r3, r3, #2
    c514:	7013      	strb	r3, [r2, #0]
    c516:	e7d7      	b.n	c4c8 <Output_usbMouse_capability+0x2c>
		if ( mouse_button )
    c518:	2a00      	cmp	r2, #0
    c51a:	d0f4      	beq.n	c506 <Output_usbMouse_capability+0x6a>
			USBMouse_Buttons &= ~(1 << mouse_button_shift);
    c51c:	480a      	ldr	r0, [pc, #40]	; (c548 <Output_usbMouse_capability+0xac>)
    c51e:	2301      	movs	r3, #1
    c520:	8802      	ldrh	r2, [r0, #0]
    c522:	408b      	lsls	r3, r1
    c524:	ea22 0303 	bic.w	r3, r2, r3
    c528:	8003      	strh	r3, [r0, #0]
		USBMouse_Changed |= USBMouseChangeState_Buttons;
    c52a:	4a0a      	ldr	r2, [pc, #40]	; (c554 <Output_usbMouse_capability+0xb8>)
    c52c:	7813      	ldrb	r3, [r2, #0]
    c52e:	f043 0301 	orr.w	r3, r3, #1
    c532:	7013      	strb	r3, [r2, #0]
    c534:	e7e7      	b.n	c506 <Output_usbMouse_capability+0x6a>
		print("Output_usbMouse(mouseButton,relX,relY)");
    c536:	4808      	ldr	r0, [pc, #32]	; (c558 <Output_usbMouse_capability+0xbc>)
}
    c538:	b003      	add	sp, #12
    c53a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		print("Output_usbMouse(mouseButton,relX,relY)");
    c53e:	f003 b817 	b.w	f570 <_print>
    c542:	bf00      	nop
    c544:	1fff89d0 	.word	0x1fff89d0
    c548:	1fffb2d8 	.word	0x1fffb2d8
    c54c:	1fffb328 	.word	0x1fffb328
    c550:	1fffb2dc 	.word	0x1fffb2dc
    c554:	1fffb2d1 	.word	0x1fffb2d1
    c558:	00015d80 	.word	0x00015d80

0000c55c <Output_usbMouseWheel_capability>:
{
    c55c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    c55e:	4c1a      	ldr	r4, [pc, #104]	; (c5c8 <Output_usbMouseWheel_capability+0x6c>)
    c560:	4608      	mov	r0, r1
    c562:	461d      	mov	r5, r3
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c564:	4611      	mov	r1, r2
{
    c566:	6823      	ldr	r3, [r4, #0]
    c568:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c56a:	f7fa f8e9 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    c56e:	2803      	cmp	r0, #3
    c570:	4626      	mov	r6, r4
    c572:	d003      	beq.n	c57c <Output_usbMouseWheel_capability+0x20>
    c574:	28ff      	cmp	r0, #255	; 0xff
    c576:	d01b      	beq.n	c5b0 <Output_usbMouseWheel_capability+0x54>
    c578:	2801      	cmp	r0, #1
    c57a:	d113      	bne.n	c5a4 <Output_usbMouseWheel_capability+0x48>
	int8_t wheel_vert = *(int8_t*)(&args[0]);
    c57c:	f995 1000 	ldrsb.w	r1, [r5]
	int8_t wheel_hori = *(int8_t*)(&args[2]);
    c580:	f995 2002 	ldrsb.w	r2, [r5, #2]
		if ( wheel_vert )
    c584:	b131      	cbz	r1, c594 <Output_usbMouseWheel_capability+0x38>
			USBMouse_VertWheel = wheel_vert;
    c586:	4b11      	ldr	r3, [pc, #68]	; (c5cc <Output_usbMouseWheel_capability+0x70>)
    c588:	7019      	strb	r1, [r3, #0]
			USBMouse_Changed |= USBMouseChangeState_WheelVert;
    c58a:	4911      	ldr	r1, [pc, #68]	; (c5d0 <Output_usbMouseWheel_capability+0x74>)
    c58c:	780b      	ldrb	r3, [r1, #0]
    c58e:	f043 0304 	orr.w	r3, r3, #4
    c592:	700b      	strb	r3, [r1, #0]
		if ( wheel_hori )
    c594:	b132      	cbz	r2, c5a4 <Output_usbMouseWheel_capability+0x48>
			USBMouse_HoriWheel = wheel_hori;
    c596:	4b0f      	ldr	r3, [pc, #60]	; (c5d4 <Output_usbMouseWheel_capability+0x78>)
    c598:	701a      	strb	r2, [r3, #0]
			USBMouse_Changed |= USBMouseChangeState_WheelHori;
    c59a:	4a0d      	ldr	r2, [pc, #52]	; (c5d0 <Output_usbMouseWheel_capability+0x74>)
    c59c:	7813      	ldrb	r3, [r2, #0]
    c59e:	f043 0308 	orr.w	r3, r3, #8
    c5a2:	7013      	strb	r3, [r2, #0]
}
    c5a4:	9a01      	ldr	r2, [sp, #4]
    c5a6:	6833      	ldr	r3, [r6, #0]
    c5a8:	429a      	cmp	r2, r3
    c5aa:	d105      	bne.n	c5b8 <Output_usbMouseWheel_capability+0x5c>
    c5ac:	b002      	add	sp, #8
    c5ae:	bd70      	pop	{r4, r5, r6, pc}
		print("Output_usbMouseWheel(vert,hori)");
    c5b0:	9a01      	ldr	r2, [sp, #4]
    c5b2:	6823      	ldr	r3, [r4, #0]
    c5b4:	429a      	cmp	r2, r3
    c5b6:	d001      	beq.n	c5bc <Output_usbMouseWheel_capability+0x60>
}
    c5b8:	f7f6 f8ba 	bl	2730 <__stack_chk_fail>
		print("Output_usbMouseWheel(vert,hori)");
    c5bc:	4806      	ldr	r0, [pc, #24]	; (c5d8 <Output_usbMouseWheel_capability+0x7c>)
}
    c5be:	b002      	add	sp, #8
    c5c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Output_usbMouseWheel(vert,hori)");
    c5c4:	f002 bfd4 	b.w	f570 <_print>
    c5c8:	1fff89d0 	.word	0x1fff89d0
    c5cc:	1fffb2da 	.word	0x1fffb2da
    c5d0:	1fffb2d1 	.word	0x1fffb2d1
    c5d4:	1fffb32a 	.word	0x1fffb32a
    c5d8:	00015d60 	.word	0x00015d60

0000c5dc <USB_flushBuffers>:
{
    c5dc:	b513      	push	{r0, r1, r4, lr}
    c5de:	4c0e      	ldr	r4, [pc, #56]	; (c618 <USB_flushBuffers+0x3c>)
	memset( (void*)&USBKeys_primary, 0, sizeof( USBKeys ) );
    c5e0:	480e      	ldr	r0, [pc, #56]	; (c61c <USB_flushBuffers+0x40>)
{
    c5e2:	6823      	ldr	r3, [r4, #0]
    c5e4:	9301      	str	r3, [sp, #4]
	memset( (void*)&USBKeys_primary, 0, sizeof( USBKeys ) );
    c5e6:	2222      	movs	r2, #34	; 0x22
    c5e8:	2100      	movs	r1, #0
    c5ea:	f7f6 f8af 	bl	274c <memset>
	memset( (void*)&USBKeys_idle, 0, sizeof( USBKeys ) );
    c5ee:	2222      	movs	r2, #34	; 0x22
    c5f0:	2100      	movs	r1, #0
    c5f2:	480b      	ldr	r0, [pc, #44]	; (c620 <USB_flushBuffers+0x44>)
    c5f4:	f7f6 f8aa 	bl	274c <memset>
	USBKeys_Idle_Expiry = 0;
    c5f8:	4a0a      	ldr	r2, [pc, #40]	; (c624 <USB_flushBuffers+0x48>)
    c5fa:	2300      	movs	r3, #0
    c5fc:	6013      	str	r3, [r2, #0]
	USBKeys_Idle_Count = 0;
    c5fe:	4a0a      	ldr	r2, [pc, #40]	; (c628 <USB_flushBuffers+0x4c>)
    c600:	7013      	strb	r3, [r2, #0]
	USBKeys_Sent = 0;
    c602:	4a0a      	ldr	r2, [pc, #40]	; (c62c <USB_flushBuffers+0x50>)
    c604:	7013      	strb	r3, [r2, #0]
}
    c606:	9a01      	ldr	r2, [sp, #4]
    c608:	6823      	ldr	r3, [r4, #0]
    c60a:	429a      	cmp	r2, r3
    c60c:	d001      	beq.n	c612 <USB_flushBuffers+0x36>
    c60e:	f7f6 f88f 	bl	2730 <__stack_chk_fail>
    c612:	b002      	add	sp, #8
    c614:	bd10      	pop	{r4, pc}
    c616:	bf00      	nop
    c618:	1fff89d0 	.word	0x1fff89d0
    c61c:	1fffb306 	.word	0x1fffb306
    c620:	1fffb2e0 	.word	0x1fffb2e0
    c624:	1fffb32c 	.word	0x1fffb32c
    c628:	1fffb2d0 	.word	0x1fffb2d0
    c62c:	1fffb303 	.word	0x1fffb303

0000c630 <Output_kbdProtocolBoot_capability>:
{
    c630:	b573      	push	{r0, r1, r4, r5, r6, lr}
    c632:	4d14      	ldr	r5, [pc, #80]	; (c684 <Output_kbdProtocolBoot_capability+0x54>)
    c634:	4608      	mov	r0, r1
    c636:	682b      	ldr	r3, [r5, #0]
    c638:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c63a:	4611      	mov	r1, r2
    c63c:	f7fa f880 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    c640:	2801      	cmp	r0, #1
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c642:	4604      	mov	r4, r0
    c644:	462e      	mov	r6, r5
	switch ( cstate )
    c646:	d00d      	beq.n	c664 <Output_kbdProtocolBoot_capability+0x34>
    c648:	28ff      	cmp	r0, #255	; 0xff
    c64a:	d115      	bne.n	c678 <Output_kbdProtocolBoot_capability+0x48>
		print("Output_kbdProtocolBoot()");
    c64c:	9a01      	ldr	r2, [sp, #4]
    c64e:	682b      	ldr	r3, [r5, #0]
    c650:	429a      	cmp	r2, r3
    c652:	d001      	beq.n	c658 <Output_kbdProtocolBoot_capability+0x28>
}
    c654:	f7f6 f86c 	bl	2730 <__stack_chk_fail>
		print("Output_kbdProtocolBoot()");
    c658:	480b      	ldr	r0, [pc, #44]	; (c688 <Output_kbdProtocolBoot_capability+0x58>)
}
    c65a:	b002      	add	sp, #8
    c65c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Output_kbdProtocolBoot()");
    c660:	f002 bf86 	b.w	f570 <_print>
	if ( USBKeys_Protocol == 0 )
    c664:	4b09      	ldr	r3, [pc, #36]	; (c68c <Output_kbdProtocolBoot_capability+0x5c>)
    c666:	781b      	ldrb	r3, [r3, #0]
    c668:	b133      	cbz	r3, c678 <Output_kbdProtocolBoot_capability+0x48>
	USB_flushBuffers();
    c66a:	f7ff ffb7 	bl	c5dc <USB_flushBuffers>
	USBKeys_Protocol_New = 0;
    c66e:	4b08      	ldr	r3, [pc, #32]	; (c690 <Output_kbdProtocolBoot_capability+0x60>)
    c670:	2200      	movs	r2, #0
    c672:	701a      	strb	r2, [r3, #0]
	USBKeys_Protocol_Change = 1;
    c674:	4b07      	ldr	r3, [pc, #28]	; (c694 <Output_kbdProtocolBoot_capability+0x64>)
    c676:	701c      	strb	r4, [r3, #0]
}
    c678:	9a01      	ldr	r2, [sp, #4]
    c67a:	6833      	ldr	r3, [r6, #0]
    c67c:	429a      	cmp	r2, r3
    c67e:	d1e9      	bne.n	c654 <Output_kbdProtocolBoot_capability+0x24>
    c680:	b002      	add	sp, #8
    c682:	bd70      	pop	{r4, r5, r6, pc}
    c684:	1fff89d0 	.word	0x1fff89d0
    c688:	00015c05 	.word	0x00015c05
    c68c:	1fff8e44 	.word	0x1fff8e44
    c690:	1fff8e45 	.word	0x1fff8e45
    c694:	1fffb330 	.word	0x1fffb330

0000c698 <Output_kbdProtocolNKRO_capability>:
{
    c698:	b573      	push	{r0, r1, r4, r5, r6, lr}
    c69a:	4d14      	ldr	r5, [pc, #80]	; (c6ec <Output_kbdProtocolNKRO_capability+0x54>)
    c69c:	4608      	mov	r0, r1
    c69e:	682b      	ldr	r3, [r5, #0]
    c6a0:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c6a2:	4611      	mov	r1, r2
    c6a4:	f7fa f84c 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    c6a8:	2801      	cmp	r0, #1
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c6aa:	4604      	mov	r4, r0
    c6ac:	462e      	mov	r6, r5
	switch ( cstate )
    c6ae:	d00d      	beq.n	c6cc <Output_kbdProtocolNKRO_capability+0x34>
    c6b0:	28ff      	cmp	r0, #255	; 0xff
    c6b2:	d115      	bne.n	c6e0 <Output_kbdProtocolNKRO_capability+0x48>
		print("Output_kbdProtocolNKRO()");
    c6b4:	9a01      	ldr	r2, [sp, #4]
    c6b6:	682b      	ldr	r3, [r5, #0]
    c6b8:	429a      	cmp	r2, r3
    c6ba:	d001      	beq.n	c6c0 <Output_kbdProtocolNKRO_capability+0x28>
}
    c6bc:	f7f6 f838 	bl	2730 <__stack_chk_fail>
		print("Output_kbdProtocolNKRO()");
    c6c0:	480b      	ldr	r0, [pc, #44]	; (c6f0 <Output_kbdProtocolNKRO_capability+0x58>)
}
    c6c2:	b002      	add	sp, #8
    c6c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		print("Output_kbdProtocolNKRO()");
    c6c8:	f002 bf52 	b.w	f570 <_print>
	if ( USBKeys_Protocol == 1 )
    c6cc:	4b09      	ldr	r3, [pc, #36]	; (c6f4 <Output_kbdProtocolNKRO_capability+0x5c>)
    c6ce:	781b      	ldrb	r3, [r3, #0]
    c6d0:	2b01      	cmp	r3, #1
    c6d2:	d005      	beq.n	c6e0 <Output_kbdProtocolNKRO_capability+0x48>
	USB_flushBuffers();
    c6d4:	f7ff ff82 	bl	c5dc <USB_flushBuffers>
	USBKeys_Protocol_New = 1;
    c6d8:	4b07      	ldr	r3, [pc, #28]	; (c6f8 <Output_kbdProtocolNKRO_capability+0x60>)
    c6da:	701c      	strb	r4, [r3, #0]
	USBKeys_Protocol_Change = 1;
    c6dc:	4b07      	ldr	r3, [pc, #28]	; (c6fc <Output_kbdProtocolNKRO_capability+0x64>)
    c6de:	701c      	strb	r4, [r3, #0]
}
    c6e0:	9a01      	ldr	r2, [sp, #4]
    c6e2:	6833      	ldr	r3, [r6, #0]
    c6e4:	429a      	cmp	r2, r3
    c6e6:	d1e9      	bne.n	c6bc <Output_kbdProtocolNKRO_capability+0x24>
    c6e8:	b002      	add	sp, #8
    c6ea:	bd70      	pop	{r4, r5, r6, pc}
    c6ec:	1fff89d0 	.word	0x1fff89d0
    c6f0:	00015c1e 	.word	0x00015c1e
    c6f4:	1fff8e44 	.word	0x1fff8e44
    c6f8:	1fff8e45 	.word	0x1fff8e45
    c6fc:	1fffb330 	.word	0x1fffb330

0000c700 <Output_toggleKbdProtocol_capability>:
{
    c700:	b537      	push	{r0, r1, r2, r4, r5, lr}
    c702:	4c15      	ldr	r4, [pc, #84]	; (c758 <Output_toggleKbdProtocol_capability+0x58>)
    c704:	4608      	mov	r0, r1
    c706:	6823      	ldr	r3, [r4, #0]
    c708:	9301      	str	r3, [sp, #4]
	CapabilityState cstate = KLL_CapabilityState( state, stateType );
    c70a:	4611      	mov	r1, r2
    c70c:	f7fa f818 	bl	6740 <KLL_CapabilityState>
	switch ( cstate )
    c710:	2802      	cmp	r0, #2
    c712:	4625      	mov	r5, r4
    c714:	d00d      	beq.n	c732 <Output_toggleKbdProtocol_capability+0x32>
    c716:	28ff      	cmp	r0, #255	; 0xff
    c718:	d117      	bne.n	c74a <Output_toggleKbdProtocol_capability+0x4a>
		print("Output_toggleKbdProtocol()");
    c71a:	9a01      	ldr	r2, [sp, #4]
    c71c:	6823      	ldr	r3, [r4, #0]
    c71e:	429a      	cmp	r2, r3
    c720:	d001      	beq.n	c726 <Output_toggleKbdProtocol_capability+0x26>
}
    c722:	f7f6 f805 	bl	2730 <__stack_chk_fail>
		print("Output_toggleKbdProtocol()");
    c726:	480d      	ldr	r0, [pc, #52]	; (c75c <Output_toggleKbdProtocol_capability+0x5c>)
}
    c728:	b003      	add	sp, #12
    c72a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		print("Output_toggleKbdProtocol()");
    c72e:	f002 bf1f 	b.w	f570 <_print>
	USB_flushBuffers();
    c732:	f7ff ff53 	bl	c5dc <USB_flushBuffers>
	USBKeys_Protocol_New = !USBKeys_Protocol;
    c736:	4b0a      	ldr	r3, [pc, #40]	; (c760 <Output_toggleKbdProtocol_capability+0x60>)
    c738:	4a0a      	ldr	r2, [pc, #40]	; (c764 <Output_toggleKbdProtocol_capability+0x64>)
    c73a:	781b      	ldrb	r3, [r3, #0]
    c73c:	fab3 f383 	clz	r3, r3
    c740:	095b      	lsrs	r3, r3, #5
    c742:	7013      	strb	r3, [r2, #0]
	USBKeys_Protocol_Change = 1;
    c744:	4b08      	ldr	r3, [pc, #32]	; (c768 <Output_toggleKbdProtocol_capability+0x68>)
    c746:	2201      	movs	r2, #1
    c748:	701a      	strb	r2, [r3, #0]
}
    c74a:	9a01      	ldr	r2, [sp, #4]
    c74c:	682b      	ldr	r3, [r5, #0]
    c74e:	429a      	cmp	r2, r3
    c750:	d1e7      	bne.n	c722 <Output_toggleKbdProtocol_capability+0x22>
    c752:	b003      	add	sp, #12
    c754:	bd30      	pop	{r4, r5, pc}
    c756:	bf00      	nop
    c758:	1fff89d0 	.word	0x1fff89d0
    c75c:	00015c65 	.word	0x00015c65
    c760:	1fff8e44 	.word	0x1fff8e44
    c764:	1fff8e45 	.word	0x1fff8e45
    c768:	1fffb330 	.word	0x1fffb330

0000c76c <USB_setup>:
{
    c76c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    c76e:	4d1c      	ldr	r5, [pc, #112]	; (c7e0 <USB_setup+0x74>)
    c770:	682b      	ldr	r3, [r5, #0]
    c772:	9301      	str	r3, [sp, #4]
	usb_init();
    c774:	f001 f934 	bl	d9e0 <usb_init>
	CLI_registerDictionary( usbCLIDict, usbCLIDictName );
    c778:	491a      	ldr	r1, [pc, #104]	; (c7e4 <USB_setup+0x78>)
    c77a:	481b      	ldr	r0, [pc, #108]	; (c7e8 <USB_setup+0x7c>)
    c77c:	f002 fa88 	bl	ec90 <CLI_registerDictionary>
	USBKeys_Protocol_Change = 0;
    c780:	4b1a      	ldr	r3, [pc, #104]	; (c7ec <USB_setup+0x80>)
    c782:	2400      	movs	r4, #0
    c784:	701c      	strb	r4, [r3, #0]
	USBKeys_LEDs_prev = 0;
    c786:	4b1a      	ldr	r3, [pc, #104]	; (c7f0 <USB_setup+0x84>)
    c788:	701c      	strb	r4, [r3, #0]
	USBKeys_LEDs = 0;
    c78a:	4b1a      	ldr	r3, [pc, #104]	; (c7f4 <USB_setup+0x88>)
    c78c:	701c      	strb	r4, [r3, #0]
	USBMouse_Buttons = 0;
    c78e:	4b1a      	ldr	r3, [pc, #104]	; (c7f8 <USB_setup+0x8c>)
    c790:	801c      	strh	r4, [r3, #0]
	USBMouse_Relative_x = 0;
    c792:	4b1a      	ldr	r3, [pc, #104]	; (c7fc <USB_setup+0x90>)
    c794:	801c      	strh	r4, [r3, #0]
	USBMouse_Relative_y = 0;
    c796:	4b1a      	ldr	r3, [pc, #104]	; (c800 <USB_setup+0x94>)
    c798:	801c      	strh	r4, [r3, #0]
	USBMouse_VertWheel = 0;
    c79a:	4b1a      	ldr	r3, [pc, #104]	; (c804 <USB_setup+0x98>)
    c79c:	701c      	strb	r4, [r3, #0]
	USBMouse_HoriWheel = 0;
    c79e:	4b1a      	ldr	r3, [pc, #104]	; (c808 <USB_setup+0x9c>)
    c7a0:	701c      	strb	r4, [r3, #0]
	USBMouse_Changed = 0;
    c7a2:	4b1a      	ldr	r3, [pc, #104]	; (c80c <USB_setup+0xa0>)
    c7a4:	701c      	strb	r4, [r3, #0]
	USBDev_Address = 0;
    c7a6:	4b1a      	ldr	r3, [pc, #104]	; (c810 <USB_setup+0xa4>)
    c7a8:	701c      	strb	r4, [r3, #0]
	USB_flushBuffers();
    c7aa:	f7ff ff17 	bl	c5dc <USB_flushBuffers>
	VBAT_SECURE1 = 0;
    c7ae:	4b19      	ldr	r3, [pc, #100]	; (c814 <USB_setup+0xa8>)
    c7b0:	601c      	str	r4, [r3, #0]
	VBAT_SECURE2 = 0;
    c7b2:	605c      	str	r4, [r3, #4]
	HIDIO_setup();
    c7b4:	f7fe ffd8 	bl	b768 <HIDIO_setup>
	outputPeriodicLatencyResource = Latency_add_resource("USBOutputPeri", LatencyOption_Ticks);
    c7b8:	4621      	mov	r1, r4
    c7ba:	4817      	ldr	r0, [pc, #92]	; (c818 <USB_setup+0xac>)
    c7bc:	f002 fd8e 	bl	f2dc <Latency_add_resource>
    c7c0:	4b16      	ldr	r3, [pc, #88]	; (c81c <USB_setup+0xb0>)
	outputPollLatencyResource = Latency_add_resource("USBOutputPoll", LatencyOption_Ticks);
    c7c2:	4621      	mov	r1, r4
	outputPeriodicLatencyResource = Latency_add_resource("USBOutputPeri", LatencyOption_Ticks);
    c7c4:	7018      	strb	r0, [r3, #0]
	outputPollLatencyResource = Latency_add_resource("USBOutputPoll", LatencyOption_Ticks);
    c7c6:	4816      	ldr	r0, [pc, #88]	; (c820 <USB_setup+0xb4>)
    c7c8:	f002 fd88 	bl	f2dc <Latency_add_resource>
    c7cc:	4b15      	ldr	r3, [pc, #84]	; (c824 <USB_setup+0xb8>)
}
    c7ce:	9a01      	ldr	r2, [sp, #4]
	outputPollLatencyResource = Latency_add_resource("USBOutputPoll", LatencyOption_Ticks);
    c7d0:	7018      	strb	r0, [r3, #0]
}
    c7d2:	682b      	ldr	r3, [r5, #0]
    c7d4:	429a      	cmp	r2, r3
    c7d6:	d001      	beq.n	c7dc <USB_setup+0x70>
    c7d8:	f7f5 ffaa 	bl	2730 <__stack_chk_fail>
    c7dc:	b003      	add	sp, #12
    c7de:	bd30      	pop	{r4, r5, pc}
    c7e0:	1fff89d0 	.word	0x1fff89d0
    c7e4:	00016084 	.word	0x00016084
    c7e8:	00016030 	.word	0x00016030
    c7ec:	1fffb330 	.word	0x1fffb330
    c7f0:	1fffb304 	.word	0x1fffb304
    c7f4:	1fffb32b 	.word	0x1fffb32b
    c7f8:	1fffb2d8 	.word	0x1fffb2d8
    c7fc:	1fffb328 	.word	0x1fffb328
    c800:	1fffb2dc 	.word	0x1fffb2dc
    c804:	1fffb2da 	.word	0x1fffb2da
    c808:	1fffb32a 	.word	0x1fffb32a
    c80c:	1fffb2d1 	.word	0x1fffb2d1
    c810:	1fffb302 	.word	0x1fffb302
    c814:	4003e018 	.word	0x4003e018
    c818:	00015df7 	.word	0x00015df7
    c81c:	1fff9729 	.word	0x1fff9729
    c820:	00015e05 	.word	0x00015e05
    c824:	1fff972a 	.word	0x1fff972a

0000c828 <USB_poll>:
{
    c828:	b537      	push	{r0, r1, r2, r4, r5, lr}
    c82a:	4d0c      	ldr	r5, [pc, #48]	; (c85c <USB_poll+0x34>)
	Latency_start_time( outputPollLatencyResource );
    c82c:	4c0c      	ldr	r4, [pc, #48]	; (c860 <USB_poll+0x38>)
{
    c82e:	682b      	ldr	r3, [r5, #0]
	Latency_start_time( outputPollLatencyResource );
    c830:	7820      	ldrb	r0, [r4, #0]
{
    c832:	9301      	str	r3, [sp, #4]
	Latency_start_time( outputPollLatencyResource );
    c834:	f002 fdca 	bl	f3cc <Latency_start_time>
	usb_device_check();
    c838:	f000 fa5c 	bl	ccf4 <usb_device_check>
	usb_keyboard_idle_update();
    c83c:	f001 fa8e 	bl	dd5c <usb_keyboard_idle_update>
	HIDIO_process();
    c840:	f7ff f92c 	bl	ba9c <HIDIO_process>
	Latency_end_time( outputPollLatencyResource );
    c844:	9a01      	ldr	r2, [sp, #4]
    c846:	682b      	ldr	r3, [r5, #0]
    c848:	429a      	cmp	r2, r3
    c84a:	d001      	beq.n	c850 <USB_poll+0x28>
    c84c:	f7f5 ff70 	bl	2730 <__stack_chk_fail>
    c850:	7820      	ldrb	r0, [r4, #0]
}
    c852:	b003      	add	sp, #12
    c854:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	Latency_end_time( outputPollLatencyResource );
    c858:	f002 bdd6 	b.w	f408 <Latency_end_time>
    c85c:	1fff89d0 	.word	0x1fff89d0
    c860:	1fff972a 	.word	0x1fff972a

0000c864 <USB_indicator_update>:
{
    c864:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    c868:	4c1f      	ldr	r4, [pc, #124]	; (c8e8 <USB_indicator_update+0x84>)
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    c86a:	4e20      	ldr	r6, [pc, #128]	; (c8ec <USB_indicator_update+0x88>)
{
    c86c:	6823      	ldr	r3, [r4, #0]
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    c86e:	4d20      	ldr	r5, [pc, #128]	; (c8f0 <USB_indicator_update+0x8c>)
{
    c870:	9301      	str	r3, [sp, #4]
    c872:	4637      	mov	r7, r6
    c874:	2300      	movs	r3, #0
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    c876:	2101      	movs	r1, #1
    c878:	7830      	ldrb	r0, [r6, #0]
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    c87a:	f895 e000 	ldrb.w	lr, [r5]
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    c87e:	fa01 f803 	lsl.w	r8, r1, r3
    c882:	fa4f f288 	sxtb.w	r2, r8
    c886:	b2c0      	uxtb	r0, r0
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    c888:	fa5f fe8e 	uxtb.w	lr, lr
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    c88c:	ea02 0c00 	and.w	ip, r2, r0
		if ( cur == 0 && cur == prev )
    c890:	ea40 000e 	orr.w	r0, r0, lr
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    c894:	ea02 020e 	and.w	r2, r2, lr
		if ( cur == 0 && cur == prev )
    c898:	ea10 0f08 	tst.w	r0, r8
		uint8_t cur = USBKeys_LEDs & (1 << bit);
    c89c:	fa4f fc8c 	sxtb.w	ip, ip
		uint8_t prev = USBKeys_LEDs_prev & (1 << bit);
    c8a0:	b252      	sxtb	r2, r2
    c8a2:	eb03 0801 	add.w	r8, r3, r1
		if ( cur == 0 && cur == prev )
    c8a6:	d009      	beq.n	c8bc <USB_indicator_update+0x58>
		else if ( cur && cur == prev )
    c8a8:	f1bc 0f00 	cmp.w	ip, #0
    c8ac:	d012      	beq.n	c8d4 <USB_indicator_update+0x70>
    c8ae:	4594      	cmp	ip, r2
    c8b0:	fa1f f088 	uxth.w	r0, r8
    c8b4:	d100      	bne.n	c8b8 <USB_indicator_update+0x54>
			Macro_ledState( id, ScheduleType_On );
    c8b6:	2102      	movs	r1, #2
			Macro_ledState( id, ScheduleType_D );
    c8b8:	f7fb f8a6 	bl	7a08 <Macro_ledState>
    c8bc:	4643      	mov	r3, r8
	for ( uint8_t bit = 0; bit < LED_KANA_5; bit++ )
    c8be:	2b05      	cmp	r3, #5
    c8c0:	d1d9      	bne.n	c876 <USB_indicator_update+0x12>
	USBKeys_LEDs_prev = USBKeys_LEDs;
    c8c2:	783b      	ldrb	r3, [r7, #0]
    c8c4:	b2db      	uxtb	r3, r3
    c8c6:	702b      	strb	r3, [r5, #0]
}
    c8c8:	9a01      	ldr	r2, [sp, #4]
    c8ca:	6823      	ldr	r3, [r4, #0]
    c8cc:	429a      	cmp	r2, r3
    c8ce:	d007      	beq.n	c8e0 <USB_indicator_update+0x7c>
    c8d0:	f7f5 ff2e 	bl	2730 <__stack_chk_fail>
		else if ( prev )
    c8d4:	2a00      	cmp	r2, #0
    c8d6:	d0f1      	beq.n	c8bc <USB_indicator_update+0x58>
			Macro_ledState( id, ScheduleType_D );
    c8d8:	2103      	movs	r1, #3
    c8da:	fa1f f088 	uxth.w	r0, r8
    c8de:	e7eb      	b.n	c8b8 <USB_indicator_update+0x54>
}
    c8e0:	b002      	add	sp, #8
    c8e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c8e6:	bf00      	nop
    c8e8:	1fff89d0 	.word	0x1fff89d0
    c8ec:	1fffb32b 	.word	0x1fffb32b
    c8f0:	1fffb304 	.word	0x1fffb304

0000c8f4 <USB_periodic>:
{
    c8f4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    c8f8:	4e2b      	ldr	r6, [pc, #172]	; (c9a8 <USB_periodic+0xb4>)
	Latency_start_time( outputPeriodicLatencyResource );
    c8fa:	4d2c      	ldr	r5, [pc, #176]	; (c9ac <USB_periodic+0xb8>)
{
    c8fc:	6833      	ldr	r3, [r6, #0]
	Latency_start_time( outputPeriodicLatencyResource );
    c8fe:	7828      	ldrb	r0, [r5, #0]
{
    c900:	9301      	str	r3, [sp, #4]
	Latency_start_time( outputPeriodicLatencyResource );
    c902:	f002 fd63 	bl	f3cc <Latency_start_time>
	while ( USBMouse_Changed )
    c906:	4c2a      	ldr	r4, [pc, #168]	; (c9b0 <USB_periodic+0xbc>)
    c908:	f894 8000 	ldrb.w	r8, [r4]
    c90c:	f1b8 0f00 	cmp.w	r8, #0
    c910:	d124      	bne.n	c95c <USB_periodic+0x68>
	if ( USBKeys_Protocol_Change )
    c912:	4f28      	ldr	r7, [pc, #160]	; (c9b4 <USB_periodic+0xc0>)
    c914:	4c28      	ldr	r4, [pc, #160]	; (c9b8 <USB_periodic+0xc4>)
    c916:	783b      	ldrb	r3, [r7, #0]
    c918:	b143      	cbz	r3, c92c <USB_periodic+0x38>
		usb_keyboard_clear( USBKeys_Protocol );
    c91a:	7820      	ldrb	r0, [r4, #0]
    c91c:	f001 fa50 	bl	ddc0 <usb_keyboard_clear>
		USBKeys_Protocol = USBKeys_Protocol_New;
    c920:	4b26      	ldr	r3, [pc, #152]	; (c9bc <USB_periodic+0xc8>)
    c922:	781b      	ldrb	r3, [r3, #0]
    c924:	b2db      	uxtb	r3, r3
    c926:	7023      	strb	r3, [r4, #0]
		USBKeys_Protocol_Change = 0;
    c928:	f887 8000 	strb.w	r8, [r7]
	if ( USBKeys_Protocol == 0 )
    c92c:	7823      	ldrb	r3, [r4, #0]
    c92e:	4f24      	ldr	r7, [pc, #144]	; (c9c0 <USB_periodic+0xcc>)
    c930:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    c934:	b1ab      	cbz	r3, c962 <USB_periodic+0x6e>
		usb_keyboard_send( (USBKeys*)&USBKeys_primary, USBKeys_Protocol );
    c936:	f8df 8088 	ldr.w	r8, [pc, #136]	; c9c0 <USB_periodic+0xcc>
	while ( USBKeys_primary.changed )
    c93a:	f897 3020 	ldrb.w	r3, [r7, #32]
    c93e:	b9d3      	cbnz	r3, c976 <USB_periodic+0x82>
	switch ( USBKeys_Protocol )
    c940:	7823      	ldrb	r3, [r4, #0]
    c942:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    c946:	b1db      	cbz	r3, c980 <USB_periodic+0x8c>
    c948:	2a01      	cmp	r2, #1
    c94a:	d023      	beq.n	c994 <USB_periodic+0xa0>
	USB_indicator_update();
    c94c:	f7ff ff8a 	bl	c864 <USB_indicator_update>
	Latency_end_time( outputPeriodicLatencyResource );
    c950:	9a01      	ldr	r2, [sp, #4]
    c952:	6833      	ldr	r3, [r6, #0]
    c954:	429a      	cmp	r2, r3
    c956:	d020      	beq.n	c99a <USB_periodic+0xa6>
    c958:	f7f5 feea 	bl	2730 <__stack_chk_fail>
		usb_mouse_send();
    c95c:	f001 faae 	bl	debc <usb_mouse_send>
    c960:	e7d2      	b.n	c908 <USB_periodic+0x14>
		for ( uint8_t c = USBKeys_Sent; c < USB_BOOT_MAX_KEYS; c++ )
    c962:	4b18      	ldr	r3, [pc, #96]	; (c9c4 <USB_periodic+0xd0>)
    c964:	781b      	ldrb	r3, [r3, #0]
    c966:	b2db      	uxtb	r3, r3
    c968:	b2d9      	uxtb	r1, r3
    c96a:	2905      	cmp	r1, #5
    c96c:	d8e3      	bhi.n	c936 <USB_periodic+0x42>
			USBKeys_primary.keys[c] = 0;
    c96e:	18f9      	adds	r1, r7, r3
    c970:	3301      	adds	r3, #1
    c972:	704a      	strb	r2, [r1, #1]
    c974:	e7f8      	b.n	c968 <USB_periodic+0x74>
		usb_keyboard_send( (USBKeys*)&USBKeys_primary, USBKeys_Protocol );
    c976:	7821      	ldrb	r1, [r4, #0]
    c978:	4640      	mov	r0, r8
    c97a:	f001 f8e7 	bl	db4c <usb_keyboard_send>
    c97e:	e7dc      	b.n	c93a <USB_periodic+0x46>
		Scan_finishedWithOutput( USBKeys_Sent <= USB_BOOT_MAX_KEYS ? USBKeys_Sent : USB_BOOT_MAX_KEYS );
    c980:	4b10      	ldr	r3, [pc, #64]	; (c9c4 <USB_periodic+0xd0>)
    c982:	781a      	ldrb	r2, [r3, #0]
    c984:	2a06      	cmp	r2, #6
    c986:	bf96      	itet	ls
    c988:	7818      	ldrbls	r0, [r3, #0]
    c98a:	2006      	movhi	r0, #6
    c98c:	b2c0      	uxtbls	r0, r0
		Scan_finishedWithOutput( USBKeys_Sent );
    c98e:	f7f9 fe7f 	bl	6690 <Scan_finishedWithOutput>
		break;
    c992:	e7db      	b.n	c94c <USB_periodic+0x58>
		Scan_finishedWithOutput( USBKeys_Sent );
    c994:	4b0b      	ldr	r3, [pc, #44]	; (c9c4 <USB_periodic+0xd0>)
    c996:	7818      	ldrb	r0, [r3, #0]
    c998:	e7f9      	b.n	c98e <USB_periodic+0x9a>
	Latency_end_time( outputPeriodicLatencyResource );
    c99a:	7828      	ldrb	r0, [r5, #0]
}
    c99c:	b002      	add	sp, #8
    c99e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	Latency_end_time( outputPeriodicLatencyResource );
    c9a2:	f002 bd31 	b.w	f408 <Latency_end_time>
    c9a6:	bf00      	nop
    c9a8:	1fff89d0 	.word	0x1fff89d0
    c9ac:	1fff9729 	.word	0x1fff9729
    c9b0:	1fffb2d1 	.word	0x1fffb2d1
    c9b4:	1fffb330 	.word	0x1fffb330
    c9b8:	1fff8e44 	.word	0x1fff8e44
    c9bc:	1fff8e45 	.word	0x1fff8e45
    c9c0:	1fffb306 	.word	0x1fffb306
    c9c4:	1fffb303 	.word	0x1fffb303

0000c9c8 <USB_SysCtrlDebug>:
{
    c9c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    c9ca:	4c0b      	ldr	r4, [pc, #44]	; (c9f8 <USB_SysCtrlDebug+0x30>)
    c9cc:	4605      	mov	r5, r0
    c9ce:	6823      	ldr	r3, [r4, #0]
	print("\033[1;34mSysCtrl\033[0m[");
    c9d0:	480a      	ldr	r0, [pc, #40]	; (c9fc <USB_SysCtrlDebug+0x34>)
{
    c9d2:	9301      	str	r3, [sp, #4]
	print("\033[1;34mSysCtrl\033[0m[");
    c9d4:	f002 fdcc 	bl	f570 <_print>
	printHex_op( buffer->sys_ctrl, 2 );
    c9d8:	2102      	movs	r1, #2
    c9da:	7f68      	ldrb	r0, [r5, #29]
    c9dc:	f002 feee 	bl	f7bc <printHex_op>
	print( "] " NL );
    c9e0:	9a01      	ldr	r2, [sp, #4]
    c9e2:	6823      	ldr	r3, [r4, #0]
    c9e4:	429a      	cmp	r2, r3
    c9e6:	d001      	beq.n	c9ec <USB_SysCtrlDebug+0x24>
    c9e8:	f7f5 fea2 	bl	2730 <__stack_chk_fail>
    c9ec:	4804      	ldr	r0, [pc, #16]	; (ca00 <USB_SysCtrlDebug+0x38>)
}
    c9ee:	b003      	add	sp, #12
    c9f0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	print( "] " NL );
    c9f4:	f002 bdbc 	b.w	f570 <_print>
    c9f8:	1fff89d0 	.word	0x1fff89d0
    c9fc:	00015dde 	.word	0x00015dde
    ca00:	00015df2 	.word	0x00015df2

0000ca04 <USB_ConsCtrlDebug>:
{
    ca04:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ca06:	4c0b      	ldr	r4, [pc, #44]	; (ca34 <USB_ConsCtrlDebug+0x30>)
    ca08:	4605      	mov	r5, r0
    ca0a:	6823      	ldr	r3, [r4, #0]
	print("\033[1;34mConsCtrl\033[0m[");
    ca0c:	480a      	ldr	r0, [pc, #40]	; (ca38 <USB_ConsCtrlDebug+0x34>)
{
    ca0e:	9301      	str	r3, [sp, #4]
	print("\033[1;34mConsCtrl\033[0m[");
    ca10:	f002 fdae 	bl	f570 <_print>
	printHex_op( buffer->cons_ctrl, 2 );
    ca14:	2102      	movs	r1, #2
    ca16:	8be8      	ldrh	r0, [r5, #30]
    ca18:	f002 fed0 	bl	f7bc <printHex_op>
	print( "] " NL );
    ca1c:	9a01      	ldr	r2, [sp, #4]
    ca1e:	6823      	ldr	r3, [r4, #0]
    ca20:	429a      	cmp	r2, r3
    ca22:	d001      	beq.n	ca28 <USB_ConsCtrlDebug+0x24>
    ca24:	f7f5 fe84 	bl	2730 <__stack_chk_fail>
    ca28:	4804      	ldr	r0, [pc, #16]	; (ca3c <USB_ConsCtrlDebug+0x38>)
}
    ca2a:	b003      	add	sp, #12
    ca2c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	print( "] " NL );
    ca30:	f002 bd9e 	b.w	f570 <_print>
    ca34:	1fff89d0 	.word	0x1fff89d0
    ca38:	00015db8 	.word	0x00015db8
    ca3c:	00015df2 	.word	0x00015df2

0000ca40 <USB_6KRODebug>:
{
    ca40:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ca42:	4d1c      	ldr	r5, [pc, #112]	; (cab4 <USB_6KRODebug+0x74>)
    ca44:	4604      	mov	r4, r0
    ca46:	682b      	ldr	r3, [r5, #0]
	print("\033[1;34m6KRO\033[0m ");
    ca48:	481b      	ldr	r0, [pc, #108]	; (cab8 <USB_6KRODebug+0x78>)
{
    ca4a:	9301      	str	r3, [sp, #4]
	print("\033[1;34m6KRO\033[0m ");
    ca4c:	f002 fd90 	bl	f570 <_print>
	printHex_op( buffer->modifiers, 2 );
    ca50:	2102      	movs	r1, #2
    ca52:	7820      	ldrb	r0, [r4, #0]
    ca54:	f002 feb2 	bl	f7bc <printHex_op>
	print(" ");
    ca58:	4818      	ldr	r0, [pc, #96]	; (cabc <USB_6KRODebug+0x7c>)
    ca5a:	f002 fd89 	bl	f570 <_print>
	printHex( 0 );
    ca5e:	2101      	movs	r1, #1
    ca60:	2000      	movs	r0, #0
    ca62:	f002 feab 	bl	f7bc <printHex_op>
	print(" ");
    ca66:	4815      	ldr	r0, [pc, #84]	; (cabc <USB_6KRODebug+0x7c>)
    ca68:	f002 fd82 	bl	f570 <_print>
	printHex_op( buffer->keys[0], 2 );
    ca6c:	2102      	movs	r1, #2
    ca6e:	7860      	ldrb	r0, [r4, #1]
    ca70:	f002 fea4 	bl	f7bc <printHex_op>
	printHex_op( buffer->keys[1], 2 );
    ca74:	2102      	movs	r1, #2
    ca76:	78a0      	ldrb	r0, [r4, #2]
    ca78:	f002 fea0 	bl	f7bc <printHex_op>
	printHex_op( buffer->keys[2], 2 );
    ca7c:	2102      	movs	r1, #2
    ca7e:	78e0      	ldrb	r0, [r4, #3]
    ca80:	f002 fe9c 	bl	f7bc <printHex_op>
	printHex_op( buffer->keys[3], 2 );
    ca84:	2102      	movs	r1, #2
    ca86:	7920      	ldrb	r0, [r4, #4]
    ca88:	f002 fe98 	bl	f7bc <printHex_op>
	printHex_op( buffer->keys[4], 2 );
    ca8c:	2102      	movs	r1, #2
    ca8e:	7960      	ldrb	r0, [r4, #5]
    ca90:	f002 fe94 	bl	f7bc <printHex_op>
	printHex_op( buffer->keys[5], 2 );
    ca94:	2102      	movs	r1, #2
    ca96:	79a0      	ldrb	r0, [r4, #6]
    ca98:	f002 fe90 	bl	f7bc <printHex_op>
	print( NL );
    ca9c:	9a01      	ldr	r2, [sp, #4]
    ca9e:	682b      	ldr	r3, [r5, #0]
    caa0:	429a      	cmp	r2, r3
    caa2:	d001      	beq.n	caa8 <USB_6KRODebug+0x68>
    caa4:	f7f5 fe44 	bl	2730 <__stack_chk_fail>
    caa8:	4805      	ldr	r0, [pc, #20]	; (cac0 <USB_6KRODebug+0x80>)
}
    caaa:	b003      	add	sp, #12
    caac:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	print( NL );
    cab0:	f002 bd5e 	b.w	f570 <_print>
    cab4:	1fff89d0 	.word	0x1fff89d0
    cab8:	00015da7 	.word	0x00015da7
    cabc:	00016f5e 	.word	0x00016f5e
    cac0:	00015df4 	.word	0x00015df4

0000cac4 <USB_NKRODebug>:
{
    cac4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    cac6:	4604      	mov	r4, r0
    cac8:	4e18      	ldr	r6, [pc, #96]	; (cb2c <USB_NKRODebug+0x68>)
	print("\033[1;34mNKRO\033[0m ");
    caca:	4819      	ldr	r0, [pc, #100]	; (cb30 <USB_NKRODebug+0x6c>)
{
    cacc:	6833      	ldr	r3, [r6, #0]
    cace:	9301      	str	r3, [sp, #4]
	printHex_op( buffer->modifiers, 2 );
    cad0:	4625      	mov	r5, r4
	print("\033[1;34mNKRO\033[0m ");
    cad2:	f002 fd4d 	bl	f570 <_print>
	printHex_op( buffer->modifiers, 2 );
    cad6:	2102      	movs	r1, #2
    cad8:	f815 0b01 	ldrb.w	r0, [r5], #1
    cadc:	f002 fe6e 	bl	f7bc <printHex_op>
	print(" ");
    cae0:	4814      	ldr	r0, [pc, #80]	; (cb34 <USB_NKRODebug+0x70>)
    cae2:	f002 fd45 	bl	f570 <_print>
    cae6:	f104 0716 	add.w	r7, r4, #22
		printHex_op( buffer->keys[ c ], 2 );
    caea:	f815 0b01 	ldrb.w	r0, [r5], #1
    caee:	2102      	movs	r1, #2
    caf0:	f002 fe64 	bl	f7bc <printHex_op>
	for ( uint8_t c = 0; c < 21; c++ )
    caf4:	42bd      	cmp	r5, r7
    caf6:	d1f8      	bne.n	caea <USB_NKRODebug+0x26>
	print(" ");
    caf8:	480e      	ldr	r0, [pc, #56]	; (cb34 <USB_NKRODebug+0x70>)
    cafa:	f002 fd39 	bl	f570 <_print>
    cafe:	f104 0517 	add.w	r5, r4, #23
    cb02:	341d      	adds	r4, #29
		printHex_op( buffer->keys[ c ], 2 );
    cb04:	f815 0b01 	ldrb.w	r0, [r5], #1
    cb08:	2102      	movs	r1, #2
    cb0a:	f002 fe57 	bl	f7bc <printHex_op>
	for ( uint8_t c = 22; c < 28; c++ )
    cb0e:	42a5      	cmp	r5, r4
    cb10:	d1f8      	bne.n	cb04 <USB_NKRODebug+0x40>
	print( NL );
    cb12:	9a01      	ldr	r2, [sp, #4]
    cb14:	6833      	ldr	r3, [r6, #0]
    cb16:	429a      	cmp	r2, r3
    cb18:	d001      	beq.n	cb1e <USB_NKRODebug+0x5a>
    cb1a:	f7f5 fe09 	bl	2730 <__stack_chk_fail>
    cb1e:	4806      	ldr	r0, [pc, #24]	; (cb38 <USB_NKRODebug+0x74>)
}
    cb20:	b003      	add	sp, #12
    cb22:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	print( NL );
    cb26:	f002 bd23 	b.w	f570 <_print>
    cb2a:	bf00      	nop
    cb2c:	1fff89d0 	.word	0x1fff89d0
    cb30:	00015dcd 	.word	0x00015dcd
    cb34:	00016f5e 	.word	0x00016f5e
    cb38:	00015df4 	.word	0x00015df4

0000cb3c <USB_firmwareReload>:
{
    cb3c:	b507      	push	{r0, r1, r2, lr}
    cb3e:	4b07      	ldr	r3, [pc, #28]	; (cb5c <USB_firmwareReload+0x20>)
    cb40:	681a      	ldr	r2, [r3, #0]
    cb42:	9201      	str	r2, [sp, #4]
	usb_device_reload();
    cb44:	9a01      	ldr	r2, [sp, #4]
    cb46:	681b      	ldr	r3, [r3, #0]
    cb48:	429a      	cmp	r2, r3
    cb4a:	d001      	beq.n	cb50 <USB_firmwareReload+0x14>
    cb4c:	f7f5 fdf0 	bl	2730 <__stack_chk_fail>
}
    cb50:	b003      	add	sp, #12
    cb52:	f85d eb04 	ldr.w	lr, [sp], #4
	usb_device_reload();
    cb56:	f000 bd3f 	b.w	d5d8 <usb_device_reload>
    cb5a:	bf00      	nop
    cb5c:	1fff89d0 	.word	0x1fff89d0

0000cb60 <USB_softReset>:
{
    cb60:	b507      	push	{r0, r1, r2, lr}
    cb62:	4b07      	ldr	r3, [pc, #28]	; (cb80 <USB_softReset+0x20>)
	usb_device_software_reset();
    cb64:	4907      	ldr	r1, [pc, #28]	; (cb84 <USB_softReset+0x24>)
{
    cb66:	681a      	ldr	r2, [r3, #0]
    cb68:	9201      	str	r2, [sp, #4]
	usb_device_software_reset();
    cb6a:	4a07      	ldr	r2, [pc, #28]	; (cb88 <USB_softReset+0x28>)
    cb6c:	6011      	str	r1, [r2, #0]
}
    cb6e:	9a01      	ldr	r2, [sp, #4]
    cb70:	681b      	ldr	r3, [r3, #0]
    cb72:	429a      	cmp	r2, r3
    cb74:	d001      	beq.n	cb7a <USB_softReset+0x1a>
    cb76:	f7f5 fddb 	bl	2730 <__stack_chk_fail>
    cb7a:	b003      	add	sp, #12
    cb7c:	f85d fb04 	ldr.w	pc, [sp], #4
    cb80:	1fff89d0 	.word	0x1fff89d0
    cb84:	05fa0004 	.word	0x05fa0004
    cb88:	e000ed0c 	.word	0xe000ed0c

0000cb8c <USB_availablechar>:
{
    cb8c:	b507      	push	{r0, r1, r2, lr}
    cb8e:	4b07      	ldr	r3, [pc, #28]	; (cbac <USB_availablechar+0x20>)
    cb90:	681a      	ldr	r2, [r3, #0]
    cb92:	9201      	str	r2, [sp, #4]
	return usb_serial_available();
    cb94:	9a01      	ldr	r2, [sp, #4]
    cb96:	681b      	ldr	r3, [r3, #0]
    cb98:	429a      	cmp	r2, r3
    cb9a:	d001      	beq.n	cba0 <USB_availablechar+0x14>
    cb9c:	f7f5 fdc8 	bl	2730 <__stack_chk_fail>
}
    cba0:	b003      	add	sp, #12
    cba2:	f85d eb04 	ldr.w	lr, [sp], #4
	return usb_serial_available();
    cba6:	f001 bae9 	b.w	e17c <usb_serial_available>
    cbaa:	bf00      	nop
    cbac:	1fff89d0 	.word	0x1fff89d0

0000cbb0 <USB_getchar>:
{
    cbb0:	b507      	push	{r0, r1, r2, lr}
    cbb2:	4b07      	ldr	r3, [pc, #28]	; (cbd0 <USB_getchar+0x20>)
    cbb4:	681a      	ldr	r2, [r3, #0]
    cbb6:	9201      	str	r2, [sp, #4]
	return (int)usb_serial_getchar();
    cbb8:	9a01      	ldr	r2, [sp, #4]
    cbba:	681b      	ldr	r3, [r3, #0]
    cbbc:	429a      	cmp	r2, r3
    cbbe:	d001      	beq.n	cbc4 <USB_getchar+0x14>
    cbc0:	f7f5 fdb6 	bl	2730 <__stack_chk_fail>
}
    cbc4:	b003      	add	sp, #12
    cbc6:	f85d eb04 	ldr.w	lr, [sp], #4
	return (int)usb_serial_getchar();
    cbca:	f001 baa5 	b.w	e118 <usb_serial_getchar>
    cbce:	bf00      	nop
    cbd0:	1fff89d0 	.word	0x1fff89d0

0000cbd4 <USB_putstr>:
{
    cbd4:	b513      	push	{r0, r1, r4, lr}
    cbd6:	4b0a      	ldr	r3, [pc, #40]	; (cc00 <USB_putstr+0x2c>)
    cbd8:	681a      	ldr	r2, [r3, #0]
    cbda:	9201      	str	r2, [sp, #4]
	while ( str[count] != '\0' )
    cbdc:	4602      	mov	r2, r0
    cbde:	1a11      	subs	r1, r2, r0
    cbe0:	f812 4b01 	ldrb.w	r4, [r2], #1
    cbe4:	2c00      	cmp	r4, #0
    cbe6:	d1fa      	bne.n	cbde <USB_putstr+0xa>
	return usb_serial_write( str, count );
    cbe8:	9a01      	ldr	r2, [sp, #4]
    cbea:	681b      	ldr	r3, [r3, #0]
    cbec:	429a      	cmp	r2, r3
    cbee:	d001      	beq.n	cbf4 <USB_putstr+0x20>
    cbf0:	f7f5 fd9e 	bl	2730 <__stack_chk_fail>
}
    cbf4:	b002      	add	sp, #8
    cbf6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return usb_serial_write( str, count );
    cbfa:	f001 badb 	b.w	e1b4 <usb_serial_write>
    cbfe:	bf00      	nop
    cc00:	1fff89d0 	.word	0x1fff89d0

0000cc04 <USB_rawio_availablechar>:
{
    cc04:	b507      	push	{r0, r1, r2, lr}
    cc06:	4b07      	ldr	r3, [pc, #28]	; (cc24 <USB_rawio_availablechar+0x20>)
    cc08:	681a      	ldr	r2, [r3, #0]
    cc0a:	9201      	str	r2, [sp, #4]
	return usb_rawio_available();
    cc0c:	9a01      	ldr	r2, [sp, #4]
    cc0e:	681b      	ldr	r3, [r3, #0]
    cc10:	429a      	cmp	r2, r3
    cc12:	d001      	beq.n	cc18 <USB_rawio_availablechar+0x14>
    cc14:	f7f5 fd8c 	bl	2730 <__stack_chk_fail>
}
    cc18:	b003      	add	sp, #12
    cc1a:	f85d eb04 	ldr.w	lr, [sp], #4
	return usb_rawio_available();
    cc1e:	f001 b9d5 	b.w	dfcc <usb_rawio_available>
    cc22:	bf00      	nop
    cc24:	1fff89d0 	.word	0x1fff89d0

0000cc28 <USB_rawio_getbuffer>:
{
    cc28:	b507      	push	{r0, r1, r2, lr}
    cc2a:	4b07      	ldr	r3, [pc, #28]	; (cc48 <USB_rawio_getbuffer+0x20>)
    cc2c:	681a      	ldr	r2, [r3, #0]
    cc2e:	9201      	str	r2, [sp, #4]
	return usb_rawio_rx( (void*)buffer, 0 );
    cc30:	9a01      	ldr	r2, [sp, #4]
    cc32:	681b      	ldr	r3, [r3, #0]
    cc34:	429a      	cmp	r2, r3
    cc36:	d001      	beq.n	cc3c <USB_rawio_getbuffer+0x14>
    cc38:	f7f5 fd7a 	bl	2730 <__stack_chk_fail>
    cc3c:	2100      	movs	r1, #0
}
    cc3e:	b003      	add	sp, #12
    cc40:	f85d eb04 	ldr.w	lr, [sp], #4
	return usb_rawio_rx( (void*)buffer, 0 );
    cc44:	f001 b9dc 	b.w	e000 <usb_rawio_rx>
    cc48:	1fff89d0 	.word	0x1fff89d0

0000cc4c <USB_rawio_sendbuffer>:
{
    cc4c:	b507      	push	{r0, r1, r2, lr}
    cc4e:	4b07      	ldr	r3, [pc, #28]	; (cc6c <USB_rawio_sendbuffer+0x20>)
    cc50:	681a      	ldr	r2, [r3, #0]
    cc52:	9201      	str	r2, [sp, #4]
	return usb_rawio_tx( (void*)buffer, 0 );
    cc54:	9a01      	ldr	r2, [sp, #4]
    cc56:	681b      	ldr	r3, [r3, #0]
    cc58:	429a      	cmp	r2, r3
    cc5a:	d001      	beq.n	cc60 <USB_rawio_sendbuffer+0x14>
    cc5c:	f7f5 fd68 	bl	2730 <__stack_chk_fail>
    cc60:	2100      	movs	r1, #0
}
    cc62:	b003      	add	sp, #12
    cc64:	f85d eb04 	ldr.w	lr, [sp], #4
	return usb_rawio_tx( (void*)buffer, 0 );
    cc68:	f001 ba0c 	b.w	e084 <usb_rawio_tx>
    cc6c:	1fff89d0 	.word	0x1fff89d0

0000cc70 <usb_set_config_descriptor_size>:
	{0, 0, NULL, 0}
};

// Simplifies defines for USB descriptors
void usb_set_config_descriptor_size()
{
    cc70:	b507      	push	{r0, r1, r2, lr}
    cc72:	4b08      	ldr	r3, [pc, #32]	; (cc94 <usb_set_config_descriptor_size+0x24>)
    cc74:	681a      	ldr	r2, [r3, #0]
    cc76:	9201      	str	r2, [sp, #4]
	config_descriptor[2] = LSB( sizeof( config_descriptor ) );
    cc78:	4a07      	ldr	r2, [pc, #28]	; (cc98 <usb_set_config_descriptor_size+0x28>)
    cc7a:	21cf      	movs	r1, #207	; 0xcf
    cc7c:	7091      	strb	r1, [r2, #2]
	config_descriptor[3] = MSB( sizeof( config_descriptor ) );
    cc7e:	2100      	movs	r1, #0
    cc80:	70d1      	strb	r1, [r2, #3]
}
    cc82:	9a01      	ldr	r2, [sp, #4]
    cc84:	681b      	ldr	r3, [r3, #0]
    cc86:	429a      	cmp	r2, r3
    cc88:	d001      	beq.n	cc8e <usb_set_config_descriptor_size+0x1e>
    cc8a:	f7f5 fd51 	bl	2730 <__stack_chk_fail>
    cc8e:	b003      	add	sp, #12
    cc90:	f85d fb04 	ldr.w	pc, [sp], #4
    cc94:	1fff89d0 	.word	0x1fff89d0
    cc98:	1fff8e46 	.word	0x1fff8e46

0000cc9c <endpoint0_transmit>:
	udd_ctrl_stall_data();
#endif
}

static void endpoint0_transmit( const void *data, uint32_t len )
{
    cc9c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    cc9e:	4c11      	ldr	r4, [pc, #68]	; (cce4 <endpoint0_transmit+0x48>)
#if defined(_kinetis_)
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    cca0:	4d11      	ldr	r5, [pc, #68]	; (cce8 <endpoint0_transmit+0x4c>)
{
    cca2:	6823      	ldr	r3, [r4, #0]
    cca4:	9301      	str	r3, [sp, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    cca6:	782b      	ldrb	r3, [r5, #0]
    cca8:	4f10      	ldr	r7, [pc, #64]	; (ccec <endpoint0_transmit+0x50>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ccaa:	4e11      	ldr	r6, [pc, #68]	; (ccf0 <endpoint0_transmit+0x54>)
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ccac:	f043 0c02 	orr.w	ip, r3, #2
    ccb0:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    ccb4:	f083 0301 	eor.w	r3, r3, #1
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    ccb8:	6050      	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ccba:	7832      	ldrb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    ccbc:	702b      	strb	r3, [r5, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ccbe:	2a00      	cmp	r2, #0
	ep0_tx_data_toggle ^= 1;
    ccc0:	f082 0201 	eor.w	r2, r2, #1
    ccc4:	7032      	strb	r2, [r6, #0]
#elif defined(_sam_)
	udd_set_setup_payload((uint8_t*)data, len);
#endif
}
    ccc6:	9a01      	ldr	r2, [sp, #4]
    ccc8:	6823      	ldr	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ccca:	bf14      	ite	ne
    cccc:	20c8      	movne	r0, #200	; 0xc8
    ccce:	2088      	moveq	r0, #136	; 0x88
    ccd0:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
}
    ccd4:	429a      	cmp	r2, r3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    ccd6:	f847 103c 	str.w	r1, [r7, ip, lsl #3]
}
    ccda:	d001      	beq.n	cce0 <endpoint0_transmit+0x44>
    ccdc:	f7f5 fd28 	bl	2730 <__stack_chk_fail>
    cce0:	b003      	add	sp, #12
    cce2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cce4:	1fff89d0 	.word	0x1fff89d0
    cce8:	1fff97b0 	.word	0x1fff97b0
    ccec:	1fff8000 	.word	0x1fff8000
    ccf0:	1fff97b1 	.word	0x1fff97b1

0000ccf4 <usb_device_check>:
}

// Used to check any USB state changes that may not have a proper interrupt
// Called once per scan loop, should take minimal processing time or it may affect other modules
void usb_device_check()
{
    ccf4:	b513      	push	{r0, r1, r4, lr}
    ccf6:	4b11      	ldr	r3, [pc, #68]	; (cd3c <usb_device_check+0x48>)
	// Check to see if we're still waiting for the next USB request after Get Configuration Descriptor
	// If still waiting, restart the USB initialization with a lower power requirement
	if ( power_neg_delay )
    ccf8:	4911      	ldr	r1, [pc, #68]	; (cd40 <usb_device_check+0x4c>)
{
    ccfa:	681a      	ldr	r2, [r3, #0]
    ccfc:	9201      	str	r2, [sp, #4]
	if ( power_neg_delay )
    ccfe:	780a      	ldrb	r2, [r1, #0]
    cd00:	4618      	mov	r0, r3
    cd02:	b1a2      	cbz	r2, cd2e <usb_device_check+0x3a>
	{
		// Check if 100 ms has elapsed
		if ( systick_millis_count - power_neg_time > 100 )
    cd04:	4a0f      	ldr	r2, [pc, #60]	; (cd44 <usb_device_check+0x50>)
    cd06:	4c10      	ldr	r4, [pc, #64]	; (cd48 <usb_device_check+0x54>)
    cd08:	6812      	ldr	r2, [r2, #0]
    cd0a:	6824      	ldr	r4, [r4, #0]
    cd0c:	1b12      	subs	r2, r2, r4
    cd0e:	2a64      	cmp	r2, #100	; 0x64
    cd10:	d90d      	bls.n	cd2e <usb_device_check+0x3a>
		{
			power_neg_delay = 0;
    cd12:	2200      	movs	r2, #0
    cd14:	700a      	strb	r2, [r1, #0]
			*usb_bMaxPower = 50;

			// Re-initialize USB
			usb_reinit();
#else
			warn_msg("USB Low Power Negotation Disabled, condition detected.");
    cd16:	9a01      	ldr	r2, [sp, #4]
    cd18:	681b      	ldr	r3, [r3, #0]
    cd1a:	429a      	cmp	r2, r3
    cd1c:	d001      	beq.n	cd22 <usb_device_check+0x2e>
#endif
		}
	}
}
    cd1e:	f7f5 fd07 	bl	2730 <__stack_chk_fail>
			warn_msg("USB Low Power Negotation Disabled, condition detected.");
    cd22:	480a      	ldr	r0, [pc, #40]	; (cd4c <usb_device_check+0x58>)
}
    cd24:	b002      	add	sp, #8
    cd26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			warn_msg("USB Low Power Negotation Disabled, condition detected.");
    cd2a:	f002 bc21 	b.w	f570 <_print>
}
    cd2e:	9a01      	ldr	r2, [sp, #4]
    cd30:	6803      	ldr	r3, [r0, #0]
    cd32:	429a      	cmp	r2, r3
    cd34:	d1f3      	bne.n	cd1e <usb_device_check+0x2a>
    cd36:	b002      	add	sp, #8
    cd38:	bd10      	pop	{r4, pc}
    cd3a:	bf00      	nop
    cd3c:	1fff89d0 	.word	0x1fff89d0
    cd40:	1fff97b8 	.word	0x1fff97b8
    cd44:	1fff92d8 	.word	0x1fff92d8
    cd48:	1fff97bc 	.word	0x1fff97bc
    cd4c:	0001628f 	.word	0x0001628f

0000cd50 <usb_set_configuration>:

void usb_set_configuration(uint8_t config) {
    cd50:	b507      	push	{r0, r1, r2, lr}
    cd52:	4a09      	ldr	r2, [pc, #36]	; (cd78 <usb_set_configuration+0x28>)
	usb_configuration = config;
	Output_Available = usb_configuration;
    cd54:	4909      	ldr	r1, [pc, #36]	; (cd7c <usb_set_configuration+0x2c>)
void usb_set_configuration(uint8_t config) {
    cd56:	6813      	ldr	r3, [r2, #0]
    cd58:	9301      	str	r3, [sp, #4]
	usb_configuration = config;
    cd5a:	4b09      	ldr	r3, [pc, #36]	; (cd80 <usb_set_configuration+0x30>)
    cd5c:	7018      	strb	r0, [r3, #0]
	Output_Available = usb_configuration;
    cd5e:	781b      	ldrb	r3, [r3, #0]
    cd60:	b2db      	uxtb	r3, r3
    cd62:	700b      	strb	r3, [r1, #0]
#if defined(_sam_)
	// Instead of using a callback to set the address for the CLI, just query it after USB is configured
	USBDev_Address = udd_getaddress();
#endif
}
    cd64:	9901      	ldr	r1, [sp, #4]
    cd66:	6813      	ldr	r3, [r2, #0]
    cd68:	4299      	cmp	r1, r3
    cd6a:	d001      	beq.n	cd70 <usb_set_configuration+0x20>
    cd6c:	f7f5 fce0 	bl	2730 <__stack_chk_fail>
    cd70:	b003      	add	sp, #12
    cd72:	f85d fb04 	ldr.w	pc, [sp], #4
    cd76:	bf00      	nop
    cd78:	1fff89d0 	.word	0x1fff89d0
    cd7c:	1fffb2ca 	.word	0x1fffb2ca
    cd80:	1fff987a 	.word	0x1fff987a

0000cd84 <usb_setup>:

void usb_setup()
{
    cd84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cd88:	4ebe      	ldr	r6, [pc, #760]	; (d084 <usb_setup+0x300>)
	uint32_t datalen = 0;
	const usb_descriptor_list_t *list;
	uint32_t size;

	// Reset USB Init timer
	USBInit_TimeEnd = systick_millis_count;
    cd8a:	4fbf      	ldr	r7, [pc, #764]	; (d088 <usb_setup+0x304>)
{
    cd8c:	6833      	ldr	r3, [r6, #0]
    cd8e:	b085      	sub	sp, #20
    cd90:	9303      	str	r3, [sp, #12]
	USBInit_TimeEnd = systick_millis_count;
    cd92:	4bbe      	ldr	r3, [pc, #760]	; (d08c <usb_setup+0x308>)
    cd94:	683a      	ldr	r2, [r7, #0]
    cd96:	601a      	str	r2, [r3, #0]
	USBInit_Ticks++;
    cd98:	4abd      	ldr	r2, [pc, #756]	; (d090 <usb_setup+0x30c>)
    cd9a:	8813      	ldrh	r3, [r2, #0]
    cd9c:	3301      	adds	r3, #1
    cd9e:	b29b      	uxth	r3, r3
    cda0:	8013      	strh	r3, [r2, #0]
	setup = *(setup_t*)&udd_g_ctrlreq.req;
#endif

	// If another request is made, disable the power negotiation check
	// See GET_DESCRIPTOR - Configuration
	if ( power_neg_delay )
    cda2:	4abc      	ldr	r2, [pc, #752]	; (d094 <usb_setup+0x310>)
    cda4:	7813      	ldrb	r3, [r2, #0]
    cda6:	b10b      	cbz	r3, cdac <usb_setup+0x28>
	{
		power_neg_delay = 0;
    cda8:	2300      	movs	r3, #0
    cdaa:	7013      	strb	r3, [r2, #0]
	}

	switch ( setup.wRequestAndType )
    cdac:	4cba      	ldr	r4, [pc, #744]	; (d098 <usb_setup+0x314>)
    cdae:	8823      	ldrh	r3, [r4, #0]
    cdb0:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    cdb4:	4625      	mov	r5, r4
    cdb6:	f000 80ff 	beq.w	cfb8 <usb_setup+0x234>
    cdba:	d84f      	bhi.n	ce5c <usb_setup+0xd8>
    cdbc:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    cdc0:	f000 81d2 	beq.w	d168 <usb_setup+0x3e4>
    cdc4:	d82d      	bhi.n	ce22 <usb_setup+0x9e>
    cdc6:	2b82      	cmp	r3, #130	; 0x82
    cdc8:	f000 81b3 	beq.w	d132 <usb_setup+0x3ae>
    cdcc:	d80f      	bhi.n	cdee <usb_setup+0x6a>
    cdce:	2b80      	cmp	r3, #128	; 0x80
    cdd0:	f000 81a0 	beq.w	d114 <usb_setup+0x390>
    cdd4:	2b81      	cmp	r3, #129	; 0x81
    cdd6:	f000 81a8 	beq.w	d12a <usb_setup+0x3a6>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    cdda:	4bb0      	ldr	r3, [pc, #704]	; (d09c <usb_setup+0x318>)
    cddc:	220f      	movs	r2, #15
    cdde:	701a      	strb	r2, [r3, #0]
	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
#elif defined(_sam_)
	endpoint0_transmit( data, size );
#endif
}
    cde0:	9a03      	ldr	r2, [sp, #12]
    cde2:	6833      	ldr	r3, [r6, #0]
    cde4:	429a      	cmp	r2, r3
    cde6:	f000 8270 	beq.w	d2ca <usb_setup+0x546>
    cdea:	f7f5 fca1 	bl	2730 <__stack_chk_fail>
	switch ( setup.wRequestAndType )
    cdee:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    cdf2:	f000 81b2 	beq.w	d15a <usb_setup+0x3d6>
    cdf6:	f240 1201 	movw	r2, #257	; 0x101
    cdfa:	4293      	cmp	r3, r2
    cdfc:	d1ed      	bne.n	cdda <usb_setup+0x56>
		warn_msg("CLEAR_FEATURE - Interface wValue(");
    cdfe:	48a8      	ldr	r0, [pc, #672]	; (d0a0 <usb_setup+0x31c>)
    ce00:	f002 fbb6 	bl	f570 <_print>
		printHex( setup.wValue );
    ce04:	2101      	movs	r1, #1
    ce06:	8860      	ldrh	r0, [r4, #2]
    ce08:	f002 fcd8 	bl	f7bc <printHex_op>
		print(") wIndex(");
    ce0c:	48a5      	ldr	r0, [pc, #660]	; (d0a4 <usb_setup+0x320>)
    ce0e:	f002 fbaf 	bl	f570 <_print>
		printHex( setup.wIndex );
    ce12:	88a0      	ldrh	r0, [r4, #4]
    ce14:	2101      	movs	r1, #1
    ce16:	f002 fcd1 	bl	f7bc <printHex_op>
		print( ")" NL );
    ce1a:	48a3      	ldr	r0, [pc, #652]	; (d0a8 <usb_setup+0x324>)
    ce1c:	f002 fba8 	bl	f570 <_print>
    ce20:	e7db      	b.n	cdda <usb_setup+0x56>
	switch ( setup.wRequestAndType )
    ce22:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
    ce26:	f000 81b3 	beq.w	d190 <usb_setup+0x40c>
    ce2a:	d80a      	bhi.n	ce42 <usb_setup+0xbe>
    ce2c:	f240 12a1 	movw	r2, #417	; 0x1a1
    ce30:	4293      	cmp	r3, r2
    ce32:	f000 80b0 	beq.w	cf96 <usb_setup+0x212>
    ce36:	f240 22a1 	movw	r2, #673	; 0x2a1
    ce3a:	4293      	cmp	r3, r2
    ce3c:	d1cd      	bne.n	cdda <usb_setup+0x56>
		reply_buffer[0] = USBKeys_Idle_Config;
    ce3e:	4b9b      	ldr	r3, [pc, #620]	; (d0ac <usb_setup+0x328>)
    ce40:	e165      	b.n	d10e <usb_setup+0x38a>
	switch ( setup.wRequestAndType )
    ce42:	f240 3202 	movw	r2, #770	; 0x302
    ce46:	4293      	cmp	r3, r2
    ce48:	f000 81ba 	beq.w	d1c0 <usb_setup+0x43c>
    ce4c:	f0c0 81b6 	bcc.w	d1bc <usb_setup+0x438>
    ce50:	f240 32a1 	movw	r2, #929	; 0x3a1
    ce54:	4293      	cmp	r3, r2
    ce56:	d1c0      	bne.n	cdda <usb_setup+0x56>
		reply_buffer[0] = USBKeys_Protocol_New; // Must be the same data set by SET_PROTOCOL
    ce58:	4b95      	ldr	r3, [pc, #596]	; (d0b0 <usb_setup+0x32c>)
    ce5a:	e158      	b.n	d10e <usb_setup+0x38a>
	switch ( setup.wRequestAndType )
    ce5c:	f640 2181 	movw	r1, #2689	; 0xa81
    ce60:	428b      	cmp	r3, r1
    ce62:	f000 81bc 	beq.w	d1de <usb_setup+0x45a>
    ce66:	d86f      	bhi.n	cf48 <usb_setup+0x1c4>
    ce68:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    ce6c:	f000 814e 	beq.w	d10c <usb_setup+0x388>
    ce70:	d81b      	bhi.n	ceaa <usb_setup+0x126>
    ce72:	f5a3 63d0 	sub.w	r3, r3, #1664	; 0x680
    ce76:	2b01      	cmp	r3, #1
    ce78:	d8af      	bhi.n	cdda <usb_setup+0x56>
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    ce7a:	8861      	ldrh	r1, [r4, #2]
    ce7c:	88a0      	ldrh	r0, [r4, #4]
		for ( list = usb_descriptor_list; 1; list++ )
    ce7e:	4b8d      	ldr	r3, [pc, #564]	; (d0b4 <usb_setup+0x330>)
			if ( list->addr == NULL )
    ce80:	685c      	ldr	r4, [r3, #4]
    ce82:	2c00      	cmp	r4, #0
    ce84:	d0a9      	beq.n	cdda <usb_setup+0x56>
			if ( setup.wValue == list->wValue && setup.wIndex == list->wIndex )
    ce86:	f8b3 c000 	ldrh.w	ip, [r3]
    ce8a:	458c      	cmp	ip, r1
    ce8c:	f040 81e6 	bne.w	d25c <usb_setup+0x4d8>
    ce90:	f8b3 c002 	ldrh.w	ip, [r3, #2]
    ce94:	4584      	cmp	ip, r0
    ce96:	f040 81e1 	bne.w	d25c <usb_setup+0x4d8>
				if ( (setup.wValue >> 8) == 3 )
    ce9a:	ea4f 2c11 	mov.w	ip, r1, lsr #8
    ce9e:	f1bc 0f03 	cmp.w	ip, #3
    cea2:	f040 81cf 	bne.w	d244 <usb_setup+0x4c0>
					datalen = *(list->addr);
    cea6:	7823      	ldrb	r3, [r4, #0]
    cea8:	e1a1      	b.n	d1ee <usb_setup+0x46a>
	switch ( setup.wRequestAndType )
    ceaa:	f640 1221 	movw	r2, #2337	; 0x921
    ceae:	4293      	cmp	r3, r2
    ceb0:	f000 81d9 	beq.w	d266 <usb_setup+0x4e2>
    ceb4:	f640 2221 	movw	r2, #2593	; 0xa21
    ceb8:	4293      	cmp	r3, r2
    ceba:	f000 81e8 	beq.w	d28e <usb_setup+0x50a>
    cebe:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    cec2:	d18a      	bne.n	cdda <usb_setup+0x56>
		usb_set_configuration(setup.wValue);
    cec4:	78a0      	ldrb	r0, [r4, #2]
			if ( table[i].desc & BDT_OWN )
    cec6:	f8df 8224 	ldr.w	r8, [pc, #548]	; d0ec <usb_setup+0x368>
		usb_set_configuration(setup.wValue);
    ceca:	f7ff ff41 	bl	cd50 <usb_set_configuration>
		Output_update_usb_current( *usb_bMaxPower * 2 );
    cece:	4b7a      	ldr	r3, [pc, #488]	; (d0b8 <usb_setup+0x334>)
    ced0:	681b      	ldr	r3, [r3, #0]
    ced2:	7818      	ldrb	r0, [r3, #0]
    ced4:	0040      	lsls	r0, r0, #1
    ced6:	f7fe fec5 	bl	bc64 <Output_update_usb_current>
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
    ceda:	2704      	movs	r7, #4
    cedc:	4644      	mov	r4, r8
			if ( table[i].desc & BDT_OWN )
    cede:	f858 2037 	ldr.w	r2, [r8, r7, lsl #3]
    cee2:	0611      	lsls	r1, r2, #24
    cee4:	ea4f 03c7 	mov.w	r3, r7, lsl #3
    cee8:	d504      	bpl.n	cef4 <usb_setup+0x170>
				usb_free( (usb_packet_t *)((uint8_t *)(table[ i ].addr) - 8) );
    ceea:	4443      	add	r3, r8
    ceec:	6858      	ldr	r0, [r3, #4]
    ceee:	3808      	subs	r0, #8
    cef0:	f000 ffac 	bl	de4c <usb_free>
		for ( i = 4; i < ( NUM_ENDPOINTS + 1) * 4; i++ )
    cef4:	3701      	adds	r7, #1
    cef6:	2f2c      	cmp	r7, #44	; 0x2c
    cef8:	d1f1      	bne.n	cede <usb_setup+0x15a>
			p = rx_first[i];
    cefa:	4f70      	ldr	r7, [pc, #448]	; (d0bc <usb_setup+0x338>)
			rx_last[ i ] = NULL;
    cefc:	f8df 81f0 	ldr.w	r8, [pc, #496]	; d0f0 <usb_setup+0x36c>
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
    cf00:	f04f 0a00 	mov.w	sl, #0
    cf04:	46b9      	mov	r9, r7
			p = rx_first[i];
    cf06:	f857 002a 	ldr.w	r0, [r7, sl, lsl #2]
    cf0a:	ea4f 0b8a 	mov.w	fp, sl, lsl #2
			while ( p )
    cf0e:	2800      	cmp	r0, #0
    cf10:	d156      	bne.n	cfc0 <usb_setup+0x23c>
			p = tx_first[i];
    cf12:	4b6b      	ldr	r3, [pc, #428]	; (d0c0 <usb_setup+0x33c>)
			rx_first[ i ] = NULL;
    cf14:	f849 000b 	str.w	r0, [r9, fp]
			rx_last[ i ] = NULL;
    cf18:	f84b 0008 	str.w	r0, [fp, r8]
			p = tx_first[i];
    cf1c:	f85b 0003 	ldr.w	r0, [fp, r3]
			while (p)
    cf20:	2800      	cmp	r0, #0
    cf22:	d154      	bne.n	cfce <usb_setup+0x24a>
			tx_first[ i ] = NULL;
    cf24:	f843 000b 	str.w	r0, [r3, fp]
			tx_last[ i ] = NULL;
    cf28:	4b66      	ldr	r3, [pc, #408]	; (d0c4 <usb_setup+0x340>)
			switch ( tx_state[ i ] )
    cf2a:	4a67      	ldr	r2, [pc, #412]	; (d0c8 <usb_setup+0x344>)
			tx_last[ i ] = NULL;
    cf2c:	f84b 0003 	str.w	r0, [fp, r3]
			usb_rx_byte_count_data[i] = 0;
    cf30:	4b66      	ldr	r3, [pc, #408]	; (d0cc <usb_setup+0x348>)
    cf32:	f823 001a 	strh.w	r0, [r3, sl, lsl #1]
			switch ( tx_state[ i ] )
    cf36:	f812 300a 	ldrb.w	r3, [r2, sl]
    cf3a:	3b02      	subs	r3, #2
    cf3c:	2b03      	cmp	r3, #3
    cf3e:	d852      	bhi.n	cfe6 <usb_setup+0x262>
    cf40:	e8df f003 	tbb	[pc, r3]
    cf44:	934e934e 	.word	0x934e934e
	switch ( setup.wRequestAndType )
    cf48:	f640 4282 	movw	r2, #3202	; 0xc82
    cf4c:	4293      	cmp	r3, r2
    cf4e:	f000 816b 	beq.w	d228 <usb_setup+0x4a4>
    cf52:	d80f      	bhi.n	cf74 <usb_setup+0x1f0>
    cf54:	f640 3201 	movw	r2, #2817	; 0xb01
    cf58:	4293      	cmp	r3, r2
    cf5a:	f000 815c 	beq.w	d216 <usb_setup+0x492>
    cf5e:	f640 3221 	movw	r2, #2849	; 0xb21
    cf62:	4293      	cmp	r3, r2
    cf64:	f47f af39 	bne.w	cdda <usb_setup+0x56>
		USBKeys_Protocol_New = setup.wValue & 0xFF; // 0 - Boot Mode, 1 - NKRO Mode
    cf68:	4b51      	ldr	r3, [pc, #324]	; (d0b0 <usb_setup+0x32c>)
    cf6a:	78a2      	ldrb	r2, [r4, #2]
    cf6c:	701a      	strb	r2, [r3, #0]
		USBKeys_Protocol_Change = 1;
    cf6e:	4b58      	ldr	r3, [pc, #352]	; (d0d0 <usb_setup+0x34c>)
    cf70:	2201      	movs	r2, #1
    cf72:	e023      	b.n	cfbc <usb_setup+0x238>
	switch ( setup.wRequestAndType )
    cf74:	f242 12a1 	movw	r2, #8609	; 0x21a1
    cf78:	4293      	cmp	r3, r2
    cf7a:	f000 8190 	beq.w	d29e <usb_setup+0x51a>
    cf7e:	f242 2221 	movw	r2, #8737	; 0x2221
    cf82:	4293      	cmp	r3, r2
    cf84:	f000 816c 	beq.w	d260 <usb_setup+0x4dc>
    cf88:	f242 0221 	movw	r2, #8225	; 0x2021
    cf8c:	4293      	cmp	r3, r2
    cf8e:	f47f af24 	bne.w	cdda <usb_setup+0x56>
	uint32_t datalen = 0;
    cf92:	2300      	movs	r3, #0
    cf94:	e0fa      	b.n	d18c <usb_setup+0x408>
			if ( setup.wIndex == list->wIndex )
    cf96:	88a2      	ldrh	r2, [r4, #4]
		for ( list = usb_descriptor_list; 1; list++ )
    cf98:	4b46      	ldr	r3, [pc, #280]	; (d0b4 <usb_setup+0x330>)
			if ( list->addr == NULL )
    cf9a:	685c      	ldr	r4, [r3, #4]
    cf9c:	2c00      	cmp	r4, #0
    cf9e:	f43f af1c 	beq.w	cdda <usb_setup+0x56>
			if ( list->wValue != 0x2200 )
    cfa2:	8819      	ldrh	r1, [r3, #0]
    cfa4:	f5b1 5f08 	cmp.w	r1, #8704	; 0x2200
    cfa8:	f040 816f 	bne.w	d28a <usb_setup+0x506>
			if ( setup.wIndex == list->wIndex )
    cfac:	8859      	ldrh	r1, [r3, #2]
    cfae:	4291      	cmp	r1, r2
    cfb0:	f040 816b 	bne.w	d28a <usb_setup+0x506>
				datalen = list->length;
    cfb4:	891b      	ldrh	r3, [r3, #8]
				goto send;
    cfb6:	e11a      	b.n	d1ee <usb_setup+0x46a>
		USBDev_Address = setup.wValue;
    cfb8:	78a2      	ldrb	r2, [r4, #2]
    cfba:	4b46      	ldr	r3, [pc, #280]	; (d0d4 <usb_setup+0x350>)
		USBKeys_Protocol_Change = 1;
    cfbc:	701a      	strb	r2, [r3, #0]
    cfbe:	e7e8      	b.n	cf92 <usb_setup+0x20e>
				n = p->next;
    cfc0:	6843      	ldr	r3, [r0, #4]
    cfc2:	9300      	str	r3, [sp, #0]
				usb_free(p);
    cfc4:	f000 ff42 	bl	de4c <usb_free>
				p = n;
    cfc8:	9b00      	ldr	r3, [sp, #0]
    cfca:	4618      	mov	r0, r3
    cfcc:	e79f      	b.n	cf0e <usb_setup+0x18a>
				n = p->next;
    cfce:	6842      	ldr	r2, [r0, #4]
    cfd0:	9301      	str	r3, [sp, #4]
    cfd2:	9200      	str	r2, [sp, #0]
				usb_free(p);
    cfd4:	f000 ff3a 	bl	de4c <usb_free>
				p = n;
    cfd8:	9a00      	ldr	r2, [sp, #0]
    cfda:	9b01      	ldr	r3, [sp, #4]
    cfdc:	4610      	mov	r0, r2
    cfde:	e79f      	b.n	cf20 <usb_setup+0x19c>
				tx_state[ i ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    cfe0:	2300      	movs	r3, #0
				tx_state[ i ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    cfe2:	f802 300a 	strb.w	r3, [r2, sl]
		for ( i = 0; i < NUM_ENDPOINTS; i++ )
    cfe6:	f10a 0a01 	add.w	sl, sl, #1
    cfea:	f1ba 0f0a 	cmp.w	sl, #10
    cfee:	d18a      	bne.n	cf06 <usb_setup+0x182>
		usb_rx_memory_needed = 0;
    cff0:	4b39      	ldr	r3, [pc, #228]	; (d0d8 <usb_setup+0x354>)
    cff2:	4f3a      	ldr	r7, [pc, #232]	; (d0dc <usb_setup+0x358>)
		reg = &USB0_ENDPT1;
    cff4:	f8df a0fc 	ldr.w	sl, [pc, #252]	; d0f4 <usb_setup+0x370>
    cff8:	f8df 90fc 	ldr.w	r9, [pc, #252]	; d0f8 <usb_setup+0x374>
		usb_rx_memory_needed = 0;
    cffc:	2200      	movs	r2, #0
    cffe:	701a      	strb	r2, [r3, #0]
    d000:	469b      	mov	fp, r3
			epconf = *cfg++;
    d002:	f817 3f01 	ldrb.w	r3, [r7, #1]!
			*reg = epconf;
    d006:	f80a 3b04 	strb.w	r3, [sl], #4
			if ( epconf & USB_ENDPT_EPRXEN )
    d00a:	071a      	lsls	r2, r3, #28
    d00c:	eb0a 0809 	add.w	r8, sl, r9
    d010:	d51e      	bpl.n	d050 <usb_setup+0x2cc>
				p = usb_malloc();
    d012:	f000 fef1 	bl	ddf8 <usb_malloc>
    d016:	ea4f 03ca 	mov.w	r3, sl, lsl #3
				if ( p )
    d01a:	b340      	cbz	r0, d06e <usb_setup+0x2ea>
    d01c:	4423      	add	r3, r4
					table[ index( i, RX, EVEN ) ].addr = p->buf;
    d01e:	f5a3 1364 	sub.w	r3, r3, #3735552	; 0x390000
    d022:	f2a3 6c1c 	subw	ip, r3, #1564	; 0x61c
    d026:	3008      	adds	r0, #8
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    d028:	f5a3 63c4 	sub.w	r3, r3, #1568	; 0x620
					table[ index( i, RX, EVEN ) ].addr = p->buf;
    d02c:	f8cc 0000 	str.w	r0, [ip]
					table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    d030:	482b      	ldr	r0, [pc, #172]	; (d0e0 <usb_setup+0x35c>)
    d032:	6018      	str	r0, [r3, #0]
				p = usb_malloc();
    d034:	f000 fee0 	bl	ddf8 <usb_malloc>
    d038:	f048 0301 	orr.w	r3, r8, #1
				if ( p )
    d03c:	2800      	cmp	r0, #0
    d03e:	d05d      	beq.n	d0fc <usb_setup+0x378>
					table[ index( i, RX, ODD ) ].addr = p->buf;
    d040:	eb04 0cc3 	add.w	ip, r4, r3, lsl #3
					table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    d044:	4a27      	ldr	r2, [pc, #156]	; (d0e4 <usb_setup+0x360>)
    d046:	f844 2033 	str.w	r2, [r4, r3, lsl #3]
					table[ index( i, RX, ODD ) ].addr = p->buf;
    d04a:	3008      	adds	r0, #8
    d04c:	f8cc 0004 	str.w	r0, [ip, #4]
			table[ index( i, TX, EVEN ) ].desc = 0;
    d050:	f048 0002 	orr.w	r0, r8, #2
			table[ index( i, TX, ODD ) ].desc = 0;
    d054:	f048 0103 	orr.w	r1, r8, #3
			table[ index( i, TX, EVEN ) ].desc = 0;
    d058:	2300      	movs	r3, #0
    d05a:	f844 3030 	str.w	r3, [r4, r0, lsl #3]
			table[ index( i, TX, ODD ) ].desc = 0;
    d05e:	f844 3031 	str.w	r3, [r4, r1, lsl #3]
		for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    d062:	4b21      	ldr	r3, [pc, #132]	; (d0e8 <usb_setup+0x364>)
    d064:	459a      	cmp	sl, r3
    d066:	d1cc      	bne.n	d002 <usb_setup+0x27e>
    d068:	e793      	b.n	cf92 <usb_setup+0x20e>
				tx_state[ i ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    d06a:	2301      	movs	r3, #1
    d06c:	e7b9      	b.n	cfe2 <usb_setup+0x25e>
					table[ index( i, RX, EVEN ) ].desc = 0;
    d06e:	f5a3 1364 	sub.w	r3, r3, #3735552	; 0x390000
    d072:	f5a3 63c4 	sub.w	r3, r3, #1568	; 0x620
    d076:	50e0      	str	r0, [r4, r3]
					usb_rx_memory_needed++;
    d078:	f89b 3000 	ldrb.w	r3, [fp]
    d07c:	3301      	adds	r3, #1
    d07e:	f88b 3000 	strb.w	r3, [fp]
    d082:	e7d7      	b.n	d034 <usb_setup+0x2b0>
    d084:	1fff89d0 	.word	0x1fff89d0
    d088:	1fff92d8 	.word	0x1fff92d8
    d08c:	1fffb2d4 	.word	0x1fffb2d4
    d090:	1fffb2de 	.word	0x1fffb2de
    d094:	1fff97b8 	.word	0x1fff97b8
    d098:	1fff9818 	.word	0x1fff9818
    d09c:	400720c0 	.word	0x400720c0
    d0a0:	0001630d 	.word	0x0001630d
    d0a4:	00016344 	.word	0x00016344
    d0a8:	00016dad 	.word	0x00016dad
    d0ac:	1fff9728 	.word	0x1fff9728
    d0b0:	1fff8e45 	.word	0x1fff8e45
    d0b4:	00016104 	.word	0x00016104
    d0b8:	1fff9090 	.word	0x1fff9090
    d0bc:	1fff97c8 	.word	0x1fff97c8
    d0c0:	1fff9820 	.word	0x1fff9820
    d0c4:	1fff9848 	.word	0x1fff9848
    d0c8:	1fff9870 	.word	0x1fff9870
    d0cc:	1fffb338 	.word	0x1fffb338
    d0d0:	1fffb330 	.word	0x1fffb330
    d0d4:	1fffb302 	.word	0x1fffb302
    d0d8:	1fff987e 	.word	0x1fff987e
    d0dc:	00016247 	.word	0x00016247
    d0e0:	00400088 	.word	0x00400088
    d0e4:	004000c8 	.word	0x004000c8
    d0e8:	400720ec 	.word	0x400720ec
    d0ec:	1fff8000 	.word	0x1fff8000
    d0f0:	1fff97f0 	.word	0x1fff97f0
    d0f4:	400720c4 	.word	0x400720c4
    d0f8:	bff8df3c 	.word	0xbff8df3c
					table[ index( i, RX, ODD ) ].desc = 0;
    d0fc:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
					usb_rx_memory_needed++;
    d100:	f89b 3000 	ldrb.w	r3, [fp]
    d104:	3301      	adds	r3, #1
    d106:	f88b 3000 	strb.w	r3, [fp]
    d10a:	e7a1      	b.n	d050 <usb_setup+0x2cc>
		reply_buffer[0] = usb_configuration;
    d10c:	4b70      	ldr	r3, [pc, #448]	; (d2d0 <usb_setup+0x54c>)
		reply_buffer[0] = USBKeys_Idle_Config;
    d10e:	781b      	ldrb	r3, [r3, #0]
    d110:	4c70      	ldr	r4, [pc, #448]	; (d2d4 <usb_setup+0x550>)
    d112:	e06a      	b.n	d1ea <usb_setup+0x466>
		reply_buffer[0] = (usb_remote_wakeup ? 1 : 0) << 1; // D1 is the remote wakeup bit
    d114:	4b70      	ldr	r3, [pc, #448]	; (d2d8 <usb_setup+0x554>)
    d116:	4c6f      	ldr	r4, [pc, #444]	; (d2d4 <usb_setup+0x550>)
    d118:	781b      	ldrb	r3, [r3, #0]
    d11a:	2b00      	cmp	r3, #0
    d11c:	bf18      	it	ne
    d11e:	2302      	movne	r3, #2
    d120:	7023      	strb	r3, [r4, #0]
		reply_buffer[1] = 0;
    d122:	2300      	movs	r3, #0
		reply_buffer[1] = 0;
    d124:	7063      	strb	r3, [r4, #1]
		datalen = 2;
    d126:	2302      	movs	r3, #2
    d128:	e061      	b.n	d1ee <usb_setup+0x46a>
		reply_buffer[0] = 0;
    d12a:	4c6a      	ldr	r4, [pc, #424]	; (d2d4 <usb_setup+0x550>)
    d12c:	2300      	movs	r3, #0
    d12e:	7023      	strb	r3, [r4, #0]
    d130:	e7f8      	b.n	d124 <usb_setup+0x3a0>
		uint8_t endpoint = setup.wIndex & 0x0F; // D0..D3 Endpoint Number
    d132:	7923      	ldrb	r3, [r4, #4]
    d134:	4a69      	ldr	r2, [pc, #420]	; (d2dc <usb_setup+0x558>)
    d136:	f003 030f 	and.w	r3, r3, #15
		if ( endpoint > NUM_ENDPOINTS )
    d13a:	2b0a      	cmp	r3, #10
    d13c:	d902      	bls.n	d144 <usb_setup+0x3c0>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    d13e:	230f      	movs	r3, #15
    d140:	7013      	strb	r3, [r2, #0]
    d142:	e64d      	b.n	cde0 <usb_setup+0x5c>
		reply_buffer[0] = 0;
    d144:	4c63      	ldr	r4, [pc, #396]	; (d2d4 <usb_setup+0x550>)
    d146:	2100      	movs	r1, #0
    d148:	7021      	strb	r1, [r4, #0]
		reply_buffer[1] = 0;
    d14a:	7061      	strb	r1, [r4, #1]
		if ( *(uint8_t *)(&USB0_ENDPT0 + endpoint * 4) & USB_ENDPT_EPSTALL )
    d14c:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
    d150:	079b      	lsls	r3, r3, #30
    d152:	d5e8      	bpl.n	d126 <usb_setup+0x3a2>
			reply_buffer[0] = 1;
    d154:	2301      	movs	r3, #1
    d156:	7023      	strb	r3, [r4, #0]
    d158:	e7e5      	b.n	d126 <usb_setup+0x3a2>
		switch ( setup.wValue )
    d15a:	8863      	ldrh	r3, [r4, #2]
    d15c:	2b01      	cmp	r3, #1
    d15e:	d127      	bne.n	d1b0 <usb_setup+0x42c>
			usb_remote_wakeup = 0;
    d160:	4a5d      	ldr	r2, [pc, #372]	; (d2d8 <usb_setup+0x554>)
    d162:	2300      	movs	r3, #0
			USBKeys_Idle_Config = USBIdle_define;
    d164:	7013      	strb	r3, [r2, #0]
    d166:	e011      	b.n	d18c <usb_setup+0x408>
		uint8_t endpoint = setup.wIndex & 0x0F; // D0..D3 Endpoint Number
    d168:	7922      	ldrb	r2, [r4, #4]
    d16a:	495c      	ldr	r1, [pc, #368]	; (d2dc <usb_setup+0x558>)
    d16c:	f002 020f 	and.w	r2, r2, #15
		if ( endpoint > NUM_ENDPOINTS || setup.wValue != 0 )
    d170:	2a0a      	cmp	r2, #10
    d172:	d801      	bhi.n	d178 <usb_setup+0x3f4>
    d174:	8863      	ldrh	r3, [r4, #2]
    d176:	b113      	cbz	r3, d17e <usb_setup+0x3fa>
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    d178:	230f      	movs	r3, #15
    d17a:	700b      	strb	r3, [r1, #0]
    d17c:	e630      	b.n	cde0 <usb_setup+0x5c>
		(*(uint8_t *)(&USB0_ENDPT0 + endpoint * 4)) &= ~USB_ENDPT_EPSTALL;
    d17e:	b212      	sxth	r2, r2
    d180:	f811 0022 	ldrb.w	r0, [r1, r2, lsl #2]
    d184:	f020 0002 	bic.w	r0, r0, #2
		(*(uint8_t *)(&USB0_ENDPT0 + endpoint * 4)) |= USB_ENDPT_EPSTALL;
    d188:	f801 0022 	strb.w	r0, [r1, r2, lsl #2]
	const uint8_t *data = NULL;
    d18c:	461c      	mov	r4, r3
    d18e:	e02e      	b.n	d1ee <usb_setup+0x46a>
		warn_msg("(SET_FEATURE, SETUP)  - ");
    d190:	4853      	ldr	r0, [pc, #332]	; (d2e0 <usb_setup+0x55c>)
    d192:	f002 f9ed 	bl	f570 <_print>
		printHex32( setup.wValue );
    d196:	2101      	movs	r1, #1
    d198:	8860      	ldrh	r0, [r4, #2]
    d19a:	f002 fb61 	bl	f860 <printHex32_op>
		print(NL);
    d19e:	4851      	ldr	r0, [pc, #324]	; (d2e4 <usb_setup+0x560>)
    d1a0:	f002 f9e6 	bl	f570 <_print>
		switch ( setup.wValue )
    d1a4:	8863      	ldrh	r3, [r4, #2]
    d1a6:	2b01      	cmp	r3, #1
    d1a8:	d102      	bne.n	d1b0 <usb_setup+0x42c>
			usb_remote_wakeup = 1;
    d1aa:	4a4b      	ldr	r2, [pc, #300]	; (d2d8 <usb_setup+0x554>)
    d1ac:	7013      	strb	r3, [r2, #0]
    d1ae:	e6f0      	b.n	cf92 <usb_setup+0x20e>
		warn_msg("SET_FEATURE - Device wValue(");
    d1b0:	484d      	ldr	r0, [pc, #308]	; (d2e8 <usb_setup+0x564>)
    d1b2:	f002 f9dd 	bl	f570 <_print>
		printHex( setup.wValue );
    d1b6:	2101      	movs	r1, #1
    d1b8:	8860      	ldrh	r0, [r4, #2]
    d1ba:	e62c      	b.n	ce16 <usb_setup+0x92>
		warn_msg("SET_FEATURE - Interface wValue(");
    d1bc:	484b      	ldr	r0, [pc, #300]	; (d2ec <usb_setup+0x568>)
    d1be:	e61f      	b.n	ce00 <usb_setup+0x7c>
		uint8_t endpoint = setup.wIndex & 0x0F; // D0..D3 Endpoint Number
    d1c0:	7922      	ldrb	r2, [r4, #4]
    d1c2:	4946      	ldr	r1, [pc, #280]	; (d2dc <usb_setup+0x558>)
    d1c4:	f002 020f 	and.w	r2, r2, #15
		if ( endpoint > NUM_ENDPOINTS || setup.wValue != 0 )
    d1c8:	2a0a      	cmp	r2, #10
    d1ca:	d8d5      	bhi.n	d178 <usb_setup+0x3f4>
    d1cc:	8863      	ldrh	r3, [r4, #2]
    d1ce:	2b00      	cmp	r3, #0
    d1d0:	d1d2      	bne.n	d178 <usb_setup+0x3f4>
		(*(uint8_t *)(&USB0_ENDPT0 + endpoint * 4)) |= USB_ENDPT_EPSTALL;
    d1d2:	b212      	sxth	r2, r2
    d1d4:	f811 0022 	ldrb.w	r0, [r1, r2, lsl #2]
    d1d8:	f040 0002 	orr.w	r0, r0, #2
    d1dc:	e7d4      	b.n	d188 <usb_setup+0x404>
		if ( setup.wIndex > NUM_INTERFACES )
    d1de:	88a3      	ldrh	r3, [r4, #4]
    d1e0:	2b08      	cmp	r3, #8
    d1e2:	f63f adfa 	bhi.w	cdda <usb_setup+0x56>
		reply_buffer[0] = 0;
    d1e6:	4c3b      	ldr	r4, [pc, #236]	; (d2d4 <usb_setup+0x550>)
    d1e8:	2300      	movs	r3, #0
    d1ea:	7023      	strb	r3, [r4, #0]
		datalen = 1;
    d1ec:	2301      	movs	r3, #1
	if ( datalen > setup.wLength )
    d1ee:	88ef      	ldrh	r7, [r5, #6]
    d1f0:	429f      	cmp	r7, r3
    d1f2:	bf28      	it	cs
    d1f4:	461f      	movcs	r7, r3
    d1f6:	2f40      	cmp	r7, #64	; 0x40
    d1f8:	463d      	mov	r5, r7
    d1fa:	bf28      	it	cs
    d1fc:	2540      	movcs	r5, #64	; 0x40
	endpoint0_transmit( data, size );
    d1fe:	4629      	mov	r1, r5
    d200:	4620      	mov	r0, r4
    d202:	f7ff fd4b 	bl	cc9c <endpoint0_transmit>
	data += size;
    d206:	442c      	add	r4, r5
	if ( datalen == 0 && size < EP0_SIZE )
    d208:	1b7d      	subs	r5, r7, r5
    d20a:	d14b      	bne.n	d2a4 <usb_setup+0x520>
    d20c:	2f3f      	cmp	r7, #63	; 0x3f
    d20e:	f67f ade7 	bls.w	cde0 <usb_setup+0x5c>
    d212:	462f      	mov	r7, r5
    d214:	e04a      	b.n	d2ac <usb_setup+0x528>
		if ( setup.wIndex > NUM_INTERFACES || setup.wValue != 0 )
    d216:	88a3      	ldrh	r3, [r4, #4]
    d218:	2b08      	cmp	r3, #8
    d21a:	f63f adde 	bhi.w	cdda <usb_setup+0x56>
    d21e:	8863      	ldrh	r3, [r4, #2]
    d220:	2b00      	cmp	r3, #0
    d222:	f43f aeb6 	beq.w	cf92 <usb_setup+0x20e>
    d226:	e5d8      	b.n	cdda <usb_setup+0x56>
		uint8_t endpoint = setup.wIndex & 0x0F; // D0..D3 Endpoint Number
    d228:	7923      	ldrb	r3, [r4, #4]
    d22a:	4a2c      	ldr	r2, [pc, #176]	; (d2dc <usb_setup+0x558>)
    d22c:	f003 030f 	and.w	r3, r3, #15
		if ( endpoint <= NUM_ENDPOINTS )
    d230:	2b0a      	cmp	r3, #10
    d232:	d884      	bhi.n	d13e <usb_setup+0x3ba>
			if ( ( (*(uint8_t *)(&USB0_ENDPT0 + endpoint * 4)) & USB_ENDPT_EPHSHK ) == 0 )
    d234:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
    d238:	f013 0301 	ands.w	r3, r3, #1
    d23c:	f47f af7f 	bne.w	d13e <usb_setup+0x3ba>
				reply_buffer[0] = 0;
    d240:	4c24      	ldr	r4, [pc, #144]	; (d2d4 <usb_setup+0x550>)
    d242:	e774      	b.n	d12e <usb_setup+0x3aa>
				if ( setup.wValue == 0x0200 && setup.wIndex == 0x0 )
    d244:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
					datalen = list->length;
    d248:	891b      	ldrh	r3, [r3, #8]
				if ( setup.wValue == 0x0200 && setup.wIndex == 0x0 )
    d24a:	d1d0      	bne.n	d1ee <usb_setup+0x46a>
    d24c:	2800      	cmp	r0, #0
    d24e:	d1ce      	bne.n	d1ee <usb_setup+0x46a>
					power_neg_delay = 1;
    d250:	2101      	movs	r1, #1
    d252:	7011      	strb	r1, [r2, #0]
					power_neg_time = systick_millis_count;
    d254:	4a26      	ldr	r2, [pc, #152]	; (d2f0 <usb_setup+0x56c>)
    d256:	6839      	ldr	r1, [r7, #0]
    d258:	6011      	str	r1, [r2, #0]
    d25a:	e7c8      	b.n	d1ee <usb_setup+0x46a>
		for ( list = usb_descriptor_list; 1; list++ )
    d25c:	330c      	adds	r3, #12
			if ( list->addr == NULL )
    d25e:	e60f      	b.n	ce80 <usb_setup+0xfc>
		usb_cdc_line_rtsdtr = setup.wValue;
    d260:	78a2      	ldrb	r2, [r4, #2]
    d262:	4b24      	ldr	r3, [pc, #144]	; (d2f4 <usb_setup+0x570>)
    d264:	e6aa      	b.n	cfbc <usb_setup+0x238>
    d266:	7922      	ldrb	r2, [r4, #4]
    d268:	2a05      	cmp	r2, #5
    d26a:	d805      	bhi.n	d278 <usb_setup+0x4f4>
    d26c:	2301      	movs	r3, #1
    d26e:	4093      	lsls	r3, r2
    d270:	f013 0f23 	tst.w	r3, #35	; 0x23
    d274:	f47f ae8d 	bne.w	cf92 <usb_setup+0x20e>
			warn_msg("(SET_REPORT, SETUP) Unknown interface - ");
    d278:	481f      	ldr	r0, [pc, #124]	; (d2f8 <usb_setup+0x574>)
    d27a:	f002 f979 	bl	f570 <_print>
			printHex( setup.wIndex );
    d27e:	88a8      	ldrh	r0, [r5, #4]
    d280:	2101      	movs	r1, #1
    d282:	f002 fa9b 	bl	f7bc <printHex_op>
			print( NL );
    d286:	4817      	ldr	r0, [pc, #92]	; (d2e4 <usb_setup+0x560>)
    d288:	e5c8      	b.n	ce1c <usb_setup+0x98>
		for ( list = usb_descriptor_list; 1; list++ )
    d28a:	330c      	adds	r3, #12
			if ( list->addr == NULL )
    d28c:	e685      	b.n	cf9a <usb_setup+0x216>
		USBKeys_Idle_Config = (setup.wValue >> 8);
    d28e:	8863      	ldrh	r3, [r4, #2]
    d290:	4a1a      	ldr	r2, [pc, #104]	; (d2fc <usb_setup+0x578>)
		USBKeys_Idle_Expiry = 0;
    d292:	491b      	ldr	r1, [pc, #108]	; (d300 <usb_setup+0x57c>)
		USBKeys_Idle_Config = (setup.wValue >> 8);
    d294:	0a1b      	lsrs	r3, r3, #8
    d296:	7013      	strb	r3, [r2, #0]
		USBKeys_Idle_Expiry = 0;
    d298:	2300      	movs	r3, #0
    d29a:	600b      	str	r3, [r1, #0]
    d29c:	e762      	b.n	d164 <usb_setup+0x3e0>
		datalen = sizeof( usb_cdc_line_coding );
    d29e:	2308      	movs	r3, #8
		data = (uint8_t*)&usb_cdc_line_coding;
    d2a0:	4c18      	ldr	r4, [pc, #96]	; (d304 <usb_setup+0x580>)
    d2a2:	e7a4      	b.n	d1ee <usb_setup+0x46a>
    d2a4:	2d40      	cmp	r5, #64	; 0x40
    d2a6:	462f      	mov	r7, r5
    d2a8:	bf28      	it	cs
    d2aa:	2740      	movcs	r7, #64	; 0x40
	endpoint0_transmit( data, size );
    d2ac:	4620      	mov	r0, r4
    d2ae:	4639      	mov	r1, r7
    d2b0:	f7ff fcf4 	bl	cc9c <endpoint0_transmit>
	if ( datalen == 0 && size < EP0_SIZE )
    d2b4:	1bed      	subs	r5, r5, r7
	data += size;
    d2b6:	443c      	add	r4, r7
	if ( datalen == 0 && size < EP0_SIZE )
    d2b8:	d102      	bne.n	d2c0 <usb_setup+0x53c>
    d2ba:	2f40      	cmp	r7, #64	; 0x40
    d2bc:	f47f ad90 	bne.w	cde0 <usb_setup+0x5c>
	ep0_tx_ptr = data;
    d2c0:	4b11      	ldr	r3, [pc, #68]	; (d308 <usb_setup+0x584>)
    d2c2:	601c      	str	r4, [r3, #0]
	ep0_tx_len = datalen;
    d2c4:	4b11      	ldr	r3, [pc, #68]	; (d30c <usb_setup+0x588>)
    d2c6:	801d      	strh	r5, [r3, #0]
    d2c8:	e58a      	b.n	cde0 <usb_setup+0x5c>
}
    d2ca:	b005      	add	sp, #20
    d2cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d2d0:	1fff987a 	.word	0x1fff987a
    d2d4:	1fff97c0 	.word	0x1fff97c0
    d2d8:	1fff987d 	.word	0x1fff987d
    d2dc:	400720c0 	.word	0x400720c0
    d2e0:	0001634e 	.word	0x0001634e
    d2e4:	00015df4 	.word	0x00015df4
    d2e8:	000162db 	.word	0x000162db
    d2ec:	0001637c 	.word	0x0001637c
    d2f0:	1fff97bc 	.word	0x1fff97bc
    d2f4:	1fff9890 	.word	0x1fff9890
    d2f8:	000163b1 	.word	0x000163b1
    d2fc:	1fff9728 	.word	0x1fff9728
    d300:	1fffb32c 	.word	0x1fffb32c
    d304:	1fff926c 	.word	0x1fff926c
    d308:	1fff97b4 	.word	0x1fff97b4
    d30c:	1fff97b2 	.word	0x1fff97b2

0000d310 <keyboard_control>:


void keyboard_control(uint8_t *buf) {
    d310:	b537      	push	{r0, r1, r2, r4, r5, lr}
    d312:	4d17      	ldr	r5, [pc, #92]	; (d370 <keyboard_control+0x60>)
#endif

	// Keyboard HID SET_REPORT - PID=OUT
	#if enableKeyboard_define == 1
	// XXX - Getting lots of NAKs in Linux
	if ( setup.wRequestAndType == 0x0921 && setup.wValue & 0x200 )
    d314:	4c17      	ldr	r4, [pc, #92]	; (d374 <keyboard_control+0x64>)
void keyboard_control(uint8_t *buf) {
    d316:	682b      	ldr	r3, [r5, #0]
	if ( setup.wRequestAndType == 0x0921 && setup.wValue & 0x200 )
    d318:	8822      	ldrh	r2, [r4, #0]
void keyboard_control(uint8_t *buf) {
    d31a:	9301      	str	r3, [sp, #4]
	if ( setup.wRequestAndType == 0x0921 && setup.wValue & 0x200 )
    d31c:	f640 1321 	movw	r3, #2337	; 0x921
    d320:	429a      	cmp	r2, r3
    d322:	4629      	mov	r1, r5
    d324:	d116      	bne.n	d354 <keyboard_control+0x44>
    d326:	8863      	ldrh	r3, [r4, #2]
    d328:	059b      	lsls	r3, r3, #22
    d32a:	d513      	bpl.n	d354 <keyboard_control+0x44>
		print("]");
		print( NL );
		#endif

		// Interface
		switch ( setup.wIndex & 0xFF )
    d32c:	7923      	ldrb	r3, [r4, #4]
    d32e:	b173      	cbz	r3, d34e <keyboard_control+0x3e>
    d330:	2b01      	cmp	r3, #1
    d332:	d015      	beq.n	d360 <keyboard_control+0x50>
			// Already set with the control sequence
			// Only use 2nd byte, first byte is the report id
			USBKeys_LEDs = buf[1];
			break;
		default:
			warn_msg("(SET_REPORT, BULK) Unknown interface - ");
    d334:	4810      	ldr	r0, [pc, #64]	; (d378 <keyboard_control+0x68>)
    d336:	f002 f91b 	bl	f570 <_print>
			printHex( setup.wIndex );
    d33a:	2101      	movs	r1, #1
    d33c:	88a0      	ldrh	r0, [r4, #4]
    d33e:	f002 fa3d 	bl	f7bc <printHex_op>
			print( NL );
    d342:	9a01      	ldr	r2, [sp, #4]
    d344:	682b      	ldr	r3, [r5, #0]
    d346:	429a      	cmp	r2, r3
    d348:	d00c      	beq.n	d364 <keyboard_control+0x54>

		// XXX ZLP causes timeout/delay, why? -HaaTa
		//endpoint0_transmit( NULL, 0 );
	}
	#endif
}
    d34a:	f7f5 f9f1 	bl	2730 <__stack_chk_fail>
			USBKeys_LEDs = buf[0];
    d34e:	7802      	ldrb	r2, [r0, #0]
			USBKeys_LEDs = buf[1];
    d350:	4b0a      	ldr	r3, [pc, #40]	; (d37c <keyboard_control+0x6c>)
    d352:	701a      	strb	r2, [r3, #0]
}
    d354:	9a01      	ldr	r2, [sp, #4]
    d356:	680b      	ldr	r3, [r1, #0]
    d358:	429a      	cmp	r2, r3
    d35a:	d1f6      	bne.n	d34a <keyboard_control+0x3a>
    d35c:	b003      	add	sp, #12
    d35e:	bd30      	pop	{r4, r5, pc}
			USBKeys_LEDs = buf[1];
    d360:	7842      	ldrb	r2, [r0, #1]
    d362:	e7f5      	b.n	d350 <keyboard_control+0x40>
			print( NL );
    d364:	4806      	ldr	r0, [pc, #24]	; (d380 <keyboard_control+0x70>)
}
    d366:	b003      	add	sp, #12
    d368:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
			print( NL );
    d36c:	f002 b900 	b.w	f570 <_print>
    d370:	1fff89d0 	.word	0x1fff89d0
    d374:	1fff9818 	.word	0x1fff9818
    d378:	00016252 	.word	0x00016252
    d37c:	1fffb32b 	.word	0x1fffb32b
    d380:	00015df4 	.word	0x00015df4

0000d384 <usb_rx>:
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
}
#endif

usb_packet_t *usb_rx( uint32_t endpoint )
{
    d384:	b537      	push	{r0, r1, r2, r4, r5, lr}
    d386:	4a10      	ldr	r2, [pc, #64]	; (d3c8 <usb_rx+0x44>)
    d388:	6813      	ldr	r3, [r2, #0]
    d38a:	9301      	str	r3, [sp, #4]
	//print("USB RX");

#if defined(_kinetis_)
	usb_packet_t *ret;
	endpoint--;
    d38c:	1e43      	subs	r3, r0, #1

	// Make sure this is a valid endpoint
	if ( endpoint >= NUM_ENDPOINTS )
    d38e:	2b09      	cmp	r3, #9
    d390:	d815      	bhi.n	d3be <usb_rx+0x3a>
	{
		return NULL;
	}

	__disable_irq();
    d392:	b672      	cpsid	i

	// Receive packet, check pointer
	ret = rx_first[endpoint];
    d394:	490d      	ldr	r1, [pc, #52]	; (d3cc <usb_rx+0x48>)
    d396:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
	if ( ret )
    d39a:	b148      	cbz	r0, d3b0 <usb_rx+0x2c>
	{
		rx_first[ endpoint ] = ret->next;
    d39c:	6844      	ldr	r4, [r0, #4]
    d39e:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
		usb_rx_byte_count_data[ endpoint ] -= ret->len;
    d3a2:	4c0b      	ldr	r4, [pc, #44]	; (d3d0 <usb_rx+0x4c>)
    d3a4:	8805      	ldrh	r5, [r0, #0]
    d3a6:	f834 1013 	ldrh.w	r1, [r4, r3, lsl #1]
    d3aa:	1b49      	subs	r1, r1, r5
    d3ac:	f824 1013 	strh.w	r1, [r4, r3, lsl #1]
	}

	__enable_irq();
    d3b0:	b662      	cpsie	i
	udd_ep_run(endpoint | USB_EP_DIR_OUT, false, ret->buf, ret->len, NULL);

	return ret;
#endif

}
    d3b2:	9901      	ldr	r1, [sp, #4]
    d3b4:	6813      	ldr	r3, [r2, #0]
    d3b6:	4299      	cmp	r1, r3
    d3b8:	d003      	beq.n	d3c2 <usb_rx+0x3e>
    d3ba:	f7f5 f9b9 	bl	2730 <__stack_chk_fail>
		return NULL;
    d3be:	2000      	movs	r0, #0
    d3c0:	e7f7      	b.n	d3b2 <usb_rx+0x2e>
}
    d3c2:	b003      	add	sp, #12
    d3c4:	bd30      	pop	{r4, r5, pc}
    d3c6:	bf00      	nop
    d3c8:	1fff89d0 	.word	0x1fff89d0
    d3cc:	1fff97c8 	.word	0x1fff97c8
    d3d0:	1fffb338 	.word	0x1fffb338

0000d3d4 <usb_tx_packet_count>:
	return usb_queue_byte_count( tx_first[ endpoint ] );
}
#endif

uint32_t usb_tx_packet_count( uint32_t endpoint )
{
    d3d4:	b507      	push	{r0, r1, r2, lr}
    d3d6:	4b0d      	ldr	r3, [pc, #52]	; (d40c <usb_tx_packet_count+0x38>)
	uint32_t count=0;

#if defined(_kinetis_)
	const usb_packet_t *p;

	endpoint--;
    d3d8:	3801      	subs	r0, #1
{
    d3da:	681a      	ldr	r2, [r3, #0]
    d3dc:	9201      	str	r2, [sp, #4]
	if ( endpoint >= NUM_ENDPOINTS )
    d3de:	2809      	cmp	r0, #9
    d3e0:	d80f      	bhi.n	d402 <usb_tx_packet_count+0x2e>
		return 0;
	__disable_irq();
    d3e2:	b672      	cpsid	i
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    d3e4:	4a0a      	ldr	r2, [pc, #40]	; (d410 <usb_tx_packet_count+0x3c>)
    d3e6:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
	uint32_t count=0;
    d3ea:	2000      	movs	r0, #0
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    d3ec:	b932      	cbnz	r2, d3fc <usb_tx_packet_count+0x28>
		count++;
	__enable_irq();
    d3ee:	b662      	cpsie	i
#endif

	return count;
}
    d3f0:	9a01      	ldr	r2, [sp, #4]
    d3f2:	681b      	ldr	r3, [r3, #0]
    d3f4:	429a      	cmp	r2, r3
    d3f6:	d006      	beq.n	d406 <usb_tx_packet_count+0x32>
    d3f8:	f7f5 f99a 	bl	2730 <__stack_chk_fail>
		count++;
    d3fc:	3001      	adds	r0, #1
	for ( p = tx_first[ endpoint ]; p; p = p->next )
    d3fe:	6852      	ldr	r2, [r2, #4]
    d400:	e7f4      	b.n	d3ec <usb_tx_packet_count+0x18>
		return 0;
    d402:	2000      	movs	r0, #0
    d404:	e7f4      	b.n	d3f0 <usb_tx_packet_count+0x1c>
}
    d406:	b003      	add	sp, #12
    d408:	f85d fb04 	ldr.w	pc, [sp], #4
    d40c:	1fff89d0 	.word	0x1fff89d0
    d410:	1fff9820 	.word	0x1fff9820

0000d414 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory( usb_packet_t *packet )
{
    d414:	b573      	push	{r0, r1, r4, r5, r6, lr}
    d416:	491f      	ldr	r1, [pc, #124]	; (d494 <usb_rx_memory+0x80>)
    d418:	680b      	ldr	r3, [r1, #0]
    d41a:	9301      	str	r3, [sp, #4]
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    d41c:	b672      	cpsid	i
    d41e:	4d1e      	ldr	r5, [pc, #120]	; (d498 <usb_rx_memory+0x84>)
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
	{
		if ( *cfg++ & USB_ENDPT_EPRXEN )
		{
			if ( table[ index( i, RX, EVEN ) ].desc == 0 )
    d420:	4a1e      	ldr	r2, [pc, #120]	; (d49c <usb_rx_memory+0x88>)
	__disable_irq();
    d422:	2304      	movs	r3, #4
		if ( *cfg++ & USB_ENDPT_EPRXEN )
    d424:	f815 4f01 	ldrb.w	r4, [r5, #1]!
    d428:	0724      	lsls	r4, r4, #28
    d42a:	d521      	bpl.n	d470 <usb_rx_memory+0x5c>
			if ( table[ index( i, RX, EVEN ) ].desc == 0 )
    d42c:	f852 6033 	ldr.w	r6, [r2, r3, lsl #3]
    d430:	00dc      	lsls	r4, r3, #3
    d432:	b986      	cbnz	r6, d456 <usb_rx_memory+0x42>
			{
				table[ index( i, RX, EVEN ) ].addr = packet->buf;
    d434:	4414      	add	r4, r2
    d436:	3008      	adds	r0, #8
    d438:	6060      	str	r0, [r4, #4]
				table[ index( i, RX, EVEN ) ].desc = BDT_DESC( 64, 0 );
    d43a:	4819      	ldr	r0, [pc, #100]	; (d4a0 <usb_rx_memory+0x8c>)
    d43c:	f842 0033 	str.w	r0, [r2, r3, lsl #3]
			}
			if ( table[ index( i, RX, ODD ) ].desc == 0 )
			{
				table[ index( i, RX, ODD ) ].addr = packet->buf;
				table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
				usb_rx_memory_needed--;
    d440:	4a18      	ldr	r2, [pc, #96]	; (d4a4 <usb_rx_memory+0x90>)
    d442:	7813      	ldrb	r3, [r2, #0]
    d444:	3b01      	subs	r3, #1
    d446:	7013      	strb	r3, [r2, #0]
				__enable_irq();
    d448:	b662      	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free( packet );
	return;
}
    d44a:	9a01      	ldr	r2, [sp, #4]
    d44c:	680b      	ldr	r3, [r1, #0]
    d44e:	429a      	cmp	r2, r3
    d450:	d01e      	beq.n	d490 <usb_rx_memory+0x7c>
    d452:	f7f5 f96d 	bl	2730 <__stack_chk_fail>
			if ( table[ index( i, RX, ODD ) ].desc == 0 )
    d456:	f043 0401 	orr.w	r4, r3, #1
    d45a:	f852 6034 	ldr.w	r6, [r2, r4, lsl #3]
    d45e:	b93e      	cbnz	r6, d470 <usb_rx_memory+0x5c>
				table[ index( i, RX, ODD ) ].addr = packet->buf;
    d460:	eb02 03c4 	add.w	r3, r2, r4, lsl #3
    d464:	3008      	adds	r0, #8
    d466:	6058      	str	r0, [r3, #4]
				table[ index( i, RX, ODD ) ].desc = BDT_DESC( 64, 1 );
    d468:	4b0f      	ldr	r3, [pc, #60]	; (d4a8 <usb_rx_memory+0x94>)
    d46a:	f842 3034 	str.w	r3, [r2, r4, lsl #3]
    d46e:	e7e7      	b.n	d440 <usb_rx_memory+0x2c>
    d470:	3304      	adds	r3, #4
	for ( i = 1; i <= NUM_ENDPOINTS; i++ )
    d472:	2b2c      	cmp	r3, #44	; 0x2c
    d474:	d1d6      	bne.n	d424 <usb_rx_memory+0x10>
	__enable_irq();
    d476:	b662      	cpsie	i
	usb_rx_memory_needed = 0;
    d478:	4b0a      	ldr	r3, [pc, #40]	; (d4a4 <usb_rx_memory+0x90>)
    d47a:	2200      	movs	r2, #0
    d47c:	701a      	strb	r2, [r3, #0]
	usb_free( packet );
    d47e:	9a01      	ldr	r2, [sp, #4]
    d480:	680b      	ldr	r3, [r1, #0]
    d482:	429a      	cmp	r2, r3
    d484:	d1e5      	bne.n	d452 <usb_rx_memory+0x3e>
}
    d486:	b002      	add	sp, #8
    d488:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	usb_free( packet );
    d48c:	f000 bcde 	b.w	de4c <usb_free>
}
    d490:	b002      	add	sp, #8
    d492:	bd70      	pop	{r4, r5, r6, pc}
    d494:	1fff89d0 	.word	0x1fff89d0
    d498:	00016247 	.word	0x00016247
    d49c:	1fff8000 	.word	0x1fff8000
    d4a0:	00400088 	.word	0x00400088
    d4a4:	1fff987e 	.word	0x1fff987e
    d4a8:	004000c8 	.word	0x004000c8

0000d4ac <usb_tx>:

	return 0;
}

void usb_tx( uint32_t endpoint, usb_packet_t *packet )
{
    d4ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
    d4ae:	4e27      	ldr	r6, [pc, #156]	; (d54c <usb_tx+0xa0>)
    d4b0:	6833      	ldr	r3, [r6, #0]
    d4b2:	9301      	str	r3, [sp, #4]
	// Update expiry counter
	USBKeys_Idle_Expiry = systick_millis_count;
    d4b4:	4b26      	ldr	r3, [pc, #152]	; (d550 <usb_tx+0xa4>)
    d4b6:	681a      	ldr	r2, [r3, #0]
    d4b8:	4b26      	ldr	r3, [pc, #152]	; (d554 <usb_tx+0xa8>)
    d4ba:	601a      	str	r2, [r3, #0]

	// Since we are transmitting data, USB will be brought out of sleep/suspend
	// if it's in that state
	// Use the currently set descriptor value
	Output_update_usb_current( *usb_bMaxPower * 2 );
    d4bc:	4b26      	ldr	r3, [pc, #152]	; (d558 <usb_tx+0xac>)
    d4be:	681b      	ldr	r3, [r3, #0]
{
    d4c0:	4604      	mov	r4, r0
	Output_update_usb_current( *usb_bMaxPower * 2 );
    d4c2:	7818      	ldrb	r0, [r3, #0]
    d4c4:	0040      	lsls	r0, r0, #1
{
    d4c6:	460d      	mov	r5, r1
	Output_update_usb_current( *usb_bMaxPower * 2 );
    d4c8:	f7fe fbcc 	bl	bc64 <Output_update_usb_current>

#if defined(_kinetis_)
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
	uint8_t next;

	endpoint--;
    d4cc:	1e63      	subs	r3, r4, #1
	if ( endpoint >= NUM_ENDPOINTS )
    d4ce:	2b09      	cmp	r3, #9
    d4d0:	4632      	mov	r2, r6
    d4d2:	d82c      	bhi.n	d52e <usb_tx+0x82>
	bdt_t *b = &table[ index( endpoint, TX, EVEN ) ];
    d4d4:	0164      	lsls	r4, r4, #5
    d4d6:	4821      	ldr	r0, [pc, #132]	; (d55c <usb_tx+0xb0>)
    d4d8:	f044 0410 	orr.w	r4, r4, #16
    d4dc:	4420      	add	r0, r4
		return;
	__disable_irq();
    d4de:	b672      	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[ endpoint ]);
	//serial_print("\n");
	switch ( tx_state[ endpoint ] )
    d4e0:	491f      	ldr	r1, [pc, #124]	; (d560 <usb_tx+0xb4>)
    d4e2:	5ccc      	ldrb	r4, [r1, r3]
    d4e4:	2c03      	cmp	r4, #3
    d4e6:	d818      	bhi.n	d51a <usb_tx+0x6e>
    d4e8:	e8df f004 	tbb	[pc, r4]
    d4ec:	1402112b 	.word	0x1402112b
	case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    d4f0:	2405      	movs	r4, #5
		tx_last[ endpoint ] = packet;
		__enable_irq();
		return;
	}

	tx_state[ endpoint ] = next;
    d4f2:	54cc      	strb	r4, [r1, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    d4f4:	f010 0f08 	tst.w	r0, #8
	b->addr = packet->buf;
    d4f8:	f105 0308 	add.w	r3, r5, #8
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    d4fc:	8829      	ldrh	r1, [r5, #0]
	b->addr = packet->buf;
    d4fe:	6043      	str	r3, [r0, #4]
	b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    d500:	bf14      	ite	ne
    d502:	23c8      	movne	r3, #200	; 0xc8
    d504:	2388      	moveq	r3, #136	; 0x88
    d506:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    d50a:	6003      	str	r3, [r0, #0]
    d50c:	e00e      	b.n	d52c <usb_tx+0x80>
		b++;
    d50e:	3008      	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    d510:	2402      	movs	r4, #2
		break;
    d512:	e7ee      	b.n	d4f2 <usb_tx+0x46>
		b++;
    d514:	3008      	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    d516:	2404      	movs	r4, #4
		break;
    d518:	e7eb      	b.n	d4f2 <usb_tx+0x46>
		if (tx_first[ endpoint ] == NULL)
    d51a:	4812      	ldr	r0, [pc, #72]	; (d564 <usb_tx+0xb8>)
    d51c:	4912      	ldr	r1, [pc, #72]	; (d568 <usb_tx+0xbc>)
    d51e:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    d522:	b954      	cbnz	r4, d53a <usb_tx+0x8e>
			tx_first[ endpoint ] = packet;
    d524:	f840 5023 	str.w	r5, [r0, r3, lsl #2]
		tx_last[ endpoint ] = packet;
    d528:	f841 5023 	str.w	r5, [r1, r3, lsl #2]
	__enable_irq();
    d52c:	b662      	cpsie	i

#elif defined(_sam_)
	udd_ep_run(endpoint | USB_EP_DIR_IN, false, packet->buf, packet->len, NULL);
#endif
}
    d52e:	9901      	ldr	r1, [sp, #4]
    d530:	6813      	ldr	r3, [r2, #0]
    d532:	4299      	cmp	r1, r3
    d534:	d007      	beq.n	d546 <usb_tx+0x9a>
    d536:	f7f5 f8fb 	bl	2730 <__stack_chk_fail>
			tx_last[ endpoint ]->next = packet;
    d53a:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
    d53e:	6045      	str	r5, [r0, #4]
    d540:	e7f2      	b.n	d528 <usb_tx+0x7c>
		next = TX_STATE_ODD_FREE;
    d542:	2403      	movs	r4, #3
    d544:	e7d5      	b.n	d4f2 <usb_tx+0x46>
}
    d546:	b002      	add	sp, #8
    d548:	bd70      	pop	{r4, r5, r6, pc}
    d54a:	bf00      	nop
    d54c:	1fff89d0 	.word	0x1fff89d0
    d550:	1fff92d8 	.word	0x1fff92d8
    d554:	1fffb32c 	.word	0x1fffb32c
    d558:	1fff9090 	.word	0x1fff9090
    d55c:	1fff8000 	.word	0x1fff8000
    d560:	1fff9870 	.word	0x1fff9870
    d564:	1fff9820 	.word	0x1fff9820
    d568:	1fff9848 	.word	0x1fff9848

0000d56c <usb_resume>:
{
    d56c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return usb_dev_sleep;
    d56e:	4e15      	ldr	r6, [pc, #84]	; (d5c4 <usb_resume+0x58>)
{
    d570:	4d15      	ldr	r5, [pc, #84]	; (d5c8 <usb_resume+0x5c>)
	return usb_dev_sleep;
    d572:	7830      	ldrb	r0, [r6, #0]
{
    d574:	682a      	ldr	r2, [r5, #0]
    d576:	9201      	str	r2, [sp, #4]
	if ( usb_suspended() && usb_configured() && usb_remote_wakeup )
    d578:	b1e0      	cbz	r0, d5b4 <usb_resume+0x48>

// return 0 if the USB is not configured, or the configuration
// number selected by the HOST
uint8_t usb_configured()
{
	return usb_configuration;
    d57a:	4b14      	ldr	r3, [pc, #80]	; (d5cc <usb_resume+0x60>)
    d57c:	781b      	ldrb	r3, [r3, #0]
	if ( usb_suspended() && usb_configured() && usb_remote_wakeup )
    d57e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
    d582:	b1bb      	cbz	r3, d5b4 <usb_resume+0x48>
    d584:	4b12      	ldr	r3, [pc, #72]	; (d5d0 <usb_resume+0x64>)
    d586:	7818      	ldrb	r0, [r3, #0]
    d588:	b1a0      	cbz	r0, d5b4 <usb_resume+0x48>
		USB0_CTL |= USB_CTL_RESUME;
    d58a:	4c12      	ldr	r4, [pc, #72]	; (d5d4 <usb_resume+0x68>)
    d58c:	7823      	ldrb	r3, [r4, #0]
    d58e:	f043 0304 	orr.w	r3, r3, #4
    d592:	7023      	strb	r3, [r4, #0]
		usb_packet_t *tx_packet = usb_malloc();
    d594:	f000 fc30 	bl	ddf8 <usb_malloc>
		usb_tx( KEYBOARD_ENDPOINT, tx_packet );
    d598:	4601      	mov	r1, r0
    d59a:	2001      	movs	r0, #1
    d59c:	f7ff ff86 	bl	d4ac <usb_tx>
		delay_ms(10);
    d5a0:	200a      	movs	r0, #10
    d5a2:	f7f5 f969 	bl	2878 <delay_ms>
		USB0_CTL &= ~(USB_CTL_RESUME);
    d5a6:	7823      	ldrb	r3, [r4, #0]
    d5a8:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    d5ac:	7023      	strb	r3, [r4, #0]
		usb_dev_sleep = 0; // Make sure we don't call this again, may crash system
    d5ae:	2300      	movs	r3, #0
    d5b0:	7033      	strb	r3, [r6, #0]
		return 1;
    d5b2:	2001      	movs	r0, #1
}
    d5b4:	9a01      	ldr	r2, [sp, #4]
    d5b6:	682b      	ldr	r3, [r5, #0]
    d5b8:	429a      	cmp	r2, r3
    d5ba:	d001      	beq.n	d5c0 <usb_resume+0x54>
    d5bc:	f7f5 f8b8 	bl	2730 <__stack_chk_fail>
    d5c0:	b002      	add	sp, #8
    d5c2:	bd70      	pop	{r4, r5, r6, pc}
    d5c4:	1fff987b 	.word	0x1fff987b
    d5c8:	1fff89d0 	.word	0x1fff89d0
    d5cc:	1fff987a 	.word	0x1fff987a
    d5d0:	1fff987d 	.word	0x1fff987d
    d5d4:	40072094 	.word	0x40072094

0000d5d8 <usb_device_reload>:
{
    d5d8:	b513      	push	{r0, r1, r4, lr}
    d5da:	4b0d      	ldr	r3, [pc, #52]	; (d610 <usb_device_reload+0x38>)
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
    d5dc:	4c0d      	ldr	r4, [pc, #52]	; (d614 <usb_device_reload+0x3c>)
{
    d5de:	681a      	ldr	r2, [r3, #0]
    d5e0:	9201      	str	r2, [sp, #4]
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
    d5e2:	480d      	ldr	r0, [pc, #52]	; (d618 <usb_device_reload+0x40>)
{
    d5e4:	4a0d      	ldr	r2, [pc, #52]	; (d61c <usb_device_reload+0x44>)
		(&VBAT)[ pos ] = sys_reset_to_loader_magic[ pos ];
    d5e6:	f102 4140 	add.w	r1, r2, #3221225472	; 0xc0000000
    d5ea:	f5a1 3178 	sub.w	r1, r1, #253952	; 0x3e000
    d5ee:	5d09      	ldrb	r1, [r1, r4]
    d5f0:	f802 1b01 	strb.w	r1, [r2], #1
	for ( int pos = 0; pos < sizeof(sys_reset_to_loader_magic); pos++ )
    d5f4:	4282      	cmp	r2, r0
    d5f6:	d1f6      	bne.n	d5e6 <usb_device_reload+0xe>
	SOFTWARE_RESET();
    d5f8:	4a09      	ldr	r2, [pc, #36]	; (d620 <usb_device_reload+0x48>)
    d5fa:	490a      	ldr	r1, [pc, #40]	; (d624 <usb_device_reload+0x4c>)
    d5fc:	6011      	str	r1, [r2, #0]
}
    d5fe:	9a01      	ldr	r2, [sp, #4]
    d600:	681b      	ldr	r3, [r3, #0]
    d602:	429a      	cmp	r2, r3
    d604:	d001      	beq.n	d60a <usb_device_reload+0x32>
    d606:	f7f5 f893 	bl	2730 <__stack_chk_fail>
    d60a:	b002      	add	sp, #8
    d60c:	bd10      	pop	{r4, pc}
    d60e:	bf00      	nop
    d610:	1fff89d0 	.word	0x1fff89d0
    d614:	0000fa25 	.word	0x0000fa25
    d618:	4003e016 	.word	0x4003e016
    d61c:	4003e000 	.word	0x4003e000
    d620:	e000ed0c 	.word	0xe000ed0c
    d624:	05fa0004 	.word	0x05fa0004

0000d628 <usb_isr>:
{
    d628:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d62c:	4b93      	ldr	r3, [pc, #588]	; (d87c <usb_isr+0x254>)
	status = USB0_ISTAT;
    d62e:	f8df 92a0 	ldr.w	r9, [pc, #672]	; d8d0 <usb_isr+0x2a8>
{
    d632:	681a      	ldr	r2, [r3, #0]
		stat = USB0_STAT;
    d634:	f8df a29c 	ldr.w	sl, [pc, #668]	; d8d4 <usb_isr+0x2ac>
{
    d638:	b085      	sub	sp, #20
    d63a:	4698      	mov	r8, r3
    d63c:	9203      	str	r2, [sp, #12]
    d63e:	464f      	mov	r7, r9
	status = USB0_ISTAT;
    d640:	f899 4000 	ldrb.w	r4, [r9]
    d644:	b2e4      	uxtb	r4, r4
	if ( (status & USB_INTEN_SOFTOKEN /* 04 */ ) )
    d646:	0766      	lsls	r6, r4, #29
    d648:	d525      	bpl.n	d696 <usb_isr+0x6e>
		if ( usb_configuration )
    d64a:	4b8d      	ldr	r3, [pc, #564]	; (d880 <usb_isr+0x258>)
    d64c:	781b      	ldrb	r3, [r3, #0]
    d64e:	b1ab      	cbz	r3, d67c <usb_isr+0x54>
			t = usb_reboot_timer;
    d650:	4a8c      	ldr	r2, [pc, #560]	; (d884 <usb_isr+0x25c>)
    d652:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    d654:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    d658:	b129      	cbz	r1, d666 <usb_isr+0x3e>
				usb_reboot_timer = --t;
    d65a:	3b01      	subs	r3, #1
    d65c:	b2db      	uxtb	r3, r3
    d65e:	7013      	strb	r3, [r2, #0]
				if ( !t )
    d660:	b90b      	cbnz	r3, d666 <usb_isr+0x3e>
					usb_device_reload();
    d662:	f7ff ffb9 	bl	d5d8 <usb_device_reload>
			t = usb_cdc_transmit_flush_timer;
    d666:	4a88      	ldr	r2, [pc, #544]	; (d888 <usb_isr+0x260>)
    d668:	7811      	ldrb	r1, [r2, #0]
			if ( t )
    d66a:	f001 03ff 	and.w	r3, r1, #255	; 0xff
    d66e:	b129      	cbz	r1, d67c <usb_isr+0x54>
				usb_cdc_transmit_flush_timer = --t;
    d670:	3b01      	subs	r3, #1
    d672:	b2db      	uxtb	r3, r3
    d674:	7013      	strb	r3, [r2, #0]
				if ( t == 0 )
    d676:	b90b      	cbnz	r3, d67c <usb_isr+0x54>
					usb_serial_flush_callback();
    d678:	f000 fe1c 	bl	e2b4 <usb_serial_flush_callback>
		if ( usb_dev_sleep )
    d67c:	4d83      	ldr	r5, [pc, #524]	; (d88c <usb_isr+0x264>)
    d67e:	782b      	ldrb	r3, [r5, #0]
    d680:	b13b      	cbz	r3, d692 <usb_isr+0x6a>
			Output_update_usb_current( *usb_bMaxPower * 2 );
    d682:	4b83      	ldr	r3, [pc, #524]	; (d890 <usb_isr+0x268>)
    d684:	681b      	ldr	r3, [r3, #0]
    d686:	7818      	ldrb	r0, [r3, #0]
    d688:	0040      	lsls	r0, r0, #1
    d68a:	f7fe faeb 	bl	bc64 <Output_update_usb_current>
			usb_dev_sleep = 0;
    d68e:	2300      	movs	r3, #0
    d690:	702b      	strb	r3, [r5, #0]
		USB0_ISTAT = USB_INTEN_SOFTOKEN;
    d692:	2304      	movs	r3, #4
    d694:	703b      	strb	r3, [r7, #0]
	if ( (status & USB_ISTAT_TOKDNE /* 08 */ ) )
    d696:	f014 0208 	ands.w	r2, r4, #8
    d69a:	f000 811f 	beq.w	d8dc <usb_isr+0x2b4>
		stat = USB0_STAT;
    d69e:	f89a 3000 	ldrb.w	r3, [sl]
    d6a2:	4d7c      	ldr	r5, [pc, #496]	; (d894 <usb_isr+0x26c>)
    d6a4:	b2db      	uxtb	r3, r3
		if ( endpoint == 0 )
    d6a6:	091c      	lsrs	r4, r3, #4
    d6a8:	ea4f 0b93 	mov.w	fp, r3, lsr #2
    d6ac:	d165      	bne.n	d77a <usb_isr+0x152>
	b = stat2bufferdescriptor( stat );
    d6ae:	eb05 03cb 	add.w	r3, r5, fp, lsl #3
    d6b2:	4e79      	ldr	r6, [pc, #484]	; (d898 <usb_isr+0x270>)
	buf = b->addr;
    d6b4:	685c      	ldr	r4, [r3, #4]
	pid = BDT_PID( b->desc );
    d6b6:	f855 303b 	ldr.w	r3, [r5, fp, lsl #3]
    d6ba:	f3c3 0383 	ubfx	r3, r3, #2, #4
	switch ( pid )
    d6be:	3b01      	subs	r3, #1
    d6c0:	2b0c      	cmp	r3, #12
    d6c2:	d81b      	bhi.n	d6fc <usb_isr+0xd4>
    d6c4:	e8df f003 	tbb	[pc, r3]
    d6c8:	1a1a1f1f 	.word	0x1a1a1f1f
    d6cc:	1a1a1a1a 	.word	0x1a1a1a1a
    d6d0:	1a1a1a31 	.word	0x1a1a1a31
    d6d4:	07          	.byte	0x07
    d6d5:	00          	.byte	0x00
		setup.word1 = *(uint32_t *)(buf);
    d6d6:	4b71      	ldr	r3, [pc, #452]	; (d89c <usb_isr+0x274>)
    d6d8:	6822      	ldr	r2, [r4, #0]
    d6da:	601a      	str	r2, [r3, #0]
		setup.word2 = *(uint32_t *)(buf + 4);
    d6dc:	6862      	ldr	r2, [r4, #4]
    d6de:	605a      	str	r2, [r3, #4]
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    d6e0:	4b6f      	ldr	r3, [pc, #444]	; (d8a0 <usb_isr+0x278>)
		ep0_tx_ptr = NULL;
    d6e2:	4a70      	ldr	r2, [pc, #448]	; (d8a4 <usb_isr+0x27c>)
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    d6e4:	f845 303b 	str.w	r3, [r5, fp, lsl #3]
		ep0_tx_ptr = NULL;
    d6e8:	2300      	movs	r3, #0
    d6ea:	6013      	str	r3, [r2, #0]
		table[index(0, TX, EVEN)].desc = 0;
    d6ec:	612b      	str	r3, [r5, #16]
		table[index(0, TX, ODD)].desc = 0;
    d6ee:	61ab      	str	r3, [r5, #24]
		ep0_tx_data_toggle = 1;
    d6f0:	4b6d      	ldr	r3, [pc, #436]	; (d8a8 <usb_isr+0x280>)
    d6f2:	2401      	movs	r4, #1
    d6f4:	701c      	strb	r4, [r3, #0]
		usb_setup();
    d6f6:	f7ff fb45 	bl	cd84 <usb_setup>
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    d6fa:	7034      	strb	r4, [r6, #0]
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    d6fc:	2301      	movs	r3, #1
    d6fe:	7033      	strb	r3, [r6, #0]
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    d700:	2308      	movs	r3, #8
    d702:	703b      	strb	r3, [r7, #0]
		goto restart;
    d704:	e79c      	b.n	d640 <usb_isr+0x18>
		if ( setup.wRequestAndType == 0x2021 )
    d706:	4b65      	ldr	r3, [pc, #404]	; (d89c <usb_isr+0x274>)
    d708:	881a      	ldrh	r2, [r3, #0]
    d70a:	f242 0321 	movw	r3, #8225	; 0x2021
    d70e:	429a      	cmp	r2, r3
    d710:	d104      	bne.n	d71c <usb_isr+0xf4>
			memcpy( (void*)&usb_cdc_line_coding, buf, 7 );
    d712:	2207      	movs	r2, #7
    d714:	4621      	mov	r1, r4
    d716:	4865      	ldr	r0, [pc, #404]	; (d8ac <usb_isr+0x284>)
    d718:	f7f5 f82e 	bl	2778 <memcpy>
		keyboard_control(buf);
    d71c:	4620      	mov	r0, r4
    d71e:	f7ff fdf7 	bl	d310 <keyboard_control>
		b->desc = BDT_DESC( EP0_SIZE, DATA1 );
    d722:	4b5f      	ldr	r3, [pc, #380]	; (d8a0 <usb_isr+0x278>)
    d724:	f845 303b 	str.w	r3, [r5, fp, lsl #3]
    d728:	e7e8      	b.n	d6fc <usb_isr+0xd4>
		data = ep0_tx_ptr;
    d72a:	f8df b178 	ldr.w	fp, [pc, #376]	; d8a4 <usb_isr+0x27c>
    d72e:	f8db 2000 	ldr.w	r2, [fp]
		if ( data )
    d732:	b1ba      	cbz	r2, d764 <usb_isr+0x13c>
			size = ep0_tx_len;
    d734:	4b5e      	ldr	r3, [pc, #376]	; (d8b0 <usb_isr+0x288>)
    d736:	9301      	str	r3, [sp, #4]
    d738:	881d      	ldrh	r5, [r3, #0]
			endpoint0_transmit( data, size );
    d73a:	9200      	str	r2, [sp, #0]
    d73c:	2d40      	cmp	r5, #64	; 0x40
    d73e:	462c      	mov	r4, r5
    d740:	bf28      	it	cs
    d742:	2440      	movcs	r4, #64	; 0x40
    d744:	4621      	mov	r1, r4
    d746:	4610      	mov	r0, r2
    d748:	f7ff faa8 	bl	cc9c <endpoint0_transmit>
			data += size;
    d74c:	9a00      	ldr	r2, [sp, #0]
			ep0_tx_len -= size;
    d74e:	9b01      	ldr	r3, [sp, #4]
			data += size;
    d750:	4422      	add	r2, r4
			ep0_tx_len -= size;
    d752:	1b2c      	subs	r4, r5, r4
    d754:	b2a4      	uxth	r4, r4
    d756:	801c      	strh	r4, [r3, #0]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    d758:	b914      	cbnz	r4, d760 <usb_isr+0x138>
    d75a:	2d3f      	cmp	r5, #63	; 0x3f
    d75c:	bf98      	it	ls
    d75e:	2200      	movls	r2, #0
    d760:	f8cb 2000 	str.w	r2, [fp]
		if ( setup.bRequest == 5 && setup.bmRequestType == 0 )
    d764:	4b4d      	ldr	r3, [pc, #308]	; (d89c <usb_isr+0x274>)
    d766:	881a      	ldrh	r2, [r3, #0]
    d768:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
    d76c:	d1c6      	bne.n	d6fc <usb_isr+0xd4>
			setup.bRequest = 0;
    d76e:	2200      	movs	r2, #0
    d770:	705a      	strb	r2, [r3, #1]
			USB0_ADDR = setup.wValue;
    d772:	789a      	ldrb	r2, [r3, #2]
    d774:	4b4f      	ldr	r3, [pc, #316]	; (d8b4 <usb_isr+0x28c>)
    d776:	701a      	strb	r2, [r3, #0]
    d778:	e7c0      	b.n	d6fc <usb_isr+0xd4>
			bdt_t *b = stat2bufferdescriptor(stat);
    d77a:	465e      	mov	r6, fp
    d77c:	eb05 0bcb 	add.w	fp, r5, fp, lsl #3
			endpoint--;     // endpoint is index to zero-based arrays
    d780:	3c01      	subs	r4, #1
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    d782:	f8db c004 	ldr.w	ip, [fp, #4]
			if ( stat & 0x08 )
    d786:	f013 0308 	ands.w	r3, r3, #8
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    d78a:	f1ac 0008 	sub.w	r0, ip, #8
			endpoint--;     // endpoint is index to zero-based arrays
    d78e:	b2e4      	uxtb	r4, r4
			if ( stat & 0x08 )
    d790:	d041      	beq.n	d816 <usb_isr+0x1ee>
				usb_free( packet );
    d792:	f000 fb5b 	bl	de4c <usb_free>
				packet = tx_first[ endpoint ];
    d796:	4848      	ldr	r0, [pc, #288]	; (d8b8 <usb_isr+0x290>)
    d798:	4a48      	ldr	r2, [pc, #288]	; (d8bc <usb_isr+0x294>)
    d79a:	f850 1024 	ldr.w	r1, [r0, r4, lsl #2]
				if ( packet )
    d79e:	b301      	cbz	r1, d7e2 <usb_isr+0x1ba>
					tx_first[endpoint] = packet->next;
    d7a0:	684b      	ldr	r3, [r1, #4]
    d7a2:	f840 3024 	str.w	r3, [r0, r4, lsl #2]
					b->addr = packet->buf;
    d7a6:	f101 0308 	add.w	r3, r1, #8
    d7aa:	f8cb 3004 	str.w	r3, [fp, #4]
					switch ( tx_state[ endpoint ] )
    d7ae:	5d13      	ldrb	r3, [r2, r4]
    d7b0:	2b03      	cmp	r3, #3
    d7b2:	d805      	bhi.n	d7c0 <usb_isr+0x198>
    d7b4:	e8df f003 	tbb	[pc, r3]
    d7b8:	13110f02 	.word	0x13110f02
						tx_state[ endpoint ] = TX_STATE_ODD_FREE;
    d7bc:	2303      	movs	r3, #3
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_EVEN_FIRST;
    d7be:	5513      	strb	r3, [r2, r4]
					b->desc = BDT_DESC( packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    d7c0:	f01b 0f08 	tst.w	fp, #8
    d7c4:	880a      	ldrh	r2, [r1, #0]
    d7c6:	bf14      	ite	ne
    d7c8:	23c8      	movne	r3, #200	; 0xc8
    d7ca:	2388      	moveq	r3, #136	; 0x88
    d7cc:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
					b->desc = BDT_DESC( 64, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    d7d0:	f845 3036 	str.w	r3, [r5, r6, lsl #3]
    d7d4:	e794      	b.n	d700 <usb_isr+0xd8>
						tx_state[ endpoint ] = TX_STATE_EVEN_FREE;
    d7d6:	2302      	movs	r3, #2
    d7d8:	e7f1      	b.n	d7be <usb_isr+0x196>
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_ODD_FIRST;
    d7da:	2305      	movs	r3, #5
    d7dc:	e7ef      	b.n	d7be <usb_isr+0x196>
						tx_state[ endpoint ] = TX_STATE_NONE_FREE_EVEN_FIRST;
    d7de:	2304      	movs	r3, #4
    d7e0:	e7ed      	b.n	d7be <usb_isr+0x196>
					switch ( tx_state[ endpoint ] )
    d7e2:	5d13      	ldrb	r3, [r2, r4]
    d7e4:	2b03      	cmp	r3, #3
    d7e6:	d810      	bhi.n	d80a <usb_isr+0x1e2>
    d7e8:	a101      	add	r1, pc, #4	; (adr r1, d7f0 <usb_isr+0x1c8>)
    d7ea:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
    d7ee:	bf00      	nop
    d7f0:	0000d701 	.word	0x0000d701
    d7f4:	0000d701 	.word	0x0000d701
    d7f8:	0000d801 	.word	0x0000d801
    d7fc:	0000d807 	.word	0x0000d807
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    d800:	2300      	movs	r3, #0
						tx_state[ endpoint ] = ((uint32_t)b & 8)
    d802:	5513      	strb	r3, [r2, r4]
						break;
    d804:	e77c      	b.n	d700 <usb_isr+0xd8>
						tx_state[ endpoint ] = TX_STATE_BOTH_FREE_ODD_FIRST;
    d806:	2301      	movs	r3, #1
    d808:	e7fb      	b.n	d802 <usb_isr+0x1da>
						tx_state[ endpoint ] = ((uint32_t)b & 8)
    d80a:	f01b 0f08 	tst.w	fp, #8
    d80e:	bf14      	ite	ne
    d810:	2303      	movne	r3, #3
    d812:	2302      	moveq	r3, #2
    d814:	e7f5      	b.n	d802 <usb_isr+0x1da>
				packet->len = b->desc >> 16;
    d816:	f855 2036 	ldr.w	r2, [r5, r6, lsl #3]
    d81a:	0c12      	lsrs	r2, r2, #16
    d81c:	b291      	uxth	r1, r2
    d81e:	f82c 1c08 	strh.w	r1, [ip, #-8]
				if ( packet->len > 0 )
    d822:	b1ca      	cbz	r2, d858 <usb_isr+0x230>
					packet->index = 0;
    d824:	f82c 3c06 	strh.w	r3, [ip, #-6]
					packet->next = NULL;
    d828:	f84c 3c04 	str.w	r3, [ip, #-4]
					if ( rx_first[ endpoint ] == NULL )
    d82c:	4b24      	ldr	r3, [pc, #144]	; (d8c0 <usb_isr+0x298>)
    d82e:	f8df c0a8 	ldr.w	ip, [pc, #168]	; d8d8 <usb_isr+0x2b0>
    d832:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
    d836:	b9b2      	cbnz	r2, d866 <usb_isr+0x23e>
						rx_first[ endpoint ] = packet;
    d838:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    d83c:	4b21      	ldr	r3, [pc, #132]	; (d8c4 <usb_isr+0x29c>)
					rx_last[ endpoint ] = packet;
    d83e:	f84c 0024 	str.w	r0, [ip, r4, lsl #2]
					usb_rx_byte_count_data[ endpoint ] += packet->len;
    d842:	f833 2014 	ldrh.w	r2, [r3, r4, lsl #1]
    d846:	4411      	add	r1, r2
    d848:	f823 1014 	strh.w	r1, [r3, r4, lsl #1]
					packet = usb_malloc();
    d84c:	f000 fad4 	bl	ddf8 <usb_malloc>
					if ( packet )
    d850:	b168      	cbz	r0, d86e <usb_isr+0x246>
						b->addr = packet->buf;
    d852:	3008      	adds	r0, #8
    d854:	f8cb 0004 	str.w	r0, [fp, #4]
					b->desc = BDT_DESC( 64, ((uint32_t)b & 8) ? DATA1 : DATA0 );
    d858:	4a1b      	ldr	r2, [pc, #108]	; (d8c8 <usb_isr+0x2a0>)
    d85a:	4b11      	ldr	r3, [pc, #68]	; (d8a0 <usb_isr+0x278>)
    d85c:	f01b 0f08 	tst.w	fp, #8
    d860:	bf08      	it	eq
    d862:	4613      	moveq	r3, r2
    d864:	e7b4      	b.n	d7d0 <usb_isr+0x1a8>
						rx_last[ endpoint ]->next = packet;
    d866:	f85c 3024 	ldr.w	r3, [ip, r4, lsl #2]
    d86a:	6058      	str	r0, [r3, #4]
    d86c:	e7e6      	b.n	d83c <usb_isr+0x214>
						usb_rx_memory_needed++;
    d86e:	4a17      	ldr	r2, [pc, #92]	; (d8cc <usb_isr+0x2a4>)
						b->desc = 0;
    d870:	f845 0036 	str.w	r0, [r5, r6, lsl #3]
						usb_rx_memory_needed++;
    d874:	7813      	ldrb	r3, [r2, #0]
    d876:	3301      	adds	r3, #1
    d878:	7013      	strb	r3, [r2, #0]
    d87a:	e741      	b.n	d700 <usb_isr+0xd8>
    d87c:	1fff89d0 	.word	0x1fff89d0
    d880:	1fff987a 	.word	0x1fff987a
    d884:	1fff987c 	.word	0x1fff987c
    d888:	1fff9891 	.word	0x1fff9891
    d88c:	1fff987b 	.word	0x1fff987b
    d890:	1fff9090 	.word	0x1fff9090
    d894:	1fff8000 	.word	0x1fff8000
    d898:	40072094 	.word	0x40072094
    d89c:	1fff9818 	.word	0x1fff9818
    d8a0:	004000c8 	.word	0x004000c8
    d8a4:	1fff97b4 	.word	0x1fff97b4
    d8a8:	1fff97b1 	.word	0x1fff97b1
    d8ac:	1fff926c 	.word	0x1fff926c
    d8b0:	1fff97b2 	.word	0x1fff97b2
    d8b4:	40072098 	.word	0x40072098
    d8b8:	1fff9820 	.word	0x1fff9820
    d8bc:	1fff9870 	.word	0x1fff9870
    d8c0:	1fff97c8 	.word	0x1fff97c8
    d8c4:	1fffb338 	.word	0x1fffb338
    d8c8:	00400088 	.word	0x00400088
    d8cc:	1fff987e 	.word	0x1fff987e
    d8d0:	40072080 	.word	0x40072080
    d8d4:	40072090 	.word	0x40072090
    d8d8:	1fff97f0 	.word	0x1fff97f0
	if ( status & USB_ISTAT_USBRST /* 01 */ )
    d8dc:	07e5      	lsls	r5, r4, #31
    d8de:	d524      	bpl.n	d92a <usb_isr+0x302>
		USB0_CTL = USB_CTL_ODDRST;
    d8e0:	4933      	ldr	r1, [pc, #204]	; (d9b0 <usb_isr+0x388>)
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    d8e2:	4834      	ldr	r0, [pc, #208]	; (d9b4 <usb_isr+0x38c>)
		table[index( 0, RX, EVEN ) ].addr = ep0_rx0_buf;
    d8e4:	4c34      	ldr	r4, [pc, #208]	; (d9b8 <usb_isr+0x390>)
		USB0_CTL = USB_CTL_ODDRST;
    d8e6:	2302      	movs	r3, #2
    d8e8:	700b      	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    d8ea:	4b34      	ldr	r3, [pc, #208]	; (d9bc <usb_isr+0x394>)
    d8ec:	701a      	strb	r2, [r3, #0]
		table[index( 0, RX, EVEN ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    d8ee:	4b34      	ldr	r3, [pc, #208]	; (d9c0 <usb_isr+0x398>)
    d8f0:	6018      	str	r0, [r3, #0]
		table[index( 0, RX, ODD ) ].desc = BDT_DESC( EP0_SIZE, 0 );
    d8f2:	e9c3 4001 	strd	r4, r0, [r3, #4]
		table[index( 0, RX, ODD ) ].addr = ep0_rx1_buf;
    d8f6:	4833      	ldr	r0, [pc, #204]	; (d9c4 <usb_isr+0x39c>)
		table[index( 0, TX, ODD ) ].desc = 0;
    d8f8:	619a      	str	r2, [r3, #24]
		table[index( 0, TX, EVEN ) ].desc = 0;
    d8fa:	e9c3 0203 	strd	r0, r2, [r3, #12]
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    d8fe:	4b32      	ldr	r3, [pc, #200]	; (d9c8 <usb_isr+0x3a0>)
    d900:	200d      	movs	r0, #13
    d902:	7018      	strb	r0, [r3, #0]
		USB0_ERRSTAT = 0xFF;
    d904:	4831      	ldr	r0, [pc, #196]	; (d9cc <usb_isr+0x3a4>)
    d906:	23ff      	movs	r3, #255	; 0xff
    d908:	7003      	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    d90a:	703b      	strb	r3, [r7, #0]
		USB0_ADDR = 0;
    d90c:	7402      	strb	r2, [r0, #16]
		USB0_ERREN = 0xFF;
    d90e:	4a30      	ldr	r2, [pc, #192]	; (d9d0 <usb_isr+0x3a8>)
    d910:	7013      	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    d912:	4b30      	ldr	r3, [pc, #192]	; (d9d4 <usb_isr+0x3ac>)
    d914:	229f      	movs	r2, #159	; 0x9f
    d916:	701a      	strb	r2, [r3, #0]
		USB0_CTL = USB_CTL_USBENSOFEN;
    d918:	2301      	movs	r3, #1
    d91a:	700b      	strb	r3, [r1, #0]
}
    d91c:	9a03      	ldr	r2, [sp, #12]
    d91e:	f8d8 3000 	ldr.w	r3, [r8]
    d922:	429a      	cmp	r2, r3
    d924:	d040      	beq.n	d9a8 <usb_isr+0x380>
    d926:	f7f4 ff03 	bl	2730 <__stack_chk_fail>
	if ( (status & USB_ISTAT_STALL /* 80 */ ) )
    d92a:	0620      	lsls	r0, r4, #24
    d92c:	d504      	bpl.n	d938 <usb_isr+0x310>
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    d92e:	4b26      	ldr	r3, [pc, #152]	; (d9c8 <usb_isr+0x3a0>)
    d930:	220d      	movs	r2, #13
    d932:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    d934:	2380      	movs	r3, #128	; 0x80
    d936:	703b      	strb	r3, [r7, #0]
	if ( (status & USB_ISTAT_ERROR /* 02 */ ) )
    d938:	07a1      	lsls	r1, r4, #30
    d93a:	d505      	bpl.n	d948 <usb_isr+0x320>
		uint8_t err = USB0_ERRSTAT;
    d93c:	4a23      	ldr	r2, [pc, #140]	; (d9cc <usb_isr+0x3a4>)
    d93e:	7813      	ldrb	r3, [r2, #0]
    d940:	b2db      	uxtb	r3, r3
		USB0_ERRSTAT = err;
    d942:	7013      	strb	r3, [r2, #0]
		USB0_ISTAT = USB_ISTAT_ERROR;
    d944:	2302      	movs	r3, #2
    d946:	703b      	strb	r3, [r7, #0]
	if ( (status & USB_ISTAT_SLEEP /* 10 */ ) )
    d948:	06e2      	lsls	r2, r4, #27
    d94a:	d514      	bpl.n	d976 <usb_isr+0x34e>
		if ( !usb_dev_sleep )
    d94c:	4d22      	ldr	r5, [pc, #136]	; (d9d8 <usb_isr+0x3b0>)
    d94e:	782b      	ldrb	r3, [r5, #0]
    d950:	b923      	cbnz	r3, d95c <usb_isr+0x334>
			Output_update_usb_current( 100 ); // Set to 100 mA
    d952:	2064      	movs	r0, #100	; 0x64
    d954:	f7fe f986 	bl	bc64 <Output_update_usb_current>
			usb_dev_sleep = 1;
    d958:	2301      	movs	r3, #1
    d95a:	702b      	strb	r3, [r5, #0]
		USB0_INTEN |= USB_INTEN_RESUMEEN;
    d95c:	4b1d      	ldr	r3, [pc, #116]	; (d9d4 <usb_isr+0x3ac>)
    d95e:	781a      	ldrb	r2, [r3, #0]
    d960:	f042 0220 	orr.w	r2, r2, #32
    d964:	701a      	strb	r2, [r3, #0]
		USB0_INTEN &= ~(USB_INTEN_SLEEPEN);
    d966:	781a      	ldrb	r2, [r3, #0]
    d968:	f002 02ef 	and.w	r2, r2, #239	; 0xef
    d96c:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT |= USB_ISTAT_SLEEP;
    d96e:	783b      	ldrb	r3, [r7, #0]
    d970:	f043 0310 	orr.w	r3, r3, #16
    d974:	703b      	strb	r3, [r7, #0]
	if ( (status & USB_ISTAT_RESUME /* 20 */ ) )
    d976:	06a3      	lsls	r3, r4, #26
    d978:	d5d0      	bpl.n	d91c <usb_isr+0x2f4>
		Output_update_usb_current( *usb_bMaxPower * 2 );
    d97a:	4b18      	ldr	r3, [pc, #96]	; (d9dc <usb_isr+0x3b4>)
    d97c:	681b      	ldr	r3, [r3, #0]
    d97e:	7818      	ldrb	r0, [r3, #0]
    d980:	0040      	lsls	r0, r0, #1
    d982:	f7fe f96f 	bl	bc64 <Output_update_usb_current>
		usb_dev_sleep = 0;
    d986:	4b14      	ldr	r3, [pc, #80]	; (d9d8 <usb_isr+0x3b0>)
    d988:	2200      	movs	r2, #0
    d98a:	701a      	strb	r2, [r3, #0]
		USB0_INTEN &= ~(USB_INTEN_RESUMEEN);
    d98c:	4b11      	ldr	r3, [pc, #68]	; (d9d4 <usb_isr+0x3ac>)
    d98e:	781a      	ldrb	r2, [r3, #0]
    d990:	f002 02df 	and.w	r2, r2, #223	; 0xdf
    d994:	701a      	strb	r2, [r3, #0]
		USB0_INTEN |= USB_INTEN_SLEEPEN;
    d996:	781a      	ldrb	r2, [r3, #0]
    d998:	f042 0210 	orr.w	r2, r2, #16
    d99c:	701a      	strb	r2, [r3, #0]
		USB0_ISTAT |= USB_ISTAT_RESUME;
    d99e:	783b      	ldrb	r3, [r7, #0]
    d9a0:	f043 0320 	orr.w	r3, r3, #32
    d9a4:	703b      	strb	r3, [r7, #0]
    d9a6:	e7b9      	b.n	d91c <usb_isr+0x2f4>
}
    d9a8:	b005      	add	sp, #20
    d9aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d9ae:	bf00      	nop
    d9b0:	40072094 	.word	0x40072094
    d9b4:	00400088 	.word	0x00400088
    d9b8:	1fff9730 	.word	0x1fff9730
    d9bc:	1fff97b0 	.word	0x1fff97b0
    d9c0:	1fff8000 	.word	0x1fff8000
    d9c4:	1fff9770 	.word	0x1fff9770
    d9c8:	400720c0 	.word	0x400720c0
    d9cc:	40072088 	.word	0x40072088
    d9d0:	4007208c 	.word	0x4007208c
    d9d4:	40072084 	.word	0x40072084
    d9d8:	1fff987b 	.word	0x1fff987b
    d9dc:	1fff9090 	.word	0x1fff9090

0000d9e0 <usb_init>:
{
    d9e0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    d9e2:	4d3a      	ldr	r5, [pc, #232]	; (dacc <usb_init+0xec>)
    d9e4:	682b      	ldr	r3, [r5, #0]
    d9e6:	9301      	str	r3, [sp, #4]
	USBInit_TimeStart = systick_millis_count;
    d9e8:	4b39      	ldr	r3, [pc, #228]	; (dad0 <usb_init+0xf0>)
    d9ea:	681a      	ldr	r2, [r3, #0]
    d9ec:	4b39      	ldr	r3, [pc, #228]	; (dad4 <usb_init+0xf4>)
    d9ee:	601a      	str	r2, [r3, #0]
	USBInit_Ticks = 0;
    d9f0:	4b39      	ldr	r3, [pc, #228]	; (dad8 <usb_init+0xf8>)
    d9f2:	2400      	movs	r4, #0
    d9f4:	801c      	strh	r4, [r3, #0]
	usb_set_config_descriptor_size();
    d9f6:	f7ff f93b 	bl	cc70 <usb_set_config_descriptor_size>
	hex32ToStr16( SIM_UIDH,  &(usb_string_serial_number_default.wString[0]), 8 );
    d9fa:	4b38      	ldr	r3, [pc, #224]	; (dadc <usb_init+0xfc>)
    d9fc:	4938      	ldr	r1, [pc, #224]	; (dae0 <usb_init+0x100>)
    d9fe:	6818      	ldr	r0, [r3, #0]
    da00:	2208      	movs	r2, #8
    da02:	f001 ff43 	bl	f88c <hex32ToStr16>
	hex32ToStr16( SIM_UIDMH, &(usb_string_serial_number_default.wString[8]), 8 );
    da06:	4b37      	ldr	r3, [pc, #220]	; (dae4 <usb_init+0x104>)
    da08:	4937      	ldr	r1, [pc, #220]	; (dae8 <usb_init+0x108>)
    da0a:	6818      	ldr	r0, [r3, #0]
    da0c:	2208      	movs	r2, #8
    da0e:	f001 ff3d 	bl	f88c <hex32ToStr16>
	hex32ToStr16( SIM_UIDML, &(usb_string_serial_number_default.wString[16]), 8 );
    da12:	4b36      	ldr	r3, [pc, #216]	; (daec <usb_init+0x10c>)
    da14:	4936      	ldr	r1, [pc, #216]	; (daf0 <usb_init+0x110>)
    da16:	6818      	ldr	r0, [r3, #0]
    da18:	2208      	movs	r2, #8
    da1a:	f001 ff37 	bl	f88c <hex32ToStr16>
	hex32ToStr16( SIM_UIDL,  &(usb_string_serial_number_default.wString[24]), 8 );
    da1e:	4b35      	ldr	r3, [pc, #212]	; (daf4 <usb_init+0x114>)
    da20:	4935      	ldr	r1, [pc, #212]	; (daf8 <usb_init+0x118>)
    da22:	6818      	ldr	r0, [r3, #0]
    da24:	2208      	movs	r2, #8
    da26:	f001 ff31 	bl	f88c <hex32ToStr16>
		table[i].desc = 0;
    da2a:	4934      	ldr	r1, [pc, #208]	; (dafc <usb_init+0x11c>)
	hex32ToStr16( SIM_UIDL,  &(usb_string_serial_number_default.wString[24]), 8 );
    da2c:	4623      	mov	r3, r4
		table[i].desc = 0;
    da2e:	4618      	mov	r0, r3
    da30:	462c      	mov	r4, r5
    da32:	460a      	mov	r2, r1
    da34:	5058      	str	r0, [r3, r1]
		table[i].addr = 0;
    da36:	18cd      	adds	r5, r1, r3
    da38:	3308      	adds	r3, #8
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    da3a:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
		table[i].addr = 0;
    da3e:	6068      	str	r0, [r5, #4]
	for ( int i = 0; i <= NUM_ENDPOINTS * 4; i++ )
    da40:	d1f8      	bne.n	da34 <usb_init+0x54>
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    da42:	492f      	ldr	r1, [pc, #188]	; (db00 <usb_init+0x120>)
    da44:	680b      	ldr	r3, [r1, #0]
    da46:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    da4a:	600b      	str	r3, [r1, #0]
	USB0_USBTRC0 = USB_USBTRC_USBRESET;
    da4c:	4b2d      	ldr	r3, [pc, #180]	; (db04 <usb_init+0x124>)
    da4e:	2180      	movs	r1, #128	; 0x80
    da50:	7019      	strb	r1, [r3, #0]
	while ( (USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0 ); // wait for reset to end
    da52:	7819      	ldrb	r1, [r3, #0]
    da54:	0608      	lsls	r0, r1, #24
    da56:	d4fc      	bmi.n	da52 <usb_init+0x72>
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    da58:	492b      	ldr	r1, [pc, #172]	; (db08 <usb_init+0x128>)
    da5a:	f3c2 2007 	ubfx	r0, r2, #8, #8
    da5e:	7008      	strb	r0, [r1, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    da60:	f3c2 4007 	ubfx	r0, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    da64:	0e12      	lsrs	r2, r2, #24
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    da66:	7508      	strb	r0, [r1, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    da68:	760a      	strb	r2, [r1, #24]
	USB0_ISTAT = 0xFF;
    da6a:	22ff      	movs	r2, #255	; 0xff
    da6c:	f801 2c1c 	strb.w	r2, [r1, #-28]
	USB0_ERRSTAT = 0xFF;
    da70:	f801 2c14 	strb.w	r2, [r1, #-20]
	USB0_OTGISTAT = 0xFF;
    da74:	f801 2c8c 	strb.w	r2, [r1, #-140]
	USB0_USBTRC0 |= 0x40; // undocumented bit
    da78:	781a      	ldrb	r2, [r3, #0]
    da7a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    da7e:	701a      	strb	r2, [r3, #0]
	USB0_CTL = USB_CTL_USBENSOFEN;
    da80:	4b22      	ldr	r3, [pc, #136]	; (db0c <usb_init+0x12c>)
	USB0_USBCTRL = 0;
    da82:	4a23      	ldr	r2, [pc, #140]	; (db10 <usb_init+0x130>)
	USB0_CTL = USB_CTL_USBENSOFEN;
    da84:	2001      	movs	r0, #1
    da86:	7018      	strb	r0, [r3, #0]
	USB0_USBCTRL = 0;
    da88:	2300      	movs	r3, #0
    da8a:	7013      	strb	r3, [r2, #0]
	USB0_INTEN = USB_INTEN_USBRSTEN;
    da8c:	f802 0c7c 	strb.w	r0, [r2, #-124]
	NVIC_SET_PRIORITY( IRQ_USBOTG, 112 );
    da90:	4a20      	ldr	r2, [pc, #128]	; (db14 <usb_init+0x134>)
    da92:	2170      	movs	r1, #112	; 0x70
    da94:	7011      	strb	r1, [r2, #0]
	NVIC_ENABLE_IRQ( IRQ_USBOTG );
    da96:	f46f 7150 	mvn.w	r1, #832	; 0x340
    da9a:	440a      	add	r2, r1
    da9c:	f44f 7100 	mov.w	r1, #512	; 0x200
    daa0:	6011      	str	r1, [r2, #0]
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    daa2:	f102 42c0 	add.w	r2, r2, #1610612736	; 0x60000000
    daa6:	f502 22c8 	add.w	r2, r2, #409600	; 0x64000
    daaa:	2110      	movs	r1, #16
    daac:	7011      	strb	r1, [r2, #0]
	usb_dev_sleep = 0;
    daae:	4a1a      	ldr	r2, [pc, #104]	; (db18 <usb_init+0x138>)
    dab0:	7013      	strb	r3, [r2, #0]
	power_neg_delay = 0;
    dab2:	4a1a      	ldr	r2, [pc, #104]	; (db1c <usb_init+0x13c>)
    dab4:	7013      	strb	r3, [r2, #0]
	usb_remote_wakeup = 1;
    dab6:	4b1a      	ldr	r3, [pc, #104]	; (db20 <usb_init+0x140>)
}
    dab8:	9a01      	ldr	r2, [sp, #4]
	usb_remote_wakeup = 1;
    daba:	7018      	strb	r0, [r3, #0]
}
    dabc:	6823      	ldr	r3, [r4, #0]
    dabe:	429a      	cmp	r2, r3
    dac0:	d001      	beq.n	dac6 <usb_init+0xe6>
    dac2:	f7f4 fe35 	bl	2730 <__stack_chk_fail>
    dac6:	b003      	add	sp, #12
    dac8:	bd30      	pop	{r4, r5, pc}
    daca:	bf00      	nop
    dacc:	1fff89d0 	.word	0x1fff89d0
    dad0:	1fff92d8 	.word	0x1fff92d8
    dad4:	1fffb334 	.word	0x1fffb334
    dad8:	1fffb2de 	.word	0x1fffb2de
    dadc:	40048054 	.word	0x40048054
    dae0:	1fff91f6 	.word	0x1fff91f6
    dae4:	40048058 	.word	0x40048058
    dae8:	1fff9206 	.word	0x1fff9206
    daec:	4004805c 	.word	0x4004805c
    daf0:	1fff9216 	.word	0x1fff9216
    daf4:	40048060 	.word	0x40048060
    daf8:	1fff9226 	.word	0x1fff9226
    dafc:	1fff8000 	.word	0x1fff8000
    db00:	40048034 	.word	0x40048034
    db04:	4007210c 	.word	0x4007210c
    db08:	4007209c 	.word	0x4007209c
    db0c:	40072094 	.word	0x40072094
    db10:	40072100 	.word	0x40072100
    db14:	e000e449 	.word	0xe000e449
    db18:	1fff987b 	.word	0x1fff987b
    db1c:	1fff97b8 	.word	0x1fff97b8
    db20:	1fff987d 	.word	0x1fff987d

0000db24 <usb_configured>:
{
    db24:	b507      	push	{r0, r1, r2, lr}
    db26:	4b07      	ldr	r3, [pc, #28]	; (db44 <usb_configured+0x20>)
    db28:	681a      	ldr	r2, [r3, #0]
    db2a:	9201      	str	r2, [sp, #4]
	return usb_configuration;
    db2c:	4a06      	ldr	r2, [pc, #24]	; (db48 <usb_configured+0x24>)
    db2e:	7810      	ldrb	r0, [r2, #0]
}
    db30:	9a01      	ldr	r2, [sp, #4]
    db32:	681b      	ldr	r3, [r3, #0]
    db34:	429a      	cmp	r2, r3
    db36:	d001      	beq.n	db3c <usb_configured+0x18>
    db38:	f7f4 fdfa 	bl	2730 <__stack_chk_fail>
    db3c:	b003      	add	sp, #12
    db3e:	f85d fb04 	ldr.w	pc, [sp], #4
    db42:	bf00      	nop
    db44:	1fff89d0 	.word	0x1fff89d0
    db48:	1fff987a 	.word	0x1fff987a

0000db4c <usb_keyboard_send>:
}


// Send the contents of keyboard_keys and keyboard_modifier_keys
void usb_keyboard_send( USBKeys *buffer, uint8_t protocol )
{
    db4c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    db50:	4e79      	ldr	r6, [pc, #484]	; (dd38 <usb_keyboard_send+0x1ec>)
	usb_packet_t *tx_packet;

	// Wait till ready
	while ( 1 )
	{
		if ( !usb_configuration )
    db52:	f8df a200 	ldr.w	sl, [pc, #512]	; dd54 <usb_keyboard_send+0x208>
{
    db56:	6833      	ldr	r3, [r6, #0]
    db58:	9303      	str	r3, [sp, #12]
	Time start = Time_now();
    db5a:	f10d 0904 	add.w	r9, sp, #4
{
    db5e:	4605      	mov	r5, r0
	Time start = Time_now();
    db60:	4648      	mov	r0, r9
{
    db62:	460f      	mov	r7, r1
	Time start = Time_now();
    db64:	f7f5 f8d2 	bl	2d0c <Time_now>
    db68:	f8df 81ec 	ldr.w	r8, [pc, #492]	; dd58 <usb_keyboard_send+0x20c>
		if ( !usb_configuration )
    db6c:	f89a 3000 	ldrb.w	r3, [sl]
    db70:	b95b      	cbnz	r3, db8a <usb_keyboard_send+0x3e>
		{
			erro_print("USB not configured...");
    db72:	9a03      	ldr	r2, [sp, #12]
    db74:	6833      	ldr	r3, [r6, #0]
    db76:	429a      	cmp	r2, r3
    db78:	d001      	beq.n	db7e <usb_keyboard_send+0x32>

		break;
	}

	return;
}
    db7a:	f7f4 fdd9 	bl	2730 <__stack_chk_fail>
			erro_print("USB not configured...");
    db7e:	486f      	ldr	r0, [pc, #444]	; (dd3c <usb_keyboard_send+0x1f0>)
}
    db80:	b004      	add	sp, #16
    db82:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			warn_print("USB Transmit Timeout...auto-restart disabled");
    db86:	f001 bcf3 	b.w	f570 <_print>
		if ( usb_resume() )
    db8a:	f7ff fcef 	bl	d56c <usb_resume>
    db8e:	b108      	cbz	r0, db94 <usb_keyboard_send+0x48>
			buffer->changed = USBKeyChangeState_None; // Mark sent
    db90:	2300      	movs	r3, #0
    db92:	e044      	b.n	dc1e <usb_keyboard_send+0xd2>
		if ( protocol == 0 ) // Boot Mode
    db94:	b9b7      	cbnz	r7, dbc4 <usb_keyboard_send+0x78>
			if ( usb_tx_packet_count( KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    db96:	2001      	movs	r0, #1
    db98:	f7ff fc1c 	bl	d3d4 <usb_tx_packet_count>
    db9c:	2803      	cmp	r0, #3
    db9e:	d91c      	bls.n	dbda <usb_keyboard_send+0x8e>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    dba0:	e899 0003 	ldmia.w	r9, {r0, r1}
    dba4:	f7f5 fa04 	bl	2fb0 <Time_duration_ms>
    dba8:	2832      	cmp	r0, #50	; 0x32
    dbaa:	d93b      	bls.n	dc24 <usb_keyboard_send+0xd8>
			transmit_previous_timeout = 1;
    dbac:	2301      	movs	r3, #1
    dbae:	f888 3000 	strb.w	r3, [r8]
			buffer->changed = USBKeyChangeState_None; // Indicate packet lost
    dbb2:	2300      	movs	r3, #0
			warn_print("USB Transmit Timeout...auto-restart disabled");
    dbb4:	9a03      	ldr	r2, [sp, #12]
			buffer->changed = USBKeyChangeState_None; // Indicate packet lost
    dbb6:	f885 3020 	strb.w	r3, [r5, #32]
			warn_print("USB Transmit Timeout...auto-restart disabled");
    dbba:	6833      	ldr	r3, [r6, #0]
    dbbc:	429a      	cmp	r2, r3
    dbbe:	d1dc      	bne.n	db7a <usb_keyboard_send+0x2e>
    dbc0:	485f      	ldr	r0, [pc, #380]	; (dd40 <usb_keyboard_send+0x1f4>)
    dbc2:	e7dd      	b.n	db80 <usb_keyboard_send+0x34>
		else if ( protocol == 1 ) // NKRO Mode
    dbc4:	2f01      	cmp	r7, #1
    dbc6:	d101      	bne.n	dbcc <usb_keyboard_send+0x80>
			if ( usb_tx_packet_count( NKRO_KEYBOARD_ENDPOINT ) < TX_PACKET_LIMIT )
    dbc8:	2002      	movs	r0, #2
    dbca:	e7e5      	b.n	db98 <usb_keyboard_send+0x4c>
		else if ( buffer->changed &
    dbcc:	f895 3020 	ldrb.w	r3, [r5, #32]
    dbd0:	f013 0f0c 	tst.w	r3, #12
    dbd4:	d0e4      	beq.n	dba0 <usb_keyboard_send+0x54>
			if ( usb_tx_packet_count( SYS_CTRL_ENDPOINT ) < TX_PACKET_LIMIT )
    dbd6:	2003      	movs	r0, #3
    dbd8:	e7de      	b.n	db98 <usb_keyboard_send+0x4c>
				tx_packet = usb_malloc();
    dbda:	f000 f90d 	bl	ddf8 <usb_malloc>
				if ( tx_packet )
    dbde:	4604      	mov	r4, r0
    dbe0:	2800      	cmp	r0, #0
    dbe2:	d0dd      	beq.n	dba0 <usb_keyboard_send+0x54>
	transmit_previous_timeout = 0;
    dbe4:	2300      	movs	r3, #0
    dbe6:	f888 3000 	strb.w	r3, [r8]
	if ( buffer->changed & USBKeyChangeState_System )
    dbea:	f895 3020 	ldrb.w	r3, [r5, #32]
    dbee:	075a      	lsls	r2, r3, #29
    dbf0:	d51f      	bpl.n	dc32 <usb_keyboard_send+0xe6>
		if ( Output_DebugMode )
    dbf2:	4b54      	ldr	r3, [pc, #336]	; (dd44 <usb_keyboard_send+0x1f8>)
    dbf4:	781b      	ldrb	r3, [r3, #0]
    dbf6:	b113      	cbz	r3, dbfe <usb_keyboard_send+0xb2>
			USB_SysCtrlDebug( buffer );
    dbf8:	4628      	mov	r0, r5
    dbfa:	f7fe fee5 	bl	c9c8 <USB_SysCtrlDebug>
		USBKeys_idle.sys_ctrl = buffer->sys_ctrl;
    dbfe:	4b52      	ldr	r3, [pc, #328]	; (dd48 <usb_keyboard_send+0x1fc>)
    dc00:	7f6a      	ldrb	r2, [r5, #29]
    dc02:	775a      	strb	r2, [r3, #29]
		*tx_buf++ = 0x02; // ID
    dc04:	2302      	movs	r3, #2
    dc06:	7223      	strb	r3, [r4, #8]
		*tx_buf   = buffer->sys_ctrl;
    dc08:	7f6a      	ldrb	r2, [r5, #29]
    dc0a:	7262      	strb	r2, [r4, #9]
		tx_packet->len = 2;
    dc0c:	8023      	strh	r3, [r4, #0]
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    dc0e:	4621      	mov	r1, r4
    dc10:	2003      	movs	r0, #3
    dc12:	f7ff fc4b 	bl	d4ac <usb_tx>
		buffer->changed &= ~USBKeyChangeState_System; // Mark sent
    dc16:	f895 3020 	ldrb.w	r3, [r5, #32]
    dc1a:	f023 0304 	bic.w	r3, r3, #4
			buffer->changed = USBKeyChangeState_None; // Mark sent
    dc1e:	f885 3020 	strb.w	r3, [r5, #32]
    dc22:	e024      	b.n	dc6e <usb_keyboard_send+0x122>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    dc24:	f898 3000 	ldrb.w	r3, [r8]
    dc28:	2b00      	cmp	r3, #0
    dc2a:	d1bf      	bne.n	dbac <usb_keyboard_send+0x60>
		yield();
    dc2c:	f7f4 fdfa 	bl	2824 <yield>
		if ( !usb_configuration )
    dc30:	e79c      	b.n	db6c <usb_keyboard_send+0x20>
	if ( buffer->changed & USBKeyChangeState_Consumer )
    dc32:	071b      	lsls	r3, r3, #28
    dc34:	d518      	bpl.n	dc68 <usb_keyboard_send+0x11c>
		if ( Output_DebugMode )
    dc36:	4b43      	ldr	r3, [pc, #268]	; (dd44 <usb_keyboard_send+0x1f8>)
    dc38:	781b      	ldrb	r3, [r3, #0]
    dc3a:	b113      	cbz	r3, dc42 <usb_keyboard_send+0xf6>
			USB_ConsCtrlDebug( buffer );
    dc3c:	4628      	mov	r0, r5
    dc3e:	f7fe fee1 	bl	ca04 <USB_ConsCtrlDebug>
		USBKeys_idle.cons_ctrl = buffer->cons_ctrl;
    dc42:	4b41      	ldr	r3, [pc, #260]	; (dd48 <usb_keyboard_send+0x1fc>)
    dc44:	8bea      	ldrh	r2, [r5, #30]
    dc46:	83da      	strh	r2, [r3, #30]
		*tx_buf++ = 0x03; // ID
    dc48:	2003      	movs	r0, #3
    dc4a:	7220      	strb	r0, [r4, #8]
		*tx_buf++ = (uint8_t)(buffer->cons_ctrl & 0x00FF);
    dc4c:	8beb      	ldrh	r3, [r5, #30]
    dc4e:	7263      	strb	r3, [r4, #9]
		*tx_buf   = (uint8_t)(buffer->cons_ctrl >> 8);
    dc50:	8beb      	ldrh	r3, [r5, #30]
		tx_packet->len = 3;
    dc52:	8020      	strh	r0, [r4, #0]
		*tx_buf   = (uint8_t)(buffer->cons_ctrl >> 8);
    dc54:	0a1b      	lsrs	r3, r3, #8
    dc56:	72a3      	strb	r3, [r4, #10]
		usb_tx( SYS_CTRL_ENDPOINT, tx_packet );
    dc58:	4621      	mov	r1, r4
    dc5a:	f7ff fc27 	bl	d4ac <usb_tx>
		buffer->changed &= ~USBKeyChangeState_Consumer; // Mark sent
    dc5e:	f895 3020 	ldrb.w	r3, [r5, #32]
    dc62:	f023 0308 	bic.w	r3, r3, #8
    dc66:	e7da      	b.n	dc1e <usb_keyboard_send+0xd2>
	switch ( protocol )
    dc68:	b147      	cbz	r7, dc7c <usb_keyboard_send+0x130>
    dc6a:	2f01      	cmp	r7, #1
    dc6c:	d02a      	beq.n	dcc4 <usb_keyboard_send+0x178>
}
    dc6e:	9a03      	ldr	r2, [sp, #12]
    dc70:	6833      	ldr	r3, [r6, #0]
    dc72:	429a      	cmp	r2, r3
    dc74:	d181      	bne.n	db7a <usb_keyboard_send+0x2e>
    dc76:	b004      	add	sp, #16
    dc78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if ( Output_DebugMode )
    dc7c:	4b31      	ldr	r3, [pc, #196]	; (dd44 <usb_keyboard_send+0x1f8>)
    dc7e:	781b      	ldrb	r3, [r3, #0]
    dc80:	b113      	cbz	r3, dc88 <usb_keyboard_send+0x13c>
			USB_6KRODebug( buffer );
    dc82:	4628      	mov	r0, r5
    dc84:	f7fe fedc 	bl	ca40 <USB_6KRODebug>
		memcpy( (void*)&USBKeys_idle.keys, buffer->keys, USB_BOOT_MAX_KEYS );
    dc88:	4f30      	ldr	r7, [pc, #192]	; (dd4c <usb_keyboard_send+0x200>)
    dc8a:	f105 0801 	add.w	r8, r5, #1
    dc8e:	2206      	movs	r2, #6
    dc90:	4641      	mov	r1, r8
    dc92:	4638      	mov	r0, r7
    dc94:	f7f4 fd70 	bl	2778 <memcpy>
		USBKeys_idle.modifiers = buffer->modifiers;
    dc98:	782b      	ldrb	r3, [r5, #0]
    dc9a:	f807 3c01 	strb.w	r3, [r7, #-1]
		*tx_buf++ = buffer->modifiers;
    dc9e:	782b      	ldrb	r3, [r5, #0]
    dca0:	7223      	strb	r3, [r4, #8]
		*tx_buf++ = 0;
    dca2:	2700      	movs	r7, #0
		memcpy( tx_buf, buffer->keys, USB_BOOT_MAX_KEYS );
    dca4:	2206      	movs	r2, #6
    dca6:	4641      	mov	r1, r8
		*tx_buf++ = 0;
    dca8:	7267      	strb	r7, [r4, #9]
		memcpy( tx_buf, buffer->keys, USB_BOOT_MAX_KEYS );
    dcaa:	f104 000a 	add.w	r0, r4, #10
    dcae:	f7f4 fd63 	bl	2778 <memcpy>
		tx_packet->len = 8;
    dcb2:	2308      	movs	r3, #8
    dcb4:	8023      	strh	r3, [r4, #0]
		usb_tx( KEYBOARD_ENDPOINT, tx_packet );
    dcb6:	4621      	mov	r1, r4
    dcb8:	2001      	movs	r0, #1
    dcba:	f7ff fbf7 	bl	d4ac <usb_tx>
		buffer->changed = USBKeyChangeState_None;
    dcbe:	f885 7020 	strb.w	r7, [r5, #32]
		break;
    dcc2:	e7d4      	b.n	dc6e <usb_keyboard_send+0x122>
		if ( Output_DebugMode )
    dcc4:	4f1f      	ldr	r7, [pc, #124]	; (dd44 <usb_keyboard_send+0x1f8>)
    dcc6:	783a      	ldrb	r2, [r7, #0]
    dcc8:	b112      	cbz	r2, dcd0 <usb_keyboard_send+0x184>
			dbug_msg("NKRO USB: ");
    dcca:	4821      	ldr	r0, [pc, #132]	; (dd50 <usb_keyboard_send+0x204>)
    dccc:	f001 fc50 	bl	f570 <_print>
		if ( buffer->changed )
    dcd0:	f895 3020 	ldrb.w	r3, [r5, #32]
    dcd4:	2b00      	cmp	r3, #0
    dcd6:	d0ca      	beq.n	dc6e <usb_keyboard_send+0x122>
			if ( Output_DebugMode )
    dcd8:	783b      	ldrb	r3, [r7, #0]
    dcda:	b113      	cbz	r3, dce2 <usb_keyboard_send+0x196>
				USB_NKRODebug( buffer );
    dcdc:	4628      	mov	r0, r5
    dcde:	f7fe fef1 	bl	cac4 <USB_NKRODebug>
			memcpy( (void*)&USBKeys_idle.keys, buffer->keys, USB_NKRO_BITFIELD_SIZE_KEYS );
    dce2:	4f1a      	ldr	r7, [pc, #104]	; (dd4c <usb_keyboard_send+0x200>)
    dce4:	f105 0901 	add.w	r9, r5, #1
    dce8:	4649      	mov	r1, r9
    dcea:	221c      	movs	r2, #28
    dcec:	4638      	mov	r0, r7
    dcee:	f7f4 fd43 	bl	2778 <memcpy>
			USBKeys_idle.modifiers = buffer->modifiers;
    dcf2:	782b      	ldrb	r3, [r5, #0]
    dcf4:	f807 3c01 	strb.w	r3, [r7, #-1]
			*tx_buf++ = buffer->modifiers;
    dcf8:	462f      	mov	r7, r5
			*tx_buf++ = 0x01; // ID
    dcfa:	2301      	movs	r3, #1
    dcfc:	7223      	strb	r3, [r4, #8]
			tx_packet->len += 2;
    dcfe:	4620      	mov	r0, r4
			*tx_buf++ = buffer->modifiers;
    dd00:	f817 3b17 	ldrb.w	r3, [r7], #23
    dd04:	7263      	strb	r3, [r4, #9]
			tx_packet->len += 2;
    dd06:	f04f 0802 	mov.w	r8, #2
			memcpy( tx_buf, buffer->keys, 21 );
    dd0a:	4649      	mov	r1, r9
			tx_packet->len += 2;
    dd0c:	f820 8b0a 	strh.w	r8, [r0], #10
			memcpy( tx_buf, buffer->keys, 21 );
    dd10:	2215      	movs	r2, #21
    dd12:	f7f4 fd31 	bl	2778 <memcpy>
			tx_packet->len += 21;
    dd16:	8823      	ldrh	r3, [r4, #0]
    dd18:	4620      	mov	r0, r4
    dd1a:	3315      	adds	r3, #21
			memcpy( tx_buf, buffer->keys + 22, 6 );
    dd1c:	4639      	mov	r1, r7
			tx_packet->len += 21;
    dd1e:	f820 3b1f 	strh.w	r3, [r0], #31
			memcpy( tx_buf, buffer->keys + 22, 6 );
    dd22:	2206      	movs	r2, #6
    dd24:	f7f4 fd28 	bl	2778 <memcpy>
			tx_packet->len += 6;
    dd28:	8823      	ldrh	r3, [r4, #0]
    dd2a:	3306      	adds	r3, #6
    dd2c:	8023      	strh	r3, [r4, #0]
			usb_tx( NKRO_KEYBOARD_ENDPOINT, tx_packet );
    dd2e:	4621      	mov	r1, r4
    dd30:	4640      	mov	r0, r8
    dd32:	f7ff fbbb 	bl	d4ac <usb_tx>
    dd36:	e72b      	b.n	db90 <usb_keyboard_send+0x44>
    dd38:	1fff89d0 	.word	0x1fff89d0
    dd3c:	000163ef 	.word	0x000163ef
    dd40:	0001641c 	.word	0x0001641c
    dd44:	1fffb2c6 	.word	0x1fffb2c6
    dd48:	1fffb2e0 	.word	0x1fffb2e0
    dd4c:	1fffb2e1 	.word	0x1fffb2e1
    dd50:	00016460 	.word	0x00016460
    dd54:	1fff987a 	.word	0x1fff987a
    dd58:	1fff987f 	.word	0x1fff987f

0000dd5c <usb_keyboard_idle_update>:
{
    dd5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    dd5e:	4d12      	ldr	r5, [pc, #72]	; (dda8 <usb_keyboard_idle_update+0x4c>)
    dd60:	682b      	ldr	r3, [r5, #0]
    dd62:	9301      	str	r3, [sp, #4]
	if ( USBKeys_Idle_Config != 0 )
    dd64:	4b11      	ldr	r3, [pc, #68]	; (ddac <usb_keyboard_idle_update+0x50>)
    dd66:	7819      	ldrb	r1, [r3, #0]
    dd68:	b189      	cbz	r1, dd8e <usb_keyboard_idle_update+0x32>
		if ( USBKeys_Idle_Expiry + USBKeys_Idle_Config * 4 >= systick_millis_count )
    dd6a:	7819      	ldrb	r1, [r3, #0]
    dd6c:	4b10      	ldr	r3, [pc, #64]	; (ddb0 <usb_keyboard_idle_update+0x54>)
    dd6e:	4a11      	ldr	r2, [pc, #68]	; (ddb4 <usb_keyboard_idle_update+0x58>)
    dd70:	681b      	ldr	r3, [r3, #0]
    dd72:	6812      	ldr	r2, [r2, #0]
    dd74:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    dd78:	4293      	cmp	r3, r2
    dd7a:	d308      	bcc.n	dd8e <usb_keyboard_idle_update+0x32>
			USBKeys_idle.changed = USBKeyChangeState_All;
    dd7c:	4c0e      	ldr	r4, [pc, #56]	; (ddb8 <usb_keyboard_idle_update+0x5c>)
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    dd7e:	4e0f      	ldr	r6, [pc, #60]	; (ddbc <usb_keyboard_idle_update+0x60>)
			USBKeys_idle.changed = USBKeyChangeState_All;
    dd80:	230f      	movs	r3, #15
    dd82:	f884 3020 	strb.w	r3, [r4, #32]
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    dd86:	4627      	mov	r7, r4
			while ( USBKeys_idle.changed )
    dd88:	f894 3020 	ldrb.w	r3, [r4, #32]
    dd8c:	b92b      	cbnz	r3, dd9a <usb_keyboard_idle_update+0x3e>
}
    dd8e:	9a01      	ldr	r2, [sp, #4]
    dd90:	682b      	ldr	r3, [r5, #0]
    dd92:	429a      	cmp	r2, r3
    dd94:	d006      	beq.n	dda4 <usb_keyboard_idle_update+0x48>
    dd96:	f7f4 fccb 	bl	2730 <__stack_chk_fail>
				usb_keyboard_send( (USBKeys*)&USBKeys_idle, USBKeys_Protocol );
    dd9a:	7831      	ldrb	r1, [r6, #0]
    dd9c:	4638      	mov	r0, r7
    dd9e:	f7ff fed5 	bl	db4c <usb_keyboard_send>
    dda2:	e7f1      	b.n	dd88 <usb_keyboard_idle_update+0x2c>
}
    dda4:	b003      	add	sp, #12
    dda6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    dda8:	1fff89d0 	.word	0x1fff89d0
    ddac:	1fff9728 	.word	0x1fff9728
    ddb0:	1fffb32c 	.word	0x1fffb32c
    ddb4:	1fff92d8 	.word	0x1fff92d8
    ddb8:	1fffb2e0 	.word	0x1fffb2e0
    ddbc:	1fff8e44 	.word	0x1fff8e44

0000ddc0 <usb_keyboard_clear>:
{
    ddc0:	b530      	push	{r4, r5, lr}
    ddc2:	4c0c      	ldr	r4, [pc, #48]	; (ddf4 <usb_keyboard_clear+0x34>)
    ddc4:	b08b      	sub	sp, #44	; 0x2c
    ddc6:	6823      	ldr	r3, [r4, #0]
    ddc8:	9309      	str	r3, [sp, #36]	; 0x24
	USBKeys buffer = {
    ddca:	2222      	movs	r2, #34	; 0x22
{
    ddcc:	4605      	mov	r5, r0
	USBKeys buffer = {
    ddce:	2100      	movs	r1, #0
    ddd0:	4668      	mov	r0, sp
    ddd2:	f7f4 fcbb 	bl	274c <memset>
    ddd6:	230f      	movs	r3, #15
	usb_keyboard_send( &buffer, protocol );
    ddd8:	4629      	mov	r1, r5
    ddda:	4668      	mov	r0, sp
	USBKeys buffer = {
    dddc:	f88d 3020 	strb.w	r3, [sp, #32]
	usb_keyboard_send( &buffer, protocol );
    dde0:	f7ff feb4 	bl	db4c <usb_keyboard_send>
}
    dde4:	9a09      	ldr	r2, [sp, #36]	; 0x24
    dde6:	6823      	ldr	r3, [r4, #0]
    dde8:	429a      	cmp	r2, r3
    ddea:	d001      	beq.n	ddf0 <usb_keyboard_clear+0x30>
    ddec:	f7f4 fca0 	bl	2730 <__stack_chk_fail>
    ddf0:	b00b      	add	sp, #44	; 0x2c
    ddf2:	bd30      	pop	{r4, r5, pc}
    ddf4:	1fff89d0 	.word	0x1fff89d0

0000ddf8 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t *usb_malloc()
{
    ddf8:	b513      	push	{r0, r1, r4, lr}
    ddfa:	4b11      	ldr	r3, [pc, #68]	; (de40 <usb_malloc+0x48>)
    ddfc:	681a      	ldr	r2, [r3, #0]
    ddfe:	9201      	str	r2, [sp, #4]
#if defined(_kinetis_)
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    de00:	b672      	cpsid	i
	avail = usb_buffer_available;
    de02:	4c10      	ldr	r4, [pc, #64]	; (de44 <usb_malloc+0x4c>)
    de04:	6821      	ldr	r1, [r4, #0]
	n = __builtin_clz( avail ); // clz = count leading zeros
    de06:	fab1 f081 	clz	r0, r1
	if ( n >= NUM_USB_BUFFERS )
    de0a:	281d      	cmp	r0, #29
    de0c:	dd07      	ble.n	de1e <usb_malloc+0x26>
	{
		__enable_irq();
    de0e:	b662      	cpsie	i
		return NULL;
    de10:	2000      	movs	r0, #0
	return (usb_packet_t *)p;

#elif defined(_sam_)
	return &usb_packet;
#endif
}
    de12:	9a01      	ldr	r2, [sp, #4]
    de14:	681b      	ldr	r3, [r3, #0]
    de16:	429a      	cmp	r2, r3
    de18:	d010      	beq.n	de3c <usb_malloc+0x44>
    de1a:	f7f4 fc89 	bl	2730 <__stack_chk_fail>
	usb_buffer_available = avail & ~(0x80000000 >> n);
    de1e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    de22:	40c2      	lsrs	r2, r0
    de24:	ea21 0102 	bic.w	r1, r1, r2
    de28:	6021      	str	r1, [r4, #0]
	__enable_irq();
    de2a:	b662      	cpsie	i
	p = usb_buffer_memory + ( n * sizeof(usb_packet_t) );
    de2c:	4c06      	ldr	r4, [pc, #24]	; (de48 <usb_malloc+0x50>)
    de2e:	2248      	movs	r2, #72	; 0x48
    de30:	4342      	muls	r2, r0
    de32:	18a0      	adds	r0, r4, r2
	*(uint32_t *)p = 0;
    de34:	2100      	movs	r1, #0
    de36:	50a1      	str	r1, [r4, r2]
	*(uint32_t *)(p + 4) = 0;
    de38:	6041      	str	r1, [r0, #4]
	return (usb_packet_t *)p;
    de3a:	e7ea      	b.n	de12 <usb_malloc+0x1a>
}
    de3c:	b002      	add	sp, #8
    de3e:	bd10      	pop	{r4, pc}
    de40:	1fff89d0 	.word	0x1fff89d0
    de44:	1fff9268 	.word	0x1fff9268
    de48:	1fff8160 	.word	0x1fff8160

0000de4c <usb_free>:


void usb_free( usb_packet_t *p )
{
    de4c:	b513      	push	{r0, r1, r4, lr}
    de4e:	4a16      	ldr	r2, [pc, #88]	; (dea8 <usb_free+0x5c>)
    de50:	6813      	ldr	r3, [r2, #0]
    de52:	9301      	str	r3, [sp, #4]
#if defined(_kinetis_)
	unsigned int n, mask;

	n = ( (uint8_t *)p - usb_buffer_memory ) / sizeof(usb_packet_t);
    de54:	4b15      	ldr	r3, [pc, #84]	; (deac <usb_free+0x60>)
    de56:	2148      	movs	r1, #72	; 0x48
    de58:	1ac3      	subs	r3, r0, r3
    de5a:	fbb3 f3f1 	udiv	r3, r3, r1
	if ( n >= NUM_USB_BUFFERS )
    de5e:	2b1d      	cmp	r3, #29
    de60:	4614      	mov	r4, r2
    de62:	d81a      	bhi.n	de9a <usb_free+0x4e>
		return;

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if ( usb_rx_memory_needed && usb_configuration )
    de64:	4912      	ldr	r1, [pc, #72]	; (deb0 <usb_free+0x64>)
    de66:	7809      	ldrb	r1, [r1, #0]
    de68:	b169      	cbz	r1, de86 <usb_free+0x3a>
    de6a:	4912      	ldr	r1, [pc, #72]	; (deb4 <usb_free+0x68>)
    de6c:	7809      	ldrb	r1, [r1, #0]
    de6e:	b151      	cbz	r1, de86 <usb_free+0x3a>
	{
		usb_rx_memory( p );
    de70:	9901      	ldr	r1, [sp, #4]
    de72:	6813      	ldr	r3, [r2, #0]
    de74:	4299      	cmp	r1, r3
    de76:	d001      	beq.n	de7c <usb_free+0x30>
	mask = (0x80000000 >> n);
	__disable_irq();
	usb_buffer_available |= mask;
	__enable_irq();
#endif
}
    de78:	f7f4 fc5a 	bl	2730 <__stack_chk_fail>
    de7c:	b002      	add	sp, #8
    de7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usb_rx_memory( p );
    de82:	f7ff bac7 	b.w	d414 <usb_rx_memory>
	__disable_irq();
    de86:	b672      	cpsid	i
	usb_buffer_available |= mask;
    de88:	490b      	ldr	r1, [pc, #44]	; (deb8 <usb_free+0x6c>)
	mask = (0x80000000 >> n);
    de8a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    de8e:	fa22 f303 	lsr.w	r3, r2, r3
	usb_buffer_available |= mask;
    de92:	680a      	ldr	r2, [r1, #0]
    de94:	431a      	orrs	r2, r3
    de96:	600a      	str	r2, [r1, #0]
	__enable_irq();
    de98:	b662      	cpsie	i
}
    de9a:	9a01      	ldr	r2, [sp, #4]
    de9c:	6823      	ldr	r3, [r4, #0]
    de9e:	429a      	cmp	r2, r3
    dea0:	d1ea      	bne.n	de78 <usb_free+0x2c>
    dea2:	b002      	add	sp, #8
    dea4:	bd10      	pop	{r4, pc}
    dea6:	bf00      	nop
    dea8:	1fff89d0 	.word	0x1fff89d0
    deac:	1fff8160 	.word	0x1fff8160
    deb0:	1fff987e 	.word	0x1fff987e
    deb4:	1fff987a 	.word	0x1fff987a
    deb8:	1fff9268 	.word	0x1fff9268

0000debc <usb_mouse_send>:

// Process pending mouse commands
// XXX Proper support will require KLL generation of the USB descriptors
//     Similar support will be required for joystick control
void usb_mouse_send()
{
    debc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    dec0:	4d37      	ldr	r5, [pc, #220]	; (dfa0 <usb_mouse_send+0xe4>)
	usb_packet_t *tx_packet;

	// Wait till ready
	while ( 1 )
	{
		if ( !usb_configuration )
    dec2:	4f38      	ldr	r7, [pc, #224]	; (dfa4 <usb_mouse_send+0xe8>)
{
    dec4:	682b      	ldr	r3, [r5, #0]
    dec6:	9303      	str	r3, [sp, #12]
	Time start = Time_now();
    dec8:	ac01      	add	r4, sp, #4
    deca:	4620      	mov	r0, r4
    decc:	f7f4 ff1e 	bl	2d0c <Time_now>
    ded0:	4e35      	ldr	r6, [pc, #212]	; (dfa8 <usb_mouse_send+0xec>)
		if ( !usb_configuration )
    ded2:	783b      	ldrb	r3, [r7, #0]
    ded4:	b95b      	cbnz	r3, deee <usb_mouse_send+0x32>
		{
			erro_print("USB not configured...");
    ded6:	9a03      	ldr	r2, [sp, #12]
    ded8:	682b      	ldr	r3, [r5, #0]
    deda:	429a      	cmp	r2, r3
    dedc:	d001      	beq.n	dee2 <usb_mouse_send+0x26>
	USBMouse_Relative_x = 0;
	USBMouse_Relative_y = 0;
	USBMouse_VertWheel = 0;
	USBMouse_HoriWheel = 0;
	USBMouse_Changed = 0;
}
    dede:	f7f4 fc27 	bl	2730 <__stack_chk_fail>
			erro_print("USB not configured...");
    dee2:	4832      	ldr	r0, [pc, #200]	; (dfac <usb_mouse_send+0xf0>)
}
    dee4:	b004      	add	sp, #16
    dee6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			erro_print("USB not configured...");
    deea:	f001 bb41 	b.w	f570 <_print>
		if ( usb_tx_packet_count( MOUSE_ENDPOINT ) < TX_PACKET_LIMIT )
    deee:	2007      	movs	r0, #7
    def0:	f7ff fa70 	bl	d3d4 <usb_tx_packet_count>
    def4:	2802      	cmp	r0, #2
    def6:	d91e      	bls.n	df36 <usb_mouse_send+0x7a>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    def8:	e894 0003 	ldmia.w	r4, {r0, r1}
    defc:	f7f5 f858 	bl	2fb0 <Time_duration_ms>
    df00:	281e      	cmp	r0, #30
    df02:	d947      	bls.n	df94 <usb_mouse_send+0xd8>
			transmit_previous_timeout = 1;
    df04:	2301      	movs	r3, #1
			warn_print("USB Transmit Timeout...");
    df06:	482a      	ldr	r0, [pc, #168]	; (dfb0 <usb_mouse_send+0xf4>)
			transmit_previous_timeout = 1;
    df08:	7033      	strb	r3, [r6, #0]
			warn_print("USB Transmit Timeout...");
    df0a:	f001 fb31 	bl	f570 <_print>
			USBMouse_Buttons = 0;
    df0e:	4a29      	ldr	r2, [pc, #164]	; (dfb4 <usb_mouse_send+0xf8>)
    df10:	2300      	movs	r3, #0
    df12:	8013      	strh	r3, [r2, #0]
			USBMouse_Relative_x = 0;
    df14:	4a28      	ldr	r2, [pc, #160]	; (dfb8 <usb_mouse_send+0xfc>)
    df16:	8013      	strh	r3, [r2, #0]
			USBMouse_Relative_y = 0;
    df18:	4a28      	ldr	r2, [pc, #160]	; (dfbc <usb_mouse_send+0x100>)
    df1a:	8013      	strh	r3, [r2, #0]
			USBMouse_VertWheel = 0;
    df1c:	4a28      	ldr	r2, [pc, #160]	; (dfc0 <usb_mouse_send+0x104>)
    df1e:	7013      	strb	r3, [r2, #0]
			USBMouse_HoriWheel = 0;
    df20:	4a28      	ldr	r2, [pc, #160]	; (dfc4 <usb_mouse_send+0x108>)
    df22:	7013      	strb	r3, [r2, #0]
			USBMouse_Changed = 0;
    df24:	4a28      	ldr	r2, [pc, #160]	; (dfc8 <usb_mouse_send+0x10c>)
    df26:	7013      	strb	r3, [r2, #0]
}
    df28:	9a03      	ldr	r2, [sp, #12]
    df2a:	682b      	ldr	r3, [r5, #0]
    df2c:	429a      	cmp	r2, r3
    df2e:	d1d6      	bne.n	dede <usb_mouse_send+0x22>
    df30:	b004      	add	sp, #16
    df32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			tx_packet = usb_malloc();
    df36:	f7ff ff5f 	bl	ddf8 <usb_malloc>
			if ( tx_packet )
    df3a:	4601      	mov	r1, r0
    df3c:	2800      	cmp	r0, #0
    df3e:	d0db      	beq.n	def8 <usb_mouse_send+0x3c>
	packet_data[0] = USBMouse_Buttons;
    df40:	f8df 9070 	ldr.w	r9, [pc, #112]	; dfb4 <usb_mouse_send+0xf8>
	packet_data[1] = (uint16_t)USBMouse_Relative_x;
    df44:	f8df 8070 	ldr.w	r8, [pc, #112]	; dfb8 <usb_mouse_send+0xfc>
	packet_data[0] = USBMouse_Buttons;
    df48:	f8b9 3000 	ldrh.w	r3, [r9]
	packet_data[2] = (uint16_t)USBMouse_Relative_y;
    df4c:	4f1b      	ldr	r7, [pc, #108]	; (dfbc <usb_mouse_send+0x100>)
	packet_data[0] = USBMouse_Buttons;
    df4e:	8103      	strh	r3, [r0, #8]
	transmit_previous_timeout = 0;
    df50:	2400      	movs	r4, #0
	packet_data[1] = (uint16_t)USBMouse_Relative_x;
    df52:	f8b8 3000 	ldrh.w	r3, [r8]
	transmit_previous_timeout = 0;
    df56:	7034      	strb	r4, [r6, #0]
	packet_data[3] = (uint16_t)(USBMouse_VertWheel | (USBMouse_HoriWheel << 8));
    df58:	f8df a068 	ldr.w	sl, [pc, #104]	; dfc4 <usb_mouse_send+0x108>
    df5c:	4e18      	ldr	r6, [pc, #96]	; (dfc0 <usb_mouse_send+0x104>)
	packet_data[1] = (uint16_t)USBMouse_Relative_x;
    df5e:	8143      	strh	r3, [r0, #10]
	packet_data[2] = (uint16_t)USBMouse_Relative_y;
    df60:	883b      	ldrh	r3, [r7, #0]
    df62:	8183      	strh	r3, [r0, #12]
	packet_data[3] = (uint16_t)(USBMouse_VertWheel | (USBMouse_HoriWheel << 8));
    df64:	7833      	ldrb	r3, [r6, #0]
    df66:	f89a 2000 	ldrb.w	r2, [sl]
    df6a:	b25b      	sxtb	r3, r3
    df6c:	b252      	sxtb	r2, r2
    df6e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    df72:	81c3      	strh	r3, [r0, #14]
	tx_packet->len = 8;
    df74:	2308      	movs	r3, #8
    df76:	8003      	strh	r3, [r0, #0]
	usb_tx( MOUSE_ENDPOINT, tx_packet );
    df78:	2007      	movs	r0, #7
    df7a:	f7ff fa97 	bl	d4ac <usb_tx>
	USBMouse_Changed = 0;
    df7e:	4b12      	ldr	r3, [pc, #72]	; (dfc8 <usb_mouse_send+0x10c>)
	USBMouse_Buttons = 0;
    df80:	f8a9 4000 	strh.w	r4, [r9]
	USBMouse_Changed = 0;
    df84:	701c      	strb	r4, [r3, #0]
	USBMouse_Relative_x = 0;
    df86:	f8a8 4000 	strh.w	r4, [r8]
	USBMouse_Relative_y = 0;
    df8a:	803c      	strh	r4, [r7, #0]
	USBMouse_VertWheel = 0;
    df8c:	7034      	strb	r4, [r6, #0]
	USBMouse_HoriWheel = 0;
    df8e:	f88a 4000 	strb.w	r4, [sl]
    df92:	e7c9      	b.n	df28 <usb_mouse_send+0x6c>
		if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    df94:	7833      	ldrb	r3, [r6, #0]
    df96:	2b00      	cmp	r3, #0
    df98:	d1b4      	bne.n	df04 <usb_mouse_send+0x48>
		yield();
    df9a:	f7f4 fc43 	bl	2824 <yield>
		if ( !usb_configuration )
    df9e:	e798      	b.n	ded2 <usb_mouse_send+0x16>
    dfa0:	1fff89d0 	.word	0x1fff89d0
    dfa4:	1fff987a 	.word	0x1fff987a
    dfa8:	1fff9880 	.word	0x1fff9880
    dfac:	000163ef 	.word	0x000163ef
    dfb0:	0001647e 	.word	0x0001647e
    dfb4:	1fffb2d8 	.word	0x1fffb2d8
    dfb8:	1fffb328 	.word	0x1fffb328
    dfbc:	1fffb2dc 	.word	0x1fffb2dc
    dfc0:	1fffb2da 	.word	0x1fffb2da
    dfc4:	1fffb32a 	.word	0x1fffb32a
    dfc8:	1fffb2d1 	.word	0x1fffb2d1

0000dfcc <usb_rawio_available>:

// ----- Functions -----

// Check for packets available from host
uint32_t usb_rawio_available()
{
    dfcc:	b507      	push	{r0, r1, r2, lr}
    dfce:	4b09      	ldr	r3, [pc, #36]	; (dff4 <usb_rawio_available+0x28>)
    dfd0:	681a      	ldr	r2, [r3, #0]
    dfd2:	9201      	str	r2, [sp, #4]
	// Error if USB isn't configured
	if ( !usb_configuration )
    dfd4:	4a08      	ldr	r2, [pc, #32]	; (dff8 <usb_rawio_available+0x2c>)
    dfd6:	7812      	ldrb	r2, [r2, #0]
    dfd8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
    dfdc:	b10a      	cbz	r2, dfe2 <usb_rawio_available+0x16>
	endpoint--;
	if ( endpoint >= NUM_ENDPOINTS )
	{
		return 0;
	}
	return usb_rx_byte_count_data[ endpoint ];
    dfde:	4a07      	ldr	r2, [pc, #28]	; (dffc <usb_rawio_available+0x30>)
    dfe0:	8a10      	ldrh	r0, [r2, #16]
		return 0;

	// Query number of bytes available from the endpoint
	return usb_rx_byte_count( RAWIO_RX_ENDPOINT );
}
    dfe2:	9a01      	ldr	r2, [sp, #4]
    dfe4:	681b      	ldr	r3, [r3, #0]
    dfe6:	429a      	cmp	r2, r3
    dfe8:	d001      	beq.n	dfee <usb_rawio_available+0x22>
    dfea:	f7f4 fba1 	bl	2730 <__stack_chk_fail>
    dfee:	b003      	add	sp, #12
    dff0:	f85d fb04 	ldr.w	pc, [sp], #4
    dff4:	1fff89d0 	.word	0x1fff89d0
    dff8:	1fff987a 	.word	0x1fff987a
    dffc:	1fffb338 	.word	0x1fffb338

0000e000 <usb_rawio_rx>:

// Retrieve packets from host
// Always returns RAWIO_RX_SIZE
int32_t usb_rawio_rx( void *buf, uint32_t timeout )
{
    e000:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e004:	4f1c      	ldr	r7, [pc, #112]	; (e078 <usb_rawio_rx+0x78>)

	// Read
	while ( 1 )
	{
		// Error if USB isn't configured
		if ( !usb_configuration )
    e006:	f8df 9078 	ldr.w	r9, [pc, #120]	; e080 <usb_rawio_rx+0x80>
{
    e00a:	683b      	ldr	r3, [r7, #0]
    e00c:	b085      	sub	sp, #20
	Time start = Time_now();
    e00e:	ad01      	add	r5, sp, #4
{
    e010:	4680      	mov	r8, r0
	Time start = Time_now();
    e012:	4628      	mov	r0, r5
{
    e014:	460e      	mov	r6, r1
    e016:	9303      	str	r3, [sp, #12]
	Time start = Time_now();
    e018:	f7f4 fe78 	bl	2d0c <Time_now>
		if ( !usb_configuration )
    e01c:	f899 3000 	ldrb.w	r3, [r9]
    e020:	b31b      	cbz	r3, e06a <usb_rawio_rx+0x6a>
			return -1;

		// Retrieve packet
		rx_packet = usb_rx( RAWIO_RX_ENDPOINT );
    e022:	2009      	movs	r0, #9
    e024:	f7ff f9ae 	bl	d384 <usb_rx>
		if ( rx_packet )
    e028:	4604      	mov	r4, r0
    e02a:	b998      	cbnz	r0, e054 <usb_rawio_rx+0x54>
			break;

		// Check for timeout
		if ( Time_duration_ms( start ) > timeout || !timeout )
    e02c:	e895 0003 	ldmia.w	r5, {r0, r1}
    e030:	f7f4 ffbe 	bl	2fb0 <Time_duration_ms>
    e034:	42b0      	cmp	r0, r6
    e036:	d800      	bhi.n	e03a <usb_rawio_rx+0x3a>
    e038:	b94e      	cbnz	r6, e04e <usb_rawio_rx+0x4e>
		{
			warn_msg("RAWIO Rx - Timeout, dropping packet.");
    e03a:	4810      	ldr	r0, [pc, #64]	; (e07c <usb_rawio_rx+0x7c>)
    e03c:	f001 fa98 	bl	f570 <_print>
			return 0;
    e040:	2000      	movs	r0, #0
	memcpy( buf, rx_packet->buf, RAWIO_RX_SIZE );
	usb_free( rx_packet );

	// Data sent in full packet chunks
	return RAWIO_RX_SIZE;
}
    e042:	9a03      	ldr	r2, [sp, #12]
    e044:	683b      	ldr	r3, [r7, #0]
    e046:	429a      	cmp	r2, r3
    e048:	d012      	beq.n	e070 <usb_rawio_rx+0x70>
    e04a:	f7f4 fb71 	bl	2730 <__stack_chk_fail>
		yield();
    e04e:	f7f4 fbe9 	bl	2824 <yield>
		if ( !usb_configuration )
    e052:	e7e3      	b.n	e01c <usb_rawio_rx+0x1c>
	memcpy( buf, rx_packet->buf, RAWIO_RX_SIZE );
    e054:	f100 0108 	add.w	r1, r0, #8
    e058:	2240      	movs	r2, #64	; 0x40
    e05a:	4640      	mov	r0, r8
    e05c:	f7f4 fb8c 	bl	2778 <memcpy>
	usb_free( rx_packet );
    e060:	4620      	mov	r0, r4
    e062:	f7ff fef3 	bl	de4c <usb_free>
	return RAWIO_RX_SIZE;
    e066:	2040      	movs	r0, #64	; 0x40
    e068:	e7eb      	b.n	e042 <usb_rawio_rx+0x42>
			return -1;
    e06a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e06e:	e7e8      	b.n	e042 <usb_rawio_rx+0x42>
}
    e070:	b005      	add	sp, #20
    e072:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e076:	bf00      	nop
    e078:	1fff89d0 	.word	0x1fff89d0
    e07c:	000164ad 	.word	0x000164ad
    e080:	1fff987a 	.word	0x1fff987a

0000e084 <usb_rawio_tx>:

// Send packet to host
// XXX Only transfers RAWIO_TX_SIZE on each call (likely 64 bytes)
// Always returns RAWIO_TX_SIZE
int32_t usb_rawio_tx( const void *buf, uint32_t timeout )
{
    e084:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e088:	4f20      	ldr	r7, [pc, #128]	; (e10c <usb_rawio_tx+0x88>)
	Time start = Time_now();

	while ( 1 )
	{
		// Error if USB isn't configured
		if ( !usb_configuration )
    e08a:	f8df 9088 	ldr.w	r9, [pc, #136]	; e114 <usb_rawio_tx+0x90>
{
    e08e:	683b      	ldr	r3, [r7, #0]
    e090:	b085      	sub	sp, #20
	Time start = Time_now();
    e092:	ac01      	add	r4, sp, #4
{
    e094:	4680      	mov	r8, r0
	Time start = Time_now();
    e096:	4620      	mov	r0, r4
{
    e098:	460e      	mov	r6, r1
    e09a:	9303      	str	r3, [sp, #12]
	Time start = Time_now();
    e09c:	f7f4 fe36 	bl	2d0c <Time_now>
		if ( !usb_configuration )
    e0a0:	f899 3000 	ldrb.w	r3, [r9]
    e0a4:	b35b      	cbz	r3, e0fe <usb_rawio_tx+0x7a>
			return -1;

		// Make sure we haven't exceeded the outgoing packet limit
		if ( usb_tx_packet_count( RAWIO_TX_ENDPOINT ) < TX_PACKET_LIMIT )
    e0a6:	2008      	movs	r0, #8
    e0a8:	f7ff f994 	bl	d3d4 <usb_tx_packet_count>
    e0ac:	2804      	cmp	r0, #4
    e0ae:	d90f      	bls.n	e0d0 <usb_rawio_tx+0x4c>
			if ( tx_packet )
				break;
		}

		// Check for timeout
		if ( Time_duration_ms( start ) > timeout || !timeout )
    e0b0:	e894 0003 	ldmia.w	r4, {r0, r1}
    e0b4:	f7f4 ff7c 	bl	2fb0 <Time_duration_ms>
    e0b8:	42b0      	cmp	r0, r6
    e0ba:	d91b      	bls.n	e0f4 <usb_rawio_tx+0x70>
		{
			warn_msg("RAWIO Tx - Timeout, dropping packet.");
    e0bc:	4814      	ldr	r0, [pc, #80]	; (e110 <usb_rawio_tx+0x8c>)
    e0be:	f001 fa57 	bl	f570 <_print>
			return 0;
    e0c2:	2000      	movs	r0, #0

	// Send USB packet
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );

	return RAWIO_TX_SIZE;
}
    e0c4:	9a03      	ldr	r2, [sp, #12]
    e0c6:	683b      	ldr	r3, [r7, #0]
    e0c8:	429a      	cmp	r2, r3
    e0ca:	d01b      	beq.n	e104 <usb_rawio_tx+0x80>
    e0cc:	f7f4 fb30 	bl	2730 <__stack_chk_fail>
			tx_packet = usb_malloc();
    e0d0:	f7ff fe92 	bl	ddf8 <usb_malloc>
			if ( tx_packet )
    e0d4:	4605      	mov	r5, r0
    e0d6:	2800      	cmp	r0, #0
    e0d8:	d0ea      	beq.n	e0b0 <usb_rawio_tx+0x2c>
	memcpy( tx_packet->buf, buf, RAWIO_TX_SIZE );
    e0da:	2240      	movs	r2, #64	; 0x40
    e0dc:	4641      	mov	r1, r8
	tx_packet->len = RAWIO_TX_SIZE;
    e0de:	2440      	movs	r4, #64	; 0x40
	memcpy( tx_packet->buf, buf, RAWIO_TX_SIZE );
    e0e0:	3008      	adds	r0, #8
    e0e2:	f7f4 fb49 	bl	2778 <memcpy>
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );
    e0e6:	2008      	movs	r0, #8
	tx_packet->len = RAWIO_TX_SIZE;
    e0e8:	802c      	strh	r4, [r5, #0]
	usb_tx( RAWIO_TX_ENDPOINT, tx_packet );
    e0ea:	4629      	mov	r1, r5
    e0ec:	f7ff f9de 	bl	d4ac <usb_tx>
	return RAWIO_TX_SIZE;
    e0f0:	4620      	mov	r0, r4
    e0f2:	e7e7      	b.n	e0c4 <usb_rawio_tx+0x40>
		if ( Time_duration_ms( start ) > timeout || !timeout )
    e0f4:	2e00      	cmp	r6, #0
    e0f6:	d0e1      	beq.n	e0bc <usb_rawio_tx+0x38>
		yield();
    e0f8:	f7f4 fb94 	bl	2824 <yield>
		if ( !usb_configuration )
    e0fc:	e7d0      	b.n	e0a0 <usb_rawio_tx+0x1c>
			return -1;
    e0fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e102:	e7df      	b.n	e0c4 <usb_rawio_tx+0x40>
}
    e104:	b005      	add	sp, #20
    e106:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e10a:	bf00      	nop
    e10c:	1fff89d0 	.word	0x1fff89d0
    e110:	000164e7 	.word	0x000164e7
    e114:	1fff987a 	.word	0x1fff987a

0000e118 <usb_serial_getchar>:

// ----- Functions -----

// get the next character, or -1 if nothing received
int usb_serial_getchar()
{
    e118:	b573      	push	{r0, r1, r4, r5, r6, lr}
    e11a:	4e15      	ldr	r6, [pc, #84]	; (e170 <usb_serial_getchar+0x58>)
	unsigned int i;
	int c;

	if ( !rx_packet )
    e11c:	4c15      	ldr	r4, [pc, #84]	; (e174 <usb_serial_getchar+0x5c>)
{
    e11e:	6832      	ldr	r2, [r6, #0]
    e120:	9201      	str	r2, [sp, #4]
	if ( !rx_packet )
    e122:	6822      	ldr	r2, [r4, #0]
    e124:	b162      	cbz	r2, e140 <usb_serial_getchar+0x28>
			return -1;
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
		if ( !rx_packet )
			return -1;
	}
	i = rx_packet->index;
    e126:	6820      	ldr	r0, [r4, #0]
    e128:	8843      	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    e12a:	18c2      	adds	r2, r0, r3
    e12c:	3301      	adds	r3, #1
    e12e:	7a15      	ldrb	r5, [r2, #8]
	if ( i >= rx_packet->len )
    e130:	8802      	ldrh	r2, [r0, #0]
    e132:	429a      	cmp	r2, r3
    e134:	d817      	bhi.n	e166 <usb_serial_getchar+0x4e>
	{
		usb_free( rx_packet );
    e136:	f7ff fe89 	bl	de4c <usb_free>
		rx_packet = NULL;
    e13a:	2300      	movs	r3, #0
    e13c:	6023      	str	r3, [r4, #0]
    e13e:	e004      	b.n	e14a <usb_serial_getchar+0x32>
		if ( !usb_configuration )
    e140:	4b0d      	ldr	r3, [pc, #52]	; (e178 <usb_serial_getchar+0x60>)
    e142:	781b      	ldrb	r3, [r3, #0]
    e144:	b943      	cbnz	r3, e158 <usb_serial_getchar+0x40>
			return -1;
    e146:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
	else
	{
		rx_packet->index = i;
	}
	return c;
}
    e14a:	9a01      	ldr	r2, [sp, #4]
    e14c:	6833      	ldr	r3, [r6, #0]
    e14e:	429a      	cmp	r2, r3
    e150:	4628      	mov	r0, r5
    e152:	d00a      	beq.n	e16a <usb_serial_getchar+0x52>
    e154:	f7f4 faec 	bl	2730 <__stack_chk_fail>
		rx_packet = usb_rx( CDC_RX_ENDPOINT );
    e158:	2005      	movs	r0, #5
    e15a:	f7ff f913 	bl	d384 <usb_rx>
    e15e:	6020      	str	r0, [r4, #0]
		if ( !rx_packet )
    e160:	2800      	cmp	r0, #0
    e162:	d1e0      	bne.n	e126 <usb_serial_getchar+0xe>
    e164:	e7ef      	b.n	e146 <usb_serial_getchar+0x2e>
		rx_packet->index = i;
    e166:	8043      	strh	r3, [r0, #2]
    e168:	e7ef      	b.n	e14a <usb_serial_getchar+0x32>
}
    e16a:	b002      	add	sp, #8
    e16c:	bd70      	pop	{r4, r5, r6, pc}
    e16e:	bf00      	nop
    e170:	1fff89d0 	.word	0x1fff89d0
    e174:	1fff9884 	.word	0x1fff9884
    e178:	1fff987a 	.word	0x1fff987a

0000e17c <usb_serial_available>:
	return rx_packet->buf[ rx_packet->index ];
}

// number of bytes available in the receive buffer
int usb_serial_available()
{
    e17c:	b507      	push	{r0, r1, r2, lr}
    e17e:	4b0a      	ldr	r3, [pc, #40]	; (e1a8 <usb_serial_available+0x2c>)
    e180:	681a      	ldr	r2, [r3, #0]
    e182:	9201      	str	r2, [sp, #4]
    e184:	4a09      	ldr	r2, [pc, #36]	; (e1ac <usb_serial_available+0x30>)
	int count = usb_rx_byte_count( CDC_RX_ENDPOINT );
    e186:	8910      	ldrh	r0, [r2, #8]
	if ( rx_packet )
    e188:	4a09      	ldr	r2, [pc, #36]	; (e1b0 <usb_serial_available+0x34>)
    e18a:	6811      	ldr	r1, [r2, #0]
    e18c:	b119      	cbz	r1, e196 <usb_serial_available+0x1a>
		count += rx_packet->len - rx_packet->index;
    e18e:	880a      	ldrh	r2, [r1, #0]
    e190:	8849      	ldrh	r1, [r1, #2]
    e192:	1a52      	subs	r2, r2, r1
    e194:	4410      	add	r0, r2
	return count;
}
    e196:	9a01      	ldr	r2, [sp, #4]
    e198:	681b      	ldr	r3, [r3, #0]
    e19a:	429a      	cmp	r2, r3
    e19c:	d001      	beq.n	e1a2 <usb_serial_available+0x26>
    e19e:	f7f4 fac7 	bl	2730 <__stack_chk_fail>
    e1a2:	b003      	add	sp, #12
    e1a4:	f85d fb04 	ldr.w	pc, [sp], #4
    e1a8:	1fff89d0 	.word	0x1fff89d0
    e1ac:	1fffb338 	.word	0x1fffb338
    e1b0:	1fff9884 	.word	0x1fff9884

0000e1b4 <usb_serial_write>:
{
	return usb_serial_write( &c, 1 );
}

int usb_serial_write( const void *buffer, uint32_t size )
{
    e1b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e1b8:	4f38      	ldr	r7, [pc, #224]	; (e29c <usb_serial_write+0xe8>)
	uint32_t len;
	Time start;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    e1ba:	4d39      	ldr	r5, [pc, #228]	; (e2a0 <usb_serial_write+0xec>)
{
    e1bc:	683b      	ldr	r3, [r7, #0]
	while ( size > 0 )
	{
		if ( !tx_packet )
    e1be:	f8df 80ec 	ldr.w	r8, [pc, #236]	; e2ac <usb_serial_write+0xf8>
		{
			start = Time_now();
			while ( 1 )
			{
				if ( !usb_configuration )
    e1c2:	f8df 90ec 	ldr.w	r9, [pc, #236]	; e2b0 <usb_serial_write+0xfc>
{
    e1c6:	b085      	sub	sp, #20
    e1c8:	4606      	mov	r6, r0
    e1ca:	9303      	str	r3, [sp, #12]
	tx_noautoflush = 1;
    e1cc:	2301      	movs	r3, #1
{
    e1ce:	460c      	mov	r4, r1
	tx_noautoflush = 1;
    e1d0:	702b      	strb	r3, [r5, #0]
	while ( size > 0 )
    e1d2:	b914      	cbnz	r4, e1da <usb_serial_write+0x26>
			usb_tx( CDC_TX_ENDPOINT, tx_packet );
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    e1d4:	702c      	strb	r4, [r5, #0]
	return 0;
    e1d6:	4620      	mov	r0, r4
    e1d8:	e011      	b.n	e1fe <usb_serial_write+0x4a>
		if ( !tx_packet )
    e1da:	f8d8 3000 	ldr.w	r3, [r8]
    e1de:	bb8b      	cbnz	r3, e244 <usb_serial_write+0x90>
			start = Time_now();
    e1e0:	f10d 0a04 	add.w	sl, sp, #4
    e1e4:	4650      	mov	r0, sl
    e1e6:	f7f4 fd91 	bl	2d0c <Time_now>
    e1ea:	f8df b0b8 	ldr.w	fp, [pc, #184]	; e2a4 <usb_serial_write+0xf0>
				if ( !usb_configuration )
    e1ee:	f899 3000 	ldrb.w	r3, [r9]
    e1f2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    e1f6:	b943      	cbnz	r3, e20a <usb_serial_write+0x56>
					tx_noautoflush = 0;
    e1f8:	702a      	strb	r2, [r5, #0]
					return -1;
    e1fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    e1fe:	9a03      	ldr	r2, [sp, #12]
    e200:	683b      	ldr	r3, [r7, #0]
    e202:	429a      	cmp	r2, r3
    e204:	d047      	beq.n	e296 <usb_serial_write+0xe2>
    e206:	f7f4 fa93 	bl	2730 <__stack_chk_fail>
				if ( usb_tx_packet_count( CDC_TX_ENDPOINT ) < TX_PACKET_LIMIT )
    e20a:	2006      	movs	r0, #6
    e20c:	f7ff f8e2 	bl	d3d4 <usb_tx_packet_count>
    e210:	2807      	cmp	r0, #7
    e212:	d807      	bhi.n	e224 <usb_serial_write+0x70>
					tx_noautoflush = 1;
    e214:	2301      	movs	r3, #1
    e216:	702b      	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    e218:	f7ff fdee 	bl	ddf8 <usb_malloc>
    e21c:	f8c8 0000 	str.w	r0, [r8]
					if ( tx_packet )
    e220:	b980      	cbnz	r0, e244 <usb_serial_write+0x90>
					tx_noautoflush = 0;
    e222:	7028      	strb	r0, [r5, #0]
				if ( Time_duration_ms( start ) > TX_TIMEOUT_MS || transmit_previous_timeout )
    e224:	e89a 0003 	ldmia.w	sl, {r0, r1}
    e228:	f7f4 fec2 	bl	2fb0 <Time_duration_ms>
    e22c:	2846      	cmp	r0, #70	; 0x46
    e22e:	d802      	bhi.n	e236 <usb_serial_write+0x82>
    e230:	f89b 3000 	ldrb.w	r3, [fp]
    e234:	b11b      	cbz	r3, e23e <usb_serial_write+0x8a>
					transmit_previous_timeout = 1;
    e236:	2301      	movs	r3, #1
    e238:	f88b 3000 	strb.w	r3, [fp]
    e23c:	e7dd      	b.n	e1fa <usb_serial_write+0x46>
				yield();
    e23e:	f7f4 faf1 	bl	2824 <yield>
				if ( !usb_configuration )
    e242:	e7d4      	b.n	e1ee <usb_serial_write+0x3a>
		len = CDC_TX_SIZE - tx_packet->index;
    e244:	f8d8 1000 	ldr.w	r1, [r8]
		transmit_previous_timeout = 0;
    e248:	4b16      	ldr	r3, [pc, #88]	; (e2a4 <usb_serial_write+0xf0>)
    e24a:	2200      	movs	r2, #0
    e24c:	701a      	strb	r2, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    e24e:	884b      	ldrh	r3, [r1, #2]
    e250:	f1c3 0240 	rsb	r2, r3, #64	; 0x40
    e254:	42a2      	cmp	r2, r4
    e256:	bf28      	it	cs
    e258:	4622      	movcs	r2, r4
		tx_packet->index += len;
    e25a:	1898      	adds	r0, r3, r2
    e25c:	440b      	add	r3, r1
    e25e:	8048      	strh	r0, [r1, #2]
		size -= len;
    e260:	1aa4      	subs	r4, r4, r2
    e262:	3307      	adds	r3, #7
    e264:	eb06 0a02 	add.w	sl, r6, r2
		while ( len-- > 0 )
    e268:	4556      	cmp	r6, sl
    e26a:	d10f      	bne.n	e28c <usb_serial_write+0xd8>
		if ( tx_packet->index >= CDC_TX_SIZE )
    e26c:	884b      	ldrh	r3, [r1, #2]
    e26e:	2b3f      	cmp	r3, #63	; 0x3f
    e270:	d907      	bls.n	e282 <usb_serial_write+0xce>
			tx_packet->len = CDC_TX_SIZE;
    e272:	2340      	movs	r3, #64	; 0x40
    e274:	800b      	strh	r3, [r1, #0]
			usb_tx( CDC_TX_ENDPOINT, tx_packet );
    e276:	2006      	movs	r0, #6
    e278:	f7ff f918 	bl	d4ac <usb_tx>
			tx_packet = NULL;
    e27c:	2300      	movs	r3, #0
    e27e:	f8c8 3000 	str.w	r3, [r8]
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    e282:	4b09      	ldr	r3, [pc, #36]	; (e2a8 <usb_serial_write+0xf4>)
    e284:	2205      	movs	r2, #5
    e286:	701a      	strb	r2, [r3, #0]
    e288:	4656      	mov	r6, sl
    e28a:	e7a2      	b.n	e1d2 <usb_serial_write+0x1e>
			*dest++ = *src++;
    e28c:	f816 2b01 	ldrb.w	r2, [r6], #1
    e290:	f803 2f01 	strb.w	r2, [r3, #1]!
    e294:	e7e8      	b.n	e268 <usb_serial_write+0xb4>
}
    e296:	b005      	add	sp, #20
    e298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e29c:	1fff89d0 	.word	0x1fff89d0
    e2a0:	1fff9889 	.word	0x1fff9889
    e2a4:	1fff9888 	.word	0x1fff9888
    e2a8:	1fff9891 	.word	0x1fff9891
    e2ac:	1fff988c 	.word	0x1fff988c
    e2b0:	1fff987a 	.word	0x1fff987a

0000e2b4 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback()
{
    e2b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    e2b6:	4c16      	ldr	r4, [pc, #88]	; (e310 <usb_serial_flush_callback+0x5c>)
    e2b8:	6823      	ldr	r3, [r4, #0]
    e2ba:	9301      	str	r3, [sp, #4]
	if ( tx_noautoflush )
    e2bc:	4b15      	ldr	r3, [pc, #84]	; (e314 <usb_serial_flush_callback+0x60>)
    e2be:	781b      	ldrb	r3, [r3, #0]
    e2c0:	4626      	mov	r6, r4
    e2c2:	f003 07ff 	and.w	r7, r3, #255	; 0xff
    e2c6:	b943      	cbnz	r3, e2da <usb_serial_flush_callback+0x26>
		return;
	if ( tx_packet )
    e2c8:	4d13      	ldr	r5, [pc, #76]	; (e318 <usb_serial_flush_callback+0x64>)
    e2ca:	6829      	ldr	r1, [r5, #0]
    e2cc:	b159      	cbz	r1, e2e6 <usb_serial_flush_callback+0x32>
	{
		tx_packet->len = tx_packet->index;
    e2ce:	884b      	ldrh	r3, [r1, #2]
    e2d0:	800b      	strh	r3, [r1, #0]
		usb_tx( CDC_TX_ENDPOINT, tx_packet );
    e2d2:	2006      	movs	r0, #6
    e2d4:	f7ff f8ea 	bl	d4ac <usb_tx>
		tx_packet = NULL;
    e2d8:	602f      	str	r7, [r5, #0]
		else
		{
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    e2da:	9a01      	ldr	r2, [sp, #4]
    e2dc:	6833      	ldr	r3, [r6, #0]
    e2de:	429a      	cmp	r2, r3
    e2e0:	d109      	bne.n	e2f6 <usb_serial_flush_callback+0x42>
    e2e2:	b003      	add	sp, #12
    e2e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		usb_packet_t *tx = usb_malloc();
    e2e6:	f7ff fd87 	bl	ddf8 <usb_malloc>
		if ( tx )
    e2ea:	4601      	mov	r1, r0
    e2ec:	b158      	cbz	r0, e306 <usb_serial_flush_callback+0x52>
			usb_tx( CDC_TX_ENDPOINT, tx );
    e2ee:	9a01      	ldr	r2, [sp, #4]
    e2f0:	6823      	ldr	r3, [r4, #0]
    e2f2:	429a      	cmp	r2, r3
    e2f4:	d001      	beq.n	e2fa <usb_serial_flush_callback+0x46>
}
    e2f6:	f7f4 fa1b 	bl	2730 <__stack_chk_fail>
			usb_tx( CDC_TX_ENDPOINT, tx );
    e2fa:	2006      	movs	r0, #6
}
    e2fc:	b003      	add	sp, #12
    e2fe:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			usb_tx( CDC_TX_ENDPOINT, tx );
    e302:	f7ff b8d3 	b.w	d4ac <usb_tx>
			usb_cdc_transmit_flush_timer = 1;
    e306:	4b05      	ldr	r3, [pc, #20]	; (e31c <usb_serial_flush_callback+0x68>)
    e308:	2201      	movs	r2, #1
    e30a:	701a      	strb	r2, [r3, #0]
    e30c:	e7e5      	b.n	e2da <usb_serial_flush_callback+0x26>
    e30e:	bf00      	nop
    e310:	1fff89d0 	.word	0x1fff89d0
    e314:	1fff9889 	.word	0x1fff9889
    e318:	1fff988c 	.word	0x1fff988c
    e31c:	1fff9891 	.word	0x1fff9891

0000e320 <cliFunc_clear>:


// ----- CLI Command Functions -----

void cliFunc_clear( char* args)
{
    e320:	b507      	push	{r0, r1, r2, lr}
    e322:	4b07      	ldr	r3, [pc, #28]	; (e340 <cliFunc_clear+0x20>)
    e324:	681a      	ldr	r2, [r3, #0]
    e326:	9201      	str	r2, [sp, #4]
	print("\033[2J\033[H\r"); // Erases the whole screen
    e328:	9a01      	ldr	r2, [sp, #4]
    e32a:	681b      	ldr	r3, [r3, #0]
    e32c:	429a      	cmp	r2, r3
    e32e:	d001      	beq.n	e334 <cliFunc_clear+0x14>
    e330:	f7f4 f9fe 	bl	2730 <__stack_chk_fail>
    e334:	4803      	ldr	r0, [pc, #12]	; (e344 <cliFunc_clear+0x24>)
}
    e336:	b003      	add	sp, #12
    e338:	f85d eb04 	ldr.w	lr, [sp], #4
	print("\033[2J\033[H\r"); // Erases the whole screen
    e33c:	f001 b918 	b.w	f570 <_print>
    e340:	1fff89d0 	.word	0x1fff89d0
    e344:	00016849 	.word	0x00016849

0000e348 <cliFunc_colorTest>:
		CLIHexDebugMode = 1;
	}
}

void cliFunc_colorTest( char* args )
{
    e348:	b513      	push	{r0, r1, r4, lr}
    e34a:	4c09      	ldr	r4, [pc, #36]	; (e370 <cliFunc_colorTest+0x28>)
	print( NL );
    e34c:	4809      	ldr	r0, [pc, #36]	; (e374 <cliFunc_colorTest+0x2c>)
{
    e34e:	6823      	ldr	r3, [r4, #0]
    e350:	9301      	str	r3, [sp, #4]
	print( NL );
    e352:	f001 f90d 	bl	f570 <_print>
	print("\x1b[38;2;255;100;0mTRUECOLOR\x1b[0m");
    e356:	9a01      	ldr	r2, [sp, #4]
    e358:	6823      	ldr	r3, [r4, #0]
    e35a:	429a      	cmp	r2, r3
    e35c:	d001      	beq.n	e362 <cliFunc_colorTest+0x1a>
    e35e:	f7f4 f9e7 	bl	2730 <__stack_chk_fail>
    e362:	4805      	ldr	r0, [pc, #20]	; (e378 <cliFunc_colorTest+0x30>)
}
    e364:	b002      	add	sp, #8
    e366:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print("\x1b[38;2;255;100;0mTRUECOLOR\x1b[0m");
    e36a:	f001 b901 	b.w	f570 <_print>
    e36e:	bf00      	nop
    e370:	1fff89d0 	.word	0x1fff89d0
    e374:	00015df4 	.word	0x00015df4
    e378:	000168af 	.word	0x000168af

0000e37c <cliFunc_reload>:
	info_msg("Rand: ");
	printHex32( rand_value32() );
}

void cliFunc_reload( char* args )
{
    e37c:	b513      	push	{r0, r1, r4, lr}
    e37e:	4c0a      	ldr	r4, [pc, #40]	; (e3a8 <cliFunc_reload+0x2c>)
	if ( flashModeEnabled_define == 0 )
	{
		print( NL );
    e380:	480a      	ldr	r0, [pc, #40]	; (e3ac <cliFunc_reload+0x30>)
{
    e382:	6823      	ldr	r3, [r4, #0]
    e384:	9301      	str	r3, [sp, #4]
		print( NL );
    e386:	f001 f8f3 	bl	f570 <_print>
		warn_print("flashModeEnabled not set, cancelling firmware reload...");
    e38a:	4809      	ldr	r0, [pc, #36]	; (e3b0 <cliFunc_reload+0x34>)
    e38c:	f001 f8f0 	bl	f570 <_print>
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    e390:	9a01      	ldr	r2, [sp, #4]
    e392:	6823      	ldr	r3, [r4, #0]
    e394:	429a      	cmp	r2, r3
    e396:	d001      	beq.n	e39c <cliFunc_reload+0x20>
    e398:	f7f4 f9ca 	bl	2730 <__stack_chk_fail>
    e39c:	4805      	ldr	r0, [pc, #20]	; (e3b4 <cliFunc_reload+0x38>)
		return;
	}

	// Request to output module to be set into firmware reload mode
	Output_firmwareReload();
}
    e39e:	b002      	add	sp, #8
    e3a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		info_msg("Set flashModeEnabled to 1 in your kll configuration.");
    e3a4:	f001 b8e4 	b.w	f570 <_print>
    e3a8:	1fff89d0 	.word	0x1fff89d0
    e3ac:	00015df4 	.word	0x00015df4
    e3b0:	00011f76 	.word	0x00011f76
    e3b4:	00011fc5 	.word	0x00011fc5

0000e3b8 <cliFunc_reset>:

void cliFunc_reset( char* args )
{
    e3b8:	b507      	push	{r0, r1, r2, lr}
    e3ba:	4b07      	ldr	r3, [pc, #28]	; (e3d8 <cliFunc_reset+0x20>)
    e3bc:	681a      	ldr	r2, [r3, #0]
    e3be:	9201      	str	r2, [sp, #4]
	print("\033c"); // Resets the terminal
    e3c0:	9a01      	ldr	r2, [sp, #4]
    e3c2:	681b      	ldr	r3, [r3, #0]
    e3c4:	429a      	cmp	r2, r3
    e3c6:	d001      	beq.n	e3cc <cliFunc_reset+0x14>
    e3c8:	f7f4 f9b2 	bl	2730 <__stack_chk_fail>
    e3cc:	4803      	ldr	r0, [pc, #12]	; (e3dc <cliFunc_reset+0x24>)
}
    e3ce:	b003      	add	sp, #12
    e3d0:	f85d eb04 	ldr.w	lr, [sp], #4
	print("\033c"); // Resets the terminal
    e3d4:	f001 b8cc 	b.w	f570 <_print>
    e3d8:	1fff89d0 	.word	0x1fff89d0
    e3dc:	0001698c 	.word	0x0001698c

0000e3e0 <cliFunc_help>:
{
    e3e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e3e4:	4e2a      	ldr	r6, [pc, #168]	; (e490 <cliFunc_help+0xb0>)
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    e3e6:	f8df 80cc 	ldr.w	r8, [pc, #204]	; e4b4 <cliFunc_help+0xd4>
{
    e3ea:	6833      	ldr	r3, [r6, #0]
    e3ec:	b085      	sub	sp, #20
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    e3ee:	2700      	movs	r7, #0
{
    e3f0:	9303      	str	r3, [sp, #12]
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    e3f2:	4b28      	ldr	r3, [pc, #160]	; (e494 <cliFunc_help+0xb4>)
    e3f4:	781b      	ldrb	r3, [r3, #0]
    e3f6:	b2fc      	uxtb	r4, r7
    e3f8:	42a3      	cmp	r3, r4
    e3fa:	d805      	bhi.n	e408 <cliFunc_help+0x28>
}
    e3fc:	9a03      	ldr	r2, [sp, #12]
    e3fe:	6833      	ldr	r3, [r6, #0]
    e400:	429a      	cmp	r2, r3
    e402:	d042      	beq.n	e48a <cliFunc_help+0xaa>
    e404:	f7f4 f994 	bl	2730 <__stack_chk_fail>
		print( NL "\033[1;32m" );
    e408:	4823      	ldr	r0, [pc, #140]	; (e498 <cliFunc_help+0xb8>)
			dPrintStrs(" \033[35m", CLIDict[dict][cmd].name, "\033[0m");
    e40a:	f8df b0ac 	ldr.w	fp, [pc, #172]	; e4b8 <cliFunc_help+0xd8>
		print( NL "\033[1;32m" );
    e40e:	f001 f8af 	bl	f570 <_print>
		_print( CLIDictNames[dict] ); // This print is requride by AVR (flash)
    e412:	4b22      	ldr	r3, [pc, #136]	; (e49c <cliFunc_help+0xbc>)
    e414:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
    e418:	f001 f8aa 	bl	f570 <_print>
		print( "\033[0m" NL );
    e41c:	4820      	ldr	r0, [pc, #128]	; (e4a0 <cliFunc_help+0xc0>)
    e41e:	f001 f8a7 	bl	f570 <_print>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    e422:	f04f 0900 	mov.w	r9, #0
    e426:	fa5f f389 	uxtb.w	r3, r9
    e42a:	250c      	movs	r5, #12
    e42c:	435d      	muls	r5, r3
    e42e:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
    e432:	5959      	ldr	r1, [r3, r5]
    e434:	b909      	cbnz	r1, e43a <cliFunc_help+0x5a>
    e436:	3701      	adds	r7, #1
    e438:	e7db      	b.n	e3f2 <cliFunc_help+0x12>
			dPrintStrs(" \033[35m", CLIDict[dict][cmd].name, "\033[0m");
    e43a:	4a1a      	ldr	r2, [pc, #104]	; (e4a4 <cliFunc_help+0xc4>)
    e43c:	481a      	ldr	r0, [pc, #104]	; (e4a8 <cliFunc_help+0xc8>)
    e43e:	465b      	mov	r3, fp
    e440:	f001 f872 	bl	f528 <printstrs>
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
    e444:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
    e448:	5958      	ldr	r0, [r3, r5]
    e44a:	f001 f8a3 	bl	f594 <lenStr>
				print(" ");
    e44e:	4a17      	ldr	r2, [pc, #92]	; (e4ac <cliFunc_help+0xcc>)
			uint8_t padLength = CLIEntryTabAlign - lenStr( (char*)CLIDict[dict][cmd].name );
    e450:	f1c0 000d 	rsb	r0, r0, #13
    e454:	fa5f fa80 	uxtb.w	sl, r0
			while ( padLength-- > 0 )
    e458:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
    e45c:	fa5f fa83 	uxtb.w	sl, r3
    e460:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
    e464:	d10b      	bne.n	e47e <cliFunc_help+0x9e>
			_print( CLIDict[dict][cmd].description ); // This print is required by AVR (flash)
    e466:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
    e46a:	441d      	add	r5, r3
    e46c:	f109 0901 	add.w	r9, r9, #1
    e470:	6868      	ldr	r0, [r5, #4]
    e472:	f001 f87d 	bl	f570 <_print>
			print( NL );
    e476:	480e      	ldr	r0, [pc, #56]	; (e4b0 <cliFunc_help+0xd0>)
    e478:	f001 f87a 	bl	f570 <_print>
    e47c:	e7d3      	b.n	e426 <cliFunc_help+0x46>
				print(" ");
    e47e:	4610      	mov	r0, r2
    e480:	9201      	str	r2, [sp, #4]
    e482:	f001 f875 	bl	f570 <_print>
    e486:	9a01      	ldr	r2, [sp, #4]
    e488:	e7e6      	b.n	e458 <cliFunc_help+0x78>
}
    e48a:	b005      	add	sp, #20
    e48c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e490:	1fff89d0 	.word	0x1fff89d0
    e494:	1fff9a03 	.word	0x1fff9a03
    e498:	000168ce 	.word	0x000168ce
    e49c:	1fff9e80 	.word	0x1fff9e80
    e4a0:	000168d8 	.word	0x000168d8
    e4a4:	0001205c 	.word	0x0001205c
    e4a8:	000168df 	.word	0x000168df
    e4ac:	00016f5e 	.word	0x00016f5e
    e4b0:	00015df4 	.word	0x00015df4
    e4b4:	1fff9e54 	.word	0x1fff9e54
    e4b8:	00016521 	.word	0x00016521

0000e4bc <cliFunc_led>:
{
    e4bc:	b507      	push	{r0, r1, r2, lr}
    e4be:	4b09      	ldr	r3, [pc, #36]	; (e4e4 <cliFunc_led+0x28>)
    e4c0:	681a      	ldr	r2, [r3, #0]
    e4c2:	9201      	str	r2, [sp, #4]
	CLILEDState ^= 1 << 1; // Toggle between 0 and 1
    e4c4:	4a08      	ldr	r2, [pc, #32]	; (e4e8 <cliFunc_led+0x2c>)
    e4c6:	7810      	ldrb	r0, [r2, #0]
    e4c8:	f080 0002 	eor.w	r0, r0, #2
    e4cc:	7010      	strb	r0, [r2, #0]
	errorLED( CLILEDState ); // Enable/Disable error LED
    e4ce:	9a01      	ldr	r2, [sp, #4]
    e4d0:	681b      	ldr	r3, [r3, #0]
    e4d2:	429a      	cmp	r2, r3
    e4d4:	d001      	beq.n	e4da <cliFunc_led+0x1e>
    e4d6:	f7f4 f92b 	bl	2730 <__stack_chk_fail>
}
    e4da:	b003      	add	sp, #12
    e4dc:	f85d eb04 	ldr.w	lr, [sp], #4
	errorLED( CLILEDState ); // Enable/Disable error LED
    e4e0:	f000 bffe 	b.w	f4e0 <errorLED>
    e4e4:	1fff89d0 	.word	0x1fff89d0
    e4e8:	1fff9a02 	.word	0x1fff9a02

0000e4ec <cliFunc_restart>:

void cliFunc_restart( char* args )
{
    e4ec:	b507      	push	{r0, r1, r2, lr}
    e4ee:	4b07      	ldr	r3, [pc, #28]	; (e50c <cliFunc_restart+0x20>)
    e4f0:	681a      	ldr	r2, [r3, #0]
    e4f2:	9201      	str	r2, [sp, #4]
	// Trigger an overall software reset
	Output_softReset();
    e4f4:	9a01      	ldr	r2, [sp, #4]
    e4f6:	681b      	ldr	r3, [r3, #0]
    e4f8:	429a      	cmp	r2, r3
    e4fa:	d001      	beq.n	e500 <cliFunc_restart+0x14>
    e4fc:	f7f4 f918 	bl	2730 <__stack_chk_fail>
}
    e500:	b003      	add	sp, #12
    e502:	f85d eb04 	ldr.w	lr, [sp], #4
	Output_softReset();
    e506:	f7fd bc75 	b.w	bdf4 <Output_softReset>
    e50a:	bf00      	nop
    e50c:	1fff89d0 	.word	0x1fff89d0

0000e510 <cliFunc_tick>:

void cliFunc_tick( char* args )
{
    e510:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    e512:	4c15      	ldr	r4, [pc, #84]	; (e568 <cliFunc_tick+0x58>)
	print( NL );
    e514:	4815      	ldr	r0, [pc, #84]	; (e56c <cliFunc_tick+0x5c>)
{
    e516:	6823      	ldr	r3, [r4, #0]
    e518:	9303      	str	r3, [sp, #12]
	print( NL );
    e51a:	f001 f829 	bl	f570 <_print>

	// Get current time
	Time now = Time_now();
    e51e:	a801      	add	r0, sp, #4
    e520:	f7f4 fbf4 	bl	2d0c <Time_now>

	// Display <systick>:<cycleticks since systick>
	info_msg("ns per cycletick: ");
    e524:	4812      	ldr	r0, [pc, #72]	; (e570 <cliFunc_tick+0x60>)
    e526:	f001 f823 	bl	f570 <_print>
	print( Time_ticksPer_ns_str );
    e52a:	4b12      	ldr	r3, [pc, #72]	; (e574 <cliFunc_tick+0x64>)
    e52c:	6818      	ldr	r0, [r3, #0]
    e52e:	f001 f81f 	bl	f570 <_print>
	print( NL );
    e532:	480e      	ldr	r0, [pc, #56]	; (e56c <cliFunc_tick+0x5c>)
    e534:	f001 f81c 	bl	f570 <_print>
	info_print("<systick ms>:<cycleticks since systick>");
    e538:	480f      	ldr	r0, [pc, #60]	; (e578 <cliFunc_tick+0x68>)
    e53a:	f001 f819 	bl	f570 <_print>
	printInt32( now.ms );
    e53e:	9801      	ldr	r0, [sp, #4]
    e540:	f001 f8ec 	bl	f71c <printInt32>
	print(":");
    e544:	480d      	ldr	r0, [pc, #52]	; (e57c <cliFunc_tick+0x6c>)
    e546:	f001 f813 	bl	f570 <_print>
	printInt32( now.ticks );
    e54a:	9802      	ldr	r0, [sp, #8]
    e54c:	f001 f8e6 	bl	f71c <printInt32>
	print( NL );
    e550:	9a03      	ldr	r2, [sp, #12]
    e552:	6823      	ldr	r3, [r4, #0]
    e554:	429a      	cmp	r2, r3
    e556:	d001      	beq.n	e55c <cliFunc_tick+0x4c>
    e558:	f7f4 f8ea 	bl	2730 <__stack_chk_fail>
    e55c:	4803      	ldr	r0, [pc, #12]	; (e56c <cliFunc_tick+0x5c>)
}
    e55e:	b004      	add	sp, #16
    e560:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print( NL );
    e564:	f001 b804 	b.w	f570 <_print>
    e568:	1fff89d0 	.word	0x1fff89d0
    e56c:	00015df4 	.word	0x00015df4
    e570:	0001698f 	.word	0x0001698f
    e574:	1fff89d4 	.word	0x1fff89d4
    e578:	000169b4 	.word	0x000169b4
    e57c:	00014d02 	.word	0x00014d02

0000e580 <cliFunc_cliDebug>:
{
    e580:	b537      	push	{r0, r1, r2, r4, r5, lr}
    e582:	4c0e      	ldr	r4, [pc, #56]	; (e5bc <cliFunc_cliDebug+0x3c>)
	if ( CLIHexDebugMode )
    e584:	4d0e      	ldr	r5, [pc, #56]	; (e5c0 <cliFunc_cliDebug+0x40>)
{
    e586:	6822      	ldr	r2, [r4, #0]
    e588:	9201      	str	r2, [sp, #4]
	if ( CLIHexDebugMode )
    e58a:	782a      	ldrb	r2, [r5, #0]
		print( NL );
    e58c:	480d      	ldr	r0, [pc, #52]	; (e5c4 <cliFunc_cliDebug+0x44>)
	if ( CLIHexDebugMode )
    e58e:	b162      	cbz	r2, e5aa <cliFunc_cliDebug+0x2a>
		print( NL );
    e590:	f000 ffee 	bl	f570 <_print>
		info_print("Hex debug mode disabled...");
    e594:	480c      	ldr	r0, [pc, #48]	; (e5c8 <cliFunc_cliDebug+0x48>)
    e596:	f000 ffeb 	bl	f570 <_print>
		CLIHexDebugMode = 0;
    e59a:	2300      	movs	r3, #0
}
    e59c:	9a01      	ldr	r2, [sp, #4]
		CLIHexDebugMode = 1;
    e59e:	702b      	strb	r3, [r5, #0]
}
    e5a0:	6823      	ldr	r3, [r4, #0]
    e5a2:	429a      	cmp	r2, r3
    e5a4:	d008      	beq.n	e5b8 <cliFunc_cliDebug+0x38>
    e5a6:	f7f4 f8c3 	bl	2730 <__stack_chk_fail>
		print( NL );
    e5aa:	f000 ffe1 	bl	f570 <_print>
		info_print("Hex debug mode enabled...");
    e5ae:	4807      	ldr	r0, [pc, #28]	; (e5cc <cliFunc_cliDebug+0x4c>)
    e5b0:	f000 ffde 	bl	f570 <_print>
		CLIHexDebugMode = 1;
    e5b4:	2301      	movs	r3, #1
    e5b6:	e7f1      	b.n	e59c <cliFunc_cliDebug+0x1c>
}
    e5b8:	b003      	add	sp, #12
    e5ba:	bd30      	pop	{r4, r5, pc}
    e5bc:	1fff89d0 	.word	0x1fff89d0
    e5c0:	1fff9a00 	.word	0x1fff9a00
    e5c4:	00015df4 	.word	0x00015df4
    e5c8:	00016852 	.word	0x00016852
    e5cc:	00016881 	.word	0x00016881

0000e5d0 <cliFunc_rand>:
{
    e5d0:	b513      	push	{r0, r1, r4, lr}
    e5d2:	4c12      	ldr	r4, [pc, #72]	; (e61c <cliFunc_rand+0x4c>)
	print( NL );
    e5d4:	4812      	ldr	r0, [pc, #72]	; (e620 <cliFunc_rand+0x50>)
{
    e5d6:	6823      	ldr	r3, [r4, #0]
    e5d8:	9301      	str	r3, [sp, #4]
	print( NL );
    e5da:	f000 ffc9 	bl	f570 <_print>
	if ( !rand_available() )
    e5de:	f7f4 f9df 	bl	29a0 <rand_available>
    e5e2:	b958      	cbnz	r0, e5fc <cliFunc_rand+0x2c>
		warn_print("No entropy available!");
    e5e4:	9a01      	ldr	r2, [sp, #4]
    e5e6:	6823      	ldr	r3, [r4, #0]
    e5e8:	429a      	cmp	r2, r3
    e5ea:	d001      	beq.n	e5f0 <cliFunc_rand+0x20>
	printHex32( rand_value32() );
    e5ec:	f7f4 f8a0 	bl	2730 <__stack_chk_fail>
		warn_print("No entropy available!");
    e5f0:	480c      	ldr	r0, [pc, #48]	; (e624 <cliFunc_rand+0x54>)
}
    e5f2:	b002      	add	sp, #8
    e5f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		warn_print("No entropy available!");
    e5f8:	f000 bfba 	b.w	f570 <_print>
	info_msg("Rand: ");
    e5fc:	480a      	ldr	r0, [pc, #40]	; (e628 <cliFunc_rand+0x58>)
    e5fe:	f000 ffb7 	bl	f570 <_print>
	printHex32( rand_value32() );
    e602:	f7f4 f98f 	bl	2924 <rand_value32>
    e606:	9a01      	ldr	r2, [sp, #4]
    e608:	6823      	ldr	r3, [r4, #0]
    e60a:	429a      	cmp	r2, r3
    e60c:	d1ee      	bne.n	e5ec <cliFunc_rand+0x1c>
    e60e:	2101      	movs	r1, #1
}
    e610:	b002      	add	sp, #8
    e612:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	printHex32( rand_value32() );
    e616:	f001 b923 	b.w	f860 <printHex32_op>
    e61a:	bf00      	nop
    e61c:	1fff89d0 	.word	0x1fff89d0
    e620:	00015df4 	.word	0x00015df4
    e624:	00016946 	.word	0x00016946
    e628:	00016973 	.word	0x00016973

0000e62c <ChipVersion_cpuid_partno>:
// ----- Function Declarations -----

// ----- Functions -----
//
const char *ChipVersion_cpuid_partno()
{
    e62c:	b507      	push	{r0, r1, r2, lr}
    e62e:	4a14      	ldr	r2, [pc, #80]	; (e680 <ChipVersion_cpuid_partno+0x54>)
    e630:	6813      	ldr	r3, [r2, #0]
    e632:	9301      	str	r3, [sp, #4]
	switch ( SCB_CPUID_PARTNO )
    e634:	4b13      	ldr	r3, [pc, #76]	; (e684 <ChipVersion_cpuid_partno+0x58>)
    e636:	681b      	ldr	r3, [r3, #0]
    e638:	f640 4123 	movw	r1, #3107	; 0xc23
    e63c:	f3c3 130b 	ubfx	r3, r3, #4, #12
    e640:	428b      	cmp	r3, r1
    e642:	d00e      	beq.n	e662 <ChipVersion_cpuid_partno+0x36>
    e644:	d804      	bhi.n	e650 <ChipVersion_cpuid_partno+0x24>
    e646:	f5b3 6f42 	cmp.w	r3, #3104	; 0xc20
    e64a:	d013      	beq.n	e674 <ChipVersion_cpuid_partno+0x48>
	case 0xC60:
		return "Cortex-M0+";
	case 0xC24:
		return "Cortex-M4";
	default:
		return "--";
    e64c:	480e      	ldr	r0, [pc, #56]	; (e688 <ChipVersion_cpuid_partno+0x5c>)
    e64e:	e009      	b.n	e664 <ChipVersion_cpuid_partno+0x38>
	switch ( SCB_CPUID_PARTNO )
    e650:	f640 4124 	movw	r1, #3108	; 0xc24
    e654:	428b      	cmp	r3, r1
    e656:	d00b      	beq.n	e670 <ChipVersion_cpuid_partno+0x44>
    e658:	f5b3 6f46 	cmp.w	r3, #3168	; 0xc60
    e65c:	d1f6      	bne.n	e64c <ChipVersion_cpuid_partno+0x20>
		return "Cortex-M0+";
    e65e:	480b      	ldr	r0, [pc, #44]	; (e68c <ChipVersion_cpuid_partno+0x60>)
    e660:	e000      	b.n	e664 <ChipVersion_cpuid_partno+0x38>
		return "Cortex-M3";
    e662:	480b      	ldr	r0, [pc, #44]	; (e690 <ChipVersion_cpuid_partno+0x64>)
	}
}
    e664:	9901      	ldr	r1, [sp, #4]
    e666:	6813      	ldr	r3, [r2, #0]
    e668:	4299      	cmp	r1, r3
    e66a:	d005      	beq.n	e678 <ChipVersion_cpuid_partno+0x4c>
    e66c:	f7f4 f860 	bl	2730 <__stack_chk_fail>
		return "Cortex-M4";
    e670:	4808      	ldr	r0, [pc, #32]	; (e694 <ChipVersion_cpuid_partno+0x68>)
    e672:	e7f7      	b.n	e664 <ChipVersion_cpuid_partno+0x38>
		return "Cortex-M0";
    e674:	4808      	ldr	r0, [pc, #32]	; (e698 <ChipVersion_cpuid_partno+0x6c>)
    e676:	e7f5      	b.n	e664 <ChipVersion_cpuid_partno+0x38>
}
    e678:	b003      	add	sp, #12
    e67a:	f85d fb04 	ldr.w	pc, [sp], #4
    e67e:	bf00      	nop
    e680:	1fff89d0 	.word	0x1fff89d0
    e684:	e000ed00 	.word	0xe000ed00
    e688:	00016641 	.word	0x00016641
    e68c:	0001662c 	.word	0x0001662c
    e690:	00016622 	.word	0x00016622
    e694:	00016637 	.word	0x00016637
    e698:	00016618 	.word	0x00016618

0000e69c <ChipVersion_cpuid_implementor>:

const char *ChipVersion_cpuid_implementor()
{
    e69c:	b507      	push	{r0, r1, r2, lr}
    e69e:	4b0a      	ldr	r3, [pc, #40]	; (e6c8 <ChipVersion_cpuid_implementor+0x2c>)
	case 0x41:
		return "ARM";
	default:
		return "--";
	}
}
    e6a0:	490a      	ldr	r1, [pc, #40]	; (e6cc <ChipVersion_cpuid_implementor+0x30>)
{
    e6a2:	681a      	ldr	r2, [r3, #0]
    e6a4:	9201      	str	r2, [sp, #4]
	switch ( SCB_CPUID_IMPLEMENTOR )
    e6a6:	4a0a      	ldr	r2, [pc, #40]	; (e6d0 <ChipVersion_cpuid_implementor+0x34>)
    e6a8:	78d0      	ldrb	r0, [r2, #3]
}
    e6aa:	4a0a      	ldr	r2, [pc, #40]	; (e6d4 <ChipVersion_cpuid_implementor+0x38>)
    e6ac:	2841      	cmp	r0, #65	; 0x41
    e6ae:	bf0c      	ite	eq
    e6b0:	4608      	moveq	r0, r1
    e6b2:	4610      	movne	r0, r2
    e6b4:	9a01      	ldr	r2, [sp, #4]
    e6b6:	681b      	ldr	r3, [r3, #0]
    e6b8:	429a      	cmp	r2, r3
    e6ba:	d001      	beq.n	e6c0 <ChipVersion_cpuid_implementor+0x24>
    e6bc:	f7f4 f838 	bl	2730 <__stack_chk_fail>
    e6c0:	b003      	add	sp, #12
    e6c2:	f85d fb04 	ldr.w	pc, [sp], #4
    e6c6:	bf00      	nop
    e6c8:	1fff89d0 	.word	0x1fff89d0
    e6cc:	00016614 	.word	0x00016614
    e6d0:	e000ed00 	.word	0xe000ed00
    e6d4:	00016641 	.word	0x00016641

0000e6d8 <ChipVersion_lookup>:

// Attempts to detect the chip part number using registers only
// Not perfect, but is quite useful
// Returns -- if unknown
const char *ChipVersion_lookup()
{
    e6d8:	b507      	push	{r0, r1, r2, lr}
    e6da:	4a21      	ldr	r2, [pc, #132]	; (e760 <ChipVersion_lookup+0x88>)
	// The first m stands for production, the other option is p (unqualified sample)

	//uint8_t family = SIM_SDID_FAMID; // e.g. k20
	// TODO e.g. d (Cortex-M4)
	//uint8_t flex = SIM_FCFG1_NVMSIZE ? 1 : 0; // e.g. x (Flex memory)
	uint16_t pflash = ChipVersion_pflashsize[ SIM_FCFG1_PFSIZE ]; // e.g. 256 (256 kB)
    e6dc:	4921      	ldr	r1, [pc, #132]	; (e764 <ChipVersion_lookup+0x8c>)
{
    e6de:	6813      	ldr	r3, [r2, #0]
    e6e0:	9301      	str	r3, [sp, #4]
	uint16_t pflash = ChipVersion_pflashsize[ SIM_FCFG1_PFSIZE ]; // e.g. 256 (256 kB)
    e6e2:	4b21      	ldr	r3, [pc, #132]	; (e768 <ChipVersion_lookup+0x90>)
    e6e4:	78db      	ldrb	r3, [r3, #3]
    e6e6:	f003 030f 	and.w	r3, r3, #15
    e6ea:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
	//uint8_t pincount = SIM_SDID_PINID; // e.g. LH (64 LQFP)
	// TODO e.g. 7 (70 MHz)

	// Using openocd method of using the SDID mask
	// Not perfect, but generally ok, also using the pincount
	if ( SIM_SDID & 0x00000095 )
    e6ee:	491f      	ldr	r1, [pc, #124]	; (e76c <ChipVersion_lookup+0x94>)
    e6f0:	6808      	ldr	r0, [r1, #0]
    e6f2:	f010 0f95 	tst.w	r0, #149	; 0x95
    e6f6:	d01f      	beq.n	e738 <ChipVersion_lookup+0x60>
	{
		switch ( pflash )
    e6f8:	2b80      	cmp	r3, #128	; 0x80
    e6fa:	d004      	beq.n	e706 <ChipVersion_lookup+0x2e>
    e6fc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
    e700:	d010      	beq.n	e724 <ChipVersion_lookup+0x4c>
				return "mk20dx256vmc7";
			default:
				return "mk20dx256XXXX";
			}
		default:
			return "mk20dxXXXvlh7";
    e702:	481b      	ldr	r0, [pc, #108]	; (e770 <ChipVersion_lookup+0x98>)
    e704:	e008      	b.n	e718 <ChipVersion_lookup+0x40>
			switch ( SIM_SDID_PINID )
    e706:	f000 030f 	and.w	r3, r0, #15
    e70a:	2b04      	cmp	r3, #4
    e70c:	d01f      	beq.n	e74e <ChipVersion_lookup+0x76>
				return "mk20dx128XXXX";
    e70e:	4819      	ldr	r0, [pc, #100]	; (e774 <ChipVersion_lookup+0x9c>)
    e710:	4919      	ldr	r1, [pc, #100]	; (e778 <ChipVersion_lookup+0xa0>)
    e712:	2b05      	cmp	r3, #5
    e714:	bf18      	it	ne
    e716:	4608      	movne	r0, r1
			return "mk22fxXXXavlh12";
		}
	}

	return "--";
}
    e718:	9901      	ldr	r1, [sp, #4]
    e71a:	6813      	ldr	r3, [r2, #0]
    e71c:	4299      	cmp	r1, r3
    e71e:	d01c      	beq.n	e75a <ChipVersion_lookup+0x82>
    e720:	f7f4 f806 	bl	2730 <__stack_chk_fail>
			switch ( SIM_SDID_PINID )
    e724:	f000 030f 	and.w	r3, r0, #15
    e728:	2b05      	cmp	r3, #5
    e72a:	d012      	beq.n	e752 <ChipVersion_lookup+0x7a>
				return "mk20dx256XXXX";
    e72c:	4813      	ldr	r0, [pc, #76]	; (e77c <ChipVersion_lookup+0xa4>)
    e72e:	4914      	ldr	r1, [pc, #80]	; (e780 <ChipVersion_lookup+0xa8>)
    e730:	2b09      	cmp	r3, #9
    e732:	bf18      	it	ne
    e734:	4608      	movne	r0, r1
    e736:	e7ef      	b.n	e718 <ChipVersion_lookup+0x40>
	else if ( SIM_SDID & 0x00000315 )
    e738:	f240 3115 	movw	r1, #789	; 0x315
    e73c:	4208      	tst	r0, r1
    e73e:	d00a      	beq.n	e756 <ChipVersion_lookup+0x7e>
			return "mk22fxXXXavlh12";
    e740:	4810      	ldr	r0, [pc, #64]	; (e784 <ChipVersion_lookup+0xac>)
    e742:	4911      	ldr	r1, [pc, #68]	; (e788 <ChipVersion_lookup+0xb0>)
    e744:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    e748:	bf18      	it	ne
    e74a:	4608      	movne	r0, r1
    e74c:	e7e4      	b.n	e718 <ChipVersion_lookup+0x40>
				return "mk20dx128vlf5";
    e74e:	480f      	ldr	r0, [pc, #60]	; (e78c <ChipVersion_lookup+0xb4>)
    e750:	e7e2      	b.n	e718 <ChipVersion_lookup+0x40>
				return "mk20dx256vlh7";
    e752:	480f      	ldr	r0, [pc, #60]	; (e790 <ChipVersion_lookup+0xb8>)
    e754:	e7e0      	b.n	e718 <ChipVersion_lookup+0x40>
	return "--";
    e756:	480f      	ldr	r0, [pc, #60]	; (e794 <ChipVersion_lookup+0xbc>)
    e758:	e7de      	b.n	e718 <ChipVersion_lookup+0x40>
}
    e75a:	b003      	add	sp, #12
    e75c:	f85d fb04 	ldr.w	pc, [sp], #4
    e760:	1fff89d0 	.word	0x1fff89d0
    e764:	00016704 	.word	0x00016704
    e768:	4004804c 	.word	0x4004804c
    e76c:	40048024 	.word	0x40048024
    e770:	000166b8 	.word	0x000166b8
    e774:	00016672 	.word	0x00016672
    e778:	00016680 	.word	0x00016680
    e77c:	0001669c 	.word	0x0001669c
    e780:	000166aa 	.word	0x000166aa
    e784:	000166c6 	.word	0x000166c6
    e788:	000166d6 	.word	0x000166d6
    e78c:	00016664 	.word	0x00016664
    e790:	0001668e 	.word	0x0001668e
    e794:	00016641 	.word	0x00016641

0000e798 <cliFunc_version>:

void cliFunc_version( char* args )
{
    e798:	b537      	push	{r0, r1, r2, r4, r5, lr}
    e79a:	4d9b      	ldr	r5, [pc, #620]	; (ea08 <cliFunc_version+0x270>)
	print( NL );
    e79c:	489b      	ldr	r0, [pc, #620]	; (ea0c <cliFunc_version+0x274>)
{
    e79e:	682b      	ldr	r3, [r5, #0]
    e7a0:	9301      	str	r3, [sp, #4]
	print( NL );
    e7a2:	f000 fee5 	bl	f570 <_print>
	print( " \033[1mRevision:\033[0m      " CLI_Revision          NL );
    e7a6:	489a      	ldr	r0, [pc, #616]	; (ea10 <cliFunc_version+0x278>)
	print( " \033[1mCPU Detected:\033[0m  " );
	print( ChipVersion_lookup() );
	print( NL);

	print( " \033[1mCPU Id:\033[0m        " );
	printHex32( SCB_CPUID );
    e7a8:	4c9a      	ldr	r4, [pc, #616]	; (ea14 <cliFunc_version+0x27c>)
	print( " \033[1mRevision:\033[0m      " CLI_Revision          NL );
    e7aa:	f000 fee1 	bl	f570 <_print>
	print( " \033[1mRevision #:\033[0m    " CLI_RevisionNumberStr NL );
    e7ae:	489a      	ldr	r0, [pc, #616]	; (ea18 <cliFunc_version+0x280>)
    e7b0:	f000 fede 	bl	f570 <_print>
	print( " \033[1mVersion:\033[0m       " CLI_Version " (+" );
    e7b4:	4899      	ldr	r0, [pc, #612]	; (ea1c <cliFunc_version+0x284>)
    e7b6:	f000 fedb 	bl	f570 <_print>
	printInt16( CLI_RevisionNumber - CLI_VersionRevNumber );
    e7ba:	2000      	movs	r0, #0
    e7bc:	f000 ff78 	bl	f6b0 <printInt16>
	print( ":" CLI_VersionRevNumberStr ")" NL );
    e7c0:	4897      	ldr	r0, [pc, #604]	; (ea20 <cliFunc_version+0x288>)
    e7c2:	f000 fed5 	bl	f570 <_print>
	print( " \033[1mBranch:\033[0m        " CLI_Branch            NL );
    e7c6:	4897      	ldr	r0, [pc, #604]	; (ea24 <cliFunc_version+0x28c>)
    e7c8:	f000 fed2 	bl	f570 <_print>
	print( " \033[1mTree Status:\033[0m   " CLI_ModifiedStatus CLI_ModifiedFiles NL );
    e7cc:	4896      	ldr	r0, [pc, #600]	; (ea28 <cliFunc_version+0x290>)
    e7ce:	f000 fecf 	bl	f570 <_print>
	print( " \033[1mRepo Origin:\033[0m   " CLI_RepoOrigin        NL );
    e7d2:	4896      	ldr	r0, [pc, #600]	; (ea2c <cliFunc_version+0x294>)
    e7d4:	f000 fecc 	bl	f570 <_print>
	print( " \033[1mCommit Date:\033[0m   " CLI_CommitDate        NL );
    e7d8:	4895      	ldr	r0, [pc, #596]	; (ea30 <cliFunc_version+0x298>)
    e7da:	f000 fec9 	bl	f570 <_print>
	print( " \033[1mCommit Author:\033[0m " CLI_CommitAuthor      NL );
    e7de:	4895      	ldr	r0, [pc, #596]	; (ea34 <cliFunc_version+0x29c>)
    e7e0:	f000 fec6 	bl	f570 <_print>
	print( " \033[1mBuild Date:\033[0m    " CLI_BuildDate         NL );
    e7e4:	4894      	ldr	r0, [pc, #592]	; (ea38 <cliFunc_version+0x2a0>)
    e7e6:	f000 fec3 	bl	f570 <_print>
	print( " \033[1mBuild OS:\033[0m      " CLI_BuildOS           NL );
    e7ea:	4894      	ldr	r0, [pc, #592]	; (ea3c <cliFunc_version+0x2a4>)
    e7ec:	f000 fec0 	bl	f570 <_print>
	print( " \033[1mCompiler:\033[0m      " CLI_BuildCompiler     NL );
    e7f0:	4893      	ldr	r0, [pc, #588]	; (ea40 <cliFunc_version+0x2a8>)
    e7f2:	f000 febd 	bl	f570 <_print>
	print( " \033[1mArchitecture:\033[0m  " CLI_Arch              NL );
    e7f6:	4893      	ldr	r0, [pc, #588]	; (ea44 <cliFunc_version+0x2ac>)
    e7f8:	f000 feba 	bl	f570 <_print>
	print( " \033[1mChip Compiled:\033[0m " CLI_ChipShort " (" CLI_Chip ")" NL );
    e7fc:	4892      	ldr	r0, [pc, #584]	; (ea48 <cliFunc_version+0x2b0>)
    e7fe:	f000 feb7 	bl	f570 <_print>
	print( " \033[1mCPU:\033[0m           " CLI_CPU               NL );
    e802:	4892      	ldr	r0, [pc, #584]	; (ea4c <cliFunc_version+0x2b4>)
    e804:	f000 feb4 	bl	f570 <_print>
	print( " \033[1mDevice:\033[0m        " CLI_Device            NL );
    e808:	4891      	ldr	r0, [pc, #580]	; (ea50 <cliFunc_version+0x2b8>)
    e80a:	f000 feb1 	bl	f570 <_print>
	print( " \033[1mModules:\033[0m       " CLI_Modules           NL );
    e80e:	4891      	ldr	r0, [pc, #580]	; (ea54 <cliFunc_version+0x2bc>)
    e810:	f000 feae 	bl	f570 <_print>
	print( NL );
    e814:	487d      	ldr	r0, [pc, #500]	; (ea0c <cliFunc_version+0x274>)
    e816:	f000 feab 	bl	f570 <_print>
	print( " \033[1mCPU Detected:\033[0m  " );
    e81a:	488f      	ldr	r0, [pc, #572]	; (ea58 <cliFunc_version+0x2c0>)
    e81c:	f000 fea8 	bl	f570 <_print>
	print( ChipVersion_lookup() );
    e820:	f7ff ff5a 	bl	e6d8 <ChipVersion_lookup>
    e824:	f000 fea4 	bl	f570 <_print>
	print( NL);
    e828:	4878      	ldr	r0, [pc, #480]	; (ea0c <cliFunc_version+0x274>)
    e82a:	f000 fea1 	bl	f570 <_print>
	print( " \033[1mCPU Id:\033[0m        " );
    e82e:	488b      	ldr	r0, [pc, #556]	; (ea5c <cliFunc_version+0x2c4>)
    e830:	f000 fe9e 	bl	f570 <_print>
	printHex32( SCB_CPUID );
    e834:	2101      	movs	r1, #1
    e836:	6820      	ldr	r0, [r4, #0]
    e838:	f001 f812 	bl	f860 <printHex32_op>
	print( NL "  (Implementor:");
    e83c:	4888      	ldr	r0, [pc, #544]	; (ea60 <cliFunc_version+0x2c8>)
    e83e:	f000 fe97 	bl	f570 <_print>
	print( ChipVersion_cpuid_implementor() );
    e842:	f7ff ff2b 	bl	e69c <ChipVersion_cpuid_implementor>
    e846:	f000 fe93 	bl	f570 <_print>
	print( ":" );
    e84a:	4886      	ldr	r0, [pc, #536]	; (ea64 <cliFunc_version+0x2cc>)
    e84c:	f000 fe90 	bl	f570 <_print>
	printHex32( SCB_CPUID_IMPLEMENTOR );
    e850:	2101      	movs	r1, #1
    e852:	78e0      	ldrb	r0, [r4, #3]
    e854:	f001 f804 	bl	f860 <printHex32_op>
	print( ")(Variant:" );
    e858:	4883      	ldr	r0, [pc, #524]	; (ea68 <cliFunc_version+0x2d0>)
    e85a:	f000 fe89 	bl	f570 <_print>
	printHex32( SCB_CPUID_VARIANT );
    e85e:	6820      	ldr	r0, [r4, #0]
    e860:	2101      	movs	r1, #1
    e862:	f3c0 5003 	ubfx	r0, r0, #20, #4
    e866:	f000 fffb 	bl	f860 <printHex32_op>
	print( ")(Arch:" );
    e86a:	4880      	ldr	r0, [pc, #512]	; (ea6c <cliFunc_version+0x2d4>)
    e86c:	f000 fe80 	bl	f570 <_print>
	printHex32( SCB_CPUID_ARCH );
    e870:	8860      	ldrh	r0, [r4, #2]
    e872:	2101      	movs	r1, #1
    e874:	f000 000f 	and.w	r0, r0, #15
    e878:	f000 fff2 	bl	f860 <printHex32_op>
	print( ")(PartNo:" );
    e87c:	487c      	ldr	r0, [pc, #496]	; (ea70 <cliFunc_version+0x2d8>)
    e87e:	f000 fe77 	bl	f570 <_print>
	print( ChipVersion_cpuid_partno() );
    e882:	f7ff fed3 	bl	e62c <ChipVersion_cpuid_partno>
    e886:	f000 fe73 	bl	f570 <_print>
	print( ":" );
    e88a:	4876      	ldr	r0, [pc, #472]	; (ea64 <cliFunc_version+0x2cc>)
    e88c:	f000 fe70 	bl	f570 <_print>
	printHex32( SCB_CPUID_PARTNO );
    e890:	6820      	ldr	r0, [r4, #0]
    e892:	2101      	movs	r1, #1
    e894:	f3c0 100b 	ubfx	r0, r0, #4, #12
    e898:	f000 ffe2 	bl	f860 <printHex32_op>
	print( ")(Revision:" );
    e89c:	4875      	ldr	r0, [pc, #468]	; (ea74 <cliFunc_version+0x2dc>)
    e89e:	f000 fe67 	bl	f570 <_print>
	printHex32( SCB_CPUID_REVISION );
    e8a2:	6820      	ldr	r0, [r4, #0]
	print( ")" NL );

	print( " \033[1mDevice Id:\033[0m     " );
	printHex32( SIM_SDID );
    e8a4:	4c74      	ldr	r4, [pc, #464]	; (ea78 <cliFunc_version+0x2e0>)
	printHex32( SCB_CPUID_REVISION );
    e8a6:	2101      	movs	r1, #1
    e8a8:	f000 000f 	and.w	r0, r0, #15
    e8ac:	f000 ffd8 	bl	f860 <printHex32_op>
	print( ")" NL );
    e8b0:	4872      	ldr	r0, [pc, #456]	; (ea7c <cliFunc_version+0x2e4>)
    e8b2:	f000 fe5d 	bl	f570 <_print>
	print( " \033[1mDevice Id:\033[0m     " );
    e8b6:	4872      	ldr	r0, [pc, #456]	; (ea80 <cliFunc_version+0x2e8>)
    e8b8:	f000 fe5a 	bl	f570 <_print>
	printHex32( SIM_SDID );
    e8bc:	2101      	movs	r1, #1
    e8be:	6820      	ldr	r0, [r4, #0]
    e8c0:	f000 ffce 	bl	f860 <printHex32_op>
	print( NL "  (Pincount:");
    e8c4:	486f      	ldr	r0, [pc, #444]	; (ea84 <cliFunc_version+0x2ec>)
    e8c6:	f000 fe53 	bl	f570 <_print>
	print( ChipVersion_pincount[ SIM_SDID_PINID ] );
    e8ca:	6823      	ldr	r3, [r4, #0]
    e8cc:	4a6e      	ldr	r2, [pc, #440]	; (ea88 <cliFunc_version+0x2f0>)
    e8ce:	f003 030f 	and.w	r3, r3, #15
    e8d2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    e8d6:	f000 fe4b 	bl	f570 <_print>
	print( ":" );
    e8da:	4862      	ldr	r0, [pc, #392]	; (ea64 <cliFunc_version+0x2cc>)
    e8dc:	f000 fe48 	bl	f570 <_print>
	printHex32( SIM_SDID_PINID );
    e8e0:	6820      	ldr	r0, [r4, #0]
    e8e2:	2101      	movs	r1, #1
    e8e4:	f000 000f 	and.w	r0, r0, #15
    e8e8:	f000 ffba 	bl	f860 <printHex32_op>
	print( ")(Family:" );
    e8ec:	4867      	ldr	r0, [pc, #412]	; (ea8c <cliFunc_version+0x2f4>)
    e8ee:	f000 fe3f 	bl	f570 <_print>
	print( ChipVersion_familyid[ SIM_SDID_FAMID ] );
    e8f2:	6823      	ldr	r3, [r4, #0]
    e8f4:	4a66      	ldr	r2, [pc, #408]	; (ea90 <cliFunc_version+0x2f8>)
    e8f6:	f3c3 1302 	ubfx	r3, r3, #4, #3
    e8fa:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    e8fe:	f000 fe37 	bl	f570 <_print>
	print( ":" );
    e902:	4858      	ldr	r0, [pc, #352]	; (ea64 <cliFunc_version+0x2cc>)
    e904:	f000 fe34 	bl	f570 <_print>
	printHex32( SIM_SDID_FAMID );
    e908:	6820      	ldr	r0, [r4, #0]
    e90a:	2101      	movs	r1, #1
    e90c:	f3c0 1002 	ubfx	r0, r0, #4, #3
    e910:	f000 ffa6 	bl	f860 <printHex32_op>
	print( ")(Die:" );
    e914:	485f      	ldr	r0, [pc, #380]	; (ea94 <cliFunc_version+0x2fc>)
    e916:	f000 fe2b 	bl	f570 <_print>
	printHex32( SIM_SDID_DIEID );
    e91a:	6820      	ldr	r0, [r4, #0]
    e91c:	2101      	movs	r1, #1
    e91e:	f3c0 10c4 	ubfx	r0, r0, #7, #5
    e922:	f000 ff9d 	bl	f860 <printHex32_op>
	print( ")(Rev:" );
    e926:	485c      	ldr	r0, [pc, #368]	; (ea98 <cliFunc_version+0x300>)
    e928:	f000 fe22 	bl	f570 <_print>
	printHex32( SIM_SDID_REVID );
    e92c:	6820      	ldr	r0, [r4, #0]
    e92e:	2101      	movs	r1, #1
    e930:	f3c0 3003 	ubfx	r0, r0, #12, #4
    e934:	f000 ff94 	bl	f860 <printHex32_op>
	print( ")" NL );
    e938:	4850      	ldr	r0, [pc, #320]	; (ea7c <cliFunc_version+0x2e4>)
    e93a:	f000 fe19 	bl	f570 <_print>

	print( " \033[1mFlash Cfg:\033[0m     " );
    e93e:	4857      	ldr	r0, [pc, #348]	; (ea9c <cliFunc_version+0x304>)
    e940:	f000 fe16 	bl	f570 <_print>
	printHex32( SIM_FCFG1 & 0xFFFFFFF0 );
    e944:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    e946:	2101      	movs	r1, #1
    e948:	f020 000f 	bic.w	r0, r0, #15
    e94c:	f000 ff88 	bl	f860 <printHex32_op>
	print( NL "  (FlexNVM:" );
    e950:	4853      	ldr	r0, [pc, #332]	; (eaa0 <cliFunc_version+0x308>)
    e952:	f000 fe0d 	bl	f570 <_print>
	printInt16( ChipVersion_nvmsize[ SIM_FCFG1_NVMSIZE ] );
    e956:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e958:	4a52      	ldr	r2, [pc, #328]	; (eaa4 <cliFunc_version+0x30c>)
    e95a:	0f1b      	lsrs	r3, r3, #28
    e95c:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    e960:	f000 fea6 	bl	f6b0 <printInt16>
	print( "kB)(PFlash:" );
    e964:	4850      	ldr	r0, [pc, #320]	; (eaa8 <cliFunc_version+0x310>)
    e966:	f000 fe03 	bl	f570 <_print>
	printInt16( ChipVersion_pflashsize[ SIM_FCFG1_PFSIZE ] );
    e96a:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
    e96e:	4a4f      	ldr	r2, [pc, #316]	; (eaac <cliFunc_version+0x314>)
    e970:	f003 030f 	and.w	r3, r3, #15
    e974:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    e978:	f000 fe9a 	bl	f6b0 <printInt16>
	print( "kB)(EEPROM:" );
    e97c:	484c      	ldr	r0, [pc, #304]	; (eab0 <cliFunc_version+0x318>)
    e97e:	f000 fdf7 	bl	f570 <_print>
	printInt16( ChipVersion_eepromsize[ SIM_FCFG1_EESIZE ] );
    e982:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    e984:	4a4b      	ldr	r2, [pc, #300]	; (eab4 <cliFunc_version+0x31c>)
    e986:	f003 030f 	and.w	r3, r3, #15
    e98a:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    e98e:	f000 fe8f 	bl	f6b0 <printInt16>
	print( ")(DEPART:" );
    e992:	4849      	ldr	r0, [pc, #292]	; (eab8 <cliFunc_version+0x320>)
    e994:	f000 fdec 	bl	f570 <_print>
	printHex32( SIM_FCFG1_DEPART );
    e998:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    e99a:	2101      	movs	r1, #1
    e99c:	f3c0 2003 	ubfx	r0, r0, #8, #4
    e9a0:	f000 ff5e 	bl	f860 <printHex32_op>
	print( ")" NL );
    e9a4:	4835      	ldr	r0, [pc, #212]	; (ea7c <cliFunc_version+0x2e4>)
    e9a6:	f000 fde3 	bl	f570 <_print>

	print( " \033[1mRAM:\033[0m           ");
    e9aa:	4844      	ldr	r0, [pc, #272]	; (eabc <cliFunc_version+0x324>)
    e9ac:	f000 fde0 	bl	f570 <_print>
	printInt16( ChipVersion_ramsize[ SIM_SOPT1_RAMSIZE ] );
    e9b0:	4b43      	ldr	r3, [pc, #268]	; (eac0 <cliFunc_version+0x328>)
    e9b2:	4a44      	ldr	r2, [pc, #272]	; (eac4 <cliFunc_version+0x32c>)
    e9b4:	681b      	ldr	r3, [r3, #0]
    e9b6:	f3c3 3303 	ubfx	r3, r3, #12, #4
    e9ba:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
    e9be:	f000 fe77 	bl	f6b0 <printInt16>
	print( " kB" NL );
    e9c2:	4841      	ldr	r0, [pc, #260]	; (eac8 <cliFunc_version+0x330>)
    e9c4:	f000 fdd4 	bl	f570 <_print>

	print( " \033[1mUnique Id:\033[0m     " );
    e9c8:	4840      	ldr	r0, [pc, #256]	; (eacc <cliFunc_version+0x334>)
    e9ca:	f000 fdd1 	bl	f570 <_print>
	printHex32_op( SIM_UIDH, 8 );
    e9ce:	4b40      	ldr	r3, [pc, #256]	; (ead0 <cliFunc_version+0x338>)
    e9d0:	2108      	movs	r1, #8
    e9d2:	6818      	ldr	r0, [r3, #0]
    e9d4:	f000 ff44 	bl	f860 <printHex32_op>
	printHex32_op( SIM_UIDMH, 8 );
    e9d8:	4b3e      	ldr	r3, [pc, #248]	; (ead4 <cliFunc_version+0x33c>)
    e9da:	2108      	movs	r1, #8
    e9dc:	6818      	ldr	r0, [r3, #0]
    e9de:	f000 ff3f 	bl	f860 <printHex32_op>
	printHex32_op( SIM_UIDML, 8 );
    e9e2:	4b3d      	ldr	r3, [pc, #244]	; (ead8 <cliFunc_version+0x340>)
    e9e4:	2108      	movs	r1, #8
    e9e6:	6818      	ldr	r0, [r3, #0]
    e9e8:	f000 ff3a 	bl	f860 <printHex32_op>
	printHex32_op( SIM_UIDL, 8 );
    e9ec:	9a01      	ldr	r2, [sp, #4]
    e9ee:	682b      	ldr	r3, [r5, #0]
    e9f0:	429a      	cmp	r2, r3
    e9f2:	d001      	beq.n	e9f8 <cliFunc_version+0x260>
    e9f4:	f7f3 fe9c 	bl	2730 <__stack_chk_fail>
    e9f8:	4b38      	ldr	r3, [pc, #224]	; (eadc <cliFunc_version+0x344>)
    e9fa:	6818      	ldr	r0, [r3, #0]
    e9fc:	2108      	movs	r1, #8
#elif defined(_avr_at_)
#elif defined(_host_)
#else
#warning "No unique id defined."
#endif
}
    e9fe:	b003      	add	sp, #12
    ea00:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printHex32_op( SIM_UIDL, 8 );
    ea04:	f000 bf2c 	b.w	f860 <printHex32_op>
    ea08:	1fff89d0 	.word	0x1fff89d0
    ea0c:	00015df4 	.word	0x00015df4
    ea10:	000169f0 	.word	0x000169f0
    ea14:	e000ed00 	.word	0xe000ed00
    ea18:	00016a33 	.word	0x00016a33
    ea1c:	00016a50 	.word	0x00016a50
    ea20:	00016a6c 	.word	0x00016a6c
    ea24:	00016a73 	.word	0x00016a73
    ea28:	00016a94 	.word	0x00016a94
    ea2c:	00016c0b 	.word	0x00016c0b
    ea30:	00016c57 	.word	0x00016c57
    ea34:	00016c8b 	.word	0x00016c8b
    ea38:	00016cc8 	.word	0x00016cc8
    ea3c:	00016cfc 	.word	0x00016cfc
    ea40:	00016d1e 	.word	0x00016d1e
    ea44:	00016d5f 	.word	0x00016d5f
    ea48:	00016d7d 	.word	0x00016d7d
    ea4c:	00016db1 	.word	0x00016db1
    ea50:	00016dd5 	.word	0x00016dd5
    ea54:	00016df8 	.word	0x00016df8
    ea58:	00016e51 	.word	0x00016e51
    ea5c:	00016e6a 	.word	0x00016e6a
    ea60:	00016e83 	.word	0x00016e83
    ea64:	00014d02 	.word	0x00014d02
    ea68:	00016e95 	.word	0x00016e95
    ea6c:	00016ea0 	.word	0x00016ea0
    ea70:	00016ea8 	.word	0x00016ea8
    ea74:	00016eb2 	.word	0x00016eb2
    ea78:	40048024 	.word	0x40048024
    ea7c:	00016dad 	.word	0x00016dad
    ea80:	00016ebe 	.word	0x00016ebe
    ea84:	00016ed7 	.word	0x00016ed7
    ea88:	1fff9294 	.word	0x1fff9294
    ea8c:	00016ee6 	.word	0x00016ee6
    ea90:	1fff9274 	.word	0x1fff9274
    ea94:	00016ef0 	.word	0x00016ef0
    ea98:	00016ef7 	.word	0x00016ef7
    ea9c:	00016efe 	.word	0x00016efe
    eaa0:	00016f17 	.word	0x00016f17
    eaa4:	000166e6 	.word	0x000166e6
    eaa8:	00016f25 	.word	0x00016f25
    eaac:	00016704 	.word	0x00016704
    eab0:	00016f31 	.word	0x00016f31
    eab4:	00016644 	.word	0x00016644
    eab8:	00016f3d 	.word	0x00016f3d
    eabc:	00016f47 	.word	0x00016f47
    eac0:	40047000 	.word	0x40047000
    eac4:	00016724 	.word	0x00016724
    eac8:	00016f60 	.word	0x00016f60
    eacc:	00016f66 	.word	0x00016f66
    ead0:	40048054 	.word	0x40048054
    ead4:	40048058 	.word	0x40048058
    ead8:	4004805c 	.word	0x4004805c
    eadc:	40048060 	.word	0x40048060

0000eae0 <prompt>:
{
    eae0:	b513      	push	{r0, r1, r4, lr}
    eae2:	4c09      	ldr	r4, [pc, #36]	; (eb08 <prompt+0x28>)
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    eae4:	4809      	ldr	r0, [pc, #36]	; (eb0c <prompt+0x2c>)
{
    eae6:	6823      	ldr	r3, [r4, #0]
    eae8:	9301      	str	r3, [sp, #4]
	print("\033[2K\r"); // Erases the current line and resets cursor to beginning of line
    eaea:	f000 fd41 	bl	f570 <_print>
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    eaee:	9a01      	ldr	r2, [sp, #4]
    eaf0:	6823      	ldr	r3, [r4, #0]
    eaf2:	429a      	cmp	r2, r3
    eaf4:	d001      	beq.n	eafa <prompt+0x1a>
    eaf6:	f7f3 fe1b 	bl	2730 <__stack_chk_fail>
    eafa:	4805      	ldr	r0, [pc, #20]	; (eb10 <prompt+0x30>)
}
    eafc:	b002      	add	sp, #8
    eafe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	print("\033[1;34m:\033[0m "); // Blue bold prompt
    eb02:	f000 bd35 	b.w	f570 <_print>
    eb06:	bf00      	nop
    eb08:	1fff89d0 	.word	0x1fff89d0
    eb0c:	00017115 	.word	0x00017115
    eb10:	0001711b 	.word	0x0001711b

0000eb14 <CLI_argumentIsolation>:
{
    eb14:	b573      	push	{r0, r1, r4, r5, r6, lr}
    eb16:	4b0f      	ldr	r3, [pc, #60]	; (eb54 <CLI_argumentIsolation+0x40>)
    eb18:	681c      	ldr	r4, [r3, #0]
    eb1a:	9401      	str	r4, [sp, #4]
	char* cmdPtr = string - 1;
    eb1c:	3801      	subs	r0, #1
	while ( *++cmdPtr == ' ' ); // Skips leading spaces, and points to first character of cmd
    eb1e:	7844      	ldrb	r4, [r0, #1]
    eb20:	2c20      	cmp	r4, #32
    eb22:	f100 0601 	add.w	r6, r0, #1
    eb26:	d00f      	beq.n	eb48 <CLI_argumentIsolation+0x34>
	char* argPtr = cmdPtr + 1;
    eb28:	3002      	adds	r0, #2
	while ( *argPtr != ' ' && *argPtr != '\0' )
    eb2a:	7804      	ldrb	r4, [r0, #0]
    eb2c:	f014 04df 	ands.w	r4, r4, #223	; 0xdf
    eb30:	f100 0501 	add.w	r5, r0, #1
    eb34:	d10a      	bne.n	eb4c <CLI_argumentIsolation+0x38>
	(++argPtr)[-1] = '\0';
    eb36:	7004      	strb	r4, [r0, #0]
	*first = cmdPtr;
    eb38:	600e      	str	r6, [r1, #0]
	*second = argPtr;
    eb3a:	6015      	str	r5, [r2, #0]
}
    eb3c:	9a01      	ldr	r2, [sp, #4]
    eb3e:	681b      	ldr	r3, [r3, #0]
    eb40:	429a      	cmp	r2, r3
    eb42:	d005      	beq.n	eb50 <CLI_argumentIsolation+0x3c>
    eb44:	f7f3 fdf4 	bl	2730 <__stack_chk_fail>
    eb48:	4630      	mov	r0, r6
    eb4a:	e7e8      	b.n	eb1e <CLI_argumentIsolation+0xa>
    eb4c:	4628      	mov	r0, r5
    eb4e:	e7ec      	b.n	eb2a <CLI_argumentIsolation+0x16>
    eb50:	b002      	add	sp, #8
    eb52:	bd70      	pop	{r4, r5, r6, pc}
    eb54:	1fff89d0 	.word	0x1fff89d0

0000eb58 <cliFunc_periodic>:
{
    eb58:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    eb5a:	4c10      	ldr	r4, [pc, #64]	; (eb9c <cliFunc_periodic+0x44>)
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    eb5c:	aa02      	add	r2, sp, #8
{
    eb5e:	6823      	ldr	r3, [r4, #0]
    eb60:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    eb62:	a901      	add	r1, sp, #4
    eb64:	f7ff ffd6 	bl	eb14 <CLI_argumentIsolation>
	print( NL );
    eb68:	480d      	ldr	r0, [pc, #52]	; (eba0 <cliFunc_periodic+0x48>)
    eb6a:	f000 fd01 	bl	f570 <_print>
	if ( arg1Ptr[0] != '\0' )
    eb6e:	9801      	ldr	r0, [sp, #4]
    eb70:	7803      	ldrb	r3, [r0, #0]
    eb72:	b11b      	cbz	r3, eb7c <cliFunc_periodic+0x24>
		uint32_t cycles = (uint32_t)numToInt( arg1Ptr );
    eb74:	f000 fecc 	bl	f910 <numToInt>
		Periodic_init( cycles );
    eb78:	f7f4 f832 	bl	2be0 <Periodic_init>
	info_msg("Period Clock Cycles: ");
    eb7c:	4809      	ldr	r0, [pc, #36]	; (eba4 <cliFunc_periodic+0x4c>)
    eb7e:	f000 fcf7 	bl	f570 <_print>
	printInt32( Periodic_cycles() );
    eb82:	f7f4 f897 	bl	2cb4 <Periodic_cycles>
    eb86:	f000 fdc9 	bl	f71c <printInt32>
}
    eb8a:	9a03      	ldr	r2, [sp, #12]
    eb8c:	6823      	ldr	r3, [r4, #0]
    eb8e:	429a      	cmp	r2, r3
    eb90:	d001      	beq.n	eb96 <cliFunc_periodic+0x3e>
    eb92:	f7f3 fdcd 	bl	2730 <__stack_chk_fail>
    eb96:	b004      	add	sp, #16
    eb98:	bd10      	pop	{r4, pc}
    eb9a:	bf00      	nop
    eb9c:	1fff89d0 	.word	0x1fff89d0
    eba0:	00015df4 	.word	0x00015df4
    eba4:	0001691e 	.word	0x0001691e

0000eba8 <CLI_commandLookup>:
{
    eba8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ebac:	4a2a      	ldr	r2, [pc, #168]	; (ec58 <CLI_commandLookup+0xb0>)
    ebae:	b08d      	sub	sp, #52	; 0x34
    ebb0:	6813      	ldr	r3, [r2, #0]
    ebb2:	930b      	str	r3, [sp, #44]	; 0x2c
	if ( CLILineBufferCurrent == 0 )
    ebb4:	4b29      	ldr	r3, [pc, #164]	; (ec5c <CLI_commandLookup+0xb4>)
    ebb6:	781b      	ldrb	r3, [r3, #0]
    ebb8:	4690      	mov	r8, r2
    ebba:	2b00      	cmp	r3, #0
    ebbc:	d036      	beq.n	ec2c <CLI_commandLookup+0x84>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ebbe:	4d28      	ldr	r5, [pc, #160]	; (ec60 <CLI_commandLookup+0xb8>)
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    ebc0:	f8df b0c4 	ldr.w	fp, [pc, #196]	; ec88 <CLI_commandLookup+0xe0>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ebc4:	f8df a0c4 	ldr.w	sl, [pc, #196]	; ec8c <CLI_commandLookup+0xe4>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ebc8:	2400      	movs	r4, #0
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    ebca:	aa0a      	add	r2, sp, #40	; 0x28
    ebcc:	a909      	add	r1, sp, #36	; 0x24
    ebce:	4628      	mov	r0, r5
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ebd0:	54ec      	strb	r4, [r5, r3]
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ebd2:	f04f 090c 	mov.w	r9, #12
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    ebd6:	f7ff ff9d 	bl	eb14 <CLI_argumentIsolation>
    ebda:	9507      	str	r5, [sp, #28]
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    ebdc:	f89b 2000 	ldrb.w	r2, [fp]
    ebe0:	b2e6      	uxtb	r6, r4
    ebe2:	42b2      	cmp	r2, r6
    ebe4:	d829      	bhi.n	ec3a <CLI_commandLookup+0x92>
	print( NL );
    ebe6:	4c1f      	ldr	r4, [pc, #124]	; (ec64 <CLI_commandLookup+0xbc>)
    ebe8:	4620      	mov	r0, r4
    ebea:	f000 fcc1 	bl	f570 <_print>
	erro_dPrint("\"", CLILineBuffer, "\" is not a valid command...type \033[35mhelp\033[0m");
    ebee:	4b1e      	ldr	r3, [pc, #120]	; (ec68 <CLI_commandLookup+0xc0>)
    ebf0:	4a1e      	ldr	r2, [pc, #120]	; (ec6c <CLI_commandLookup+0xc4>)
    ebf2:	491f      	ldr	r1, [pc, #124]	; (ec70 <CLI_commandLookup+0xc8>)
    ebf4:	481f      	ldr	r0, [pc, #124]	; (ec74 <CLI_commandLookup+0xcc>)
    ebf6:	e9cd 4304 	strd	r4, r3, [sp, #16]
    ebfa:	4b1f      	ldr	r3, [pc, #124]	; (ec78 <CLI_commandLookup+0xd0>)
    ebfc:	9303      	str	r3, [sp, #12]
    ebfe:	9b07      	ldr	r3, [sp, #28]
    ec00:	9302      	str	r3, [sp, #8]
    ec02:	4b1e      	ldr	r3, [pc, #120]	; (ec7c <CLI_commandLookup+0xd4>)
    ec04:	9301      	str	r3, [sp, #4]
    ec06:	4b1e      	ldr	r3, [pc, #120]	; (ec80 <CLI_commandLookup+0xd8>)
    ec08:	9300      	str	r3, [sp, #0]
    ec0a:	4b1e      	ldr	r3, [pc, #120]	; (ec84 <CLI_commandLookup+0xdc>)
    ec0c:	f000 fc8c 	bl	f528 <printstrs>
    ec10:	e00c      	b.n	ec2c <CLI_commandLookup+0x84>
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == -1 )
    ec12:	9809      	ldr	r0, [sp, #36]	; 0x24
    ec14:	f000 fe5a 	bl	f8cc <eqStr>
    ec18:	3001      	adds	r0, #1
    ec1a:	f107 0701 	add.w	r7, r7, #1
    ec1e:	d10d      	bne.n	ec3c <CLI_commandLookup+0x94>
				(*(void (*)(char*))CLIDict[dict][cmd].function)( argPtr );
    ec20:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
    ec24:	980a      	ldr	r0, [sp, #40]	; 0x28
    ec26:	441d      	add	r5, r3
    ec28:	68ab      	ldr	r3, [r5, #8]
    ec2a:	4798      	blx	r3
}
    ec2c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    ec2e:	f8d8 3000 	ldr.w	r3, [r8]
    ec32:	429a      	cmp	r2, r3
    ec34:	d00c      	beq.n	ec50 <CLI_commandLookup+0xa8>
    ec36:	f7f3 fd7b 	bl	2730 <__stack_chk_fail>
    ec3a:	2700      	movs	r7, #0
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ec3c:	b2fd      	uxtb	r5, r7
    ec3e:	fb09 f505 	mul.w	r5, r9, r5
    ec42:	f85a 2026 	ldr.w	r2, [sl, r6, lsl #2]
    ec46:	5951      	ldr	r1, [r2, r5]
    ec48:	2900      	cmp	r1, #0
    ec4a:	d1e2      	bne.n	ec12 <CLI_commandLookup+0x6a>
    ec4c:	3401      	adds	r4, #1
    ec4e:	e7c5      	b.n	ebdc <CLI_commandLookup+0x34>
}
    ec50:	b00d      	add	sp, #52	; 0x34
    ec52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ec56:	bf00      	nop
    ec58:	1fff89d0 	.word	0x1fff89d0
    ec5c:	1fff9ea8 	.word	0x1fff9ea8
    ec60:	1fff9dec 	.word	0x1fff9dec
    ec64:	00015df4 	.word	0x00015df4
    ec68:	00016521 	.word	0x00016521
    ec6c:	0001205f 	.word	0x0001205f
    ec70:	0001652b 	.word	0x0001652b
    ec74:	00016532 	.word	0x00016532
    ec78:	00016535 	.word	0x00016535
    ec7c:	00016563 	.word	0x00016563
    ec80:	00010e79 	.word	0x00010e79
    ec84:	00016525 	.word	0x00016525
    ec88:	1fff9a03 	.word	0x1fff9a03
    ec8c:	1fff9e54 	.word	0x1fff9e54

0000ec90 <CLI_registerDictionary>:
{
    ec90:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ec92:	4a10      	ldr	r2, [pc, #64]	; (ecd4 <CLI_registerDictionary+0x44>)
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
    ec94:	4c10      	ldr	r4, [pc, #64]	; (ecd8 <CLI_registerDictionary+0x48>)
{
    ec96:	6813      	ldr	r3, [r2, #0]
    ec98:	9301      	str	r3, [sp, #4]
	if ( CLIDictionariesUsed >= CLIMaxDictionaries )
    ec9a:	7823      	ldrb	r3, [r4, #0]
    ec9c:	2b09      	cmp	r3, #9
    ec9e:	d90b      	bls.n	ecb8 <CLI_registerDictionary+0x28>
		erro_print("Max number of dictionaries defined already...");
    eca0:	9901      	ldr	r1, [sp, #4]
    eca2:	6813      	ldr	r3, [r2, #0]
    eca4:	4299      	cmp	r1, r3
    eca6:	d001      	beq.n	ecac <CLI_registerDictionary+0x1c>
}
    eca8:	f7f3 fd42 	bl	2730 <__stack_chk_fail>
		erro_print("Max number of dictionaries defined already...");
    ecac:	480b      	ldr	r0, [pc, #44]	; (ecdc <CLI_registerDictionary+0x4c>)
}
    ecae:	b003      	add	sp, #12
    ecb0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		erro_print("Max number of dictionaries defined already...");
    ecb4:	f000 bc5c 	b.w	f570 <_print>
	CLIDictNames[CLIDictionariesUsed] = (char*)dictName;
    ecb8:	4d09      	ldr	r5, [pc, #36]	; (ece0 <CLI_registerDictionary+0x50>)
    ecba:	f845 1023 	str.w	r1, [r5, r3, lsl #2]
	CLIDict[CLIDictionariesUsed++] = (CLIDictItem*)cmdDict;
    ecbe:	1c59      	adds	r1, r3, #1
    ecc0:	7021      	strb	r1, [r4, #0]
    ecc2:	4908      	ldr	r1, [pc, #32]	; (ece4 <CLI_registerDictionary+0x54>)
    ecc4:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
}
    ecc8:	9901      	ldr	r1, [sp, #4]
    ecca:	6813      	ldr	r3, [r2, #0]
    eccc:	4299      	cmp	r1, r3
    ecce:	d1eb      	bne.n	eca8 <CLI_registerDictionary+0x18>
    ecd0:	b003      	add	sp, #12
    ecd2:	bd30      	pop	{r4, r5, pc}
    ecd4:	1fff89d0 	.word	0x1fff89d0
    ecd8:	1fff9a03 	.word	0x1fff9a03
    ecdc:	000165cf 	.word	0x000165cf
    ece0:	1fff9e80 	.word	0x1fff9e80
    ece4:	1fff9e54 	.word	0x1fff9e54

0000ece8 <CLI_init>:
{
    ece8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ecea:	4d11      	ldr	r5, [pc, #68]	; (ed30 <CLI_init+0x48>)
    ecec:	682b      	ldr	r3, [r5, #0]
    ecee:	9301      	str	r3, [sp, #4]
	CLILineBufferCurrent = 0;
    ecf0:	4b10      	ldr	r3, [pc, #64]	; (ed34 <CLI_init+0x4c>)
    ecf2:	2400      	movs	r4, #0
    ecf4:	701c      	strb	r4, [r3, #0]
	CLIHistoryHead = 0;
    ecf6:	4b10      	ldr	r3, [pc, #64]	; (ed38 <CLI_init+0x50>)
    ecf8:	701c      	strb	r4, [r3, #0]
	CLIHistoryCurrent = 0;
    ecfa:	4b10      	ldr	r3, [pc, #64]	; (ed3c <CLI_init+0x54>)
    ecfc:	701c      	strb	r4, [r3, #0]
	CLIHistoryTail = 0;
    ecfe:	4b10      	ldr	r3, [pc, #64]	; (ed40 <CLI_init+0x58>)
    ed00:	701c      	strb	r4, [r3, #0]
	prompt();
    ed02:	f7ff feed 	bl	eae0 <prompt>
	CLIDictionariesUsed = 0;
    ed06:	4b0f      	ldr	r3, [pc, #60]	; (ed44 <CLI_init+0x5c>)
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    ed08:	490f      	ldr	r1, [pc, #60]	; (ed48 <CLI_init+0x60>)
    ed0a:	4810      	ldr	r0, [pc, #64]	; (ed4c <CLI_init+0x64>)
	CLIDictionariesUsed = 0;
    ed0c:	701c      	strb	r4, [r3, #0]
	CLI_registerDictionary( basicCLIDict, basicCLIDictName );
    ed0e:	f7ff ffbf 	bl	ec90 <CLI_registerDictionary>
	init_errorLED();
    ed12:	f000 fbcb 	bl	f4ac <init_errorLED>
	CLILEDState = 0;
    ed16:	4b0e      	ldr	r3, [pc, #56]	; (ed50 <CLI_init+0x68>)
}
    ed18:	9a01      	ldr	r2, [sp, #4]
	CLILEDState = 0;
    ed1a:	701c      	strb	r4, [r3, #0]
	CLIHexDebugMode = 0;
    ed1c:	4b0d      	ldr	r3, [pc, #52]	; (ed54 <CLI_init+0x6c>)
    ed1e:	701c      	strb	r4, [r3, #0]
}
    ed20:	682b      	ldr	r3, [r5, #0]
    ed22:	429a      	cmp	r2, r3
    ed24:	d001      	beq.n	ed2a <CLI_init+0x42>
    ed26:	f7f3 fd03 	bl	2730 <__stack_chk_fail>
    ed2a:	b003      	add	sp, #12
    ed2c:	bd30      	pop	{r4, r5, pc}
    ed2e:	bf00      	nop
    ed30:	1fff89d0 	.word	0x1fff89d0
    ed34:	1fff9ea8 	.word	0x1fff9ea8
    ed38:	1fff9e51 	.word	0x1fff9e51
    ed3c:	1fff9a01 	.word	0x1fff9a01
    ed40:	1fff9e7c 	.word	0x1fff9e7c
    ed44:	1fff9a03 	.word	0x1fff9a03
    ed48:	000167ec 	.word	0x000167ec
    ed4c:	00016744 	.word	0x00016744
    ed50:	1fff9a02 	.word	0x1fff9a02
    ed54:	1fff9a00 	.word	0x1fff9a00

0000ed58 <CLI_tabCompletion>:
{
    ed58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ed5c:	4a2d      	ldr	r2, [pc, #180]	; (ee14 <CLI_tabCompletion+0xbc>)
	if ( CLILineBufferCurrent == 0 )
    ed5e:	4e2e      	ldr	r6, [pc, #184]	; (ee18 <CLI_tabCompletion+0xc0>)
{
    ed60:	6813      	ldr	r3, [r2, #0]
    ed62:	b089      	sub	sp, #36	; 0x24
    ed64:	9307      	str	r3, [sp, #28]
	if ( CLILineBufferCurrent == 0 )
    ed66:	7833      	ldrb	r3, [r6, #0]
    ed68:	9200      	str	r2, [sp, #0]
    ed6a:	b31b      	cbz	r3, edb4 <CLI_tabCompletion+0x5c>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ed6c:	f8df 80b0 	ldr.w	r8, [pc, #176]	; ee20 <CLI_tabCompletion+0xc8>
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ed70:	f8df b0b0 	ldr.w	fp, [pc, #176]	; ee24 <CLI_tabCompletion+0xcc>
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ed74:	2400      	movs	r4, #0
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    ed76:	aa06      	add	r2, sp, #24
    ed78:	a905      	add	r1, sp, #20
    ed7a:	4640      	mov	r0, r8
	CLILineBuffer[CLILineBufferCurrent] = '\0';
    ed7c:	f808 4003 	strb.w	r4, [r8, r3]
	CLI_argumentIsolation( CLILineBuffer, &cmdPtr, &argPtr );
    ed80:	f7ff fec8 	bl	eb14 <CLI_argumentIsolation>
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    ed84:	4b25      	ldr	r3, [pc, #148]	; (ee1c <CLI_tabCompletion+0xc4>)
    ed86:	f8cd 8004 	str.w	r8, [sp, #4]
	uint8_t matches = 0;
    ed8a:	4627      	mov	r7, r4
	char* tabMatch = 0;
    ed8c:	4625      	mov	r5, r4
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ed8e:	220c      	movs	r2, #12
	for ( uint8_t dict = 0; dict < CLIDictionariesUsed; dict++ )
    ed90:	7819      	ldrb	r1, [r3, #0]
    ed92:	fa5f f984 	uxtb.w	r9, r4
    ed96:	4549      	cmp	r1, r9
    ed98:	d82f      	bhi.n	edfa <CLI_tabCompletion+0xa2>
	if ( matches == 1 )
    ed9a:	2f01      	cmp	r7, #1
    ed9c:	d10a      	bne.n	edb4 <CLI_tabCompletion+0x5c>
		CLILineBufferCurrent = 0;
    ed9e:	2300      	movs	r3, #0
    eda0:	7033      	strb	r3, [r6, #0]
		prompt();
    eda2:	f7ff fe9d 	bl	eae0 <prompt>
		dPrint( tabMatch );
    eda6:	4628      	mov	r0, r5
    eda8:	f7fd f85a 	bl	be60 <Output_putstr>
    edac:	3d01      	subs	r5, #1
		while ( *tabMatch != '\0' )
    edae:	f815 3f01 	ldrb.w	r3, [r5, #1]!
    edb2:	bb2b      	cbnz	r3, ee00 <CLI_tabCompletion+0xa8>
}
    edb4:	9b00      	ldr	r3, [sp, #0]
    edb6:	9a07      	ldr	r2, [sp, #28]
    edb8:	681b      	ldr	r3, [r3, #0]
    edba:	429a      	cmp	r2, r3
    edbc:	d027      	beq.n	ee0e <CLI_tabCompletion+0xb6>
    edbe:	f7f3 fcb7 	bl	2730 <__stack_chk_fail>
			if ( eqStr( cmdPtr, (char*)CLIDict[dict][cmd].name ) == 0 )
    edc2:	9805      	ldr	r0, [sp, #20]
    edc4:	e9cd 3202 	strd	r3, r2, [sp, #8]
    edc8:	f000 fd80 	bl	f8cc <eqStr>
    edcc:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
    edd0:	b928      	cbnz	r0, edde <CLI_tabCompletion+0x86>
				tabMatch = (char*)CLIDict[dict][cmd].name;
    edd2:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
				matches++;
    edd6:	3701      	adds	r7, #1
				tabMatch = (char*)CLIDict[dict][cmd].name;
    edd8:	f851 5008 	ldr.w	r5, [r1, r8]
				matches++;
    eddc:	b2ff      	uxtb	r7, r7
    edde:	f10a 0a01 	add.w	sl, sl, #1
		for ( uint8_t cmd = 0; CLIDict[dict][cmd].name != 0; cmd++ )
    ede2:	fa5f f88a 	uxtb.w	r8, sl
    ede6:	fb02 f808 	mul.w	r8, r2, r8
    edea:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
    edee:	f851 1008 	ldr.w	r1, [r1, r8]
    edf2:	2900      	cmp	r1, #0
    edf4:	d1e5      	bne.n	edc2 <CLI_tabCompletion+0x6a>
    edf6:	3401      	adds	r4, #1
    edf8:	e7ca      	b.n	ed90 <CLI_tabCompletion+0x38>
    edfa:	f04f 0a00 	mov.w	sl, #0
    edfe:	e7f0      	b.n	ede2 <CLI_tabCompletion+0x8a>
			CLILineBuffer[CLILineBufferCurrent++] = *tabMatch++;
    ee00:	7833      	ldrb	r3, [r6, #0]
    ee02:	9901      	ldr	r1, [sp, #4]
    ee04:	1c5a      	adds	r2, r3, #1
    ee06:	7032      	strb	r2, [r6, #0]
    ee08:	782a      	ldrb	r2, [r5, #0]
    ee0a:	54ca      	strb	r2, [r1, r3]
    ee0c:	e7cf      	b.n	edae <CLI_tabCompletion+0x56>
}
    ee0e:	b009      	add	sp, #36	; 0x24
    ee10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ee14:	1fff89d0 	.word	0x1fff89d0
    ee18:	1fff9ea8 	.word	0x1fff9ea8
    ee1c:	1fff9a03 	.word	0x1fff9a03
    ee20:	1fff9dec 	.word	0x1fff9dec
    ee24:	1fff9e54 	.word	0x1fff9e54

0000ee28 <CLI_wrap>:
{
    ee28:	b513      	push	{r0, r1, r4, lr}
    ee2a:	4b0f      	ldr	r3, [pc, #60]	; (ee68 <CLI_wrap+0x40>)
	if ( kX < kLowerBound )
    ee2c:	4281      	cmp	r1, r0
{
    ee2e:	681c      	ldr	r4, [r3, #0]
    ee30:	9401      	str	r4, [sp, #4]
	int range_size = kUpperBound - kLowerBound + 1;
    ee32:	eba2 0201 	sub.w	r2, r2, r1
    ee36:	f102 0201 	add.w	r2, r2, #1
    ee3a:	461c      	mov	r4, r3
		kX += range_size * ((kLowerBound - kX) / range_size + 1);
    ee3c:	bfc1      	itttt	gt
    ee3e:	1a0b      	subgt	r3, r1, r0
    ee40:	fb93 f3f2 	sdivgt	r3, r3, r2
    ee44:	fb03 2302 	mlagt	r3, r3, r2, r2
    ee48:	18c0      	addgt	r0, r0, r3
	return kLowerBound + (kX - kLowerBound) % range_size;
    ee4a:	1a40      	subs	r0, r0, r1
    ee4c:	fb90 f3f2 	sdiv	r3, r0, r2
    ee50:	fb02 0013 	mls	r0, r2, r3, r0
}
    ee54:	9a01      	ldr	r2, [sp, #4]
    ee56:	6823      	ldr	r3, [r4, #0]
    ee58:	429a      	cmp	r2, r3
    ee5a:	4408      	add	r0, r1
    ee5c:	d001      	beq.n	ee62 <CLI_wrap+0x3a>
    ee5e:	f7f3 fc67 	bl	2730 <__stack_chk_fail>
    ee62:	b002      	add	sp, #8
    ee64:	bd10      	pop	{r4, pc}
    ee66:	bf00      	nop
    ee68:	1fff89d0 	.word	0x1fff89d0

0000ee6c <CLI_saveHistory>:
{
    ee6c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    ee6e:	4914      	ldr	r1, [pc, #80]	; (eec0 <CLI_saveHistory+0x54>)
    ee70:	680a      	ldr	r2, [r1, #0]
    ee72:	9201      	str	r2, [sp, #4]
	if ( buff == NULL )
    ee74:	b1a8      	cbz	r0, eea2 <CLI_saveHistory+0x36>
    ee76:	3801      	subs	r0, #1
        while (*cursor == ' ') { cursor++; } // advance past the leading whitespace
    ee78:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    ee7c:	2b20      	cmp	r3, #32
    ee7e:	d0fb      	beq.n	ee78 <CLI_saveHistory+0xc>
        if (*cursor == '\0') { return ; }
    ee80:	b1ab      	cbz	r3, eeae <CLI_saveHistory+0x42>
	for (i = 0; i < CLILineBufferCurrent; i++)
    ee82:	4b10      	ldr	r3, [pc, #64]	; (eec4 <CLI_saveHistory+0x58>)
    ee84:	7818      	ldrb	r0, [r3, #0]
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    ee86:	4b10      	ldr	r3, [pc, #64]	; (eec8 <CLI_saveHistory+0x5c>)
    ee88:	781c      	ldrb	r4, [r3, #0]
    ee8a:	4b10      	ldr	r3, [pc, #64]	; (eecc <CLI_saveHistory+0x60>)
    ee8c:	2264      	movs	r2, #100	; 0x64
    ee8e:	fb04 3202 	mla	r2, r4, r2, r3
    ee92:	4c0f      	ldr	r4, [pc, #60]	; (eed0 <CLI_saveHistory+0x64>)
	for (i = 0; i < CLILineBufferCurrent; i++)
    ee94:	2300      	movs	r3, #0
    ee96:	4283      	cmp	r3, r0
    ee98:	da09      	bge.n	eeae <CLI_saveHistory+0x42>
		CLIHistoryBuffer[ CLIHistoryTail ][ i ] = CLILineBuffer[ i ];
    ee9a:	5d1d      	ldrb	r5, [r3, r4]
    ee9c:	54d5      	strb	r5, [r2, r3]
	for (i = 0; i < CLILineBufferCurrent; i++)
    ee9e:	3301      	adds	r3, #1
    eea0:	e7f9      	b.n	ee96 <CLI_saveHistory+0x2a>
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    eea2:	4b09      	ldr	r3, [pc, #36]	; (eec8 <CLI_saveHistory+0x5c>)
    eea4:	781a      	ldrb	r2, [r3, #0]
    eea6:	2364      	movs	r3, #100	; 0x64
    eea8:	4353      	muls	r3, r2
    eeaa:	4a08      	ldr	r2, [pc, #32]	; (eecc <CLI_saveHistory+0x60>)
    eeac:	54d0      	strb	r0, [r2, r3]
}
    eeae:	9a01      	ldr	r2, [sp, #4]
    eeb0:	680b      	ldr	r3, [r1, #0]
    eeb2:	429a      	cmp	r2, r3
    eeb4:	d001      	beq.n	eeba <CLI_saveHistory+0x4e>
    eeb6:	f7f3 fc3b 	bl	2730 <__stack_chk_fail>
    eeba:	b003      	add	sp, #12
    eebc:	bd30      	pop	{r4, r5, pc}
    eebe:	bf00      	nop
    eec0:	1fff89d0 	.word	0x1fff89d0
    eec4:	1fff9ea8 	.word	0x1fff9ea8
    eec8:	1fff9e7c 	.word	0x1fff9e7c
    eecc:	1fff9a04 	.word	0x1fff9a04
    eed0:	1fff9dec 	.word	0x1fff9dec

0000eed4 <CLI_retreiveHistory>:
{
    eed4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    eed6:	4f12      	ldr	r7, [pc, #72]	; (ef20 <CLI_retreiveHistory+0x4c>)
	CLILineBufferCurrent = 0;
    eed8:	4d12      	ldr	r5, [pc, #72]	; (ef24 <CLI_retreiveHistory+0x50>)
{
    eeda:	683b      	ldr	r3, [r7, #0]
    eedc:	9301      	str	r3, [sp, #4]
	char *histMatch = CLIHistoryBuffer[ index ];
    eede:	4b12      	ldr	r3, [pc, #72]	; (ef28 <CLI_retreiveHistory+0x54>)
    eee0:	2664      	movs	r6, #100	; 0x64
    eee2:	fb06 3600 	mla	r6, r6, r0, r3
	CLILineBufferCurrent = 0;
    eee6:	2400      	movs	r4, #0
    eee8:	702c      	strb	r4, [r5, #0]
	prompt();
    eeea:	f7ff fdf9 	bl	eae0 <prompt>
	dPrint( histMatch );
    eeee:	4630      	mov	r0, r6
    eef0:	f7fc ffb6 	bl	be60 <Output_putstr>
		CLILineBuffer[ CLILineBufferCurrent++ ] = *histMatch++;
    eef4:	480d      	ldr	r0, [pc, #52]	; (ef2c <CLI_retreiveHistory+0x58>)
	CLILineBufferCurrent = 0;
    eef6:	702c      	strb	r4, [r5, #0]
	while ( *histMatch != '\0' )
    eef8:	4632      	mov	r2, r6
    eefa:	1b93      	subs	r3, r2, r6
    eefc:	f812 1b01 	ldrb.w	r1, [r2], #1
    ef00:	b2db      	uxtb	r3, r3
    ef02:	b939      	cbnz	r1, ef14 <CLI_retreiveHistory+0x40>
    ef04:	b104      	cbz	r4, ef08 <CLI_retreiveHistory+0x34>
    ef06:	702b      	strb	r3, [r5, #0]
}
    ef08:	9a01      	ldr	r2, [sp, #4]
    ef0a:	683b      	ldr	r3, [r7, #0]
    ef0c:	429a      	cmp	r2, r3
    ef0e:	d004      	beq.n	ef1a <CLI_retreiveHistory+0x46>
    ef10:	f7f3 fc0e 	bl	2730 <__stack_chk_fail>
		CLILineBuffer[ CLILineBufferCurrent++ ] = *histMatch++;
    ef14:	54c1      	strb	r1, [r0, r3]
    ef16:	2401      	movs	r4, #1
    ef18:	e7ef      	b.n	eefa <CLI_retreiveHistory+0x26>
}
    ef1a:	b003      	add	sp, #12
    ef1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ef1e:	bf00      	nop
    ef20:	1fff89d0 	.word	0x1fff89d0
    ef24:	1fff9ea8 	.word	0x1fff9ea8
    ef28:	1fff9a04 	.word	0x1fff9a04
    ef2c:	1fff9dec 	.word	0x1fff9dec

0000ef30 <CLI_process>:
{
    ef30:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    ef34:	4f7b      	ldr	r7, [pc, #492]	; (f124 <CLI_process+0x1f4>)
	uint8_t prev_buf_pos = CLILineBufferCurrent;
    ef36:	4c7c      	ldr	r4, [pc, #496]	; (f128 <CLI_process+0x1f8>)
{
    ef38:	683b      	ldr	r3, [r7, #0]
	uint8_t prev_buf_pos = CLILineBufferCurrent;
    ef3a:	7825      	ldrb	r5, [r4, #0]
		CLILineBuffer[CLILineBufferCurrent++] = cur_char;
    ef3c:	4e7b      	ldr	r6, [pc, #492]	; (f12c <CLI_process+0x1fc>)
{
    ef3e:	9301      	str	r3, [sp, #4]
		if ( Output_availablechar() == 0 )
    ef40:	f7fc ff6a 	bl	be18 <Output_availablechar>
    ef44:	b1e0      	cbz	r0, ef80 <CLI_process+0x50>
		char cur_char = (char)Output_getchar();
    ef46:	f7fc ff79 	bl	be3c <Output_getchar>
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    ef4a:	7823      	ldrb	r3, [r4, #0]
    ef4c:	2b63      	cmp	r3, #99	; 0x63
		char cur_char = (char)Output_getchar();
    ef4e:	b2c0      	uxtb	r0, r0
		if ( CLILineBufferCurrent >= CLILineBufferMaxSize )
    ef50:	d912      	bls.n	ef78 <CLI_process+0x48>
			print( NL );
    ef52:	4877      	ldr	r0, [pc, #476]	; (f130 <CLI_process+0x200>)
    ef54:	f000 fb0c 	bl	f570 <_print>
			erro_print("Serial line buffer is full, dropping character and resetting...");
    ef58:	4876      	ldr	r0, [pc, #472]	; (f134 <CLI_process+0x204>)
    ef5a:	f000 fb09 	bl	f570 <_print>
			CLILineBufferCurrent = 0;
    ef5e:	2300      	movs	r3, #0
    ef60:	7023      	strb	r3, [r4, #0]
			prompt();
    ef62:	f7ff fdbd 	bl	eae0 <prompt>
}
    ef66:	9a01      	ldr	r2, [sp, #4]
    ef68:	683b      	ldr	r3, [r7, #0]
    ef6a:	429a      	cmp	r2, r3
    ef6c:	f04f 0000 	mov.w	r0, #0
    ef70:	f000 80d5 	beq.w	f11e <CLI_process+0x1ee>
    ef74:	f7f3 fbdc 	bl	2730 <__stack_chk_fail>
		CLILineBuffer[CLILineBufferCurrent++] = cur_char;
    ef78:	1c5a      	adds	r2, r3, #1
    ef7a:	7022      	strb	r2, [r4, #0]
    ef7c:	54f0      	strb	r0, [r6, r3]
	{
    ef7e:	e7df      	b.n	ef40 <CLI_process+0x10>
	if ( CLIHexDebugMode && CLILineBufferCurrent > prev_buf_pos )
    ef80:	4b6d      	ldr	r3, [pc, #436]	; (f138 <CLI_process+0x208>)
    ef82:	781b      	ldrb	r3, [r3, #0]
    ef84:	b19b      	cbz	r3, efae <CLI_process+0x7e>
    ef86:	7823      	ldrb	r3, [r4, #0]
    ef88:	42ab      	cmp	r3, r5
    ef8a:	d9ec      	bls.n	ef66 <CLI_process+0x36>
		print("\033[s\r\n"); // Save cursor position, and move to the next line
    ef8c:	486b      	ldr	r0, [pc, #428]	; (f13c <CLI_process+0x20c>)
			printHex( CLILineBuffer[pos++] );
    ef8e:	f8df 919c 	ldr.w	r9, [pc, #412]	; f12c <CLI_process+0x1fc>
			print(" ");
    ef92:	f8df 81c4 	ldr.w	r8, [pc, #452]	; f158 <CLI_process+0x228>
		print("\033[s\r\n"); // Save cursor position, and move to the next line
    ef96:	f000 faeb 	bl	f570 <_print>
		print("\033[2K");    // Erases the current line
    ef9a:	4869      	ldr	r0, [pc, #420]	; (f140 <CLI_process+0x210>)
    ef9c:	f000 fae8 	bl	f570 <_print>
		while ( CLILineBufferCurrent > pos )
    efa0:	462b      	mov	r3, r5
    efa2:	7822      	ldrb	r2, [r4, #0]
    efa4:	429a      	cmp	r2, r3
    efa6:	d819      	bhi.n	efdc <CLI_process+0xac>
		print("\033[u"); // Restore cursor position
    efa8:	4866      	ldr	r0, [pc, #408]	; (f144 <CLI_process+0x214>)
    efaa:	f000 fae1 	bl	f570 <_print>
		switch ( CLILineBuffer[prev_buf_pos] )
    efae:	4e5f      	ldr	r6, [pc, #380]	; (f12c <CLI_process+0x1fc>)
				print("\b \b");
    efb0:	f8df 81a8 	ldr.w	r8, [pc, #424]	; f15c <CLI_process+0x22c>
	while ( CLILineBufferCurrent > prev_buf_pos )
    efb4:	7823      	ldrb	r3, [r4, #0]
    efb6:	42ab      	cmp	r3, r5
    efb8:	d9d5      	bls.n	ef66 <CLI_process+0x36>
		switch ( CLILineBuffer[prev_buf_pos] )
    efba:	5d72      	ldrb	r2, [r6, r5]
    efbc:	2a0a      	cmp	r2, #10
    efbe:	d020      	beq.n	f002 <CLI_process+0xd2>
    efc0:	d818      	bhi.n	eff4 <CLI_process+0xc4>
    efc2:	2a08      	cmp	r2, #8
    efc4:	f000 80a0 	beq.w	f108 <CLI_process+0x1d8>
    efc8:	2a09      	cmp	r2, #9
    efca:	d04a      	beq.n	f062 <CLI_process+0x132>
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    efcc:	2200      	movs	r2, #0
			dPrint( &CLILineBuffer[prev_buf_pos] );
    efce:	1970      	adds	r0, r6, r5
			prev_buf_pos++;
    efd0:	3501      	adds	r5, #1
			CLILineBuffer[CLILineBufferCurrent] = '\0';
    efd2:	54f2      	strb	r2, [r6, r3]
			prev_buf_pos++;
    efd4:	b2ed      	uxtb	r5, r5
			dPrint( &CLILineBuffer[prev_buf_pos] );
    efd6:	f7fc ff43 	bl	be60 <Output_putstr>
			break;
    efda:	e7eb      	b.n	efb4 <CLI_process+0x84>
			printHex( CLILineBuffer[pos++] );
    efdc:	1c5e      	adds	r6, r3, #1
    efde:	f819 0003 	ldrb.w	r0, [r9, r3]
    efe2:	2101      	movs	r1, #1
    efe4:	f000 fbea 	bl	f7bc <printHex_op>
    efe8:	b2f6      	uxtb	r6, r6
			print(" ");
    efea:	4640      	mov	r0, r8
    efec:	f000 fac0 	bl	f570 <_print>
			printHex( CLILineBuffer[pos++] );
    eff0:	4633      	mov	r3, r6
    eff2:	e7d6      	b.n	efa2 <CLI_process+0x72>
		switch ( CLILineBuffer[prev_buf_pos] )
    eff4:	2a1b      	cmp	r2, #27
    eff6:	d03a      	beq.n	f06e <CLI_process+0x13e>
    eff8:	2a7f      	cmp	r2, #127	; 0x7f
    effa:	f000 8085 	beq.w	f108 <CLI_process+0x1d8>
    effe:	2a0d      	cmp	r2, #13
    f000:	d1e4      	bne.n	efcc <CLI_process+0x9c>
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    f002:	441e      	add	r6, r3
    f004:	2220      	movs	r2, #32
			if ( CLILineBufferCurrent == 1 )
    f006:	2b01      	cmp	r3, #1
			CLILineBuffer[CLILineBufferCurrent - 1] = ' '; // Replace Enter with a space (resolves a bug in args)
    f008:	f806 2c01 	strb.w	r2, [r6, #-1]
			if ( CLILineBufferCurrent == 1 )
    f00c:	d023      	beq.n	f056 <CLI_process+0x126>
				CLI_saveHistory( CLILineBuffer );
    f00e:	4847      	ldr	r0, [pc, #284]	; (f12c <CLI_process+0x1fc>)
    f010:	f7ff ff2c 	bl	ee6c <CLI_saveHistory>
				CLI_commandLookup();
    f014:	f7ff fdc8 	bl	eba8 <CLI_commandLookup>
				if ( CLIHistoryTail < CLIHistoryHead )
    f018:	4a4b      	ldr	r2, [pc, #300]	; (f148 <CLI_process+0x218>)
    f01a:	494c      	ldr	r1, [pc, #304]	; (f14c <CLI_process+0x21c>)
    f01c:	7813      	ldrb	r3, [r2, #0]
    f01e:	7808      	ldrb	r0, [r1, #0]
    f020:	4283      	cmp	r3, r0
    f022:	d206      	bcs.n	f032 <CLI_process+0x102>
					CLIHistoryHead = ( CLIHistoryHead + 1 ) % CLIMaxHistorySize;
    f024:	3001      	adds	r0, #1
    f026:	260a      	movs	r6, #10
    f028:	fb90 f5f6 	sdiv	r5, r0, r6
    f02c:	fb06 0015 	mls	r0, r6, r5, r0
    f030:	7008      	strb	r0, [r1, #0]
				CLIHistoryTail++;
    f032:	3301      	adds	r3, #1
    f034:	b2db      	uxtb	r3, r3
				if ( CLIHistoryTail == CLIMaxHistorySize )
    f036:	2b0a      	cmp	r3, #10
					CLIHistoryTail = 0;
    f038:	bf03      	ittte	eq
    f03a:	2300      	moveq	r3, #0
    f03c:	7013      	strbeq	r3, [r2, #0]
					CLIHistoryHead = 1;
    f03e:	2301      	moveq	r3, #1
				CLIHistoryTail++;
    f040:	7013      	strbne	r3, [r2, #0]
					CLIHistoryHead = 1;
    f042:	bf08      	it	eq
    f044:	700b      	strbeq	r3, [r1, #0]
				CLIHistoryCurrent = CLIHistoryTail; // 'Up' starts at the last item
    f046:	4b42      	ldr	r3, [pc, #264]	; (f150 <CLI_process+0x220>)
    f048:	7812      	ldrb	r2, [r2, #0]
    f04a:	701a      	strb	r2, [r3, #0]
		CLIHistoryBuffer[ CLIHistoryTail ][ 0 ] = '\0';
    f04c:	2364      	movs	r3, #100	; 0x64
    f04e:	4353      	muls	r3, r2
    f050:	4a40      	ldr	r2, [pc, #256]	; (f154 <CLI_process+0x224>)
    f052:	2100      	movs	r1, #0
    f054:	54d1      	strb	r1, [r2, r3]
			CLILineBufferCurrent = 0;
    f056:	2300      	movs	r3, #0
			print( NL );
    f058:	4835      	ldr	r0, [pc, #212]	; (f130 <CLI_process+0x200>)
			CLILineBufferCurrent = 0;
    f05a:	7023      	strb	r3, [r4, #0]
			print( NL );
    f05c:	f000 fa88 	bl	f570 <_print>
    f060:	e77f      	b.n	ef62 <CLI_process+0x32>
			CLI_tabCompletion();
    f062:	f7ff fe79 	bl	ed58 <CLI_tabCompletion>
			CLILineBufferCurrent--; // Remove the Tab
    f066:	7823      	ldrb	r3, [r4, #0]
    f068:	3b01      	subs	r3, #1
    f06a:	7023      	strb	r3, [r4, #0]
			return 0;
    f06c:	e77b      	b.n	ef66 <CLI_process+0x36>
			if ( CLILineBufferCurrent >= prev_buf_pos + 3
    f06e:	f105 0802 	add.w	r8, r5, #2
    f072:	4598      	cmp	r8, r3
    f074:	f6bf af77 	bge.w	ef66 <CLI_process+0x36>
				&& CLILineBuffer[ prev_buf_pos + 1] == 0x5B )
    f078:	1973      	adds	r3, r6, r5
    f07a:	785b      	ldrb	r3, [r3, #1]
    f07c:	2b5b      	cmp	r3, #91	; 0x5b
    f07e:	f47f af72 	bne.w	ef66 <CLI_process+0x36>
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x41 ) // Hist prev
    f082:	f816 3008 	ldrb.w	r3, [r6, r8]
    f086:	2b41      	cmp	r3, #65	; 0x41
    f088:	d121      	bne.n	f0ce <CLI_process+0x19e>
					if ( CLIHistoryCurrent == CLIHistoryTail )
    f08a:	4c31      	ldr	r4, [pc, #196]	; (f150 <CLI_process+0x220>)
    f08c:	4b2e      	ldr	r3, [pc, #184]	; (f148 <CLI_process+0x218>)
    f08e:	f994 2000 	ldrsb.w	r2, [r4]
    f092:	781b      	ldrb	r3, [r3, #0]
    f094:	429a      	cmp	r2, r3
    f096:	d104      	bne.n	f0a2 <CLI_process+0x172>
						CLILineBuffer[ prev_buf_pos ] = '\0';
    f098:	2300      	movs	r3, #0
						CLI_saveHistory( CLILineBuffer );
    f09a:	4824      	ldr	r0, [pc, #144]	; (f12c <CLI_process+0x1fc>)
						CLILineBuffer[ prev_buf_pos ] = '\0';
    f09c:	5573      	strb	r3, [r6, r5]
						CLI_saveHistory( CLILineBuffer );
    f09e:	f7ff fee5 	bl	ee6c <CLI_saveHistory>
					if ( RING_PREV( CLIHistoryCurrent ) != RING_PREV( CLIHistoryHead ) )
    f0a2:	f994 0000 	ldrsb.w	r0, [r4]
    f0a6:	2209      	movs	r2, #9
    f0a8:	2100      	movs	r1, #0
    f0aa:	3801      	subs	r0, #1
    f0ac:	f7ff febc 	bl	ee28 <CLI_wrap>
    f0b0:	4b26      	ldr	r3, [pc, #152]	; (f14c <CLI_process+0x21c>)
    f0b2:	4605      	mov	r5, r0
    f0b4:	7818      	ldrb	r0, [r3, #0]
    f0b6:	2209      	movs	r2, #9
    f0b8:	2100      	movs	r1, #0
    f0ba:	3801      	subs	r0, #1
    f0bc:	f7ff feb4 	bl	ee28 <CLI_wrap>
    f0c0:	4285      	cmp	r5, r0
						CLIHistoryCurrent = RING_PREV( CLIHistoryCurrent );
    f0c2:	bf18      	it	ne
    f0c4:	7025      	strbne	r5, [r4, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    f0c6:	f994 0000 	ldrsb.w	r0, [r4]
    f0ca:	f7ff ff03 	bl	eed4 <CLI_retreiveHistory>
				if ( CLILineBuffer[ prev_buf_pos + 2 ] == 0x42 ) // Hist next
    f0ce:	f816 3008 	ldrb.w	r3, [r6, r8]
    f0d2:	2b42      	cmp	r3, #66	; 0x42
    f0d4:	f47f af47 	bne.w	ef66 <CLI_process+0x36>
					if ( RING_NEXT( CLIHistoryCurrent ) != RING_NEXT( CLIHistoryTail ) )
    f0d8:	4c1d      	ldr	r4, [pc, #116]	; (f150 <CLI_process+0x220>)
    f0da:	f994 0000 	ldrsb.w	r0, [r4]
    f0de:	2209      	movs	r2, #9
    f0e0:	2100      	movs	r1, #0
    f0e2:	3001      	adds	r0, #1
    f0e4:	f7ff fea0 	bl	ee28 <CLI_wrap>
    f0e8:	4b17      	ldr	r3, [pc, #92]	; (f148 <CLI_process+0x218>)
    f0ea:	4605      	mov	r5, r0
    f0ec:	7818      	ldrb	r0, [r3, #0]
    f0ee:	2209      	movs	r2, #9
    f0f0:	2100      	movs	r1, #0
    f0f2:	3001      	adds	r0, #1
    f0f4:	f7ff fe98 	bl	ee28 <CLI_wrap>
    f0f8:	4285      	cmp	r5, r0
						CLIHistoryCurrent = RING_NEXT( CLIHistoryCurrent );
    f0fa:	bf18      	it	ne
    f0fc:	7025      	strbne	r5, [r4, #0]
					CLI_retreiveHistory( CLIHistoryCurrent );
    f0fe:	f994 0000 	ldrsb.w	r0, [r4]
    f102:	f7ff fee7 	bl	eed4 <CLI_retreiveHistory>
    f106:	e72e      	b.n	ef66 <CLI_process+0x36>
			if ( CLILineBufferCurrent > 0 )
    f108:	2b01      	cmp	r3, #1
    f10a:	d102      	bne.n	f112 <CLI_process+0x1e2>
			CLILineBufferCurrent--; // Remove the backspace
    f10c:	2300      	movs	r3, #0
    f10e:	7023      	strb	r3, [r4, #0]
    f110:	e750      	b.n	efb4 <CLI_process+0x84>
				CLILineBufferCurrent--;
    f112:	3b02      	subs	r3, #2
				print("\b \b");
    f114:	4640      	mov	r0, r8
				CLILineBufferCurrent--;
    f116:	7023      	strb	r3, [r4, #0]
				print("\b \b");
    f118:	f000 fa2a 	bl	f570 <_print>
    f11c:	e74a      	b.n	efb4 <CLI_process+0x84>
}
    f11e:	b003      	add	sp, #12
    f120:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    f124:	1fff89d0 	.word	0x1fff89d0
    f128:	1fff9ea8 	.word	0x1fff9ea8
    f12c:	1fff9dec 	.word	0x1fff9dec
    f130:	00015df4 	.word	0x00015df4
    f134:	00016565 	.word	0x00016565
    f138:	1fff9a00 	.word	0x1fff9a00
    f13c:	000165bc 	.word	0x000165bc
    f140:	000165c2 	.word	0x000165c2
    f144:	000165c7 	.word	0x000165c7
    f148:	1fff9e7c 	.word	0x1fff9e7c
    f14c:	1fff9e51 	.word	0x1fff9e51
    f150:	1fff9a01 	.word	0x1fff9a01
    f154:	1fff9a04 	.word	0x1fff9a04
    f158:	00016f5e 	.word	0x00016f5e
    f15c:	000165cb 	.word	0x000165cb

0000f160 <printLatency>:
{
    f160:	b537      	push	{r0, r1, r2, r4, r5, lr}
    f162:	4d22      	ldr	r5, [pc, #136]	; (f1ec <printLatency+0x8c>)
    f164:	682b      	ldr	r3, [r5, #0]
    f166:	9301      	str	r3, [sp, #4]
    f168:	4604      	mov	r4, r0
	printInt8( resource );
    f16a:	f000 fa6b 	bl	f644 <printInt8>
	print(":");
    f16e:	4820      	ldr	r0, [pc, #128]	; (f1f0 <printLatency+0x90>)
    f170:	f000 f9fe 	bl	f570 <_print>
	print( Latency_query_name( resource ) );
    f174:	4620      	mov	r0, r4
    f176:	f000 f913 	bl	f3a0 <Latency_query_name>
    f17a:	f000 f9f9 	bl	f570 <_print>
	print("\t");
    f17e:	481d      	ldr	r0, [pc, #116]	; (f1f4 <printLatency+0x94>)
    f180:	f000 f9f6 	bl	f570 <_print>
	printInt32( Latency_query( LatencyQuery_Count, resource ) );
    f184:	4621      	mov	r1, r4
    f186:	2004      	movs	r0, #4
    f188:	f000 f8d2 	bl	f330 <Latency_query>
    f18c:	f000 fac6 	bl	f71c <printInt32>
	print("\t");
    f190:	4818      	ldr	r0, [pc, #96]	; (f1f4 <printLatency+0x94>)
    f192:	f000 f9ed 	bl	f570 <_print>
	printInt32( Latency_query( LatencyQuery_Min, resource ) );
    f196:	4621      	mov	r1, r4
    f198:	2000      	movs	r0, #0
    f19a:	f000 f8c9 	bl	f330 <Latency_query>
    f19e:	f000 fabd 	bl	f71c <printInt32>
	print("\t");
    f1a2:	4814      	ldr	r0, [pc, #80]	; (f1f4 <printLatency+0x94>)
    f1a4:	f000 f9e4 	bl	f570 <_print>
	printInt32( Latency_query( LatencyQuery_Average, resource ) );
    f1a8:	4621      	mov	r1, r4
    f1aa:	2002      	movs	r0, #2
    f1ac:	f000 f8c0 	bl	f330 <Latency_query>
    f1b0:	f000 fab4 	bl	f71c <printInt32>
	print("\t");
    f1b4:	480f      	ldr	r0, [pc, #60]	; (f1f4 <printLatency+0x94>)
    f1b6:	f000 f9db 	bl	f570 <_print>
	printInt32( Latency_query( LatencyQuery_Last, resource ) );
    f1ba:	4621      	mov	r1, r4
    f1bc:	2003      	movs	r0, #3
    f1be:	f000 f8b7 	bl	f330 <Latency_query>
    f1c2:	f000 faab 	bl	f71c <printInt32>
	print("\t");
    f1c6:	480b      	ldr	r0, [pc, #44]	; (f1f4 <printLatency+0x94>)
    f1c8:	f000 f9d2 	bl	f570 <_print>
	printInt32( Latency_query( LatencyQuery_Max, resource ) );
    f1cc:	4621      	mov	r1, r4
    f1ce:	2001      	movs	r0, #1
    f1d0:	f000 f8ae 	bl	f330 <Latency_query>
    f1d4:	9a01      	ldr	r2, [sp, #4]
    f1d6:	682b      	ldr	r3, [r5, #0]
    f1d8:	429a      	cmp	r2, r3
    f1da:	d001      	beq.n	f1e0 <printLatency+0x80>
    f1dc:	f7f3 faa8 	bl	2730 <__stack_chk_fail>
}
    f1e0:	b003      	add	sp, #12
    f1e2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	printInt32( Latency_query( LatencyQuery_Max, resource ) );
    f1e6:	f000 ba99 	b.w	f71c <printInt32>
    f1ea:	bf00      	nop
    f1ec:	1fff89d0 	.word	0x1fff89d0
    f1f0:	00014d02 	.word	0x00014d02
    f1f4:	00011f60 	.word	0x00011f60

0000f1f8 <cliFunc_latency>:
{
    f1f8:	b5f0      	push	{r4, r5, r6, r7, lr}
    f1fa:	4e1c      	ldr	r6, [pc, #112]	; (f26c <cliFunc_latency+0x74>)
    f1fc:	b085      	sub	sp, #20
    f1fe:	6833      	ldr	r3, [r6, #0]
    f200:	9303      	str	r3, [sp, #12]
	CLI_argumentIsolation( args, &arg1Ptr, &arg2Ptr );
    f202:	aa02      	add	r2, sp, #8
    f204:	a901      	add	r1, sp, #4
    f206:	f7ff fc85 	bl	eb14 <CLI_argumentIsolation>
	print( NL );
    f20a:	4819      	ldr	r0, [pc, #100]	; (f270 <cliFunc_latency+0x78>)
    f20c:	f000 f9b0 	bl	f570 <_print>
	print("Latency" NL );
    f210:	4818      	ldr	r0, [pc, #96]	; (f274 <cliFunc_latency+0x7c>)
    f212:	f000 f9ad 	bl	f570 <_print>
	print("<i>:<module>\t<count>\t<min>\t<avg>\t<last>\t<max>");
    f216:	4818      	ldr	r0, [pc, #96]	; (f278 <cliFunc_latency+0x80>)
    f218:	f000 f9aa 	bl	f570 <_print>
	if ( arg1Ptr[0] == '\0' )
    f21c:	9b01      	ldr	r3, [sp, #4]
    f21e:	781c      	ldrb	r4, [r3, #0]
    f220:	b304      	cbz	r4, f264 <cliFunc_latency+0x6c>
		print( NL );
    f222:	4813      	ldr	r0, [pc, #76]	; (f270 <cliFunc_latency+0x78>)
    f224:	f000 f9a4 	bl	f570 <_print>
		if ( arg1Ptr[0] < Latency_resources() )
    f228:	9b01      	ldr	r3, [sp, #4]
    f22a:	781c      	ldrb	r4, [r3, #0]
    f22c:	f000 f842 	bl	f2b4 <Latency_resources>
    f230:	4284      	cmp	r4, r0
    f232:	d211      	bcs.n	f258 <cliFunc_latency+0x60>
			printLatency( arg1Ptr[0] );
    f234:	9b01      	ldr	r3, [sp, #4]
    f236:	7818      	ldrb	r0, [r3, #0]
    f238:	f7ff ff92 	bl	f160 <printLatency>
}
    f23c:	e00c      	b.n	f258 <cliFunc_latency+0x60>
			print( NL );
    f23e:	4638      	mov	r0, r7
    f240:	f000 f996 	bl	f570 <_print>
			printLatency( c );
    f244:	4628      	mov	r0, r5
    f246:	f7ff ff8b 	bl	f160 <printLatency>
		for ( uint8_t c = 0; c < Latency_resources(); c++ )
    f24a:	f000 f833 	bl	f2b4 <Latency_resources>
    f24e:	b2e5      	uxtb	r5, r4
    f250:	4285      	cmp	r5, r0
    f252:	f104 0401 	add.w	r4, r4, #1
    f256:	d3f2      	bcc.n	f23e <cliFunc_latency+0x46>
}
    f258:	9a03      	ldr	r2, [sp, #12]
    f25a:	6833      	ldr	r3, [r6, #0]
    f25c:	429a      	cmp	r2, r3
    f25e:	d003      	beq.n	f268 <cliFunc_latency+0x70>
    f260:	f7f3 fa66 	bl	2730 <__stack_chk_fail>
			print( NL );
    f264:	4f02      	ldr	r7, [pc, #8]	; (f270 <cliFunc_latency+0x78>)
    f266:	e7f0      	b.n	f24a <cliFunc_latency+0x52>
}
    f268:	b005      	add	sp, #20
    f26a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f26c:	1fff89d0 	.word	0x1fff89d0
    f270:	00015df4 	.word	0x00015df4
    f274:	000168e6 	.word	0x000168e6
    f278:	000168f0 	.word	0x000168f0

0000f27c <Latency_init>:
// ----- Functions -----

// Initialize latency module
// Call before adding resources
void Latency_init()
{
    f27c:	b513      	push	{r0, r1, r4, lr}
    f27e:	4c0a      	ldr	r4, [pc, #40]	; (f2a8 <Latency_init+0x2c>)
	// Zero out all measurements
	memset( &latency_measurements, 0, sizeof(LatencyMeasurement) * LatencyMeasurementCount_define );
    f280:	480a      	ldr	r0, [pc, #40]	; (f2ac <Latency_init+0x30>)
{
    f282:	6823      	ldr	r3, [r4, #0]
    f284:	9301      	str	r3, [sp, #4]
	memset( &latency_measurements, 0, sizeof(LatencyMeasurement) * LatencyMeasurementCount_define );
    f286:	f44f 72b4 	mov.w	r2, #360	; 0x168
    f28a:	2100      	movs	r1, #0
    f28c:	f7f3 fa5e 	bl	274c <memset>

	// Set used resources to 0
	latency_resources = 0;
    f290:	4b07      	ldr	r3, [pc, #28]	; (f2b0 <Latency_init+0x34>)
    f292:	2200      	movs	r2, #0
    f294:	701a      	strb	r2, [r3, #0]
}
    f296:	9a01      	ldr	r2, [sp, #4]
    f298:	6823      	ldr	r3, [r4, #0]
    f29a:	429a      	cmp	r2, r3
    f29c:	d001      	beq.n	f2a2 <Latency_init+0x26>
    f29e:	f7f3 fa47 	bl	2730 <__stack_chk_fail>
    f2a2:	b002      	add	sp, #8
    f2a4:	bd10      	pop	{r4, pc}
    f2a6:	bf00      	nop
    f2a8:	1fff89d0 	.word	0x1fff89d0
    f2ac:	1fff9894 	.word	0x1fff9894
    f2b0:	1fff99fc 	.word	0x1fff99fc

0000f2b4 <Latency_resources>:

// Number of latency resources used
uint8_t Latency_resources()
{
    f2b4:	b507      	push	{r0, r1, r2, lr}
    f2b6:	4b07      	ldr	r3, [pc, #28]	; (f2d4 <Latency_resources+0x20>)
    f2b8:	681a      	ldr	r2, [r3, #0]
    f2ba:	9201      	str	r2, [sp, #4]
	return latency_resources;
}
    f2bc:	4a06      	ldr	r2, [pc, #24]	; (f2d8 <Latency_resources+0x24>)
    f2be:	7810      	ldrb	r0, [r2, #0]
    f2c0:	9a01      	ldr	r2, [sp, #4]
    f2c2:	681b      	ldr	r3, [r3, #0]
    f2c4:	429a      	cmp	r2, r3
    f2c6:	d001      	beq.n	f2cc <Latency_resources+0x18>
    f2c8:	f7f3 fa32 	bl	2730 <__stack_chk_fail>
    f2cc:	b003      	add	sp, #12
    f2ce:	f85d fb04 	ldr.w	pc, [sp], #4
    f2d2:	bf00      	nop
    f2d4:	1fff89d0 	.word	0x1fff89d0
    f2d8:	1fff99fc 	.word	0x1fff99fc

0000f2dc <Latency_add_resource>:

// Add latency tracking resource
//
// return: resource index
uint8_t Latency_add_resource( const char* name, LatencyOption option )
{
    f2dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    f2de:	4a10      	ldr	r2, [pc, #64]	; (f320 <Latency_add_resource+0x44>)
	// Add identifier name
	uint8_t index = latency_resources++;
    f2e0:	4c10      	ldr	r4, [pc, #64]	; (f324 <Latency_add_resource+0x48>)
{
    f2e2:	6813      	ldr	r3, [r2, #0]
    f2e4:	9301      	str	r3, [sp, #4]
	uint8_t index = latency_resources++;
    f2e6:	7823      	ldrb	r3, [r4, #0]
    f2e8:	1c5d      	adds	r5, r3, #1

	// Make sure there are resources left to allocate
	if ( index >= LatencyMeasurementCount_define )
    f2ea:	2b09      	cmp	r3, #9
	uint8_t index = latency_resources++;
    f2ec:	7025      	strb	r5, [r4, #0]
    f2ee:	4614      	mov	r4, r2
	if ( index >= LatencyMeasurementCount_define )
    f2f0:	d90a      	bls.n	f308 <Latency_add_resource+0x2c>
	{
		erro_print("No more latency resources available...");
    f2f2:	480d      	ldr	r0, [pc, #52]	; (f328 <Latency_add_resource+0x4c>)
    f2f4:	f000 f93c 	bl	f570 <_print>
		return 0;
    f2f8:	2300      	movs	r3, #0

	// Max out min latency
	latency_measurements[index].min_latency = 0xFFFFFFFF;

	return index;
}
    f2fa:	9a01      	ldr	r2, [sp, #4]
    f2fc:	4618      	mov	r0, r3
    f2fe:	6823      	ldr	r3, [r4, #0]
    f300:	429a      	cmp	r2, r3
    f302:	d00b      	beq.n	f31c <Latency_add_resource+0x40>
    f304:	f7f3 fa14 	bl	2730 <__stack_chk_fail>
	latency_measurements[index].name = name;
    f308:	4e08      	ldr	r6, [pc, #32]	; (f32c <Latency_add_resource+0x50>)
    f30a:	2224      	movs	r2, #36	; 0x24
    f30c:	435a      	muls	r2, r3
    f30e:	18b5      	adds	r5, r6, r2
    f310:	50b0      	str	r0, [r6, r2]
	latency_measurements[index].min_latency = 0xFFFFFFFF;
    f312:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	latency_measurements[index].option = option;
    f316:	7329      	strb	r1, [r5, #12]
	latency_measurements[index].min_latency = 0xFFFFFFFF;
    f318:	612a      	str	r2, [r5, #16]
	return index;
    f31a:	e7ee      	b.n	f2fa <Latency_add_resource+0x1e>
}
    f31c:	b002      	add	sp, #8
    f31e:	bd70      	pop	{r4, r5, r6, pc}
    f320:	1fff89d0 	.word	0x1fff89d0
    f324:	1fff99fc 	.word	0x1fff99fc
    f328:	00017339 	.word	0x00017339
    f32c:	1fff9894 	.word	0x1fff9894

0000f330 <Latency_query>:
// type:     type of query
// resource: index of resource
//
// return: latency query result
uint32_t Latency_query( LatencyQuery type, uint8_t resource )
{
    f330:	b507      	push	{r0, r1, r2, lr}
    f332:	4b19      	ldr	r3, [pc, #100]	; (f398 <Latency_query+0x68>)
    f334:	681a      	ldr	r2, [r3, #0]
    f336:	9201      	str	r2, [sp, #4]
    f338:	461a      	mov	r2, r3
	switch ( type )
    f33a:	2804      	cmp	r0, #4
    f33c:	d827      	bhi.n	f38e <Latency_query+0x5e>
    f33e:	e8df f000 	tbb	[pc, r0]
    f342:	0e03      	.short	0x0e03
    f344:	1a14      	.short	0x1a14
    f346:	20          	.byte	0x20
    f347:	00          	.byte	0x00
	{
	case LatencyQuery_Min:
		return latency_measurements[resource].min_latency;
    f348:	4814      	ldr	r0, [pc, #80]	; (f39c <Latency_query+0x6c>)
    f34a:	2324      	movs	r3, #36	; 0x24
    f34c:	fb03 0101 	mla	r1, r3, r1, r0
    f350:	6908      	ldr	r0, [r1, #16]
		return latency_measurements[resource].count;

	default:
		return 0;
	}
}
    f352:	9901      	ldr	r1, [sp, #4]
    f354:	6813      	ldr	r3, [r2, #0]
    f356:	4299      	cmp	r1, r3
    f358:	d01b      	beq.n	f392 <Latency_query+0x62>
    f35a:	f7f3 f9e9 	bl	2730 <__stack_chk_fail>
		return latency_measurements[resource].max_latency;
    f35e:	480f      	ldr	r0, [pc, #60]	; (f39c <Latency_query+0x6c>)
    f360:	2324      	movs	r3, #36	; 0x24
    f362:	fb03 0101 	mla	r1, r3, r1, r0
    f366:	6948      	ldr	r0, [r1, #20]
    f368:	e7f3      	b.n	f352 <Latency_query+0x22>
		return latency_measurements[resource].average_latency;
    f36a:	480c      	ldr	r0, [pc, #48]	; (f39c <Latency_query+0x6c>)
    f36c:	2324      	movs	r3, #36	; 0x24
    f36e:	fb03 0101 	mla	r1, r3, r1, r0
    f372:	6988      	ldr	r0, [r1, #24]
    f374:	e7ed      	b.n	f352 <Latency_query+0x22>
		return latency_measurements[resource].last_latency;
    f376:	4809      	ldr	r0, [pc, #36]	; (f39c <Latency_query+0x6c>)
    f378:	2324      	movs	r3, #36	; 0x24
    f37a:	fb03 0101 	mla	r1, r3, r1, r0
    f37e:	69c8      	ldr	r0, [r1, #28]
    f380:	e7e7      	b.n	f352 <Latency_query+0x22>
		return latency_measurements[resource].count;
    f382:	4b06      	ldr	r3, [pc, #24]	; (f39c <Latency_query+0x6c>)
    f384:	2024      	movs	r0, #36	; 0x24
    f386:	fb00 3101 	mla	r1, r0, r1, r3
    f38a:	6a08      	ldr	r0, [r1, #32]
    f38c:	e7e1      	b.n	f352 <Latency_query+0x22>
		return 0;
    f38e:	2000      	movs	r0, #0
    f390:	e7df      	b.n	f352 <Latency_query+0x22>
}
    f392:	b003      	add	sp, #12
    f394:	f85d fb04 	ldr.w	pc, [sp], #4
    f398:	1fff89d0 	.word	0x1fff89d0
    f39c:	1fff9894 	.word	0x1fff9894

0000f3a0 <Latency_query_name>:
// Resource Lookup
// resource: index of resource
//
// return: Name of resource
const char* Latency_query_name( uint8_t resource )
{
    f3a0:	b507      	push	{r0, r1, r2, lr}
    f3a2:	4a08      	ldr	r2, [pc, #32]	; (f3c4 <Latency_query_name+0x24>)
    f3a4:	6813      	ldr	r3, [r2, #0]
    f3a6:	9301      	str	r3, [sp, #4]
	return latency_measurements[resource].name;
    f3a8:	2324      	movs	r3, #36	; 0x24
    f3aa:	4358      	muls	r0, r3
}
    f3ac:	4b06      	ldr	r3, [pc, #24]	; (f3c8 <Latency_query_name+0x28>)
    f3ae:	9901      	ldr	r1, [sp, #4]
    f3b0:	5818      	ldr	r0, [r3, r0]
    f3b2:	6813      	ldr	r3, [r2, #0]
    f3b4:	4299      	cmp	r1, r3
    f3b6:	d001      	beq.n	f3bc <Latency_query_name+0x1c>
    f3b8:	f7f3 f9ba 	bl	2730 <__stack_chk_fail>
    f3bc:	b003      	add	sp, #12
    f3be:	f85d fb04 	ldr.w	pc, [sp], #4
    f3c2:	bf00      	nop
    f3c4:	1fff89d0 	.word	0x1fff89d0
    f3c8:	1fff9894 	.word	0x1fff9894

0000f3cc <Latency_start_time>:

// Resource start time
//
// resource: index of resource
void Latency_start_time( uint8_t resource )
{
    f3cc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    f3ce:	4e0c      	ldr	r6, [pc, #48]	; (f400 <Latency_start_time+0x34>)
	latency_measurements[resource].start_time = Time_now();
    f3d0:	4c0c      	ldr	r4, [pc, #48]	; (f404 <Latency_start_time+0x38>)
{
    f3d2:	6833      	ldr	r3, [r6, #0]
    f3d4:	9303      	str	r3, [sp, #12]
	latency_measurements[resource].start_time = Time_now();
    f3d6:	466d      	mov	r5, sp
    f3d8:	2324      	movs	r3, #36	; 0x24
    f3da:	fb03 4400 	mla	r4, r3, r0, r4
    f3de:	4628      	mov	r0, r5
    f3e0:	f7f3 fc94 	bl	2d0c <Time_now>
    f3e4:	e895 0003 	ldmia.w	r5, {r0, r1}
    f3e8:	1d23      	adds	r3, r4, #4
}
    f3ea:	9a03      	ldr	r2, [sp, #12]
	latency_measurements[resource].start_time = Time_now();
    f3ec:	e883 0003 	stmia.w	r3, {r0, r1}
}
    f3f0:	6833      	ldr	r3, [r6, #0]
    f3f2:	429a      	cmp	r2, r3
    f3f4:	d001      	beq.n	f3fa <Latency_start_time+0x2e>
    f3f6:	f7f3 f99b 	bl	2730 <__stack_chk_fail>
    f3fa:	b004      	add	sp, #16
    f3fc:	bd70      	pop	{r4, r5, r6, pc}
    f3fe:	bf00      	nop
    f400:	1fff89d0 	.word	0x1fff89d0
    f404:	1fff9894 	.word	0x1fff9894

0000f408 <Latency_end_time>:

// Measure latency, and store
//
// resource: index of resource
void Latency_end_time( uint8_t resource )
{
    f408:	b573      	push	{r0, r1, r4, r5, r6, lr}
    f40a:	4d26      	ldr	r5, [pc, #152]	; (f4a4 <Latency_end_time+0x9c>)
	uint32_t measured;
	switch ( latency_measurements[resource].option )
    f40c:	4e26      	ldr	r6, [pc, #152]	; (f4a8 <Latency_end_time+0xa0>)
{
    f40e:	682b      	ldr	r3, [r5, #0]
    f410:	9301      	str	r3, [sp, #4]
	switch ( latency_measurements[resource].option )
    f412:	2324      	movs	r3, #36	; 0x24
    f414:	fb03 6300 	mla	r3, r3, r0, r6
{
    f418:	4604      	mov	r4, r0
	switch ( latency_measurements[resource].option )
    f41a:	7b1a      	ldrb	r2, [r3, #12]
    f41c:	2a02      	cmp	r2, #2
    f41e:	f103 0304 	add.w	r3, r3, #4
    f422:	d033      	beq.n	f48c <Latency_end_time+0x84>
    f424:	2a03      	cmp	r2, #3
    f426:	d006      	beq.n	f436 <Latency_end_time+0x2e>
    f428:	2a01      	cmp	r2, #1
    f42a:	d134      	bne.n	f496 <Latency_end_time+0x8e>
	case LatencyOption_us:
		measured = Time_duration_us( latency_measurements[resource].start_time );
		break;

	case LatencyOption_ns:
		measured = Time_duration_ns( latency_measurements[resource].start_time );
    f42c:	e893 0003 	ldmia.w	r3, {r0, r1}
    f430:	f7f3 fdf4 	bl	301c <Time_duration_ns>
		break;
    f434:	e003      	b.n	f43e <Latency_end_time+0x36>
		measured = Time_duration_ms( latency_measurements[resource].start_time );
    f436:	e893 0003 	ldmia.w	r3, {r0, r1}
    f43a:	f7f3 fdb9 	bl	2fb0 <Time_duration_ms>
		measured = Time_duration_ticks( latency_measurements[resource].start_time );
		break;
	}

	// Check if min or max latencies need to change
	if ( measured < latency_measurements[resource].min_latency )
    f43e:	2224      	movs	r2, #36	; 0x24
    f440:	fb02 6304 	mla	r3, r2, r4, r6
	{
		latency_measurements[resource].min_latency = measured;
	}
	if ( measured > latency_measurements[resource].max_latency )
    f444:	fb02 6204 	mla	r2, r2, r4, r6
	if ( measured < latency_measurements[resource].min_latency )
    f448:	6919      	ldr	r1, [r3, #16]
    f44a:	4281      	cmp	r1, r0
		latency_measurements[resource].min_latency = measured;
    f44c:	bf88      	it	hi
    f44e:	6118      	strhi	r0, [r3, #16]
	if ( measured > latency_measurements[resource].max_latency )
    f450:	6953      	ldr	r3, [r2, #20]
    f452:	4283      	cmp	r3, r0
	{
		latency_measurements[resource].max_latency = measured;
	}

	// Calculate average, places emphasis on recent values
	uint32_t old_avg = latency_measurements[resource].average_latency;
    f454:	f04f 0324 	mov.w	r3, #36	; 0x24
    f458:	fb03 6304 	mla	r3, r3, r4, r6
		latency_measurements[resource].max_latency = measured;
    f45c:	bf38      	it	cc
    f45e:	6150      	strcc	r0, [r2, #20]
	uint32_t old_avg = latency_measurements[resource].average_latency;
    f460:	6999      	ldr	r1, [r3, #24]
	if ( old_avg == 0 )
	{
		// Use measured value if this is the first calculation
		old_avg = measured;
	}
	latency_measurements[resource].average_latency = ( old_avg / 2 ) + ( measured / 2 ) + ( old_avg & measured & 1 );
    f462:	f000 0201 	and.w	r2, r0, #1
	if ( old_avg == 0 )
    f466:	2900      	cmp	r1, #0
    f468:	bf08      	it	eq
    f46a:	4601      	moveq	r1, r0
	latency_measurements[resource].average_latency = ( old_avg / 2 ) + ( measured / 2 ) + ( old_avg & measured & 1 );
    f46c:	400a      	ands	r2, r1
    f46e:	eb02 0251 	add.w	r2, r2, r1, lsr #1
    f472:	eb02 0250 	add.w	r2, r2, r0, lsr #1

	// Set last average
	latency_measurements[resource].last_latency = measured;
    f476:	e9c3 2006 	strd	r2, r0, [r3, #24]

	// Latency check count
	latency_measurements[resource].count++;
    f47a:	6a1a      	ldr	r2, [r3, #32]
    f47c:	3201      	adds	r2, #1
    f47e:	621a      	str	r2, [r3, #32]
}
    f480:	9a01      	ldr	r2, [sp, #4]
    f482:	682b      	ldr	r3, [r5, #0]
    f484:	429a      	cmp	r2, r3
    f486:	d00b      	beq.n	f4a0 <Latency_end_time+0x98>
    f488:	f7f3 f952 	bl	2730 <__stack_chk_fail>
		measured = Time_duration_us( latency_measurements[resource].start_time );
    f48c:	e893 0003 	ldmia.w	r3, {r0, r1}
    f490:	f7f3 fda6 	bl	2fe0 <Time_duration_us>
		break;
    f494:	e7d3      	b.n	f43e <Latency_end_time+0x36>
		measured = Time_duration_ticks( latency_measurements[resource].start_time );
    f496:	e893 0003 	ldmia.w	r3, {r0, r1}
    f49a:	f7f3 fddd 	bl	3058 <Time_duration_ticks>
		break;
    f49e:	e7ce      	b.n	f43e <Latency_end_time+0x36>
}
    f4a0:	b002      	add	sp, #8
    f4a2:	bd70      	pop	{r4, r5, r6, pc}
    f4a4:	1fff89d0 	.word	0x1fff89d0
    f4a8:	1fff9894 	.word	0x1fff9894

0000f4ac <init_errorLED>:

// ----- Functions -----

// Error LED Setup
inline void init_errorLED()
{
    f4ac:	b507      	push	{r0, r1, r2, lr}
    f4ae:	4b0a      	ldr	r3, [pc, #40]	; (f4d8 <init_errorLED+0x2c>)
    f4b0:	681a      	ldr	r2, [r3, #0]
    f4b2:	9201      	str	r2, [sp, #4]
	// Enable output
	GPIO_Ctrl( led_pin, GPIO_Type_DriveSetup, GPIO_Config_None );
    f4b4:	9a01      	ldr	r2, [sp, #4]
    f4b6:	681b      	ldr	r3, [r3, #0]
    f4b8:	429a      	cmp	r2, r3
    f4ba:	d001      	beq.n	f4c0 <init_errorLED+0x14>
    f4bc:	f7f3 f938 	bl	2730 <__stack_chk_fail>
    f4c0:	4b06      	ldr	r3, [pc, #24]	; (f4dc <init_errorLED+0x30>)
    f4c2:	7818      	ldrb	r0, [r3, #0]
    f4c4:	785b      	ldrb	r3, [r3, #1]
    f4c6:	2200      	movs	r2, #0
    f4c8:	2103      	movs	r1, #3
    f4ca:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
}
    f4ce:	b003      	add	sp, #12
    f4d0:	f85d eb04 	ldr.w	lr, [sp], #4
	GPIO_Ctrl( led_pin, GPIO_Type_DriveSetup, GPIO_Config_None );
    f4d4:	f7f3 bb18 	b.w	2b08 <GPIO_Ctrl>
    f4d8:	1fff89d0 	.word	0x1fff89d0
    f4dc:	00017377 	.word	0x00017377

0000f4e0 <errorLED>:

// Error LED Control
inline void errorLED( uint8_t on )
{
    f4e0:	b507      	push	{r0, r1, r2, lr}
    f4e2:	490f      	ldr	r1, [pc, #60]	; (f520 <errorLED+0x40>)
    f4e4:	680b      	ldr	r3, [r1, #0]
    f4e6:	9301      	str	r3, [sp, #4]
	// Error LED On
	if (on)
    f4e8:	4602      	mov	r2, r0
    f4ea:	4b0e      	ldr	r3, [pc, #56]	; (f524 <errorLED+0x44>)
	{
		GPIO_Ctrl( led_pin, GPIO_Type_DriveHigh, GPIO_Config_None );
    f4ec:	9801      	ldr	r0, [sp, #4]
	if (on)
    f4ee:	b17a      	cbz	r2, f510 <errorLED+0x30>
		GPIO_Ctrl( led_pin, GPIO_Type_DriveHigh, GPIO_Config_None );
    f4f0:	680a      	ldr	r2, [r1, #0]
    f4f2:	4290      	cmp	r0, r2
    f4f4:	d001      	beq.n	f4fa <errorLED+0x1a>
	}
	// Error LED Off
	else
	{
		GPIO_Ctrl( led_pin, GPIO_Type_DriveLow, GPIO_Config_None );
    f4f6:	f7f3 f91b 	bl	2730 <__stack_chk_fail>
		GPIO_Ctrl( led_pin, GPIO_Type_DriveHigh, GPIO_Config_None );
    f4fa:	7818      	ldrb	r0, [r3, #0]
    f4fc:	785b      	ldrb	r3, [r3, #1]
    f4fe:	2200      	movs	r2, #0
    f500:	4611      	mov	r1, r2
		GPIO_Ctrl( led_pin, GPIO_Type_DriveLow, GPIO_Config_None );
    f502:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
	}
}
    f506:	b003      	add	sp, #12
    f508:	f85d eb04 	ldr.w	lr, [sp], #4
		GPIO_Ctrl( led_pin, GPIO_Type_DriveLow, GPIO_Config_None );
    f50c:	f7f3 bafc 	b.w	2b08 <GPIO_Ctrl>
    f510:	6809      	ldr	r1, [r1, #0]
    f512:	4288      	cmp	r0, r1
    f514:	d1ef      	bne.n	f4f6 <errorLED+0x16>
    f516:	7818      	ldrb	r0, [r3, #0]
    f518:	785b      	ldrb	r3, [r3, #1]
    f51a:	2101      	movs	r1, #1
    f51c:	e7f1      	b.n	f502 <errorLED+0x22>
    f51e:	bf00      	nop
    f520:	1fff89d0 	.word	0x1fff89d0
    f524:	00017377 	.word	0x00017377

0000f528 <printstrs>:

// ----- Functions -----

// Multiple string Output
void printstrs( char* first, ... )
{
    f528:	b40f      	push	{r0, r1, r2, r3}
    f52a:	b513      	push	{r0, r1, r4, lr}
    f52c:	4c0f      	ldr	r4, [pc, #60]	; (f56c <printstrs+0x44>)
    f52e:	aa04      	add	r2, sp, #16
    f530:	6821      	ldr	r1, [r4, #0]
    f532:	f852 0b04 	ldr.w	r0, [r2], #4
    f536:	9101      	str	r1, [sp, #4]
	// Initialize the variadic function parameter list
	va_list ap;

	// Get the first parameter
	va_start( ap, first );
    f538:	9200      	str	r2, [sp, #0]
	char *cur = first;

	// Loop through the variadic list until "\0\0\0" is found
	while ( !( cur[0] == '\0' && cur[1] == '\0' && cur[2] == '\0' ) )
    f53a:	7803      	ldrb	r3, [r0, #0]
    f53c:	b94b      	cbnz	r3, f552 <printstrs+0x2a>
    f53e:	7843      	ldrb	r3, [r0, #1]
    f540:	b93b      	cbnz	r3, f552 <printstrs+0x2a>
    f542:	7883      	ldrb	r3, [r0, #2]
    f544:	b92b      	cbnz	r3, f552 <printstrs+0x2a>
		// Get the next argument ready
		cur = va_arg( ap, char* );
	}

	va_end( ap ); // Not required, but good practice
}
    f546:	9a01      	ldr	r2, [sp, #4]
    f548:	6823      	ldr	r3, [r4, #0]
    f54a:	429a      	cmp	r2, r3
    f54c:	d008      	beq.n	f560 <printstrs+0x38>
    f54e:	f7f3 f8ef 	bl	2730 <__stack_chk_fail>
		Output_putstr( cur );
    f552:	f7fc fc85 	bl	be60 <Output_putstr>
		cur = va_arg( ap, char* );
    f556:	9b00      	ldr	r3, [sp, #0]
    f558:	1d1a      	adds	r2, r3, #4
    f55a:	9200      	str	r2, [sp, #0]
    f55c:	6818      	ldr	r0, [r3, #0]
    f55e:	e7ec      	b.n	f53a <printstrs+0x12>
}
    f560:	b002      	add	sp, #8
    f562:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f566:	b004      	add	sp, #16
    f568:	4770      	bx	lr
    f56a:	bf00      	nop
    f56c:	1fff89d0 	.word	0x1fff89d0

0000f570 <_print>:

// Print a constant string
void _print( const char* s )
{
    f570:	b507      	push	{r0, r1, r2, lr}
    f572:	4b07      	ldr	r3, [pc, #28]	; (f590 <_print+0x20>)
    f574:	681a      	ldr	r2, [r3, #0]
    f576:	9201      	str	r2, [sp, #4]
	while ( ( c = pgm_read_byte( s++ ) ) != '\0' )
	{
		Output_putchar( c );
	}
#elif defined(_kinetis_) || defined(_sam_) // ARM
	Output_putstr( (char*)s );
    f578:	9a01      	ldr	r2, [sp, #4]
    f57a:	681b      	ldr	r3, [r3, #0]
    f57c:	429a      	cmp	r2, r3
    f57e:	d001      	beq.n	f584 <_print+0x14>
    f580:	f7f3 f8d6 	bl	2730 <__stack_chk_fail>
#elif defined(_host_) // Host
	Output_putstr( (char*)s );
#endif
}
    f584:	b003      	add	sp, #12
    f586:	f85d eb04 	ldr.w	lr, [sp], #4
	Output_putstr( (char*)s );
    f58a:	f7fc bc69 	b.w	be60 <Output_putstr>
    f58e:	bf00      	nop
    f590:	1fff89d0 	.word	0x1fff89d0

0000f594 <lenStr>:
	}
}


uint16_t lenStr( char* in )
{
    f594:	b513      	push	{r0, r1, r4, lr}
    f596:	4a09      	ldr	r2, [pc, #36]	; (f5bc <lenStr+0x28>)
    f598:	6813      	ldr	r3, [r2, #0]
    f59a:	9301      	str	r3, [sp, #4]
    f59c:	4603      	mov	r3, r0
	// Iterator
	char *pos;

	// Loop until null is found
	for ( pos = in; *pos; pos++ );
    f59e:	7819      	ldrb	r1, [r3, #0]
    f5a0:	1c5c      	adds	r4, r3, #1
    f5a2:	b939      	cbnz	r1, f5b4 <lenStr+0x20>

	// Return the difference between the pointers of in and pos (which is the string length)
	return (pos - in);
    f5a4:	1a18      	subs	r0, r3, r0
}
    f5a6:	9901      	ldr	r1, [sp, #4]
    f5a8:	6813      	ldr	r3, [r2, #0]
    f5aa:	4299      	cmp	r1, r3
    f5ac:	b280      	uxth	r0, r0
    f5ae:	d003      	beq.n	f5b8 <lenStr+0x24>
    f5b0:	f7f3 f8be 	bl	2730 <__stack_chk_fail>
    f5b4:	4623      	mov	r3, r4
    f5b6:	e7f2      	b.n	f59e <lenStr+0xa>
    f5b8:	b002      	add	sp, #8
    f5ba:	bd10      	pop	{r4, pc}
    f5bc:	1fff89d0 	.word	0x1fff89d0

0000f5c0 <revsStr>:
{
    f5c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    f5c2:	4c0e      	ldr	r4, [pc, #56]	; (f5fc <revsStr+0x3c>)
    f5c4:	6823      	ldr	r3, [r4, #0]
    f5c6:	9301      	str	r3, [sp, #4]
    f5c8:	4605      	mov	r5, r0
	for ( i = 0, j = lenStr( in ) - 1; i < j; i++, j-- )
    f5ca:	f7ff ffe3 	bl	f594 <lenStr>
    f5ce:	3801      	subs	r0, #1
    f5d0:	4428      	add	r0, r5
    f5d2:	462b      	mov	r3, r5
    f5d4:	1b5a      	subs	r2, r3, r5
    f5d6:	1b41      	subs	r1, r0, r5
    f5d8:	428a      	cmp	r2, r1
    f5da:	db05      	blt.n	f5e8 <revsStr+0x28>
}
    f5dc:	9a01      	ldr	r2, [sp, #4]
    f5de:	6823      	ldr	r3, [r4, #0]
    f5e0:	429a      	cmp	r2, r3
    f5e2:	d008      	beq.n	f5f6 <revsStr+0x36>
    f5e4:	f7f3 f8a4 	bl	2730 <__stack_chk_fail>
		c = in[i];
    f5e8:	781a      	ldrb	r2, [r3, #0]
		in[i] = in[j];
    f5ea:	7801      	ldrb	r1, [r0, #0]
    f5ec:	f803 1b01 	strb.w	r1, [r3], #1
		in[j] = c;
    f5f0:	f800 2901 	strb.w	r2, [r0], #-1
    f5f4:	e7ee      	b.n	f5d4 <revsStr+0x14>
}
    f5f6:	b003      	add	sp, #12
    f5f8:	bd30      	pop	{r4, r5, pc}
    f5fa:	bf00      	nop
    f5fc:	1fff89d0 	.word	0x1fff89d0

0000f600 <int8ToStr>:
{
    f600:	b573      	push	{r0, r1, r4, r5, r6, lr}
    f602:	4a0f      	ldr	r2, [pc, #60]	; (f640 <int8ToStr+0x40>)
    f604:	4603      	mov	r3, r0
    f606:	6810      	ldr	r0, [r2, #0]
    f608:	9001      	str	r0, [sp, #4]
	pos = 0;
    f60a:	2400      	movs	r4, #0
		out[pos++] = in % 10 + '0';
    f60c:	250a      	movs	r5, #10
    f60e:	fbb3 f0f5 	udiv	r0, r3, r5
    f612:	fb05 3310 	mls	r3, r5, r0, r3
    f616:	3330      	adds	r3, #48	; 0x30
    f618:	550b      	strb	r3, [r1, r4]
    f61a:	1c66      	adds	r6, r4, #1
	while ( (in /= 10) > 0 );
    f61c:	f010 03ff 	ands.w	r3, r0, #255	; 0xff
		out[pos++] = in % 10 + '0';
    f620:	b2f4      	uxtb	r4, r6
	while ( (in /= 10) > 0 );
    f622:	d1f4      	bne.n	f60e <int8ToStr+0xe>
	out[pos] = '\0';
    f624:	550b      	strb	r3, [r1, r4]
	revsStr(out);
    f626:	9801      	ldr	r0, [sp, #4]
    f628:	6813      	ldr	r3, [r2, #0]
    f62a:	4298      	cmp	r0, r3
    f62c:	d001      	beq.n	f632 <int8ToStr+0x32>
    f62e:	f7f3 f87f 	bl	2730 <__stack_chk_fail>
    f632:	4608      	mov	r0, r1
}
    f634:	b002      	add	sp, #8
    f636:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	revsStr(out);
    f63a:	f7ff bfc1 	b.w	f5c0 <revsStr>
    f63e:	bf00      	nop
    f640:	1fff89d0 	.word	0x1fff89d0

0000f644 <printInt8>:
{
    f644:	b513      	push	{r0, r1, r4, lr}
    f646:	4c08      	ldr	r4, [pc, #32]	; (f668 <printInt8+0x24>)
	int8ToStr( in, tmpStr );
    f648:	4669      	mov	r1, sp
{
    f64a:	6823      	ldr	r3, [r4, #0]
    f64c:	9301      	str	r3, [sp, #4]
	int8ToStr( in, tmpStr );
    f64e:	f7ff ffd7 	bl	f600 <int8ToStr>
	dPrintStr( tmpStr );
    f652:	4668      	mov	r0, sp
    f654:	f7fc fc04 	bl	be60 <Output_putstr>
}
    f658:	9a01      	ldr	r2, [sp, #4]
    f65a:	6823      	ldr	r3, [r4, #0]
    f65c:	429a      	cmp	r2, r3
    f65e:	d001      	beq.n	f664 <printInt8+0x20>
    f660:	f7f3 f866 	bl	2730 <__stack_chk_fail>
    f664:	b002      	add	sp, #8
    f666:	bd10      	pop	{r4, pc}
    f668:	1fff89d0 	.word	0x1fff89d0

0000f66c <int16ToStr>:
{
    f66c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    f66e:	4a0f      	ldr	r2, [pc, #60]	; (f6ac <int16ToStr+0x40>)
    f670:	4603      	mov	r3, r0
    f672:	6810      	ldr	r0, [r2, #0]
    f674:	9001      	str	r0, [sp, #4]
	pos = 0;
    f676:	2400      	movs	r4, #0
		out[pos++] = in % 10 + '0';
    f678:	250a      	movs	r5, #10
    f67a:	fbb3 f0f5 	udiv	r0, r3, r5
    f67e:	fb05 3310 	mls	r3, r5, r0, r3
    f682:	3330      	adds	r3, #48	; 0x30
    f684:	550b      	strb	r3, [r1, r4]
    f686:	1c66      	adds	r6, r4, #1
	while ( (in /= 10) > 0 );
    f688:	b283      	uxth	r3, r0
		out[pos++] = in % 10 + '0';
    f68a:	b2b4      	uxth	r4, r6
	while ( (in /= 10) > 0 );
    f68c:	2b00      	cmp	r3, #0
    f68e:	d1f4      	bne.n	f67a <int16ToStr+0xe>
	out[pos] = '\0';
    f690:	550b      	strb	r3, [r1, r4]
	revsStr(out);
    f692:	9801      	ldr	r0, [sp, #4]
    f694:	6813      	ldr	r3, [r2, #0]
    f696:	4298      	cmp	r0, r3
    f698:	d001      	beq.n	f69e <int16ToStr+0x32>
    f69a:	f7f3 f849 	bl	2730 <__stack_chk_fail>
    f69e:	4608      	mov	r0, r1
}
    f6a0:	b002      	add	sp, #8
    f6a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	revsStr(out);
    f6a6:	f7ff bf8b 	b.w	f5c0 <revsStr>
    f6aa:	bf00      	nop
    f6ac:	1fff89d0 	.word	0x1fff89d0

0000f6b0 <printInt16>:
{
    f6b0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    f6b2:	4c08      	ldr	r4, [pc, #32]	; (f6d4 <printInt16+0x24>)
	int16ToStr( in, tmpStr );
    f6b4:	a901      	add	r1, sp, #4
{
    f6b6:	6823      	ldr	r3, [r4, #0]
    f6b8:	9303      	str	r3, [sp, #12]
	int16ToStr( in, tmpStr );
    f6ba:	f7ff ffd7 	bl	f66c <int16ToStr>
	dPrintStr( tmpStr );
    f6be:	a801      	add	r0, sp, #4
    f6c0:	f7fc fbce 	bl	be60 <Output_putstr>
}
    f6c4:	9a03      	ldr	r2, [sp, #12]
    f6c6:	6823      	ldr	r3, [r4, #0]
    f6c8:	429a      	cmp	r2, r3
    f6ca:	d001      	beq.n	f6d0 <printInt16+0x20>
    f6cc:	f7f3 f830 	bl	2730 <__stack_chk_fail>
    f6d0:	b004      	add	sp, #16
    f6d2:	bd10      	pop	{r4, pc}
    f6d4:	1fff89d0 	.word	0x1fff89d0

0000f6d8 <int32ToStr>:
{
    f6d8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    f6da:	4a0f      	ldr	r2, [pc, #60]	; (f718 <int32ToStr+0x40>)
    f6dc:	4603      	mov	r3, r0
    f6de:	6810      	ldr	r0, [r2, #0]
    f6e0:	9001      	str	r0, [sp, #4]
    f6e2:	1e4d      	subs	r5, r1, #1
	pos = 0;
    f6e4:	2000      	movs	r0, #0
		out[pos++] = in % 10 + '0';
    f6e6:	260a      	movs	r6, #10
    f6e8:	fbb3 f4f6 	udiv	r4, r3, r6
    f6ec:	fb06 3314 	mls	r3, r6, r4, r3
    f6f0:	3330      	adds	r3, #48	; 0x30
    f6f2:	f805 3f01 	strb.w	r3, [r5, #1]!
    f6f6:	3001      	adds	r0, #1
	while ( (in /= 10) > 0 );
    f6f8:	4623      	mov	r3, r4
    f6fa:	2c00      	cmp	r4, #0
    f6fc:	d1f4      	bne.n	f6e8 <int32ToStr+0x10>
	out[pos] = '\0';
    f6fe:	540c      	strb	r4, [r1, r0]
	revsStr(out);
    f700:	9801      	ldr	r0, [sp, #4]
    f702:	6813      	ldr	r3, [r2, #0]
    f704:	4298      	cmp	r0, r3
    f706:	d001      	beq.n	f70c <int32ToStr+0x34>
    f708:	f7f3 f812 	bl	2730 <__stack_chk_fail>
    f70c:	4608      	mov	r0, r1
}
    f70e:	b002      	add	sp, #8
    f710:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	revsStr(out);
    f714:	f7ff bf54 	b.w	f5c0 <revsStr>
    f718:	1fff89d0 	.word	0x1fff89d0

0000f71c <printInt32>:
{
    f71c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    f71e:	4c08      	ldr	r4, [pc, #32]	; (f740 <printInt32+0x24>)
	int32ToStr( in, tmpStr );
    f720:	4669      	mov	r1, sp
{
    f722:	6823      	ldr	r3, [r4, #0]
    f724:	9303      	str	r3, [sp, #12]
	int32ToStr( in, tmpStr );
    f726:	f7ff ffd7 	bl	f6d8 <int32ToStr>
	dPrintStr( tmpStr );
    f72a:	4668      	mov	r0, sp
    f72c:	f7fc fb98 	bl	be60 <Output_putstr>
}
    f730:	9a03      	ldr	r2, [sp, #12]
    f732:	6823      	ldr	r3, [r4, #0]
    f734:	429a      	cmp	r2, r3
    f736:	d001      	beq.n	f73c <printInt32+0x20>
    f738:	f7f2 fffa 	bl	2730 <__stack_chk_fail>
    f73c:	b004      	add	sp, #16
    f73e:	bd10      	pop	{r4, pc}
    f740:	1fff89d0 	.word	0x1fff89d0

0000f744 <hexToStr_op>:
{
    f744:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    f746:	4e1c      	ldr	r6, [pc, #112]	; (f7b8 <hexToStr_op+0x74>)
    f748:	6834      	ldr	r4, [r6, #0]
    f74a:	9401      	str	r4, [sp, #4]
	uint16_t pos = 0;
    f74c:	2400      	movs	r4, #0
		uint16_t cur = in % 16;
    f74e:	f000 050f 	and.w	r5, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    f752:	2d09      	cmp	r5, #9
    f754:	bf8c      	ite	hi
    f756:	2737      	movhi	r7, #55	; 0x37
    f758:	2730      	movls	r7, #48	; 0x30
    f75a:	1c63      	adds	r3, r4, #1
    f75c:	443d      	add	r5, r7
	while ( (in /= 16) > 0 );
    f75e:	0900      	lsrs	r0, r0, #4
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    f760:	b29b      	uxth	r3, r3
    f762:	550d      	strb	r5, [r1, r4]
	while ( (in /= 16) > 0 );
    f764:	d115      	bne.n	f792 <hexToStr_op+0x4e>
	switch ( op )
    f766:	2a02      	cmp	r2, #2
    f768:	d015      	beq.n	f796 <hexToStr_op+0x52>
    f76a:	2a04      	cmp	r2, #4
    f76c:	d013      	beq.n	f796 <hexToStr_op+0x52>
    f76e:	2a01      	cmp	r2, #1
    f770:	d107      	bne.n	f782 <hexToStr_op+0x3e>
		out[pos++] = 'x';
    f772:	2278      	movs	r2, #120	; 0x78
    f774:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    f776:	1ce3      	adds	r3, r4, #3
		out[pos++] = 'x';
    f778:	3402      	adds	r4, #2
		out[pos++] = '0';
    f77a:	b2a4      	uxth	r4, r4
    f77c:	2230      	movs	r2, #48	; 0x30
    f77e:	550a      	strb	r2, [r1, r4]
    f780:	b29b      	uxth	r3, r3
	out[pos] = '\0';
    f782:	2200      	movs	r2, #0
    f784:	54ca      	strb	r2, [r1, r3]
	revsStr(out);
    f786:	9a01      	ldr	r2, [sp, #4]
    f788:	6833      	ldr	r3, [r6, #0]
    f78a:	429a      	cmp	r2, r3
    f78c:	d00e      	beq.n	f7ac <hexToStr_op+0x68>
    f78e:	f7f2 ffcf 	bl	2730 <__stack_chk_fail>
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    f792:	461c      	mov	r4, r3
    f794:	e7db      	b.n	f74e <hexToStr_op+0xa>
    f796:	1e58      	subs	r0, r3, #1
    f798:	4408      	add	r0, r1
		while ( pos < op )
    f79a:	b292      	uxth	r2, r2
			out[pos++] = '0';
    f79c:	2430      	movs	r4, #48	; 0x30
		while ( pos < op )
    f79e:	429a      	cmp	r2, r3
    f7a0:	d9ef      	bls.n	f782 <hexToStr_op+0x3e>
			out[pos++] = '0';
    f7a2:	3301      	adds	r3, #1
    f7a4:	b29b      	uxth	r3, r3
    f7a6:	f800 4f01 	strb.w	r4, [r0, #1]!
    f7aa:	e7f8      	b.n	f79e <hexToStr_op+0x5a>
	revsStr(out);
    f7ac:	4608      	mov	r0, r1
}
    f7ae:	b003      	add	sp, #12
    f7b0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	revsStr(out);
    f7b4:	f7ff bf04 	b.w	f5c0 <revsStr>
    f7b8:	1fff89d0 	.word	0x1fff89d0

0000f7bc <printHex_op>:
{
    f7bc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    f7be:	4c09      	ldr	r4, [pc, #36]	; (f7e4 <printHex_op+0x28>)
	hexToStr_op( in, tmpStr, op );
    f7c0:	460a      	mov	r2, r1
{
    f7c2:	6823      	ldr	r3, [r4, #0]
    f7c4:	9303      	str	r3, [sp, #12]
	hexToStr_op( in, tmpStr, op );
    f7c6:	a901      	add	r1, sp, #4
    f7c8:	f7ff ffbc 	bl	f744 <hexToStr_op>
	dPrintStr( tmpStr );
    f7cc:	a801      	add	r0, sp, #4
    f7ce:	f7fc fb47 	bl	be60 <Output_putstr>
}
    f7d2:	9a03      	ldr	r2, [sp, #12]
    f7d4:	6823      	ldr	r3, [r4, #0]
    f7d6:	429a      	cmp	r2, r3
    f7d8:	d001      	beq.n	f7de <printHex_op+0x22>
    f7da:	f7f2 ffa9 	bl	2730 <__stack_chk_fail>
    f7de:	b004      	add	sp, #16
    f7e0:	bd10      	pop	{r4, pc}
    f7e2:	bf00      	nop
    f7e4:	1fff89d0 	.word	0x1fff89d0

0000f7e8 <hex32ToStr_op>:
{
    f7e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    f7ea:	4b1c      	ldr	r3, [pc, #112]	; (f85c <hex32ToStr_op+0x74>)
    f7ec:	681c      	ldr	r4, [r3, #0]
    f7ee:	9401      	str	r4, [sp, #4]
    f7f0:	1e4e      	subs	r6, r1, #1
	uint32_t pos = 0;
    f7f2:	2400      	movs	r4, #0
    f7f4:	469c      	mov	ip, r3
		uint32_t cur = in % 16;
    f7f6:	f000 070f 	and.w	r7, r0, #15
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    f7fa:	2f09      	cmp	r7, #9
    f7fc:	bf8c      	ite	hi
    f7fe:	2537      	movhi	r5, #55	; 0x37
    f800:	2530      	movls	r5, #48	; 0x30
    f802:	443d      	add	r5, r7
	while ( (in /= 16) > 0 );
    f804:	0900      	lsrs	r0, r0, #4
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    f806:	f104 0301 	add.w	r3, r4, #1
    f80a:	f806 5f01 	strb.w	r5, [r6, #1]!
	while ( (in /= 16) > 0 );
    f80e:	d108      	bne.n	f822 <hex32ToStr_op+0x3a>
	switch ( op )
    f810:	1e50      	subs	r0, r2, #1
    f812:	2807      	cmp	r0, #7
    f814:	d813      	bhi.n	f83e <hex32ToStr_op+0x56>
    f816:	e8df f000 	tbb	[pc, r0]
    f81a:	060c      	.short	0x060c
    f81c:	12120612 	.word	0x12120612
    f820:	0612      	.short	0x0612
		out[pos++] = cur + (( cur < 10 ) ? '0' : 'A' - 10);
    f822:	461c      	mov	r4, r3
    f824:	e7e7      	b.n	f7f6 <hex32ToStr_op+0xe>
			out[pos++] = '0';
    f826:	2030      	movs	r0, #48	; 0x30
		while ( pos < op )
    f828:	4293      	cmp	r3, r2
    f82a:	d208      	bcs.n	f83e <hex32ToStr_op+0x56>
			out[pos++] = '0';
    f82c:	54c8      	strb	r0, [r1, r3]
    f82e:	3301      	adds	r3, #1
    f830:	e7fa      	b.n	f828 <hex32ToStr_op+0x40>
		out[pos++] = 'x';
    f832:	2278      	movs	r2, #120	; 0x78
    f834:	54ca      	strb	r2, [r1, r3]
		out[pos++] = '0';
    f836:	1ce3      	adds	r3, r4, #3
    f838:	440c      	add	r4, r1
    f83a:	2230      	movs	r2, #48	; 0x30
    f83c:	70a2      	strb	r2, [r4, #2]
	out[pos] = '\0';
    f83e:	2200      	movs	r2, #0
    f840:	54ca      	strb	r2, [r1, r3]
	revsStr(out);
    f842:	9a01      	ldr	r2, [sp, #4]
    f844:	f8dc 3000 	ldr.w	r3, [ip]
    f848:	429a      	cmp	r2, r3
    f84a:	d001      	beq.n	f850 <hex32ToStr_op+0x68>
    f84c:	f7f2 ff70 	bl	2730 <__stack_chk_fail>
    f850:	4608      	mov	r0, r1
}
    f852:	b003      	add	sp, #12
    f854:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	revsStr(out);
    f858:	f7ff beb2 	b.w	f5c0 <revsStr>
    f85c:	1fff89d0 	.word	0x1fff89d0

0000f860 <printHex32_op>:
{
    f860:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    f862:	4c09      	ldr	r4, [pc, #36]	; (f888 <printHex32_op+0x28>)
	hex32ToStr_op( in, tmpStr, op );
    f864:	460a      	mov	r2, r1
{
    f866:	6823      	ldr	r3, [r4, #0]
    f868:	9303      	str	r3, [sp, #12]
	hex32ToStr_op( in, tmpStr, op );
    f86a:	4669      	mov	r1, sp
    f86c:	f7ff ffbc 	bl	f7e8 <hex32ToStr_op>
	dPrintStr( tmpStr );
    f870:	4668      	mov	r0, sp
    f872:	f7fc faf5 	bl	be60 <Output_putstr>
}
    f876:	9a03      	ldr	r2, [sp, #12]
    f878:	6823      	ldr	r3, [r4, #0]
    f87a:	429a      	cmp	r2, r3
    f87c:	d001      	beq.n	f882 <printHex32_op+0x22>
    f87e:	f7f2 ff57 	bl	2730 <__stack_chk_fail>
    f882:	b004      	add	sp, #16
    f884:	bd10      	pop	{r4, pc}
    f886:	bf00      	nop
    f888:	1fff89d0 	.word	0x1fff89d0

0000f88c <hex32ToStr16>:
{
    f88c:	b530      	push	{r4, r5, lr}
    f88e:	4c0e      	ldr	r4, [pc, #56]	; (f8c8 <hex32ToStr16+0x3c>)
    f890:	b085      	sub	sp, #20
    f892:	6823      	ldr	r3, [r4, #0]
    f894:	9303      	str	r3, [sp, #12]
    f896:	460d      	mov	r5, r1
	hex32ToStr_op( in, tmpStr, op );
    f898:	4669      	mov	r1, sp
    f89a:	f7ff ffa5 	bl	f7e8 <hex32ToStr_op>
    f89e:	2300      	movs	r3, #0
		if ( tmpStr[byte] == '\0' && out[byte] != 0x0000 )
    f8a0:	f81d 2003 	ldrb.w	r2, [sp, r3]
    f8a4:	b912      	cbnz	r2, f8ac <hex32ToStr16+0x20>
    f8a6:	f835 1013 	ldrh.w	r1, [r5, r3, lsl #1]
    f8aa:	b921      	cbnz	r1, f8b6 <hex32ToStr16+0x2a>
		out[byte] = tmpStr[byte] | 0x0000;
    f8ac:	f825 2013 	strh.w	r2, [r5, r3, lsl #1]
    f8b0:	3301      	adds	r3, #1
	for ( uint8_t byte = 0; byte < sizeof( tmpStr ); byte++ )
    f8b2:	2b0b      	cmp	r3, #11
    f8b4:	d1f4      	bne.n	f8a0 <hex32ToStr16+0x14>
}
    f8b6:	9a03      	ldr	r2, [sp, #12]
    f8b8:	6823      	ldr	r3, [r4, #0]
    f8ba:	429a      	cmp	r2, r3
    f8bc:	d001      	beq.n	f8c2 <hex32ToStr16+0x36>
    f8be:	f7f2 ff37 	bl	2730 <__stack_chk_fail>
    f8c2:	b005      	add	sp, #20
    f8c4:	bd30      	pop	{r4, r5, pc}
    f8c6:	bf00      	nop
    f8c8:	1fff89d0 	.word	0x1fff89d0

0000f8cc <eqStr>:


int16_t eqStr( char* str1, char* str2 )
{
    f8cc:	b537      	push	{r0, r1, r2, r4, r5, lr}
    f8ce:	4b0f      	ldr	r3, [pc, #60]	; (f90c <eqStr+0x40>)
    f8d0:	681a      	ldr	r2, [r3, #0]
    f8d2:	9201      	str	r2, [sp, #4]
    f8d4:	4602      	mov	r2, r0
	// Scan each string for NULLs and whether they are the same
	while( *str1 != '\0' && *str1++ == *str2++ );
    f8d6:	f810 4b01 	ldrb.w	r4, [r0], #1
    f8da:	b124      	cbz	r4, f8e6 <eqStr+0x1a>
    f8dc:	f811 5b01 	ldrb.w	r5, [r1], #1
    f8e0:	42a5      	cmp	r5, r4
    f8e2:	4602      	mov	r2, r0
    f8e4:	d0f6      	beq.n	f8d4 <eqStr+0x8>

	// If the strings are still identical (i.e. both NULL), then return -1, otherwise current *str1
	// If *str1 is 0, then str1 ended (and str1 is "like" str2), otherwise strings are different
	return *--str1 == *--str2 ? -1 : *++str1;
    f8e6:	f812 0c01 	ldrb.w	r0, [r2, #-1]
    f8ea:	f811 1c01 	ldrb.w	r1, [r1, #-1]
    f8ee:	4288      	cmp	r0, r1
    f8f0:	bf18      	it	ne
    f8f2:	7810      	ldrbne	r0, [r2, #0]
}
    f8f4:	9a01      	ldr	r2, [sp, #4]
    f8f6:	681b      	ldr	r3, [r3, #0]
	return *--str1 == *--str2 ? -1 : *++str1;
    f8f8:	bf08      	it	eq
    f8fa:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
}
    f8fe:	429a      	cmp	r2, r3
    f900:	d001      	beq.n	f906 <eqStr+0x3a>
    f902:	f7f2 ff15 	bl	2730 <__stack_chk_fail>
    f906:	b003      	add	sp, #12
    f908:	bd30      	pop	{r4, r5, pc}
    f90a:	bf00      	nop
    f90c:	1fff89d0 	.word	0x1fff89d0

0000f910 <numToInt>:

int numToInt( char* in )
{
    f910:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    f912:	4d25      	ldr	r5, [pc, #148]	; (f9a8 <numToInt+0x98>)
    f914:	682b      	ldr	r3, [r5, #0]
    f916:	9301      	str	r3, [sp, #4]
    f918:	4604      	mov	r4, r0
	char* lsd = in;
	char* msd = in;

	int total = 0;
	int sign = 1; // Default to positive
	uint8_t base = 10; // Use base 10 by default TODO Add support for bases other than 10 and 16
    f91a:	220a      	movs	r2, #10
	int sign = 1; // Default to positive
    f91c:	2601      	movs	r6, #1
    f91e:	4621      	mov	r1, r4

	// Scan the string once to determine the length
	while ( *lsd != '\0' )
    f920:	f814 3b01 	ldrb.w	r3, [r4], #1
    f924:	b95b      	cbnz	r3, f93e <numToInt+0x2e>
			break;
		}
	}

	// Process string depending on which base
	switch ( base )
    f926:	2a0a      	cmp	r2, #10
    f928:	d024      	beq.n	f974 <numToInt+0x64>
    f92a:	2a10      	cmp	r2, #16
    f92c:	d037      	beq.n	f99e <numToInt+0x8e>
		break;
	}

	// Propagate sign and return
	return total * sign;
}
    f92e:	9a01      	ldr	r2, [sp, #4]
    f930:	fb06 f003 	mul.w	r0, r6, r3
    f934:	682b      	ldr	r3, [r5, #0]
    f936:	429a      	cmp	r2, r3
    f938:	d033      	beq.n	f9a2 <numToInt+0x92>
    f93a:	f7f2 fef9 	bl	2730 <__stack_chk_fail>
		switch ( *lsd++ )
    f93e:	2b2b      	cmp	r3, #43	; 0x2b
    f940:	4621      	mov	r1, r4
    f942:	d00c      	beq.n	f95e <numToInt+0x4e>
    f944:	d803      	bhi.n	f94e <numToInt+0x3e>
    f946:	2b20      	cmp	r3, #32
    f948:	d009      	beq.n	f95e <numToInt+0x4e>
    f94a:	4601      	mov	r1, r0
    f94c:	e007      	b.n	f95e <numToInt+0x4e>
    f94e:	2b2d      	cmp	r3, #45	; 0x2d
    f950:	d003      	beq.n	f95a <numToInt+0x4a>
    f952:	2b78      	cmp	r3, #120	; 0x78
    f954:	d1f9      	bne.n	f94a <numToInt+0x3a>
			base = 0x10;
    f956:	2210      	movs	r2, #16
			break;
    f958:	e001      	b.n	f95e <numToInt+0x4e>
		case '-': sign = -1;
    f95a:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    f95e:	4608      	mov	r0, r1
    f960:	e7dd      	b.n	f91e <numToInt+0xe>
			total += ( (*--lsd) - '0' ) * digit;
    f962:	f811 7d01 	ldrb.w	r7, [r1, #-1]!
    f966:	3f30      	subs	r7, #48	; 0x30
    f968:	fb04 3307 	mla	r3, r4, r7, r3
		for ( unsigned int digit = 1; lsd > msd ; digit *= 10 )
    f96c:	4354      	muls	r4, r2
    f96e:	4281      	cmp	r1, r0
    f970:	d8f7      	bhi.n	f962 <numToInt+0x52>
    f972:	e7dc      	b.n	f92e <numToInt+0x1e>
    f974:	2401      	movs	r4, #1
    f976:	e7fa      	b.n	f96e <numToInt+0x5e>
			if    ( *--lsd <= '9' ) total += ( *lsd - '0' ) * digit;
    f978:	f811 2d01 	ldrb.w	r2, [r1, #-1]!
    f97c:	2a39      	cmp	r2, #57	; 0x39
    f97e:	d806      	bhi.n	f98e <numToInt+0x7e>
    f980:	3a30      	subs	r2, #48	; 0x30
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    f982:	fb04 3302 	mla	r3, r4, r2, r3
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
    f986:	0124      	lsls	r4, r4, #4
    f988:	4281      	cmp	r1, r0
    f98a:	d8f5      	bhi.n	f978 <numToInt+0x68>
    f98c:	e7cf      	b.n	f92e <numToInt+0x1e>
			else if ( *lsd <= 'F' ) total += ( *lsd - 'A' + 10 ) * digit;
    f98e:	2a46      	cmp	r2, #70	; 0x46
    f990:	d801      	bhi.n	f996 <numToInt+0x86>
    f992:	3a37      	subs	r2, #55	; 0x37
    f994:	e7f5      	b.n	f982 <numToInt+0x72>
			else if ( *lsd <= 'f' ) total += ( *lsd - 'a' + 10 ) * digit;
    f996:	2a66      	cmp	r2, #102	; 0x66
    f998:	d8f5      	bhi.n	f986 <numToInt+0x76>
    f99a:	3a57      	subs	r2, #87	; 0x57
    f99c:	e7f1      	b.n	f982 <numToInt+0x72>
		for ( unsigned int digit = 1; lsd > msd ; digit *= 0x10 )
    f99e:	2401      	movs	r4, #1
    f9a0:	e7f2      	b.n	f988 <numToInt+0x78>
}
    f9a2:	b003      	add	sp, #12
    f9a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f9a6:	bf00      	nop
    f9a8:	1fff89d0 	.word	0x1fff89d0
    f9ac:	66676553 	.word	0x66676553
    f9b0:	746c7561 	.word	0x746c7561
    f9b4:	000a0d21 	.word	0x000a0d21
    f9b8:	20737542 	.word	0x20737542
    f9bc:	6c756146 	.word	0x6c756146
    f9c0:	53202174 	.word	0x53202174
    f9c4:	435f4243 	.word	0x435f4243
    f9c8:	3a525346 	.word	0x3a525346
    f9cc:	53200020 	.word	0x53200020
    f9d0:	425f4243 	.word	0x425f4243
    f9d4:	3a524146 	.word	0x3a524146
    f9d8:	0020      	.short	0x0020
    f9da:	6148      	.short	0x6148
    f9dc:	46206472 	.word	0x46206472
    f9e0:	746c7561 	.word	0x746c7561
    f9e4:	43532021 	.word	0x43532021
    f9e8:	46485f42 	.word	0x46485f42
    f9ec:	203a5253 	.word	0x203a5253
    f9f0:	00          	.byte	0x00
    f9f1:	4d          	.byte	0x4d
    f9f2:	6d65      	.short	0x6d65
    f9f4:	2079726f 	.word	0x2079726f
    f9f8:	616e614d 	.word	0x616e614d
    f9fc:	20726567 	.word	0x20726567
    fa00:	6c756146 	.word	0x6c756146
    fa04:	53202174 	.word	0x53202174
    fa08:	435f4243 	.word	0x435f4243
    fa0c:	3a525346 	.word	0x3a525346
    fa10:	53200020 	.word	0x53200020
    fa14:	4d5f4243 	.word	0x4d5f4243
    fa18:	3a52414d 	.word	0x3a52414d
    fa1c:	0020      	.short	0x0020
    fa1e:	4d4e      	.short	0x4d4e
    fa20:	0a0d2149 	.word	0x0a0d2149
    fa24:	00          	.byte	0x00

0000fa25 <sys_reset_to_loader_magic>:
    fa25:	ff 00 7f 52 45 53 45 54 20 54 4f 20 4c 4f 41 44     ...RESET TO LOAD
    fa35:	45 52 7f 00 ff 00 55 73 61 67 65 20 46 61 75 6c     ER....Usage Faul
    fa45:	74 21 20 53 43 42 5f 43 46 53 52 3a 20 00 57 61     t! SCB_CFSR: .Wa
    fa55:	74 63 68 64 6f 67 20 74 69 6d 65 6f 75 74 21 20     tchdog timeout! 
    fa65:	00 57 61 74 63 68 64 6f 67 20 52 65 73 65 74 20     .Watchdog Reset 
    fa75:	43 6f 75 6e 74 3a 20 00 31 33 2e 38 38 39 20 6e     Count: .13.889 n
    fa85:	73 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47     s..[1;33mWARNING
    fa95:	1b 5b 30 6d 20 2d 20 4e 41 43 4b 20 52 65 63 65     .[0m - NACK Rece
    faa5:	69 76 65 64 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41     ived....[1;33mWA
    fab5:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 49 53 52 20     RNING.[0m - ISR 
    fac5:	65 72 72 6f 72 0d 0a 00 1b 5b 31 3b 33 33 6d 57     error....[1;33mW
    fad5:	41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 49 32 43     ARNING.[0m - I2C
    fae5:	20 42 75 73 20 45 72 72 6f 72 3a 20 00 20 65 72      Bus Error: . er
    faf5:	72 6f 72 73 3a 20 00 1b 5b 31 3b 33 33 6d 57 41     rors: ..[1;33mWA
    fb05:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 41 72 62 69     RNING.[0m - Arbi
    fb15:	74 72 61 74 69 6f 6e 20 6c 6f 73 74 0d 0a 00 4c     tration lost...L
    fb25:	45 44 5f 63 6f 6e 74 72 6f 6c 5f 63 61 70 61 62     ED_control_capab
    fb35:	69 6c 69 74 79 28 6d 6f 64 65 2c 61 6d 6f 75 6e     ility(mode,amoun
    fb45:	74 29 00                                            t).

0000fb48 <LED_ledEnableMask>:
    fb48:	e8 00 00 00 ff 00 00 00 ff 00 00 00 ff 00 00 00     ................
    fb58:	ff 00 00 00 3f 00 00 00 00 00 00 00 00 00 00 00     ....?...........
    fb68:	00 00 00 00 00 00 00 00 1b 5b 31 3b 33 35 6d 44     .........[1;35mD
    fb78:	45 42 55 47 1b 5b 30 6d 20 2d 20 31 66 72 61 6d     EBUG.[0m - 1fram
    fb88:	65 2f 00 6d 73 20 2b 20 00 20 74 69 63 6b 73 00     e/.ms + . ticks.
    fb98:	20 2d 20 43 6f 75 6c 64 20 6e 6f 74 20 6d 65 65      - Could not mee
    fba8:	74 20 66 72 61 6d 65 72 61 74 65 3a 20 00 49 53     t framerate: .IS
    fbb8:	53 49 4c 65 64 00 1b 5b 31 3b 33 32 6d 49 4e 46     SILed..[1;32mINF
    fbc8:	4f 1b 5b 30 6d 20 2d 20 46 50 53 20 54 6f 67 67     O.[0m - FPS Togg
    fbd8:	6c 65 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     le..[1;32mINFO.[
    fbe8:	30 6d 20 2d 20 53 65 74 74 69 6e 67 20 66 72 61     0m - Setting fra
    fbf8:	6d 65 72 61 74 65 20 74 6f 3a 20 00 6d 73 00 1b     merate to: .ms..
    fc08:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
    fc18:	20 4c 45 44 20 42 72 69 67 68 74 6e 65 73 73 20      LED Brightness 
    fc28:	53 65 74 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     Set..[1;32mINFO.
    fc38:	5b 30 6d 20 2d 20 4c 45 44 73 20 54 6f 67 67 6c     [0m - LEDs Toggl
    fc48:	65 00                                               e.

0000fc4a <hardware_shutdown_pin>:
    fc4a:	01 10                                               ..

0000fc4c <ledCLIDict>:
    fc4c:	61 fd 00 00 ad fc 00 00 51 36 00 00 6a fd 00 00     a.......Q6..j...
    fc5c:	e3 fc 00 00 49 37 00 00 71 fd 00 00 13 fd 00 00     ....I7..q.......
    fc6c:	3d 3a 00 00 7a fd 00 00 25 fd 00 00 79 36 00 00     =:..z...%...y6..
    fc7c:	81 fd 00 00 42 fd 00 00 11 36 00 00 00 00 00 00     ....B....6......
    fc8c:	00 00 00 00 00 00 00 00                             ........

0000fc94 <ledCLIDictName>:
    fc94:	49 53 53 49 20 4c 45 44 20 4d 6f 64 75 6c 65 20     ISSI LED Module 
    fca4:	43 6f 6d 6d 61 6e 64 73 00                          Commands.

0000fcad <ledCheckCLIDict_DescEntry>:
    fcad:	52 75 6e 20 4c 45 44 20 64 69 61 67 6e 6f 73 74     Run LED diagnost
    fcbd:	69 63 73 2e 20 4e 6f 74 20 61 6c 6c 20 49 53 53     ics. Not all ISS
    fccd:	49 20 63 68 69 70 73 20 73 75 70 70 6f 72 74 20     I chips support 
    fcdd:	74 68 69 73 2e 00                                   this..

0000fce3 <ledFPSCLIDict_DescEntry>:
    fce3:	53 68 6f 77 2f 73 65 74 20 46 50 53 20 6f 66 20     Show/set FPS of 
    fcf3:	4c 45 44 20 64 72 69 76 65 72 2c 20 72 20 2d 20     LED driver, r - 
    fd03:	52 65 73 65 74 20 66 72 61 6d 65 72 61 74 65 00     Reset framerate.

0000fd13 <ledResetCLIDict_DescEntry>:
    fd13:	52 65 73 65 74 20 49 53 53 49 20 63 68 69 70 73     Reset ISSI chips
    fd23:	2e 00                                               ..

0000fd25 <ledSetCLIDict_DescEntry>:
    fd25:	53 65 74 20 49 53 53 49 20 6f 76 65 72 61 6c 6c     Set ISSI overall
    fd35:	20 62 72 69 67 68 74 6e 65 73 73 2e 00               brightness..

0000fd42 <ledToggleCLIDict_DescEntry>:
    fd42:	54 6f 67 67 6c 65 20 49 53 53 49 20 68 61 72 64     Toggle ISSI hard
    fd52:	77 61 72 65 20 73 68 75 74 64 6f 77 6e 2e 00 6c     ware shutdown..l
    fd62:	65 64 43 68 65 63 6b 00 6c 65 64 46 50 53 00 6c     edCheck.ledFPS.l
    fd72:	65 64 52 65 73 65 74 00 6c 65 64 53 65 74 00 6c     edReset.ledSet.l
    fd82:	65 64 54 6f 67 67 6c 65 00                          edToggle.

0000fd8b <Matrix_cols>:
    fd8b:	01 02 01 03 01 12 01 13 02 00 02 09 02 0a 02 0b     ................
    fd9b:	03 00 1b 5b 31 6d 4f 1b 5b 30 6d 00 1b 5b 31 3b     ...[1mO.[0m..[1;
    fdab:	33 33 6d 50 1b 5b 30 6d 00 1b 5b 31 3b 33 32 6d     33mP.[0m..[1;32m
    fdbb:	48 1b 5b 30 6d 00 1b 5b 31 3b 33 35 6d 52 1b 5b     H.[0m..[1;35mR.[
    fdcb:	30 6d 00 1b 5b 31 3b 33 31 6d 49 1b 5b 30 6d 00     0m..[1;31mI.[0m.

0000fddb <Matrix_rows>:
    fddb:	03 01 03 04 03 05 03 06 03 07 4d 61 74 72 69 78     ..........Matrix
    fdeb:	41 52 4d 50 65 72 69 00 1b 5b 31 3b 35 3b 33 31     ARMPeri..[1;5;31
    fdfb:	6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 4d 61 74     mERROR.[0m - Mat
    fe0b:	72 69 78 20 73 63 61 6e 20 62 75 67 21 21 20 52     rix scan bug!! R
    fe1b:	65 70 6f 72 74 20 6d 65 21 20 2d 20 00 20 43 6f     eport me! - . Co
    fe2b:	6c 3a 20 00 20 52 6f 77 3a 20 00 20 4b 65 79 3a     l: . Row: . Key:
    fe3b:	20 00 1b 5b 31 6d 00 20 30 78 00 3c 6b 65 79 3e      ..[1m. 0x.<key>
    fe4b:	3a 3c 70 72 65 76 69 6f 75 73 20 73 74 61 74 65     :<previous state
    fe5b:	3e 3c 63 75 72 72 65 6e 74 20 73 74 61 74 65 3e     ><current state>
    fe6b:	20 3c 61 63 74 69 76 65 20 63 6f 75 6e 74 3e 20      <active count> 
    fe7b:	3c 69 6e 61 63 74 69 76 65 20 63 6f 75 6e 74 3e     <inactive count>
    fe8b:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    fe9b:	20 2d 20 44 65 62 6f 75 6e 63 65 20 54 69 6d 65      - Debounce Time
    feab:	72 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     r: ..[1;32mINFO.
    febb:	5b 30 6d 20 2d 20 4d 61 74 72 69 78 20 44 65 62     [0m - Matrix Deb
    fecb:	75 67 20 4d 6f 64 65 3a 20 00 1b 5b 31 3b 33 32     ug Mode: ..[1;32
    fedb:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 43 6f 6c 75     mINFO.[0m - Colu
    feeb:	6d 6e 73 3a 20 20 00 1b 5b 31 3b 33 32 6d 49 4e     mns:  ..[1;32mIN
    fefb:	46 4f 1b 5b 30 6d 20 2d 20 52 6f 77 73 3a 20 20     FO.[0m - Rows:  
    ff0b:	20 20 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b        ..[1;32mINFO.
    ff1b:	5b 30 6d 20 2d 20 4d 61 78 20 4b 65 79 73 3a 20     [0m - Max Keys: 
    ff2b:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
    ff3b:	20 2d 20 53 74 72 6f 62 65 20 44 65 6c 61 79 3a      - Strobe Delay:
    ff4b:	20 00                                                .

0000ff4d <debounceCLIDict_DescEntry>:
    ff4d:	53 65 74 20 74 68 65 20 64 65 62 6f 75 6e 63 65     Set the debounce
    ff5d:	20 74 69 6d 65 72 20 28 6d 73 29 2e 20 55 73 65      timer (ms). Use
    ff6d:	66 75 6c 20 66 6f 72 20 62 6f 75 6e 63 79 20 73     ful for bouncy s
    ff7d:	77 69 74 63 68 65 73 2e 00 00 00                    witches....

0000ff88 <matrixCLIDict>:
    ff88:	2f 01 01 00 4d ff 00 00 c9 3e 00 00 38 01 01 00     /...M....>..8...
    ff98:	e7 ff 00 00 8d 3f 00 00 44 01 01 00 6d 00 01 00     .....?..D...m...
    ffa8:	29 3f 00 00 4f 01 01 00 95 00 01 00 89 3e 00 00     )?..O........>..
    ffb8:	5b 01 01 00 67 01 01 00 1d 40 00 00 00 00 00 00     [...g....@......
    ffc8:	00 00 00 00 00 00 00 00                             ........

0000ffd0 <matrixCLIDictName>:
    ffd0:	4d 61 74 72 69 78 20 4d 6f 64 75 6c 65 20 43 6f     Matrix Module Co
    ffe0:	6d 6d 61 6e 64 73 00                                mmands.

0000ffe7 <matrixDebugCLIDict_DescEntry>:
    ffe7:	45 6e 61 62 6c 65 73 20 6d 61 74 72 69 78 20 64     Enables matrix d
    fff7:	65 62 75 67 20 6d 6f 64 65 2c 20 70 72 69 6e 74     ebug mode, print
   10007:	73 20 6f 75 74 20 65 61 63 68 20 73 63 61 6e 20     s out each scan 
   10017:	63 6f 64 65 2e 0d 0a 09 09 49 66 20 61 72 67 75     code.....If argu
   10027:	6d 65 6e 74 20 1b 5b 33 35 6d 54 1b 5b 30 6d 20     ment .[35mT.[0m 
   10037:	69 73 20 67 69 76 65 6e 2c 20 70 72 69 6e 74 73     is given, prints
   10047:	20 6f 75 74 20 65 61 63 68 20 73 63 61 6e 20 63      out each scan c
   10057:	6f 64 65 20 73 74 61 74 65 20 74 72 61 6e 73 69     ode state transi
   10067:	74 69 6f 6e 2e 00                                   tion..

0001006d <matrixInfoCLIDict_DescEntry>:
   1006d:	50 72 69 6e 74 20 69 6e 66 6f 20 61 62 6f 75 74     Print info about
   1007d:	20 74 68 65 20 63 6f 6e 66 69 67 75 72 65 64 20      the configured 
   1008d:	6d 61 74 72 69 78 2e 00                             matrix..

00010095 <matrixStateCLIDict_DescEntry>:
   10095:	50 72 69 6e 74 73 20 6f 75 74 20 74 68 65 20 63     Prints out the c
   100a5:	75 72 72 65 6e 74 20 73 63 61 6e 20 74 61 62 6c     urrent scan tabl
   100b5:	65 20 4e 20 74 69 6d 65 73 2e 0d 0a 09 09 20 1b     e N times..... .
   100c5:	5b 31 6d 4f 1b 5b 30 6d 20 2d 20 4f 66 66 2c 20     [1mO.[0m - Off, 
   100d5:	1b 5b 31 3b 33 33 6d 50 1b 5b 30 6d 20 2d 20 50     .[1;33mP.[0m - P
   100e5:	72 65 73 73 2c 20 1b 5b 31 3b 33 32 6d 48 1b 5b     ress, .[1;32mH.[
   100f5:	30 6d 20 2d 20 48 6f 6c 64 2c 20 1b 5b 31 3b 33     0m - Hold, .[1;3
   10105:	35 6d 52 1b 5b 30 6d 20 2d 20 52 65 6c 65 61 73     5mR.[0m - Releas
   10115:	65 2c 20 1b 5b 31 3b 33 31 6d 49 1b 5b 30 6d 20     e, .[1;31mI.[0m 
   10125:	2d 20 49 6e 76 61 6c 69 64 00 64 65 62 6f 75 6e     - Invalid.deboun
   10135:	63 65 00 6d 61 74 72 69 78 44 65 62 75 67 00 6d     ce.matrixDebug.m
   10145:	61 74 72 69 78 49 6e 66 6f 00 6d 61 74 72 69 78     atrixInfo.matrix
   10155:	53 74 61 74 65 00 73 74 72 6f 62 65 44 65 6c 61     State.strobeDela
   10165:	79 00                                               y.

00010167 <strobeDelayCLIDict_DescEntry>:
   10167:	53 65 74 20 74 68 65 20 73 74 72 6f 62 65 20 64     Set the strobe d
   10177:	65 6c 61 79 20 28 75 73 29 2e 20 55 73 65 66 75     elay (us). Usefu
   10187:	6c 20 66 6f 72 20 62 61 64 20 70 75 6c 6c 75 70     l for bad pullup
   10197:	20 72 65 73 69 73 74 6f 72 73 2e 00 00 00 00 00      resistors......
   101a7:	ff ff ff ff ff ff 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ......??????????
   101b7:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
   101c7:	ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00     ................
   101d7:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   101e7:	ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00     ................
   101f7:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10207:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
   10217:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10227:	00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff     ................
   10237:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10247:	00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff     ................
   10257:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10267:	00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff     ................
   10277:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10287:	00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff ff     ................
   10297:	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   102a7:	ff ff ff ff ff ff 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ......??????????
   102b7:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 00 00 00 00 00 00     ??????????......
   102c7:	ff ff ff ff ff ff e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
   102d7:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 00 00 00 00 00 00     ................
   102e7:	07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07     ................
   102f7:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10307:	fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc     ................
   10317:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10327:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ????????????????
   10337:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
   10347:	00 00 00 00 00 00 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
   10357:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10367:	00 00 00 00 00 00 07 07 07 07 07 07 07 07 07 07     ................
   10377:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10387:	fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc     ................
   10397:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
   103a7:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   103b7:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   103c7:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
   103d7:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   103e7:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
   103f7:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10407:	ff ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00     ................
   10417:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10427:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ????????????????
   10437:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
   10447:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
   10457:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10467:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
   10477:	07 07 07 07 07 07 07 07 07 07 00 00 00 00 00 00     ................
   10487:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
   10497:	fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00 00     ................
   104a7:	ff ff ff ff ff ff 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ......??????????
   104b7:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
   104c7:	ff ff ff ff ff ff e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
   104d7:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   104e7:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
   104f7:	07 07 07 07 07 07 07 07 07 07 00 00 00 00 00 00     ................
   10507:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
   10517:	fc fc fc fc fc fc fc fc fc fc 00 00 00 00 00 00     ................
   10527:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10537:	00 00 00 00 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10547:	00 00 00 00 00 00 00 00 00 00 00 00 00 e0 e0 e0     ................
   10557:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10567:	00 00 00 00 00 00 00 00 00 00 00 00 00 07 07 07     ................
   10577:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10587:	fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc     ................
   10597:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
   105a7:	ff ff ff ff ff ff 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ......??????????
   105b7:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
   105c7:	ff ff ff ff ff ff e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
   105d7:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   105e7:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
   105f7:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10607:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
   10617:	fc fc fc fc ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10627:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ????????????????
   10637:	3f 3f 3f 3f ff ff ff ff ff ff 00 00 00 00 00 00     ????............
   10647:	e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0 e0     ................
   10657:	e0 e0 e0 e0 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10667:	ff ff ff ff ff ff 07 07 07 07 07 07 07 07 07 07     ................
   10677:	07 07 07 07 ff ff ff ff ff ff 00 00 00 00 00 00     ................
   10687:	ff ff ff ff ff ff fc fc fc fc fc fc fc fc fc fc     ................
   10697:	fc fc fc fc ff ff ff ff ff ff 00 00 00 39 b9 ea     .............9..
   106a7:	aa 8d 8d a8 a8 27 27 a0 1f 4b 4b 8d 8d b5 34 00     .....''..KK...4.
   106b7:	00 42 82 f3 b3 f6 f6 a5 a5 49 49 b7 b7 5d 5d 45     .B.......II..]]E
   106c7:	85 fc bc f6 b6 2d 2d c1 00 7e 7e 3c 3c 03 83 94     .....--..~~<<...
   106d7:	13 f9 b9 ca 09 d3 12 84 84 4c 43 44 5f 6c 61 79     .........LCD_lay
   106e7:	65 72 53 74 61 63 6b 45 78 61 63 74 5f 63 61 70     erStackExact_cap
   106f7:	61 62 69 6c 69 74 79 28 6e 75 6d 2c 6c 61 79 65     ability(num,laye
   10707:	72 31 2c 6c 61 79 65 72 32 2c 6c 61 79 65 72 33     r1,layer2,layer3
   10717:	2c 6c 61 79 65 72 34 29 00 4c 43 44 5f 6c 61 79     ,layer4).LCD_lay
   10727:	65 72 53 74 61 63 6b 5f 63 61 70 61 62 69 6c 69     erStack_capabili
   10737:	74 79 28 29 00 53 54 4c 63 64 00                    ty().STLcd.

00010742 <STLcdDefaultImage>:
   10742:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10752:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10762:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
   10772:	c0 c0 c0 c0 c0 00 00 00 00 00 00 00 00 00 00 00     ................
   10782:	ff ff ff ff ff 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f     ................
   10792:	1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f     ................
   107a2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   107b2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   107c2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   107d2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   107e2:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
   107f2:	03 03 03 03 03 00 00 00 00 00 00 00 00 00 00 00     ................
   10802:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
   10812:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10822:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10832:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10842:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10852:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10862:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
   10872:	c0 c0 c0 c0 c0 00 00 00 00 00 00 00 00 00 00 00     ................
   10882:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
   10892:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   108a2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   108b2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   108c2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   108d2:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   108e2:	ff ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00     ................
   108f2:	03 03 03 03 03 00 00 00 00 00 00 00 00 00 00 00     ................
   10902:	ff ff ff ff ff f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8     ................
   10912:	f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8     ................
   10922:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10932:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   10942:	4e 6f 20 61 72 67 73 20 70 72 6f 76 69 64 65 64     No args provided
   10952:	2e 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     ...[1;32mINFO.[0
   10962:	6d 20 2d 20 53 65 6e 64 69 6e 67 2d 20 00 1b 5b     m - Sending- ..[
   10972:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
   10982:	53 65 6e 64 69 6e 67 20 57 49 54 48 20 41 30 20     Sending WITH A0 
   10992:	46 4c 41 47 20 53 45 54 2d 20 00 00 00 00           FLAG SET- ....

000109a0 <lcdCLIDict>:
   109a0:	0f 0b 01 00 ff 09 01 00 6d 49 00 00 16 0b 01 00     ........mI......
   109b0:	43 0a 01 00 05 47 00 00 1f 0b 01 00 88 0a 01 00     C....G..........
   109c0:	85 48 00 00 27 0b 01 00 d6 0a 01 00 f9 4c 00 00     .H..'........L..
   109d0:	2f 0b 01 00 f5 0a 01 00 51 4a 00 00 00 00 00 00     /.......QJ......
   109e0:	00 00 00 00 00 00 00 00                             ........

000109e8 <lcdCLIDictName>:
   109e8:	53 54 20 4c 43 44 20 4d 6f 64 75 6c 65 20 43 6f     ST LCD Module Co
   109f8:	6d 6d 61 6e 64 73 00                                mmands.

000109ff <lcdCmdCLIDict_DescEntry>:
   109ff:	53 65 6e 64 20 62 79 74 65 20 76 69 61 20 53 50     Send byte via SP
   10a0f:	49 2c 20 73 65 63 6f 6e 64 20 61 72 67 75 6d 65     I, second argume
   10a1f:	6e 74 20 65 6e 61 62 6c 65 73 20 61 30 2e 20 44     nt enables a0. D
   10a2f:	65 66 61 75 6c 74 73 20 74 6f 20 63 6f 6e 74 72     efaults to contr
   10a3f:	6f 6c 2e 00                                         ol..

00010a43 <lcdColorCLIDict_DescEntry>:
   10a43:	53 65 74 20 62 61 63 6b 6c 69 67 68 74 20 63 6f     Set backlight co
   10a53:	6c 6f 72 2e 20 33 20 31 36 2d 62 69 74 20 6e 75     lor. 3 16-bit nu
   10a63:	6d 62 65 72 73 3a 20 52 20 47 20 42 2e 20 69 2e     mbers: R G B. i.
   10a73:	65 2e 20 30 78 46 46 46 20 30 78 31 34 34 34 20     e. 0xFFF 0x1444 
   10a83:	30 78 33 32 00                                      0x32.

00010a88 <lcdDispCLIDict_DescEntry>:
   10a88:	57 72 69 74 65 20 62 79 74 65 28 73 29 20 74 6f     Write byte(s) to
   10a98:	20 67 69 76 65 6e 20 70 61 67 65 20 73 74 61 72      given page star
   10aa8:	74 69 6e 67 20 61 74 20 67 69 76 65 6e 20 61 64     ting at given ad
   10ab8:	64 72 65 73 73 2e 20 69 2e 65 2e 20 30 78 31 20     dress. i.e. 0x1 
   10ac8:	30 78 35 20 30 78 46 46 20 30 78 30 30 00           0x5 0xFF 0x00.

00010ad6 <lcdInitCLIDict_DescEntry>:
   10ad6:	52 65 2d 69 6e 69 74 69 61 6c 69 7a 65 20 74 68     Re-initialize th
   10ae6:	65 20 4c 43 44 20 64 69 73 70 6c 61 79 2e 00        e LCD display..

00010af5 <lcdTestCLIDict_DescEntry>:
   10af5:	54 65 73 74 20 6f 75 74 20 74 68 65 20 4c 43 44     Test out the LCD
   10b05:	20 64 69 73 70 6c 61 79 2e 00 6c 63 64 43 6d 64      display..lcdCmd
   10b15:	00 6c 63 64 43 6f 6c 6f 72 00 6c 63 64 44 69 73     .lcdColor.lcdDis
   10b25:	70 00 6c 63 64 49 6e 69 74 00 6c 63 64 54 65 73     p.lcdInit.lcdTes
   10b35:	74 00 00 74 12 01 00 7f 12 01 00 89 12 01 00 97     t..t............
   10b45:	12 01 00 a0 12 01 00 a9 12 01 00 b3 12 01 00 c4     ................
   10b55:	12 01 00 d1 12 01 00 dd 12 01 00 16 01 16 01 01     ................
   10b65:	00 01 05 00 03 16 1b 5b 31 3b 33 33 6d 57 41 52     .......[1;33mWAR
   10b75:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 54 6f 6f 20 6d     NING.[0m - Too m
   10b85:	75 63 68 20 64 61 74 61 20 74 6f 20 73 65 6e 64     uch data to send
   10b95:	20 6f 6e 20 55 41 52 54 00 2c 20 77 61 69 74 69      on UART., waiti
   10ba5:	6e 67 2e 2e 2e 0d 0a 00 20 2b 00 1b 5b 31 3b 35     ng...... +..[1;5
   10bb5:	3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20     ;31mERROR.[0m - 
   10bc5:	54 6f 6f 20 62 69 67 20 6f 66 20 61 20 63 6f 6d     Too big of a com
   10bd5:	6d 61 6e 64 20 74 6f 20 66 69 74 20 69 6e 74 6f     mand to fit into
   10be5:	20 74 68 65 20 62 75 66 66 65 72 2e 2e 2e 00 1b      the buffer.....
   10bf5:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
   10c05:	6d 20 2d 20 49 6e 76 61 6c 69 64 20 55 41 52 54     m - Invalid UART
   10c15:	20 74 6f 20 73 65 6e 64 20 66 72 6f 6d 2e 2e 2e      to send from...
   10c25:	0d 0a 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47 1b     ....[1;35mDEBUG.
   10c35:	5b 30 6d 20 2d 20 41 6e 69 6d 61 74 69 6f 6e 0d     [0m - Animation.
   10c45:	0a 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47 1b 5b     ...[1;35mDEBUG.[
   10c55:	30 6d 20 2d 20 50 45 4e 44 49 4e 47 20 53 45 54     0m - PENDING SET
   10c65:	20 2d 3e 20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e      -> ..[1;33mWARN
   10c75:	49 4e 47 1b 5b 30 6d 20 2d 20 43 61 62 6c 65 20     ING.[0m - Cable 
   10c85:	46 61 75 6c 74 21 0d 0a 00 20 53 6c 61 76 65 20     Fault!... Slave 
   10c95:	00 20 4d 61 73 74 65 72 20 00 1b 5b 31 3b 33 35     . Master ..[1;35
   10ca5:	6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20 43 41 42     mDEBUG.[0m - CAB
   10cb5:	4c 45 43 48 45 43 4b 20 52 45 43 45 49 56 45 20     LECHECK RECEIVE 
   10cc5:	2d 20 00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f     - ..[1;5;31mERRO
   10cd5:	52 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20     R.[0m - Invalid 
   10ce5:	43 75 72 72 65 6e 74 45 76 65 6e 74 20 64 69 72     CurrentEvent dir
   10cf5:	65 63 74 69 6f 6e 2e 2e 2e 0d 0a 00 1b 5b 31 3b     ection.......[1;
   10d05:	33 35 6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20 49     35mDEBUG.[0m - I
   10d15:	64 45 6e 75 6d 65 72 61 74 69 6f 6e 0d 0a 00 1b     dEnumeration....
   10d25:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
   10d35:	6d 20 2d 20 49 6e 76 61 6c 69 64 20 49 64 45 6e     m - Invalid IdEn
   10d45:	75 6d 65 72 61 74 69 6f 6e 20 64 69 72 65 63 74     umeration direct
   10d55:	69 6f 6e 2e 2e 2e 0d 0a 00 1b 5b 31 3b 33 35 6d     ion.......[1;35m
   10d65:	44 45 42 55 47 1b 5b 30 6d 20 2d 20 49 64 52 65     DEBUG.[0m - IdRe
   10d75:	70 6f 72 74 0d 0a 00 1b 5b 31 3b 33 32 6d 49 4e     port....[1;32mIN
   10d85:	46 4f 1b 5b 30 6d 20 2d 20 49 64 20 52 65 70 6f     FO.[0m - Id Repo
   10d95:	72 74 65 64 3a 20 00 1b 5b 31 3b 33 35 6d 44 45     rted: ..[1;35mDE
   10da5:	42 55 47 1b 5b 30 6d 20 2d 20 49 64 52 65 71 75     BUG.[0m - IdRequ
   10db5:	65 73 74 0d 0a 00 1b 5b 31 3b 35 3b 33 31 6d 45     est....[1;5;31mE
   10dc5:	52 52 4f 52 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c     RROR.[0m - Inval
   10dd5:	69 64 20 49 64 52 65 71 75 65 73 74 20 64 69 72     id IdRequest dir
   10de5:	65 63 74 69 6f 6e 2e 2e 2e 0d 0a 00 1b 5b 31 3b     ection.......[1;
   10df5:	35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d     5;31mERROR.[0m -
   10e05:	20 49 6e 76 61 6c 69 64 20 53 63 61 6e 43 6f 64      Invalid ScanCod
   10e15:	65 20 64 69 72 65 63 74 69 6f 6e 2e 2e 2e 0d 0a     e direction.....
   10e25:	00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b     ..[1;33mWARNING.
   10e35:	5b 30 6d 20 2d 20 4e 6f 74 20 65 6e 6f 75 67 68     [0m - Not enough
   10e45:	20 69 6e 74 65 72 63 6f 6e 6e 65 63 74 20 6c 61      interconnect la
   10e55:	79 6f 75 74 20 6e 6f 64 65 73 20 63 6f 6e 66 69     yout nodes confi
   10e65:	67 75 72 65 64 3a 20 00 1b 5b 31 3b 33 35 6d 44     gured: ..[1;35mD
   10e75:	45 42 55 47 1b 5b 30 6d 20 2d 20 00 20 57 61 69     EBUG.[0m - . Wai
   10e85:	74 20 00 20 53 59 4e 20 00 20 53 4f 48 20 00 20     t . SYN . SOH . 
   10e95:	23 23 23 20 00 20 43 4d 44 20 00 1b 5b 31 3b 35     ### . CMD ..[1;5
   10ea5:	3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20     ;31mERROR.[0m - 
   10eb5:	49 6e 76 61 6c 69 64 20 55 41 52 54 53 74 61 74     Invalid UARTStat
   10ec5:	75 73 2e 2e 2e 00 54 78 46 49 46 4f 20 30 20 2d     us....TxFIFO 0 -
   10ed5:	20 00 54 78 46 49 46 4f 20 31 20 2d 20 00 55 41      .TxFIFO 1 - .UA
   10ee5:	52 54 43 6f 6e 6e 65 63 74 00 1b 5b 31 3b 33 35     RTConnect..[1;35
   10ef5:	6d 44 45 42 55 47 1b 5b 30 6d 20 2d 20 53 65 6e     mDEBUG.[0m - Sen
   10f05:	64 69 6e 67 20 63 75 72 72 65 6e 74 20 65 76 65     ding current eve
   10f15:	6e 74 0d 0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f     nt....[1;32mINFO
   10f25:	1b 5b 30 6d 20 2d 20 43 6f 6e 6e 65 63 74 20 44     .[0m - Connect D
   10f35:	65 62 75 67 20 4d 6f 64 65 20 54 6f 67 67 6c 65     ebug Mode Toggle
   10f45:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
   10f55:	20 2d 20 53 65 6e 64 69 6e 67 20 53 79 6e 63 20      - Sending Sync 
   10f65:	49 64 6c 65 73 2e 2e 2e 00 1b 5b 31 3b 33 32 6d     Idles.....[1;32m
   10f75:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 4c 69 73 74 20     INFO.[0m - List 
   10f85:	6f 66 20 55 41 52 54 43 6f 6e 6e 65 63 74 20 63     of UARTConnect c
   10f95:	6f 6d 6d 61 6e 64 73 00 1b 5b 31 3b 33 32 6d 49     ommands..[1;32mI
   10fa5:	4e 46 4f 1b 5b 30 6d 20 2d 20 53 65 74 74 69 6e     NFO.[0m - Settin
   10fb5:	67 20 64 65 76 69 63 65 20 61 73 20 73 6c 61 76     g device as slav
   10fc5:	65 2e 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     e...[1;32mINFO.[
   10fd5:	30 6d 20 2d 20 53 65 74 74 69 6e 67 20 64 65 76     0m - Setting dev
   10fe5:	69 63 65 20 61 73 20 6d 61 73 74 65 72 2e 00 1b     ice as master...
   10ff5:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
   11005:	20 52 65 73 65 74 74 69 6e 67 20 55 41 52 54 43      Resetting UARTC
   11015:	6f 6e 6e 65 63 74 20 73 74 61 74 65 2e 2e 2e 00     onnect state....
   11025:	4d 61 73 74 65 72 00 53 6c 61 76 65 00 1b 5b 31     Master.Slave..[1
   11035:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 55     ;32mINFO.[0m - U
   11045:	41 52 54 43 6f 6e 6e 65 63 74 20 53 74 61 74 75     ARTConnect Statu
   11055:	73 00 0d 0a 44 65 76 69 63 65 20 54 79 70 65 3a     s...Device Type:
   11065:	09 00 0d 0a 44 65 76 69 63 65 20 49 64 3a 09 00     ....Device Id:..
   11075:	0d 0a 4d 61 78 20 49 64 3a 09 00 0d 0a 4d 61 73     ..Max Id:....Mas
   11085:	74 65 72 20 3c 3d 0d 0a 09 53 74 61 74 75 73 3a     ter <=...Status:
   11095:	09 00 0d 0a 09 46 61 75 6c 74 73 3a 09 00 0d 0a     .....Faults:....
   110a5:	09 52 78 3a 09 00 0d 0a 09 54 78 3a 09 00 0d 0a     .Rx:.....Tx:....
   110b5:	53 6c 61 76 65 20 3c 3d 0d 0a 09 53 74 61 74 75     Slave <=...Statu
   110c5:	73 3a 09 00                                         s:..

000110c9 <connectCmdCLIDict_DescEntry>:
   110c9:	53 65 6e 64 73 20 61 20 63 6f 6d 6d 61 6e 64 20     Sends a command 
   110d9:	76 69 61 20 55 41 52 54 20 43 6f 6e 6e 65 63 74     via UART Connect
   110e9:	2c 20 66 69 72 73 74 20 61 72 67 20 69 73 20 77     , first arg is w
   110f9:	68 69 63 68 20 75 61 72 74 2c 20 6e 65 78 74 20     hich uart, next 
   11109:	61 72 67 20 69 73 20 74 68 65 20 63 6f 6d 6d 61     arg is the comma
   11119:	6e 64 2c 20 72 65 73 74 20 61 72 65 20 74 68 65     nd, rest are the
   11129:	20 61 72 67 75 6d 65 6e 74 73 2e 00                  arguments..

00011135 <connectDbgCLIDict_DescEntry>:
   11135:	54 6f 67 67 6c 65 20 55 41 52 54 43 6f 6e 6e 65     Toggle UARTConne
   11145:	63 74 20 64 65 62 75 67 20 6d 6f 64 65 2e 00        ct debug mode..

00011154 <connectIdlCLIDict_DescEntry>:
   11154:	53 65 6e 64 73 20 4e 20 6e 75 6d 62 65 72 20 6f     Sends N number o
   11164:	66 20 49 64 6c 65 20 63 6f 6d 6d 61 6e 64 73 2c     f Idle commands,
   11174:	20 32 20 69 73 20 74 68 65 20 64 65 66 61 75 6c      2 is the defaul
   11184:	74 20 76 61 6c 75 65 2c 20 61 6e 64 20 73 68 6f     t value, and sho
   11194:	75 6c 64 20 62 65 20 73 75 66 66 69 63 69 65 6e     uld be sufficien
   111a4:	74 20 69 6e 20 6d 6f 73 74 20 63 61 73 65 73 2e     t in most cases.
   111b4:	00                                                  .

000111b5 <connectLstCLIDict_DescEntry>:
   111b5:	4c 69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 20     Lists available 
   111c5:	55 41 52 54 43 6f 6e 6e 65 63 74 20 63 6f 6d 6d     UARTConnect comm
   111d5:	61 6e 64 73 20 61 6e 64 20 69 6e 64 65 78 20 69     ands and index i
   111e5:	64 00                                               d.

000111e7 <connectMstCLIDict_DescEntry>:
   111e7:	53 65 74 73 20 74 68 65 20 64 65 76 69 63 65 20     Sets the device 
   111f7:	61 73 20 6d 61 73 74 65 72 2e 20 55 73 65 20 61     as master. Use a
   11207:	72 67 75 6d 65 6e 74 20 6f 66 20 73 20 74 6f 20     rgument of s to 
   11217:	73 65 74 20 61 73 20 73 6c 61 76 65 2e 00           set as slave..

00011225 <connectRstCLIDict_DescEntry>:
   11225:	52 65 73 65 74 73 20 62 6f 74 68 20 52 78 20 61     Resets both Rx a
   11235:	6e 64 20 54 78 20 63 6f 6e 6e 65 63 74 20 62 75     nd Tx connect bu
   11245:	66 66 65 72 73 20 61 6e 64 20 73 74 61 74 65 20     ffers and state 
   11255:	76 61 72 69 61 62 6c 65 73 2e 00                    variables..

00011260 <connectStsCLIDict_DescEntry>:
   11260:	55 41 52 54 43 6f 6e 6e 65 63 74 20 73 74 61 74     UARTConnect stat
   11270:	75 73 2e 00 43 61 62 6c 65 43 68 65 63 6b 00 49     us..CableCheck.I
   11280:	64 52 65 71 75 65 73 74 00 49 64 45 6e 75 6d 65     dRequest.IdEnume
   11290:	72 61 74 69 6f 6e 00 49 64 52 65 70 6f 72 74 00     ration.IdReport.
   112a0:	53 63 61 6e 43 6f 64 65 00 41 6e 69 6d 61 74 69     ScanCode.Animati
   112b0:	6f 6e 00 52 65 6d 6f 74 65 43 61 70 61 62 69 6c     on.RemoteCapabil
   112c0:	69 74 79 00 52 65 6d 6f 74 65 4f 75 74 70 75 74     ity.RemoteOutput
   112d0:	00 52 65 6d 6f 74 65 49 6e 70 75 74 00 43 75 72     .RemoteInput.Cur
   112e0:	72 65 6e 74 45 76 65 6e 74 00 63 6f 6e 6e 65 63     rentEvent.connec
   112f0:	74 43 6d 64 00 63 6f 6e 6e 65 63 74 44 62 67 00     tCmd.connectDbg.
   11300:	63 6f 6e 6e 65 63 74 49 64 6c 00 63 6f 6e 6e 65     connectIdl.conne
   11310:	63 74 4c 73 74 00 63 6f 6e 6e 65 63 74 4d 73 74     ctLst.connectMst
   11320:	00 63 6f 6e 6e 65 63 74 52 73 74 00 63 6f 6e 6e     .connectRst.conn
   11330:	65 63 74 53 74 73 00 00                             ectSts..

00011338 <uartConnectCLIDict>:
   11338:	ea 12 01 00 c9 10 01 00 05 5e 00 00 f5 12 01 00     .........^......
   11348:	35 11 01 00 a9 50 00 00 00 13 01 00 54 11 01 00     5....P......T...
   11358:	59 5d 00 00 0b 13 01 00 b5 11 01 00 a5 52 00 00     Y]...........R..
   11368:	16 13 01 00 e7 11 01 00 81 54 00 00 21 13 01 00     .........T..!...
   11378:	25 12 01 00 f9 5e 00 00 2c 13 01 00 60 12 01 00     %....^..,...`...
   11388:	21 53 00 00 00 00 00 00 00 00 00 00 00 00 00 00     !S..............

00011398 <uartConnectCLIDictName>:
   11398:	55 41 52 54 43 6f 6e 6e 65 63 74 20 4d 6f 64 75     UARTConnect Modu
   113a8:	6c 65 20 43 6f 6d 6d 61 6e 64 73 00 4c 61 79 65     le Commands.Laye
   113b8:	72 5f 6c 61 79 65 72 4c 61 74 63 68 28 6c 61 79     r_layerLatch(lay
   113c8:	65 72 49 6e 64 65 78 29 00 4c 61 79 65 72 5f 6c     erIndex).Layer_l
   113d8:	61 79 65 72 4c 6f 63 6b 28 6c 61 79 65 72 49 6e     ayerLock(layerIn
   113e8:	64 65 78 29 00 4c 61 79 65 72 5f 6c 61 79 65 72     dex).Layer_layer
   113f8:	52 6f 74 61 74 65 28 70 72 65 76 69 6f 75 73 29     Rotate(previous)
   11408:	00 4c 61 79 65 72 5f 6c 61 79 65 72 53 68 69 66     .Layer_layerShif
   11418:	74 28 6c 61 79 65 72 49 6e 64 65 78 29 00 1b 5b     t(layerIndex)..[
   11428:	31 3b 33 36 6d 4c 1b 5b 30 6d 20 00 20 30 00 4c     1;36mL.[0m . 0.L
   11438:	61 79 65 72 5f 6c 61 79 65 72 53 74 61 74 65 28     ayer_layerState(
   11448:	6c 61 79 65 72 49 6e 64 65 78 2c 6c 61 79 65 72     layerIndex,layer
   11458:	53 74 61 74 65 29 00 00                             State)..

00011460 <CapabilitiesList>:
   11460:	1d 4f 00 00 09 00 00 00 7d 4f 00 00 00 00 00 00     .O......}O......
   11470:	fd 3d 00 00 02 00 00 00 9d 69 00 00 02 01 00 00     .=.......i......
   11480:	15 6a 00 00 02 01 00 00 41 6b 00 00 01 01 00 00     .j......Ak......
   11490:	8d 6a 00 00 02 01 00 00 21 69 00 00 03 01 00 00     .j......!i......
   114a0:	a9 6d 00 00 00 00 00 00 31 7c 00 00 02 00 00 00     .m......1|......
   114b0:	4d 76 00 00 00 01 00 00 c9 76 00 00 00 00 00 00     Mv.......v......
   114c0:	f5 c0 00 00 02 01 00 00 9d bb 00 00 00 01 00 00     ................
   114d0:	31 c6 00 00 00 00 00 00 99 c6 00 00 00 00 00 00     1...............
   114e0:	89 c1 00 00 00 01 00 00 c5 c1 00 00 01 01 00 00     ................
   114f0:	01 c7 00 00 00 00 00 00 59 c2 00 00 01 01 00 00     ........Y.......
   11500:	5d c5 00 00 02 01 00 00 9d c4 00 00 06 01 00 00     ]...............
   11510:	d5 94 00 00 01 00 00 00 d9 97 00 00 02 00 00 00     ................
   11520:	55 98 00 00 07 00 00 00 e1 95 00 00 02 00 00 00     U...............
   11530:	65 95 00 00 03 00 00 00 99 94 00 00 00 00 00 00     e...............

00011540 <InterconnectOffsetList>:
   11540:	00 2d 5a 00                                         .-Z.

00011544 <LayerIndex>:
   11544:	0c 8a ff 1f bf 2f 01 00 00 5a 00 00 78 8b ff 1f     ...../...Z..x...
   11554:	66 36 01 00 03 58 00 00 d0 8c ff 1f fc 3c 01 00     f6...X.......<..
   11564:	03 58 00 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49     .X...[1;33mWARNI
   11574:	4e 47 1b 5b 30 6d 20 2d 20 41 6e 69 6d 61 74 69     NG.[0m - Animati
   11584:	6f 6e 49 6e 64 65 78 20 69 73 20 6f 75 74 20 6f     onIndex is out o
   11594:	66 20 72 61 6e 67 65 2f 6e 6f 74 20 64 65 66 69     f range/not defi
   115a4:	6e 65 64 3a 20 00 1b 5b 31 3b 33 33 6d 57 41 52     ned: ..[1;33mWAR
   115b4:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 53 63 61 6e 43     NING.[0m - ScanC
   115c4:	6f 64 65 20 69 73 20 6f 75 74 20 6f 66 20 72 61     ode is out of ra
   115d4:	6e 67 65 2f 6e 6f 74 20 64 65 66 69 6e 65 64 3a     nge/not defined:
   115e4:	20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47      ..[1;33mWARNING
   115f4:	1b 5b 30 6d 20 2d 20 4c 61 79 65 72 49 6e 64 65     .[0m - LayerInde
   11604:	78 20 69 73 20 6f 75 74 20 6f 66 20 72 61 6e 67     x is out of rang
   11614:	65 2f 6e 6f 74 20 64 65 66 69 6e 65 64 3a 20 00     e/not defined: .
   11624:	4d 61 63 72 6f 5f 6e 6f 6e 65 28 29 00 1b 5b 31     Macro_none()..[1
   11634:	3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20     ;5;31mERROR.[0m 
   11644:	2d 20 49 6e 74 65 72 63 6f 6e 6e 65 63 74 20 54     - Interconnect T
   11654:	72 69 67 67 65 72 20 45 76 65 6e 74 20 54 79 70     rigger Event Typ
   11664:	65 20 2d 20 4e 6f 74 20 49 6d 70 6c 65 6d 65 6e     e - Not Implemen
   11674:	74 65 64 20 00 1b 5b 31 3b 35 3b 33 31 6d 45 52     ted ..[1;5;31mER
   11684:	52 4f 52 1b 5b 30 6d 20 2d 20 4d 61 63 72 6f 20     ROR.[0m - Macro 
   11694:	54 72 69 67 67 65 72 20 45 76 65 6e 74 20 4f 76     Trigger Event Ov
   116a4:	65 72 66 6c 6f 77 21 20 53 65 72 69 6f 75 73 20     erflow! Serious 
   116b4:	42 75 67 21 20 00 1b 5b 31 3b 33 35 6d 44 45 42     Bug! ..[1;35mDEB
   116c4:	55 47 1b 5b 30 6d 20 2d 20 4d 61 63 72 6f 20 53     UG.[0m - Macro S
   116d4:	74 65 70 0d 0a 00 1b 5b 31 3b 35 3b 33 31 6d 45     tep....[1;5;31mE
   116e4:	52 52 4f 52 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c     RROR.[0m - Inval
   116f4:	69 64 20 6b 65 79 20 73 74 61 74 65 20 2d 20 00     id key state - .
   11704:	1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b     .[1;5;31mERROR.[
   11714:	30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 74 79 70     0m - Invalid typ
   11724:	65 20 2d 20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e     e - ..[1;33mWARN
   11734:	49 4e 47 1b 5b 30 6d 20 2d 20 53 63 61 6e 43 6f     ING.[0m - ScanCo
   11744:	64 65 20 69 73 20 6f 75 74 20 6f 66 20 72 61 6e     de is out of ran
   11754:	67 65 2f 6e 6f 74 20 64 65 66 69 6e 65 64 20 2d     ge/not defined -
   11764:	20 00 4d 61 63 72 6f 5f 72 6f 74 61 74 65 28 29      .Macro_rotate()
   11774:	00 50 61 72 74 69 61 6c 4d 61 70 00 55 50 00 55     .PartialMap.UP.U
   11784:	52 00 44 6f 6e 65 00 52 65 70 65 61 74 00 1b 5b     R.Done.Repeat..[
   11794:	31 3b 33 31 6d 49 4e 56 41 4c 49 44 1b 5b 30 6d     1;31mINVALID.[0m
   117a4:	00 53 68 00 4c 61 00 4c 6f 00 53 77 00 4c 45 44     .Sh.La.Lo.Sw.LED
   117b4:	00 41 6e 00 4c 61 79 65 72 00 53 6c 65 65 70 00     .An.Layer.Sleep.
   117c4:	52 65 73 75 6d 65 00 49 6e 61 63 74 69 76 65 00     Resume.Inactive.
   117d4:	41 63 74 69 76 65 00 52 6f 74 61 74 69 6f 6e 00     Active.Rotation.
   117e4:	49 4e 56 41 4c 49 44 00 4d 61 63 72 6f 5f 74 65     INVALID.Macro_te
   117f4:	73 74 54 68 72 65 61 64 53 61 66 65 28 29 00 54     stThreadSafe().T
   11804:	68 72 65 61 64 53 61 66 65 3a 20 00 4d 61 63 72     hreadSafe: .Macr
   11814:	6f 5f 74 65 73 74 54 68 72 65 61 64 55 6e 73 61     o_testThreadUnsa
   11824:	66 65 28 29 00 54 68 72 65 61 64 55 6e 73 61 66     fe().ThreadUnsaf
   11834:	65 3a 20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49     e: ..[1;33mWARNI
   11844:	4e 47 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64     NG.[0m - Invalid
   11854:	20 74 69 6d 65 20 73 74 61 74 65 20 74 72 69 67      time state trig
   11864:	67 65 72 20 75 70 64 61 74 65 3a 20 00 1b 5b 31     ger update: ..[1
   11874:	3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20     ;33mWARNING.[0m 
   11884:	2d 20 4f 6e 6c 79 20 32 35 35 20 74 69 6d 65 20     - Only 255 time 
   11894:	69 6e 73 74 61 6e 63 65 73 20 61 72 65 20 61 63     instances are ac
   118a4:	63 65 70 74 65 64 20 66 6f 72 20 61 20 74 69 6d     cepted for a tim
   118b4:	65 20 73 74 61 74 65 20 74 72 69 67 67 65 72 3a     e state trigger:
   118c4:	20 00 00 00                                          ...

000118c8 <ResultMacroList>:
   118c8:	5e 2d 01 00 b0 2d 01 00 dd 2d 01 00 0a 2e 01 00     ^-...-...-......
   118d8:	37 2e 01 00 64 2e 01 00 90 2e 01 00 bc 2e 01 00     7...d...........
   118e8:	f0 2e 01 00 1f 2f 01 00 88 2d 01 00 8c 2d 01 00     ...../...-...-..
   118f8:	90 2d 01 00 94 2d 01 00 98 2d 01 00 9c 2d 01 00     .-...-...-...-..
   11908:	a0 2d 01 00 a4 2d 01 00 a8 2d 01 00 ac 2d 01 00     .-...-...-...-..
   11918:	b5 2d 01 00 b9 2d 01 00 bd 2d 01 00 c1 2d 01 00     .-...-...-...-..
   11928:	c5 2d 01 00 c9 2d 01 00 cd 2d 01 00 d1 2d 01 00     .-...-...-...-..
   11938:	d5 2d 01 00 d9 2d 01 00 e2 2d 01 00 e6 2d 01 00     .-...-...-...-..
   11948:	ea 2d 01 00 ee 2d 01 00 f2 2d 01 00 f6 2d 01 00     .-...-...-...-..
   11958:	fa 2d 01 00 fe 2d 01 00 02 2e 01 00 06 2e 01 00     .-...-..........
   11968:	0f 2e 01 00 13 2e 01 00 17 2e 01 00 1b 2e 01 00     ................
   11978:	1f 2e 01 00 23 2e 01 00 27 2e 01 00 2b 2e 01 00     ....#...'...+...
   11988:	2f 2e 01 00 33 2e 01 00 3c 2e 01 00 40 2e 01 00     /...3...<...@...
   11998:	44 2e 01 00 48 2e 01 00 4c 2e 01 00 50 2e 01 00     D...H...L...P...
   119a8:	54 2e 01 00 58 2e 01 00 5c 2e 01 00 60 2e 01 00     T...X...\...`...
   119b8:	68 2e 01 00 6c 2e 01 00 70 2e 01 00 74 2e 01 00     h...l...p...t...
   119c8:	78 2e 01 00 7c 2e 01 00 80 2e 01 00 84 2e 01 00     x...|...........
   119d8:	88 2e 01 00 8c 2e 01 00 94 2e 01 00 98 2e 01 00     ................
   119e8:	9c 2e 01 00 a0 2e 01 00 a4 2e 01 00 a8 2e 01 00     ................
   119f8:	ac 2e 01 00 b0 2e 01 00 b4 2e 01 00 b8 2e 01 00     ................
   11a08:	c0 2e 01 00 c4 2e 01 00 c8 2e 01 00 cc 2e 01 00     ................
   11a18:	d0 2e 01 00 d4 2e 01 00 d8 2e 01 00 dc 2e 01 00     ................
   11a28:	e0 2e 01 00 ec 2e 01 00 f4 2e 01 00 f8 2e 01 00     ................
   11a38:	fc 2e 01 00 00 2f 01 00 04 2f 01 00 08 2f 01 00     ...../.../.../..
   11a48:	0c 2f 01 00 0f 2f 01 00 14 2f 01 00 1a 2f 01 00     ./.../.../.../..
   11a58:	63 2d 01 00 68 2d 01 00 6e 2d 01 00 73 2d 01 00     c-..h-..n-..s-..
   11a68:	79 2d 01 00 7e 2d 01 00 83 2d 01 00                 y-..~-...-..

00011a74 <TriggerMacroList>:
   11a74:	92 43 01 00 24 00 00 00 92 43 01 00 44 00 00 00     .C..$....C..D...
   11a84:	92 43 01 00 69 00 00 00 c9 43 01 00 25 00 00 00     .C..i....C..%...
   11a94:	c9 43 01 00 3e 00 00 00 00 44 01 00 26 00 00 00     .C..>....D..&...
   11aa4:	00 44 01 00 3f 00 00 00 00 44 01 00 46 00 00 00     .D..?....D..F...
   11ab4:	37 44 01 00 27 00 00 00 37 44 01 00 40 00 00 00     7D..'...7D..@...
   11ac4:	37 44 01 00 47 00 00 00 6e 44 01 00 28 00 00 00     7D..G...nD..(...
   11ad4:	6e 44 01 00 41 00 00 00 6e 44 01 00 48 00 00 00     nD..A...nD..H...
   11ae4:	a5 44 01 00 02 00 00 00 a5 44 01 00 42 00 00 00     .D.......D..B...
   11af4:	a5 44 01 00 49 00 00 00 dc 44 01 00 2f 00 00 00     .D..I....D../...
   11b04:	ff 44 01 00 03 00 00 00 04 45 01 00 1d 00 00 00     .D.......E......
   11b14:	09 45 01 00 19 00 00 00 09 45 01 00 52 00 00 00     .E.......E..R...
   11b24:	97 43 01 00 0d 00 00 00 97 43 01 00 53 00 00 00     .C.......C..S...
   11b34:	9c 43 01 00 13 00 00 00 9c 43 01 00 54 00 00 00     .C.......C..T...
   11b44:	a1 43 01 00 14 00 00 00 a1 43 01 00 4a 00 00 00     .C.......C..J...
   11b54:	a6 43 01 00 32 00 00 00 ab 43 01 00 0c 00 00 00     .C..2....C......
   11b64:	b0 43 01 00 0e 00 00 00 b0 43 01 00 4f 00 00 00     .C.......C..O...
   11b74:	b5 43 01 00 0f 00 00 00 b5 43 01 00 50 00 00 00     .C.......C..P...
   11b84:	ba 43 01 00 10 00 00 00 ba 43 01 00 51 00 00 00     .C.......C..Q...
   11b94:	bf 43 01 00 33 00 00 00 bf 43 01 00 4a 00 00 00     .C..3....C..J...
   11ba4:	c4 43 01 00 34 00 00 00 ce 43 01 00 62 00 00 00     .C..4....C..b...
   11bb4:	d3 43 01 00 60 00 00 00 d8 43 01 00 04 00 00 00     .C..`....C......
   11bc4:	d8 43 01 00 6a 00 00 00 dd 43 01 00 12 00 00 00     .C..j....C......
   11bd4:	dd 43 01 00 58 00 00 00 e2 43 01 00 11 00 00 00     .C..X....C......
   11be4:	e2 43 01 00 4c 00 00 00 e7 43 01 00 36 00 00 00     .C..L....C..6...
   11bf4:	e7 43 01 00 4d 00 00 00 ec 43 01 00 37 00 00 00     .C..M....C..7...
   11c04:	ec 43 01 00 4e 00 00 00 f1 43 01 00 38 00 00 00     .C..N....C..8...
   11c14:	f1 43 01 00 4b 00 00 00 f6 43 01 00 5d 00 00 00     .C..K....C..]...
   11c24:	fb 43 01 00 5e 00 00 00 05 44 01 00 5f 00 00 00     .C..^....D.._...
   11c34:	0a 44 01 00 29 00 00 00 0f 44 01 00 2d 00 00 00     .D..)....D..-...
   11c44:	0f 44 01 00 55 00 00 00 14 44 01 00 31 00 00 00     .D..U....D..1...
   11c54:	19 44 01 00 2e 00 00 00 1e 44 01 00 01 00 00 00     .D.......D......
   11c64:	1e 44 01 00 56 00 00 00 23 44 01 00 00 00 00 00     .D..V...#D......
   11c74:	23 44 01 00 4b 00 00 00 28 44 01 00 5c 00 00 00     #D..K...(D..\...
   11c84:	2d 44 01 00 23 00 00 00 2d 44 01 00 43 00 00 00     -D..#...-D..C...
   11c94:	32 44 01 00 22 00 00 00 32 44 01 00 3d 00 00 00     2D.."...2D..=...
   11ca4:	3c 44 01 00 21 00 00 00 3c 44 01 00 3c 00 00 00     <D..!...<D..<...
   11cb4:	41 44 01 00 20 00 00 00 41 44 01 00 3b 00 00 00     AD.. ...AD..;...
   11cc4:	46 44 01 00 1f 00 00 00 46 44 01 00 3a 00 00 00     FD......FD..:...
   11cd4:	4b 44 01 00 35 00 00 00 4b 44 01 00 39 00 00 00     KD..5...KD..9...
   11ce4:	50 44 01 00 2a 00 00 00 50 44 01 00 60 00 00 00     PD..*...PD..`...
   11cf4:	55 44 01 00 62 00 00 00 55 44 01 00 61 00 00 00     UD..b...UD..a...
   11d04:	5a 44 01 00 18 00 00 00 5f 44 01 00 16 00 00 00     ZD......_D......
   11d14:	64 44 01 00 09 00 00 00 69 44 01 00 1b 00 00 00     dD......iD......
   11d24:	73 44 01 00 15 00 00 00 78 44 01 00 2c 00 00 00     sD......xD..,...
   11d34:	7d 44 01 00 0b 00 00 00 82 44 01 00 0a 00 00 00     }D.......D......
   11d44:	87 44 01 00 08 00 00 00 8c 44 01 00 17 00 00 00     .D.......D......
   11d54:	91 44 01 00 05 00 00 00 96 44 01 00 62 00 00 00     .D.......D..b...
   11d64:	9b 44 01 00 62 00 00 00 a0 44 01 00 60 00 00 00     .D..b....D..`...
   11d74:	aa 44 01 00 45 00 00 00 aa 44 01 00 63 00 00 00     .D..E....D..c...
   11d84:	af 44 01 00 06 00 00 00 b4 44 01 00 1a 00 00 00     .D.......D......
   11d94:	b9 44 01 00 07 00 00 00 be 44 01 00 1c 00 00 00     .D.......D......
   11da4:	c3 44 01 00 1e 00 00 00 c8 44 01 00 59 00 00 00     .D.......D..Y...
   11db4:	cd 44 01 00 5a 00 00 00 d2 44 01 00 5b 00 00 00     .D..Z....D..[...
   11dc4:	d7 44 01 00 2b 00 00 00 e1 44 01 00 2d 00 00 00     .D..+....D..-...
   11dd4:	e6 44 01 00 30 00 00 00 e6 44 01 00 68 00 00 00     .D..0....D..h...
   11de4:	eb 44 01 00 67 00 00 00 eb 44 01 00 66 00 00 00     .D..g....D..f...
   11df4:	f0 44 01 00 65 00 00 00 f0 44 01 00 64 00 00 00     .D..e....D..d...
   11e04:	f5 44 01 00 5a 00 00 00 fa 44 01 00 57 00 00 00     .D..Z....D..W...

00011e14 <capDebugCLIDict_DescEntry>:
   11e14:	50 72 69 6e 74 73 20 63 61 70 61 62 69 6c 69 74     Prints capabilit
   11e24:	79 20 64 65 62 75 67 20 6d 65 73 73 61 67 65 20     y debug message 
   11e34:	62 65 66 6f 72 65 20 63 61 6c 6c 69 6e 67 2c 20     before calling, 
   11e44:	77 69 74 68 20 74 72 69 67 67 65 72 20 63 6f 6e     with trigger con
   11e54:	64 69 74 69 6f 6e 73 2e 00                          ditions..

00011e5d <capListCLIDict_DescEntry>:
   11e5d:	50 72 69 6e 74 73 20 61 6e 20 69 6e 64 65 78 65     Prints an indexe
   11e6d:	64 20 6c 69 73 74 20 6f 66 20 61 6c 6c 20 6e 6f     d list of all no
   11e7d:	6e 20 55 53 42 20 6b 65 79 63 6f 64 65 20 63 61     n USB keycode ca
   11e8d:	70 61 62 69 6c 69 74 69 65 73 2e 00                 pabilities..

00011e99 <capSelectCLIDict_DescEntry>:
   11e99:	54 72 69 67 67 65 72 73 20 74 68 65 20 73 70 65     Triggers the spe
   11ea9:	63 69 66 69 65 64 20 63 61 70 61 62 69 6c 69 74     cified capabilit
   11eb9:	69 65 73 2e 20 46 69 72 73 74 20 74 77 6f 20 61     ies. First two a
   11ec9:	72 67 73 20 61 72 65 20 73 74 61 74 65 20 61 6e     rgs are state an
   11ed9:	64 20 73 74 61 74 65 54 79 70 65 2e 0d 0a 09 09     d stateType.....
   11ee9:	1b 5b 33 35 6d 4b 31 31 1b 5b 30 6d 20 4b 65 79     .[35mK11.[0m Key
   11ef9:	62 6f 61 72 64 20 43 61 70 61 62 69 6c 69 74 79     board Capability
   11f09:	20 30 78 30 42 00 1b 5b 31 3b 33 32 6d 49 4e 46      0x0B..[1;32mINF
   11f19:	4f 1b 5b 30 6d 20 2d 20 43 61 70 61 62 69 6c 69     O.[0m - Capabili
   11f29:	74 79 20 44 65 62 75 67 20 4d 6f 64 65 3a 20 00     ty Debug Mode: .
   11f39:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
   11f49:	2d 20 43 61 70 61 62 69 6c 69 74 69 65 73 20 4c     - Capabilities L
   11f59:	69 73 74 20 00 0d 0a 09 00 1b 5b 31 3b 33 32 6d     ist ......[1;32m
   11f69:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 4b 00 1b 5b 31     INFO.[0m - K..[1
   11f79:	3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20     ;33mWARNING.[0m 
   11f89:	2d 20 66 6c 61 73 68 4d 6f 64 65 45 6e 61 62 6c     - flashModeEnabl
   11f99:	65 64 20 6e 6f 74 20 73 65 74 2c 20 63 61 6e 63     ed not set, canc
   11fa9:	65 6c 6c 69 6e 67 20 66 69 72 6d 77 61 72 65 20     elling firmware 
   11fb9:	72 65 6c 6f 61 64 2e 2e 2e 0d 0a 00 1b 5b 31 3b     reload.......[1;
   11fc9:	33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 53 65     32mINFO.[0m - Se
   11fd9:	74 20 66 6c 61 73 68 4d 6f 64 65 45 6e 61 62 6c     t flashModeEnabl
   11fe9:	65 64 20 74 6f 20 31 20 69 6e 20 79 6f 75 72 20     ed to 1 in your 
   11ff9:	6b 6c 6c 20 63 6f 6e 66 69 67 75 72 61 74 69 6f     kll configuratio
   12009:	6e 2e 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     n...[1;32mINFO.[
   12019:	30 6d 20 2d 20 4c 61 79 65 72 20 44 65 62 75 67     0m - Layer Debug
   12029:	20 4d 6f 64 65 3a 20 00 1b 5b 31 3b 33 32 6d 49      Mode: ..[1;32mI
   12039:	4e 46 4f 1b 5b 30 6d 20 2d 20 4c 61 79 65 72 20     NFO.[0m - Layer 
   12049:	4c 69 73 74 00 20 1b 5b 31 6d 28 64 65 66 61 75     List. .[1m(defau
   12059:	6c 74 29 1b 5b 30 6d 00 0d 0a 09 09 20 4c 61 79     lt).[0m..... Lay
   12069:	65 72 20 53 74 61 74 65 3a 20 00 20 46 69 72 73     er State: . Firs
   12079:	74 20 2d 3e 20 4c 61 73 74 20 49 6e 64 69 63 65     t -> Last Indice
   12089:	73 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     s: ..[1;32mINFO.
   12099:	5b 30 6d 20 2d 20 53 65 74 74 69 6e 67 20 4c 61     [0m - Setting La
   120a9:	79 65 72 20 4c 00 20 74 6f 20 2d 20 00 1b 5b 31     yer L. to - ..[1
   120b9:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 4d     ;32mINFO.[0m - M
   120c9:	61 63 72 6f 20 44 65 62 75 67 20 4d 6f 64 65 3a     acro Debug Mode:
   120d9:	20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30      ..[1;32mINFO.[0
   120e9:	6d 20 2d 20 50 65 6e 64 69 6e 67 20 4b 65 79 20     m - Pending Key 
   120f9:	45 76 65 6e 74 73 3a 20 00 20 3a 20 00 1b 5b 31     Events: . : ..[1
   12109:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 50     ;32mINFO.[0m - P
   12119:	65 6e 64 69 6e 67 20 54 72 69 67 67 65 72 20 4d     ending Trigger M
   12129:	61 63 72 6f 73 3a 20 00 1b 5b 31 3b 33 32 6d 49     acros: ..[1;32mI
   12139:	4e 46 4f 1b 5b 30 6d 20 2d 20 50 65 6e 64 69 6e     NFO.[0m - Pendin
   12149:	67 20 52 65 73 75 6c 74 20 4d 61 63 72 6f 73 3a     g Result Macros:
   12159:	20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30      ..[1;32mINFO.[0
   12169:	6d 20 2d 20 54 72 69 67 67 65 72 20 4d 61 63 72     m - Trigger Macr
   12179:	6f 73 20 52 61 6e 67 65 3a 20 54 30 20 2d 3e 20     os Range: T0 -> 
   12189:	54 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     T..[1;32mINFO.[0
   12199:	6d 20 2d 20 52 65 73 75 6c 74 20 20 4d 61 63 72     m - Result  Macr
   121a9:	6f 73 20 52 61 6e 67 65 3a 20 52 30 20 2d 3e 20     os Range: R0 -> 
   121b9:	52 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     R..[1;32mINFO.[0
   121c9:	6d 20 2d 20 54 72 69 67 67 65 72 20 3a 20 52 65     m - Trigger : Re
   121d9:	73 75 6c 74 20 4d 61 63 72 6f 20 50 61 69 72 73     sult Macro Pairs
   121e9:	00 09 54 00 20 3a 20 52 00 1b 5b 31 3b 33 32 6d     ..T. : R..[1;32m
   121f9:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 4d 61 63 72 6f     INFO.[0m - Macro
   12209:	20 50 72 6f 63 65 73 73 69 6e 67 20 4d 6f 64 65      Processing Mode
   12219:	3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     : ..[1;32mINFO.[
   12229:	30 6d 20 2d 20 56 6f 74 65 20 44 65 62 75 67 20     0m - Vote Debug 
   12239:	4d 6f 64 65 3a 20 00                                Mode: .

00012240 <default_tl_0x00>:
   12240:	00 00 00 00                                         ....

00012244 <default_tl_0x01>:
   12244:	00 00 00 00                                         ....

00012248 <default_tl_0x02>:
   12248:	00 00 00 00                                         ....

0001224c <default_tl_0x03>:
   1224c:	01 00 00 00 00 00 00 00                             ........

00012254 <default_tl_0x04>:
   12254:	01 00 00 00 03 00 00 00                             ........

0001225c <default_tl_0x05>:
   1225c:	01 00 00 00 05 00 00 00                             ........

00012264 <default_tl_0x06>:
   12264:	01 00 00 00 08 00 00 00                             ........

0001226c <default_tl_0x07>:
   1226c:	01 00 00 00 0b 00 00 00                             ........

00012274 <default_tl_0x08>:
   12274:	01 00 00 00 0e 00 00 00                             ........

0001227c <default_tl_0x09>:
   1227c:	01 00 00 00 11 00 00 00                             ........

00012284 <default_tl_0x0A>:
   12284:	00 00 00 00                                         ....

00012288 <default_tl_0x0B>:
   12288:	00 00 00 00                                         ....

0001228c <default_tl_0x0C>:
   1228c:	01 00 00 00 12 00 00 00                             ........

00012294 <default_tl_0x0D>:
   12294:	01 00 00 00 13 00 00 00                             ........

0001229c <default_tl_0x0E>:
   1229c:	01 00 00 00 14 00 00 00                             ........

000122a4 <default_tl_0x0F>:
   122a4:	01 00 00 00 16 00 00 00                             ........

000122ac <default_tl_0x10>:
   122ac:	01 00 00 00 18 00 00 00                             ........

000122b4 <default_tl_0x11>:
   122b4:	01 00 00 00 1a 00 00 00                             ........

000122bc <default_tl_0x12>:
   122bc:	01 00 00 00 1c 00 00 00                             ........

000122c4 <default_tl_0x13>:
   122c4:	00 00 00 00                                         ....

000122c8 <default_tl_0x14>:
   122c8:	00 00 00 00                                         ....

000122cc <default_tl_0x15>:
   122cc:	00 00 00 00                                         ....

000122d0 <default_tl_0x16>:
   122d0:	01 00 00 00 1d 00 00 00                             ........

000122d8 <default_tl_0x17>:
   122d8:	01 00 00 00 1e 00 00 00                             ........

000122e0 <default_tl_0x18>:
   122e0:	01 00 00 00 20 00 00 00                             .... ...

000122e8 <default_tl_0x19>:
   122e8:	01 00 00 00 22 00 00 00                             ...."...

000122f0 <default_tl_0x1A>:
   122f0:	01 00 00 00 24 00 00 00                             ....$...

000122f8 <default_tl_0x1B>:
   122f8:	01 00 00 00 26 00 00 00                             ....&...

00012300 <default_tl_0x1C>:
   12300:	01 00 00 00 27 00 00 00                             ....'...

00012308 <default_tl_0x1D>:
   12308:	01 00 00 00 28 00 00 00                             ....(...

00012310 <default_tl_0x1E>:
   12310:	01 00 00 00 29 00 00 00                             ....)...

00012318 <default_tl_0x1F>:
   12318:	01 00 00 00 2b 00 00 00                             ....+...

00012320 <default_tl_0x20>:
   12320:	01 00 00 00 2d 00 00 00                             ....-...

00012328 <default_tl_0x21>:
   12328:	01 00 00 00 2f 00 00 00                             ..../...

00012330 <default_tl_0x22>:
   12330:	01 00 00 00 31 00 00 00                             ....1...

00012338 <default_tl_0x23>:
   12338:	01 00 00 00 33 00 00 00                             ....3...

00012340 <default_tl_0x24>:
   12340:	01 00 00 00 35 00 00 00                             ....5...

00012348 <default_tl_0x25>:
   12348:	01 00 00 00 36 00 00 00                             ....6...

00012350 <default_tl_0x26>:
   12350:	01 00 00 00 37 00 00 00                             ....7...

00012358 <default_tl_0x27>:
   12358:	01 00 00 00 38 00 00 00                             ....8...

00012360 <default_tl_0x28>:
   12360:	01 00 00 00 39 00 00 00                             ....9...

00012368 <default_tl_0x29>:
   12368:	01 00 00 00 3b 00 00 00                             ....;...

00012370 <default_tl_0x2A>:
   12370:	01 00 00 00 3c 00 00 00                             ....<...

00012378 <default_tl_0x2B>:
   12378:	01 00 00 00 3d 00 00 00                             ....=...

00012380 <default_tl_0x2C>:
   12380:	01 00 00 00 3f 00 00 00                             ....?...

00012388 <default_tl_0x2D>:
   12388:	01 00 00 00 41 00 00 00                             ....A...

00012390 <default_tl_0x2E>:
   12390:	00 00 00 00                                         ....

00012394 <default_tl_0x2F>:
   12394:	00 00 00 00                                         ....

00012398 <default_tl_0x30>:
   12398:	01 00 00 00 42 00 00 00                             ....B...

000123a0 <default_tl_0x31>:
   123a0:	01 00 00 00 44 00 00 00                             ....D...

000123a8 <default_tl_0x32>:
   123a8:	01 00 00 00 46 00 00 00                             ....F...

000123b0 <default_tl_0x33>:
   123b0:	01 00 00 00 48 00 00 00                             ....H...

000123b8 <default_tl_0x34>:
   123b8:	01 00 00 00 4a 00 00 00                             ....J...

000123c0 <default_tl_0x35>:
   123c0:	01 00 00 00 4c 00 00 00                             ....L...

000123c8 <default_tl_0x36>:
   123c8:	01 00 00 00 4e 00 00 00                             ....N...

000123d0 <default_tl_0x37>:
   123d0:	00 00 00 00                                         ....

000123d4 <default_tl_0x38>:
   123d4:	00 00 00 00                                         ....

000123d8 <default_tl_0x39>:
   123d8:	01 00 00 00 50 00 00 00                             ....P...

000123e0 <default_tl_0x3A>:
   123e0:	01 00 00 00 52 00 00 00                             ....R...

000123e8 <default_tl_0x3B>:
   123e8:	01 00 00 00 53 00 00 00                             ....S...

000123f0 <default_tl_0x3C>:
   123f0:	01 00 00 00 54 00 00 00                             ....T...

000123f8 <default_tl_0x3D>:
   123f8:	01 00 00 00 55 00 00 00                             ....U...

00012400 <default_tl_0x3E>:
   12400:	01 00 00 00 56 00 00 00                             ....V...

00012408 <default_tl_0x3F>:
   12408:	01 00 00 00 57 00 00 00                             ....W...

00012410 <default_tl_0x40>:
   12410:	00 00 00 00                                         ....

00012414 <default_tl_0x41>:
   12414:	00 00 00 00                                         ....

00012418 <default_tl_0x42>:
   12418:	00 00 00 00                                         ....

0001241c <default_tl_0x43>:
   1241c:	01 00 00 00 58 00 00 00                             ....X...

00012424 <default_tl_0x44>:
   12424:	01 00 00 00 59 00 00 00                             ....Y...

0001242c <default_tl_0x45>:
   1242c:	01 00 00 00 5a 00 00 00                             ....Z...

00012434 <default_tl_0x46>:
   12434:	01 00 00 00 5b 00 00 00                             ....[...

0001243c <default_tl_0x47>:
   1243c:	01 00 00 00 5c 00 00 00                             ....\...

00012444 <default_tl_0x48>:
   12444:	01 00 00 00 5d 00 00 00                             ....]...

0001244c <default_tl_0x49>:
   1244c:	01 00 00 00 5e 00 00 00                             ....^...

00012454 <default_tl_0x4A>:
   12454:	01 00 00 00 5f 00 00 00                             ...._...

0001245c <default_tl_0x4B>:
   1245c:	01 00 00 00 60 00 00 00                             ....`...

00012464 <default_tl_0x4C>:
   12464:	01 00 00 00 62 00 00 00                             ....b...

0001246c <default_tl_0x4D>:
   1246c:	01 00 00 00 63 00 00 00                             ....c...

00012474 <default_tl_0x4E>:
   12474:	01 00 00 00 64 00 00 00                             ....d...

0001247c <default_tl_0x4F>:
   1247c:	01 00 00 00 65 00 00 00                             ....e...

00012484 <default_tl_0x50>:
   12484:	01 00 00 00 66 00 00 00                             ....f...

0001248c <default_tl_0x51>:
   1248c:	01 00 00 00 67 00 00 00                             ....g...

00012494 <default_tl_0x52>:
   12494:	01 00 00 00 68 00 00 00                             ....h...

0001249c <default_tl_0x53>:
   1249c:	01 00 00 00 69 00 00 00                             ....i...

000124a4 <default_tl_0x54>:
   124a4:	01 00 00 00 6a 00 00 00                             ....j...

000124ac <default_tl_0x55>:
   124ac:	01 00 00 00 6b 00 00 00                             ....k...

000124b4 <default_tl_0x56>:
   124b4:	01 00 00 00 6c 00 00 00                             ....l...

000124bc <default_tl_0x57>:
   124bc:	01 00 00 00 6e 00 00 00                             ....n...

000124c4 <default_tl_0x58>:
   124c4:	01 00 00 00 70 00 00 00                             ....p...

000124cc <default_tl_0x59>:
   124cc:	01 00 00 00 72 00 00 00                             ....r...

000124d4 <default_tl_0x5A>:
   124d4:	01 00 00 00 73 00 00 00                             ....s...

000124dc <keyHoldCLIDict_DescEntry>:
   124dc:	53 65 6e 64 20 6b 65 79 2d 68 6f 6c 64 20 65 76     Send key-hold ev
   124ec:	65 6e 74 73 20 74 6f 20 74 68 65 20 6d 61 63 72     ents to the macr
   124fc:	6f 20 6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69 63     o module. Duplic
   1250c:	61 74 65 73 20 68 61 76 65 20 75 6e 64 65 66 69     ates have undefi
   1251c:	6e 65 64 20 62 65 68 61 76 69 6f 75 72 2e 0d 0a     ned behaviour...
   1252c:	09 09 1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20 53     ...[35mS10.[0m S
   1253c:	63 61 6e 63 6f 64 65 20 30 78 30 41 00              cancode 0x0A.

00012549 <keyPressCLIDict_DescEntry>:
   12549:	53 65 6e 64 20 6b 65 79 2d 70 72 65 73 73 20 65     Send key-press e
   12559:	76 65 6e 74 73 20 74 6f 20 74 68 65 20 6d 61 63     vents to the mac
   12569:	72 6f 20 6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69     ro module. Dupli
   12579:	63 61 74 65 73 20 68 61 76 65 20 75 6e 64 65 66     cates have undef
   12589:	69 6e 65 64 20 62 65 68 61 76 69 6f 75 72 2e 0d     ined behaviour..
   12599:	0a 09 09 1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20     ....[35mS10.[0m 
   125a9:	53 63 61 6e 63 6f 64 65 20 30 78 30 41 00           Scancode 0x0A.

000125b7 <keyReleaseCLIDict_DescEntry>:
   125b7:	53 65 6e 64 20 6b 65 79 2d 72 65 6c 65 61 73 65     Send key-release
   125c7:	20 65 76 65 6e 74 20 74 6f 20 6d 61 63 72 6f 20      event to macro 
   125d7:	6d 6f 64 75 6c 65 2e 20 44 75 70 6c 69 63 61 74     module. Duplicat
   125e7:	65 73 20 68 61 76 65 20 75 6e 64 65 66 69 6e 65     es have undefine
   125f7:	64 20 62 65 68 61 76 69 6f 75 72 2e 0d 0a 09 09     d behaviour.....
   12607:	1b 5b 33 35 6d 53 31 30 1b 5b 30 6d 20 53 63 61     .[35mS10.[0m Sca
   12617:	6e 63 6f 64 65 20 30 78 30 41 00 00 00              ncode 0x0A...

00012624 <layer1_tl_0x00>:
   12624:	01 00 00 00 01 00 00 00                             ........

0001262c <layer1_tl_0x01>:
   1262c:	01 00 00 00 04 00 00 00                             ........

00012634 <layer1_tl_0x02>:
   12634:	01 00 00 00 06 00 00 00                             ........

0001263c <layer1_tl_0x03>:
   1263c:	01 00 00 00 09 00 00 00                             ........

00012644 <layer1_tl_0x04>:
   12644:	01 00 00 00 0c 00 00 00                             ........

0001264c <layer1_tl_0x05>:
   1264c:	01 00 00 00 0f 00 00 00                             ........

00012654 <layer1_tl_0x06>:
   12654:	00 00 00 00                                         ....

00012658 <layer1_tl_0x07>:
   12658:	00 00 00 00                                         ....

0001265c <layer1_tl_0x08>:
   1265c:	00 00 00 00                                         ....

00012660 <layer1_tl_0x09>:
   12660:	00 00 00 00                                         ....

00012664 <layer1_tl_0x0A>:
   12664:	00 00 00 00                                         ....

00012668 <layer1_tl_0x0B>:
   12668:	00 00 00 00                                         ....

0001266c <layer1_tl_0x0C>:
   1266c:	00 00 00 00                                         ....

00012670 <layer1_tl_0x0D>:
   12670:	00 00 00 00                                         ....

00012674 <layer1_tl_0x0E>:
   12674:	00 00 00 00                                         ....

00012678 <layer1_tl_0x0F>:
   12678:	00 00 00 00                                         ....

0001267c <layer1_tl_0x10>:
   1267c:	00 00 00 00                                         ....

00012680 <layer1_tl_0x11>:
   12680:	00 00 00 00                                         ....

00012684 <layer1_tl_0x12>:
   12684:	00 00 00 00                                         ....

00012688 <layer1_tl_0x13>:
   12688:	00 00 00 00                                         ....

0001268c <layer1_tl_0x14>:
   1268c:	00 00 00 00                                         ....

00012690 <layer1_tl_0x15>:
   12690:	00 00 00 00                                         ....

00012694 <layer1_tl_0x16>:
   12694:	00 00 00 00                                         ....

00012698 <layer1_tl_0x17>:
   12698:	00 00 00 00                                         ....

0001269c <layer1_tl_0x18>:
   1269c:	00 00 00 00                                         ....

000126a0 <layer1_tl_0x19>:
   126a0:	00 00 00 00                                         ....

000126a4 <layer1_tl_0x1A>:
   126a4:	00 00 00 00                                         ....

000126a8 <layer1_tl_0x1B>:
   126a8:	01 00 00 00 2a 00 00 00                             ....*...

000126b0 <layer1_tl_0x1C>:
   126b0:	01 00 00 00 2c 00 00 00                             ....,...

000126b8 <layer1_tl_0x1D>:
   126b8:	00 00 00 00                                         ....

000126bc <layer1_tl_0x1E>:
   126bc:	00 00 00 00                                         ....

000126c0 <layer1_tl_0x1F>:
   126c0:	00 00 00 00                                         ....

000126c4 <layer1_tl_0x20>:
   126c4:	00 00 00 00                                         ....

000126c8 <layer1_tl_0x21>:
   126c8:	00 00 00 00                                         ....

000126cc <layer1_tl_0x22>:
   126cc:	00 00 00 00                                         ....

000126d0 <layer1_tl_0x23>:
   126d0:	00 00 00 00                                         ....

000126d4 <layer1_tl_0x24>:
   126d4:	00 00 00 00                                         ....

000126d8 <layer1_tl_0x25>:
   126d8:	00 00 00 00                                         ....

000126dc <layer1_tl_0x26>:
   126dc:	00 00 00 00                                         ....

000126e0 <layer1_tl_0x27>:
   126e0:	00 00 00 00                                         ....

000126e4 <layer1_tl_0x28>:
   126e4:	00 00 00 00                                         ....

000126e8 <layer1_tl_0x29>:
   126e8:	00 00 00 00                                         ....

000126ec <layer1_tl_0x2A>:
   126ec:	00 00 00 00                                         ....

000126f0 <layer1_tl_0x2B>:
   126f0:	00 00 00 00                                         ....

000126f4 <layer1_tl_0x2C>:
   126f4:	00 00 00 00                                         ....

000126f8 <layer1_tl_0x2D>:
   126f8:	01 00 00 00 43 00 00 00                             ....C...

00012700 <layer1_tl_0x2E>:
   12700:	01 00 00 00 45 00 00 00                             ....E...

00012708 <layer1_tl_0x2F>:
   12708:	01 00 00 00 47 00 00 00                             ....G...

00012710 <layer1_tl_0x30>:
   12710:	01 00 00 00 49 00 00 00                             ....I...

00012718 <layer1_tl_0x31>:
   12718:	01 00 00 00 4b 00 00 00                             ....K...

00012720 <layer1_tl_0x32>:
   12720:	01 00 00 00 4d 00 00 00                             ....M...

00012728 <layer1_tl_0x33>:
   12728:	00 00 00 00                                         ....

0001272c <layer1_tl_0x34>:
   1272c:	00 00 00 00                                         ....

00012730 <layer1_tl_0x35>:
   12730:	00 00 00 00                                         ....

00012734 <layer1_tl_0x36>:
   12734:	01 00 00 00 51 00 00 00                             ....Q...

0001273c <layer1_tl_0x37>:
   1273c:	00 00 00 00                                         ....

00012740 <layer1_tl_0x38>:
   12740:	00 00 00 00                                         ....

00012744 <layer1_tl_0x39>:
   12744:	00 00 00 00                                         ....

00012748 <layer1_tl_0x3A>:
   12748:	00 00 00 00                                         ....

0001274c <layer1_tl_0x3B>:
   1274c:	00 00 00 00                                         ....

00012750 <layer1_tl_0x3C>:
   12750:	00 00 00 00                                         ....

00012754 <layer1_tl_0x3D>:
   12754:	00 00 00 00                                         ....

00012758 <layer1_tl_0x3E>:
   12758:	00 00 00 00                                         ....

0001275c <layer1_tl_0x3F>:
   1275c:	00 00 00 00                                         ....

00012760 <layer1_tl_0x40>:
   12760:	00 00 00 00                                         ....

00012764 <layer1_tl_0x41>:
   12764:	00 00 00 00                                         ....

00012768 <layer1_tl_0x42>:
   12768:	00 00 00 00                                         ....

0001276c <layer1_tl_0x43>:
   1276c:	00 00 00 00                                         ....

00012770 <layer1_tl_0x44>:
   12770:	00 00 00 00                                         ....

00012774 <layer1_tl_0x45>:
   12774:	00 00 00 00                                         ....

00012778 <layer1_tl_0x46>:
   12778:	00 00 00 00                                         ....

0001277c <layer1_tl_0x47>:
   1277c:	00 00 00 00                                         ....

00012780 <layer1_tl_0x48>:
   12780:	01 00 00 00 61 00 00 00                             ....a...

00012788 <layer1_tl_0x49>:
   12788:	00 00 00 00                                         ....

0001278c <layer1_tl_0x4A>:
   1278c:	00 00 00 00                                         ....

00012790 <layer1_tl_0x4B>:
   12790:	00 00 00 00                                         ....

00012794 <layer1_tl_0x4C>:
   12794:	00 00 00 00                                         ....

00012798 <layer1_tl_0x4D>:
   12798:	00 00 00 00                                         ....

0001279c <layer1_tl_0x4E>:
   1279c:	00 00 00 00                                         ....

000127a0 <layer1_tl_0x4F>:
   127a0:	00 00 00 00                                         ....

000127a4 <layer1_tl_0x50>:
   127a4:	00 00 00 00                                         ....

000127a8 <layer1_tl_0x51>:
   127a8:	00 00 00 00                                         ....

000127ac <layer1_tl_0x52>:
   127ac:	00 00 00 00                                         ....

000127b0 <layer1_tl_0x53>:
   127b0:	01 00 00 00 6d 00 00 00                             ....m...

000127b8 <layer1_tl_0x54>:
   127b8:	01 00 00 00 6f 00 00 00                             ....o...

000127c0 <layer1_tl_0x55>:
   127c0:	01 00 00 00 71 00 00 00                             ....q...

000127c8 <layer2_tl_0x00>:
   127c8:	01 00 00 00 02 00 00 00                             ........

000127d0 <layer2_tl_0x01>:
   127d0:	00 00 00 00                                         ....

000127d4 <layer2_tl_0x02>:
   127d4:	01 00 00 00 07 00 00 00                             ........

000127dc <layer2_tl_0x03>:
   127dc:	01 00 00 00 0a 00 00 00                             ........

000127e4 <layer2_tl_0x04>:
   127e4:	01 00 00 00 0d 00 00 00                             ........

000127ec <layer2_tl_0x05>:
   127ec:	01 00 00 00 10 00 00 00                             ........

000127f4 <layer2_tl_0x06>:
   127f4:	00 00 00 00                                         ....

000127f8 <layer2_tl_0x07>:
   127f8:	00 00 00 00                                         ....

000127fc <layer2_tl_0x08>:
   127fc:	00 00 00 00                                         ....

00012800 <layer2_tl_0x09>:
   12800:	00 00 00 00                                         ....

00012804 <layer2_tl_0x0A>:
   12804:	00 00 00 00                                         ....

00012808 <layer2_tl_0x0B>:
   12808:	01 00 00 00 15 00 00 00                             ........

00012810 <layer2_tl_0x0C>:
   12810:	01 00 00 00 17 00 00 00                             ........

00012818 <layer2_tl_0x0D>:
   12818:	01 00 00 00 19 00 00 00                             ........

00012820 <layer2_tl_0x0E>:
   12820:	01 00 00 00 1b 00 00 00                             ........

00012828 <layer2_tl_0x0F>:
   12828:	00 00 00 00                                         ....

0001282c <layer2_tl_0x10>:
   1282c:	00 00 00 00                                         ....

00012830 <layer2_tl_0x11>:
   12830:	00 00 00 00                                         ....

00012834 <layer2_tl_0x12>:
   12834:	00 00 00 00                                         ....

00012838 <layer2_tl_0x13>:
   12838:	00 00 00 00                                         ....

0001283c <layer2_tl_0x14>:
   1283c:	01 00 00 00 1f 00 00 00                             ........

00012844 <layer2_tl_0x15>:
   12844:	01 00 00 00 21 00 00 00                             ....!...

0001284c <layer2_tl_0x16>:
   1284c:	01 00 00 00 23 00 00 00                             ....#...

00012854 <layer2_tl_0x17>:
   12854:	01 00 00 00 25 00 00 00                             ....%...

0001285c <layer2_tl_0x18>:
   1285c:	00 00 00 00                                         ....

00012860 <layer2_tl_0x19>:
   12860:	00 00 00 00                                         ....

00012864 <layer2_tl_0x1A>:
   12864:	00 00 00 00                                         ....

00012868 <layer2_tl_0x1B>:
   12868:	01 00 00 00 2a 00 00 00                             ....*...

00012870 <layer2_tl_0x1C>:
   12870:	00 00 00 00                                         ....

00012874 <layer2_tl_0x1D>:
   12874:	01 00 00 00 2e 00 00 00                             ........

0001287c <layer2_tl_0x1E>:
   1287c:	01 00 00 00 30 00 00 00                             ....0...

00012884 <layer2_tl_0x1F>:
   12884:	01 00 00 00 32 00 00 00                             ....2...

0001288c <layer2_tl_0x20>:
   1288c:	01 00 00 00 34 00 00 00                             ....4...

00012894 <layer2_tl_0x21>:
   12894:	00 00 00 00                                         ....

00012898 <layer2_tl_0x22>:
   12898:	00 00 00 00                                         ....

0001289c <layer2_tl_0x23>:
   1289c:	00 00 00 00                                         ....

000128a0 <layer2_tl_0x24>:
   128a0:	00 00 00 00                                         ....

000128a4 <layer2_tl_0x25>:
   128a4:	01 00 00 00 3a 00 00 00                             ....:...

000128ac <layer2_tl_0x26>:
   128ac:	00 00 00 00                                         ....

000128b0 <layer2_tl_0x27>:
   128b0:	00 00 00 00                                         ....

000128b4 <layer2_tl_0x28>:
   128b4:	01 00 00 00 3e 00 00 00                             ....>...

000128bc <layer2_tl_0x29>:
   128bc:	01 00 00 00 40 00 00 00                             ....@...

000128c4 <layer2_tl_0x2A>:
   128c4:	00 00 00 00                                         ....

000128c8 <layer2_tl_0x2B>:
   128c8:	00 00 00 00                                         ....

000128cc <layer2_tl_0x2C>:
   128cc:	00 00 00 00                                         ....

000128d0 <layer2_tl_0x2D>:
   128d0:	00 00 00 00                                         ....

000128d4 <layer2_tl_0x2E>:
   128d4:	00 00 00 00                                         ....

000128d8 <layer2_tl_0x2F>:
   128d8:	00 00 00 00                                         ....

000128dc <layer2_tl_0x30>:
   128dc:	00 00 00 00                                         ....

000128e0 <layer2_tl_0x31>:
   128e0:	00 00 00 00                                         ....

000128e4 <layer2_tl_0x32>:
   128e4:	00 00 00 00                                         ....

000128e8 <layer2_tl_0x33>:
   128e8:	01 00 00 00 4f 00 00 00                             ....O...

000128f0 <layer2_tl_0x34>:
   128f0:	00 00 00 00                                         ....

000128f4 <layer2_tl_0x35>:
   128f4:	00 00 00 00                                         ....

000128f8 <layer2_tl_0x36>:
   128f8:	01 00 00 00 51 00 00 00                             ....Q...

00012900 <layer2_tl_0x37>:
   12900:	00 00 00 00                                         ....

00012904 <layer2_tl_0x38>:
   12904:	00 00 00 00                                         ....

00012908 <layer2_tl_0x39>:
   12908:	00 00 00 00                                         ....

0001290c <layer2_tl_0x3A>:
   1290c:	00 00 00 00                                         ....

00012910 <layer2_tl_0x3B>:
   12910:	00 00 00 00                                         ....

00012914 <layer2_tl_0x3C>:
   12914:	00 00 00 00                                         ....

00012918 <layer2_tl_0x3D>:
   12918:	00 00 00 00                                         ....

0001291c <layer2_tl_0x3E>:
   1291c:	00 00 00 00                                         ....

00012920 <layer2_tl_0x3F>:
   12920:	00 00 00 00                                         ....

00012924 <layer2_tl_0x40>:
   12924:	00 00 00 00                                         ....

00012928 <layer2_tl_0x41>:
   12928:	00 00 00 00                                         ....

0001292c <layer2_tl_0x42>:
   1292c:	00 00 00 00                                         ....

00012930 <layer2_tl_0x43>:
   12930:	00 00 00 00                                         ....

00012934 <layer2_tl_0x44>:
   12934:	00 00 00 00                                         ....

00012938 <layer2_tl_0x45>:
   12938:	00 00 00 00                                         ....

0001293c <layer2_tl_0x46>:
   1293c:	00 00 00 00                                         ....

00012940 <layer2_tl_0x47>:
   12940:	00 00 00 00                                         ....

00012944 <layer2_tl_0x48>:
   12944:	01 00 00 00 61 00 00 00                             ....a...

0001294c <layer2_tl_0x49>:
   1294c:	00 00 00 00                                         ....

00012950 <layer2_tl_0x4A>:
   12950:	00 00 00 00                                         ....

00012954 <layer2_tl_0x4B>:
   12954:	00 00 00 00                                         ....

00012958 <layer2_tl_0x4C>:
   12958:	00 00 00 00                                         ....

0001295c <layer2_tl_0x4D>:
   1295c:	00 00 00 00                                         ....

00012960 <layer2_tl_0x4E>:
   12960:	00 00 00 00                                         ....

00012964 <layer2_tl_0x4F>:
   12964:	00 00 00 00                                         ....

00012968 <layer2_tl_0x50>:
   12968:	00 00 00 00                                         ....

0001296c <layer2_tl_0x51>:
   1296c:	00 00 00 00                                         ....

00012970 <layer2_tl_0x52>:
   12970:	00 00 00 00                                         ....

00012974 <layer2_tl_0x53>:
   12974:	01 00 00 00 6d 00 00 00                             ....m...

0001297c <layer2_tl_0x54>:
   1297c:	01 00 00 00 6f 00 00 00                             ....o...

00012984 <layer2_tl_0x55>:
   12984:	01 00 00 00 71 00 00 00                             ....q...

0001298c <layerDebugCLIDict_DescEntry>:
   1298c:	4c 61 79 65 72 20 64 65 62 75 67 20 6d 6f 64 65     Layer debug mode
   1299c:	2e 20 53 68 6f 77 73 20 6c 61 79 65 72 20 73 74     . Shows layer st
   129ac:	61 63 6b 20 61 6e 64 20 61 6e 79 20 63 68 61 6e     ack and any chan
   129bc:	67 65 73 2e 00                                      ges..

000129c1 <layerListCLIDict_DescEntry>:
   129c1:	4c 69 73 74 20 61 76 61 69 6c 61 62 6c 65 20 6c     List available l
   129d1:	61 79 65 72 73 2e 00                                ayers..

000129d8 <layerStateCLIDict_DescEntry>:
   129d8:	4d 6f 64 69 66 79 20 73 70 65 63 69 66 69 65 64     Modify specified
   129e8:	20 69 6e 64 65 78 65 64 20 6c 61 79 65 72 20 73      indexed layer s
   129f8:	74 61 74 65 20 3c 6c 61 79 65 72 3e 20 3c 73 74     tate <layer> <st
   12a08:	61 74 65 20 62 79 74 65 3e 2e 0d 0a 09 09 1b 5b     ate byte>......[
   12a18:	33 35 6d 4c 32 1b 5b 30 6d 20 49 6e 64 65 78 65     35mL2.[0m Indexe
   12a28:	64 20 4c 61 79 65 72 20 30 78 30 32 0d 0a 09 09     d Layer 0x02....
   12a38:	30 20 4f 66 66 2c 20 31 20 53 68 69 66 74 2c 20     0 Off, 1 Shift, 
   12a48:	32 20 4c 61 74 63 68 2c 20 34 20 4c 6f 63 6b 20     2 Latch, 4 Lock 
   12a58:	53 74 61 74 65 73 00 00                             States..

00012a60 <macroCLIDict>:
   12a60:	23 2f 01 00 14 1e 01 00 0d 6e 00 00 2c 2f 01 00     #/.......n..,/..
   12a70:	5d 1e 01 00 e5 6e 00 00 34 2f 01 00 99 1e 01 00     ]....n..4/......
   12a80:	8d 71 00 00 3e 2f 01 00 dc 24 01 00 31 79 00 00     .q..>/...$..1y..
   12a90:	46 2f 01 00 49 25 01 00 79 79 00 00 4f 2f 01 00     F/..I%..yy..O/..
   12aa0:	b7 25 01 00 c1 79 00 00 5a 2f 01 00 8c 29 01 00     .%...y..Z/...)..
   12ab0:	55 6e 00 00 65 2f 01 00 c1 29 01 00 6d 73 00 00     Un..e/...)..ms..
   12ac0:	6f 2f 01 00 d8 29 01 00 b1 72 00 00 7a 2f 01 00     o/...)...r..z/..
   12ad0:	42 2b 01 00 05 71 00 00 85 2f 01 00 3a 2c 01 00     B+...q.../..:,..
   12ae0:	65 6f 00 00 8f 2f 01 00 66 2c 01 00 9d 6e 00 00     eo.../..f,...n..
   12af0:	99 2f 01 00 85 2c 01 00 01 82 00 00 a3 2f 01 00     ./...,......./..
   12b00:	09 2d 01 00 31 73 00 00 ad 2f 01 00 35 2d 01 00     .-..1s.../..5-..
   12b10:	e5 6d 00 00 b5 2f 01 00 0e 45 01 00 25 74 00 00     .m.../...E..%t..
   12b20:	00 00 00 00 00 00 00 00 00 00 00 00                 ............

00012b2c <macroCLIDictName>:
   12b2c:	4d 61 63 72 6f 20 4d 6f 64 75 6c 65 20 43 6f 6d     Macro Module Com
   12b3c:	6d 61 6e 64 73 00                                   mands.

00012b42 <macroDebugCLIDict_DescEntry>:
   12b42:	44 69 73 61 62 6c 65 73 2f 45 6e 61 62 6c 65 73     Disables/Enables
   12b52:	20 73 65 6e 64 69 6e 67 20 55 53 42 20 6b 65 79      sending USB key
   12b62:	63 6f 64 65 73 20 74 6f 20 74 68 65 20 4f 75 74     codes to the Out
   12b72:	70 75 74 20 4d 6f 64 75 6c 65 20 61 6e 64 20 70     put Module and p
   12b82:	72 69 6e 74 73 20 55 2f 4b 20 63 6f 64 65 73 2e     rints U/K codes.
   12b92:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
   12ba2:	20 2d 20 52 65 73 75 6c 74 20 4d 61 63 72 6f 20      - Result Macro 
   12bb2:	49 6e 64 65 78 3a 20 00 2c 00 1b 5b 31 3b 33 32     Index: .,..[1;32
   12bc2:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 54 72 69 67     mINFO.[0m - Trig
   12bd2:	67 65 72 20 4d 61 63 72 6f 20 49 6e 64 65 78 3a     ger Macro Index:
   12be2:	20 00 7c 00 3b 00 0d 0a 50 6f 73 69 74 69 6f 6e      .|.;...Position
   12bf2:	3a 20 00 0d 0a 52 65 73 75 6c 74 20 4d 61 63 72     : ...Result Macr
   12c02:	6f 20 49 6e 64 65 78 3a 20 00 0d 0a 54 72 69 67     o Index: ...Trig
   12c12:	67 65 72 20 4d 61 63 72 6f 20 53 74 61 74 65 3a     ger Macro State:
   12c22:	20 00 50 72 65 73 73 7c 52 65 6c 65 61 73 65 00      .Press|Release.
   12c32:	57 61 69 74 69 6e 67 00                             Waiting.

00012c3a <macroListCLIDict_DescEntry>:
   12c3a:	4c 69 73 74 20 74 68 65 20 64 65 66 69 6e 65 64     List the defined
   12c4a:	20 74 72 69 67 67 65 72 20 61 6e 64 20 72 65 73      trigger and res
   12c5a:	75 6c 74 20 6d 61 63 72 6f 73 2e 00                 ult macros..

00012c66 <macroProcCLIDict_DescEntry>:
   12c66:	50 61 75 73 65 2f 52 65 73 75 6d 65 20 6d 61 63     Pause/Resume mac
   12c76:	72 6f 20 70 72 6f 63 65 73 73 69 6e 67 2e 00        ro processing..

00012c85 <macroShowCLIDict_DescEntry>:
   12c85:	53 68 6f 77 20 74 68 65 20 6d 61 63 72 6f 20 63     Show the macro c
   12c95:	6f 72 72 65 73 70 6f 6e 64 69 6e 67 20 74 6f 20     orresponding to 
   12ca5:	74 68 65 20 67 69 76 65 6e 20 69 6e 64 65 78 2e     the given index.
   12cb5:	0d 0a 09 09 1b 5b 33 35 6d 54 31 36 1b 5b 30 6d     .....[35mT16.[0m
   12cc5:	20 49 6e 64 65 78 65 64 20 54 72 69 67 67 65 72      Indexed Trigger
   12cd5:	20 4d 61 63 72 6f 20 30 78 31 30 2c 20 1b 5b 33      Macro 0x10, .[3
   12ce5:	35 6d 52 31 32 1b 5b 30 6d 20 49 6e 64 65 78 65     5mR12.[0m Indexe
   12cf5:	64 20 52 65 73 75 6c 74 20 4d 61 63 72 6f 20 30     d Result Macro 0
   12d05:	78 30 43 00                                         x0C.

00012d09 <macroStepCLIDict_DescEntry>:
   12d09:	44 6f 20 4e 20 6d 61 63 72 6f 20 70 72 6f 63 65     Do N macro proce
   12d19:	73 73 69 6e 67 20 73 74 65 70 73 2e 20 44 65 66     ssing steps. Def
   12d29:	61 75 6c 74 73 20 74 6f 20 31 2e 00                 aults to 1..

00012d35 <posListCLIDict_DescEntry>:
   12d35:	4c 69 73 74 20 70 68 79 73 69 63 61 6c 20 6b 65     List physical ke
   12d45:	79 20 70 6f 73 69 74 69 6f 6e 73 20 62 79 20 53     y positions by S
   12d55:	63 61 6e 43 6f 64 65 2e 00                          canCode..

00012d5e <rm0_guide>:
   12d5e:	01 0c b5 00 00                                      .....

00012d63 <rm100_guide>:
   12d63:	01 06 03 00 00                                      .....

00012d68 <rm101_guide>:
   12d68:	02 06 03 00 01 00                                   ......

00012d6e <rm102_guide>:
   12d6e:	01 06 04 00 00                                      .....

00012d73 <rm103_guide>:
   12d73:	02 06 04 00 01 00                                   ......

00012d79 <rm104_guide>:
   12d79:	01 06 05 00 00                                      .....

00012d7e <rm105_guide>:
   12d7e:	01 06 06 00 00                                      .....

00012d83 <rm106_guide>:
   12d83:	01 06 07 00 00                                      .....

00012d88 <rm10_guide>:
   12d88:	01 13 09 00                                         ....

00012d8c <rm11_guide>:
   12d8c:	01 13 0a 00                                         ....

00012d90 <rm12_guide>:
   12d90:	01 13 0b 00                                         ....

00012d94 <rm13_guide>:
   12d94:	01 13 0c 00                                         ....

00012d98 <rm14_guide>:
   12d98:	01 13 0d 00                                         ....

00012d9c <rm15_guide>:
   12d9c:	01 13 0e 00                                         ....

00012da0 <rm16_guide>:
   12da0:	01 13 0f 00                                         ....

00012da4 <rm17_guide>:
   12da4:	01 13 10 00                                         ....

00012da8 <rm18_guide>:
   12da8:	01 13 11 00                                         ....

00012dac <rm19_guide>:
   12dac:	01 13 12 00                                         ....

00012db0 <rm1_guide>:
   12db0:	01 0c b6 00 00                                      .....

00012db5 <rm20_guide>:
   12db5:	01 13 13 00                                         ....

00012db9 <rm21_guide>:
   12db9:	01 13 14 00                                         ....

00012dbd <rm22_guide>:
   12dbd:	01 13 15 00                                         ....

00012dc1 <rm23_guide>:
   12dc1:	01 13 16 00                                         ....

00012dc5 <rm24_guide>:
   12dc5:	01 13 17 00                                         ....

00012dc9 <rm25_guide>:
   12dc9:	01 13 18 00                                         ....

00012dcd <rm26_guide>:
   12dcd:	01 13 19 00                                         ....

00012dd1 <rm27_guide>:
   12dd1:	01 13 1a 00                                         ....

00012dd5 <rm28_guide>:
   12dd5:	01 13 1b 00                                         ....

00012dd9 <rm29_guide>:
   12dd9:	01 13 1c 00                                         ....

00012ddd <rm2_guide>:
   12ddd:	01 0c cd 00 00                                      .....

00012de2 <rm30_guide>:
   12de2:	01 13 1d 00                                         ....

00012de6 <rm31_guide>:
   12de6:	01 13 1e 00                                         ....

00012dea <rm32_guide>:
   12dea:	01 13 1f 00                                         ....

00012dee <rm33_guide>:
   12dee:	01 13 20 00                                         .. .

00012df2 <rm34_guide>:
   12df2:	01 13 21 00                                         ..!.

00012df6 <rm35_guide>:
   12df6:	01 13 22 00                                         ..".

00012dfa <rm36_guide>:
   12dfa:	01 13 23 00                                         ..#.

00012dfe <rm37_guide>:
   12dfe:	01 13 24 00                                         ..$.

00012e02 <rm38_guide>:
   12e02:	01 13 25 00                                         ..%.

00012e06 <rm39_guide>:
   12e06:	01 13 26 00                                         ..&.

00012e0a <rm3_guide>:
   12e0a:	01 0c e9 00 00                                      .....

00012e0f <rm40_guide>:
   12e0f:	01 13 27 00                                         ..'.

00012e13 <rm41_guide>:
   12e13:	01 13 28 00                                         ..(.

00012e17 <rm42_guide>:
   12e17:	01 13 29 00                                         ..).

00012e1b <rm43_guide>:
   12e1b:	01 13 2a 00                                         ..*.

00012e1f <rm44_guide>:
   12e1f:	01 13 2b 00                                         ..+.

00012e23 <rm45_guide>:
   12e23:	01 13 2c 00                                         ..,.

00012e27 <rm46_guide>:
   12e27:	01 13 2d 00                                         ..-.

00012e2b <rm47_guide>:
   12e2b:	01 13 2e 00                                         ....

00012e2f <rm48_guide>:
   12e2f:	01 13 2f 00                                         ../.

00012e33 <rm49_guide>:
   12e33:	01 13 30 00                                         ..0.

00012e37 <rm4_guide>:
   12e37:	01 0c ea 00 00                                      .....

00012e3c <rm50_guide>:
   12e3c:	01 13 31 00                                         ..1.

00012e40 <rm51_guide>:
   12e40:	01 13 33 00                                         ..3.

00012e44 <rm52_guide>:
   12e44:	01 13 34 00                                         ..4.

00012e48 <rm53_guide>:
   12e48:	01 13 35 00                                         ..5.

00012e4c <rm54_guide>:
   12e4c:	01 13 36 00                                         ..6.

00012e50 <rm55_guide>:
   12e50:	01 13 37 00                                         ..7.

00012e54 <rm56_guide>:
   12e54:	01 13 38 00                                         ..8.

00012e58 <rm57_guide>:
   12e58:	01 13 3a 00                                         ..:.

00012e5c <rm58_guide>:
   12e5c:	01 13 3b 00                                         ..;.

00012e60 <rm59_guide>:
   12e60:	01 13 3c 00                                         ..<.

00012e64 <rm5_guide>:
   12e64:	01 13 04 00                                         ....

00012e68 <rm60_guide>:
   12e68:	01 13 3d 00                                         ..=.

00012e6c <rm61_guide>:
   12e6c:	01 13 3e 00                                         ..>.

00012e70 <rm62_guide>:
   12e70:	01 13 3f 00                                         ..?.

00012e74 <rm63_guide>:
   12e74:	01 13 40 00                                         ..@.

00012e78 <rm64_guide>:
   12e78:	01 13 41 00                                         ..A.

00012e7c <rm65_guide>:
   12e7c:	01 13 42 00                                         ..B.

00012e80 <rm66_guide>:
   12e80:	01 13 43 00                                         ..C.

00012e84 <rm67_guide>:
   12e84:	01 13 44 00                                         ..D.

00012e88 <rm68_guide>:
   12e88:	01 13 45 00                                         ..E.

00012e8c <rm69_guide>:
   12e8c:	01 13 4c 00                                         ..L.

00012e90 <rm6_guide>:
   12e90:	01 13 05 00                                         ....

00012e94 <rm70_guide>:
   12e94:	01 13 53 00                                         ..S.

00012e98 <rm71_guide>:
   12e98:	01 13 54 00                                         ..T.

00012e9c <rm72_guide>:
   12e9c:	01 13 55 00                                         ..U.

00012ea0 <rm73_guide>:
   12ea0:	01 13 56 00                                         ..V.

00012ea4 <rm74_guide>:
   12ea4:	01 13 57 00                                         ..W.

00012ea8 <rm75_guide>:
   12ea8:	01 13 58 00                                         ..X.

00012eac <rm76_guide>:
   12eac:	01 13 59 00                                         ..Y.

00012eb0 <rm77_guide>:
   12eb0:	01 13 5a 00                                         ..Z.

00012eb4 <rm78_guide>:
   12eb4:	01 13 5b 00                                         ..[.

00012eb8 <rm79_guide>:
   12eb8:	01 13 5c 00                                         ..\.

00012ebc <rm7_guide>:
   12ebc:	01 13 06 00                                         ....

00012ec0 <rm80_guide>:
   12ec0:	01 13 5d 00                                         ..].

00012ec4 <rm81_guide>:
   12ec4:	01 13 5e 00                                         ..^.

00012ec8 <rm82_guide>:
   12ec8:	01 13 5f 00                                         .._.

00012ecc <rm83_guide>:
   12ecc:	01 13 60 00                                         ..`.

00012ed0 <rm84_guide>:
   12ed0:	01 13 61 00                                         ..a.

00012ed4 <rm85_guide>:
   12ed4:	01 13 62 00                                         ..b.

00012ed8 <rm86_guide>:
   12ed8:	01 13 63 00                                         ..c.

00012edc <rm87_guide>:
   12edc:	01 13 e0 00                                         ....

00012ee0 <rm88_guide>:
   12ee0:	02 13 e0 13 05 01 13 11 01 13 00 00                 ............

00012eec <rm89_guide>:
   12eec:	01 13 e1 00                                         ....

00012ef0 <rm8_guide>:
   12ef0:	01 13 07 00                                         ....

00012ef4 <rm90_guide>:
   12ef4:	01 13 e2 00                                         ....

00012ef8 <rm91_guide>:
   12ef8:	01 13 e3 00                                         ....

00012efc <rm92_guide>:
   12efc:	01 13 e4 00                                         ....

00012f00 <rm93_guide>:
   12f00:	01 13 e5 00                                         ....

00012f04 <rm94_guide>:
   12f04:	01 13 e6 00                                         ....

00012f08 <rm95_guide>:
   12f08:	01 13 e7 00                                         ....

00012f0c <rm96_guide>:
   12f0c:	01 0d 00                                            ...

00012f0f <rm97_guide>:
   12f0f:	01 06 01 00 00                                      .....

00012f14 <rm98_guide>:
   12f14:	02 06 01 00 01 00                                   ......

00012f1a <rm99_guide>:
   12f1a:	01 06 02 00 00                                      .....

00012f1f <rm9_guide>:
   12f1f:	01 13 08 00 63 61 70 44 65 62 75 67 00 63 61 70     ....capDebug.cap
   12f2f:	4c 69 73 74 00 63 61 70 53 65 6c 65 63 74 00 6b     List.capSelect.k
   12f3f:	65 79 48 6f 6c 64 00 6b 65 79 50 72 65 73 73 00     eyHold.keyPress.
   12f4f:	6b 65 79 52 65 6c 65 61 73 65 00 6c 61 79 65 72     keyRelease.layer
   12f5f:	44 65 62 75 67 00 6c 61 79 65 72 4c 69 73 74 00     Debug.layerList.
   12f6f:	6c 61 79 65 72 53 74 61 74 65 00 6d 61 63 72 6f     layerState.macro
   12f7f:	44 65 62 75 67 00 6d 61 63 72 6f 4c 69 73 74 00     Debug.macroList.
   12f8f:	6d 61 63 72 6f 50 72 6f 63 00 6d 61 63 72 6f 53     macroProc.macroS
   12f9f:	68 6f 77 00 6d 61 63 72 6f 53 74 65 70 00 70 6f     how.macroStep.po
   12faf:	73 4c 69 73 74 00 76 6f 74 65 44 65 62 75 67 00     sList.voteDebug.
   12fbf:	44 3a 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74     D: projects_root
   12fcf:	5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74     _keyboard_utilit
   12fdf:	69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74     ies_ergodox_cont
   12fef:	72 6f 6c 6c 65 72 5f 53 63 61 6e 5f 44 65 76 69     roller_Scan_Devi
   12fff:	63 65 73 5f 49 53 53 49 4c 65 64 40 5b 27 63 61     ces_ISSILed@['ca
   1300f:	70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72 6f     pabilities']_pro
   1301f:	63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f     cessed.kll + pro
   1302f:	6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f     jects_root_keybo
   1303f:	61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65 72     ard_utilities_er
   1304f:	67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72     godox_controller
   1305f:	5f 53 63 61 6e 5f 44 65 76 69 63 65 73 5f 4d 61     _Scan_Devices_Ma
   1306f:	74 72 69 78 41 52 4d 50 65 72 69 6f 64 69 63 40     trixARMPeriodic@
   1307f:	5b 27 63 61 70 61 62 69 6c 69 74 69 65 73 27 5d     ['capabilities']
   1308f:	5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b     _processed.kll +
   1309f:	20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b      projects_root_k
   130af:	65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65     eyboard_utilitie
   130bf:	73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f     s_ergodox_contro
   130cf:	6c 6c 65 72 5f 53 63 61 6e 5f 44 65 76 69 63 65     ller_Scan_Device
   130df:	73 5f 53 54 4c 63 64 40 5b 27 63 61 70 61 62 69     s_STLcd@['capabi
   130ef:	6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73     lities']_process
   130ff:	65 64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74     ed.kll + project
   1310f:	73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f     s_root_keyboard_
   1311f:	75 74 69 6c 69 74 69 65 73 5f 65 72 67 6f 64 6f     utilities_ergodo
   1312f:	78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 53 63 61     x_controller_Sca
   1313f:	6e 5f 44 65 76 69 63 65 73 5f 55 41 52 54 43 6f     n_Devices_UARTCo
   1314f:	6e 6e 65 63 74 40 5b 27 63 61 70 61 62 69 6c 69     nnect@['capabili
   1315f:	74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65 64     ties']_processed
   1316f:	2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f     .kll + projects_
   1317f:	72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75 74     root_keyboard_ut
   1318f:	69 6c 69 74 69 65 73 5f 65 72 67 6f 64 6f 78 5f     ilities_ergodox_
   1319f:	63 6f 6e 74 72 6f 6c 6c 65 72 5f 4d 61 63 72 6f     controller_Macro
   131af:	5f 50 61 72 74 69 61 6c 4d 61 70 40 5b 27 63 61     _PartialMap@['ca
   131bf:	70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72 6f     pabilities']_pro
   131cf:	63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f     cessed.kll + pro
   131df:	6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f     jects_root_keybo
   131ef:	61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65 72     ard_utilities_er
   131ff:	67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72     godox_controller
   1320f:	5f 4d 61 63 72 6f 5f 50 69 78 65 6c 4d 61 70 40     _Macro_PixelMap@
   1321f:	5b 27 63 61 70 61 62 69 6c 69 74 69 65 73 27 5d     ['capabilities']
   1322f:	5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b     _processed.kll +
   1323f:	20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b      projects_root_k
   1324f:	65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65     eyboard_utilitie
   1325f:	73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f     s_ergodox_contro
   1326f:	6c 6c 65 72 5f 4f 75 74 70 75 74 5f 48 49 44 2d     ller_Output_HID-
   1327f:	49 4f 40 5b 27 63 61 70 61 62 69 6c 69 74 69 65     IO@['capabilitie
   1328f:	73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c     s']_processed.kl
   1329f:	6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f     l + projects_roo
   132af:	74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69     t_keyboard_utili
   132bf:	74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e     ties_ergodox_con
   132cf:	74 72 6f 6c 6c 65 72 5f 4f 75 74 70 75 74 5f 55     troller_Output_U
   132df:	53 42 40 5b 27 63 61 70 61 62 69 6c 69 74 69 65     SB@['capabilitie
   132ef:	73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c     s']_processed.kl
   132ff:	6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f     l + projects_roo
   1330f:	74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69     t_keyboard_utili
   1331f:	74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e     ties_ergodox_con
   1332f:	74 72 6f 6c 6c 65 72 5f 44 65 62 75 67 5f 6c 61     troller_Debug_la
   1333f:	74 65 6e 63 79 40 5b 27 63 61 70 61 62 69 6c 69     tency@['capabili
   1334f:	74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65 64     ties']_processed
   1335f:	2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f     .kll + projects_
   1336f:	72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75 74     root_keyboard_ut
   1337f:	69 6c 69 74 69 65 73 5f 65 72 67 6f 64 6f 78 5f     ilities_ergodox_
   1338f:	63 6f 6e 74 72 6f 6c 6c 65 72 5f 44 65 62 75 67     controller_Debug
   1339f:	5f 6c 65 64 40 5b 27 63 61 70 61 62 69 6c 69 74     _led@['capabilit
   133af:	69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e     ies']_processed.
   133bf:	6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72     kll + projects_r
   133cf:	6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69     oot_keyboard_uti
   133df:	6c 69 74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63     lities_ergodox_c
   133ef:	6f 6e 74 72 6f 6c 6c 65 72 5f 53 63 61 6e 5f 49     ontroller_Scan_I
   133ff:	6e 66 69 6e 69 74 79 5f 45 72 67 6f 64 6f 78 40     nfinity_Ergodox@
   1340f:	5b 27 73 63 61 6e 63 6f 64 65 5f 6d 61 70 27 5d     ['scancode_map']
   1341f:	5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b     _processed.kll +
   1342f:	20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b      projects_root_k
   1343f:	65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65     eyboard_utilitie
   1344f:	73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f     s_ergodox_contro
   1345f:	6c 6c 65 72 5f 53 63 61 6e 5f 49 6e 66 69 6e 69     ller_Scan_Infini
   1346f:	74 79 5f 45 72 67 6f 64 6f 78 40 5b 27 72 69 67     ty_Ergodox@['rig
   1347f:	68 74 48 61 6e 64 27 5d 5f 70 72 6f 63 65 73 73     htHand']_process
   1348f:	65 64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74     ed.kll + project
   1349f:	73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f     s_root_keyboard_
   134af:	75 74 69 6c 69 74 69 65 73 5f 65 72 67 6f 64 6f     utilities_ergodo
   134bf:	78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 53 63 61     x_controller_Sca
   134cf:	6e 5f 49 6e 66 69 6e 69 74 79 5f 45 72 67 6f 64     n_Infinity_Ergod
   134df:	6f 78 40 5b 27 73 6c 61 76 65 31 27 5d 5f 70 72     ox@['slave1']_pr
   134ef:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72     ocessed.kll + pr
   134ff:	6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62     ojects_root_keyb
   1350f:	6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65     oard_utilities_e
   1351f:	72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65     rgodox_controlle
   1352f:	72 5f 53 63 61 6e 5f 49 6e 66 69 6e 69 74 79 5f     r_Scan_Infinity_
   1353f:	45 72 67 6f 64 6f 78 40 5b 27 6c 65 66 74 48 61     Ergodox@['leftHa
   1354f:	6e 64 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b     nd']_processed.k
   1355f:	6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f     ll + projects_ro
   1356f:	6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c     ot_keyboard_util
   1357f:	69 74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f     ities_ergodox_co
   1358f:	6e 74 72 6f 6c 6c 65 72 5f 4b 65 79 62 6f 61 72     ntroller_Keyboar
   1359f:	64 73 5f 64 61 72 77 69 6e 31 38 2e 30 2e 30 2e     ds_darwin18.0.0.
   135af:	49 43 45 44 2d 52 2e 67 63 63 2e 6d 61 6b 65 40     ICED-R.gcc.make@
   135bf:	5b 27 4d 44 45 72 67 6f 31 2d 44 65 66 61 75 6c     ['MDErgo1-Defaul
   135cf:	74 2d 30 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e     t-0']_processed.
   135df:	6b 6c 6c 20 2b 20 6c 6f 63 61 6c 5f 73 68 61 72     kll + local_shar
   135ef:	65 5f 76 69 72 74 75 61 6c 65 6e 76 73 5f 4b 65     e_virtualenvs_Ke
   135ff:	79 62 6f 61 72 64 73 2d 76 64 78 53 49 35 64 41     yboards-vdxSI5dA
   1360f:	5f 6c 69 62 5f 70 79 74 68 6f 6e 33 2e 37 5f 73     _lib_python3.7_s
   1361f:	69 74 65 2d 70 61 63 6b 61 67 65 73 5f 6b 6c 6c     ite-packages_kll
   1362f:	5f 6c 61 79 6f 75 74 73 5f 69 6e 66 69 6e 69 74     _layouts_infinit
   1363f:	79 5f 65 72 67 6f 64 6f 78 40 5b 27 6c 63 64 46     y_ergodox@['lcdF
   1364f:	75 6e 63 4d 61 70 27 5d 5f 70 72 6f 63 65 73 73     uncMap']_process
   1365f:	65 64 2e 6b 6c 6c 00 31 3a 20 70 72 6f 6a 65 63     ed.kll.1: projec
   1366f:	74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64     ts_root_keyboard
   1367f:	5f 75 74 69 6c 69 74 69 65 73 5f 65 72 67 6f 64     _utilities_ergod
   1368f:	6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 53 63     ox_controller_Sc
   1369f:	61 6e 5f 44 65 76 69 63 65 73 5f 49 53 53 49 4c     an_Devices_ISSIL
   136af:	65 64 40 5b 27 63 61 70 61 62 69 6c 69 74 69 65     ed@['capabilitie
   136bf:	73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c     s']_processed.kl
   136cf:	6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f     l + projects_roo
   136df:	74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69     t_keyboard_utili
   136ef:	74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e     ties_ergodox_con
   136ff:	74 72 6f 6c 6c 65 72 5f 53 63 61 6e 5f 44 65 76     troller_Scan_Dev
   1370f:	69 63 65 73 5f 4d 61 74 72 69 78 41 52 4d 50 65     ices_MatrixARMPe
   1371f:	72 69 6f 64 69 63 40 5b 27 63 61 70 61 62 69 6c     riodic@['capabil
   1372f:	69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65     ities']_processe
   1373f:	64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73     d.kll + projects
   1374f:	5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75     _root_keyboard_u
   1375f:	74 69 6c 69 74 69 65 73 5f 65 72 67 6f 64 6f 78     tilities_ergodox
   1376f:	5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 53 63 61 6e     _controller_Scan
   1377f:	5f 44 65 76 69 63 65 73 5f 53 54 4c 63 64 40 5b     _Devices_STLcd@[
   1378f:	27 63 61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f     'capabilities']_
   1379f:	70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20     processed.kll + 
   137af:	70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65     projects_root_ke
   137bf:	79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73     yboard_utilities
   137cf:	5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c     _ergodox_control
   137df:	6c 65 72 5f 53 63 61 6e 5f 44 65 76 69 63 65 73     ler_Scan_Devices
   137ef:	5f 55 41 52 54 43 6f 6e 6e 65 63 74 40 5b 27 63     _UARTConnect@['c
   137ff:	61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72     apabilities']_pr
   1380f:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72     ocessed.kll + pr
   1381f:	6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62     ojects_root_keyb
   1382f:	6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65     oard_utilities_e
   1383f:	72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65     rgodox_controlle
   1384f:	72 5f 4d 61 63 72 6f 5f 50 61 72 74 69 61 6c 4d     r_Macro_PartialM
   1385f:	61 70 40 5b 27 63 61 70 61 62 69 6c 69 74 69 65     ap@['capabilitie
   1386f:	73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c     s']_processed.kl
   1387f:	6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f     l + projects_roo
   1388f:	74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69     t_keyboard_utili
   1389f:	74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e     ties_ergodox_con
   138af:	74 72 6f 6c 6c 65 72 5f 4d 61 63 72 6f 5f 50 69     troller_Macro_Pi
   138bf:	78 65 6c 4d 61 70 40 5b 27 63 61 70 61 62 69 6c     xelMap@['capabil
   138cf:	69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65     ities']_processe
   138df:	64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73     d.kll + projects
   138ef:	5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75     _root_keyboard_u
   138ff:	74 69 6c 69 74 69 65 73 5f 65 72 67 6f 64 6f 78     tilities_ergodox
   1390f:	5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 4f 75 74 70     _controller_Outp
   1391f:	75 74 5f 48 49 44 2d 49 4f 40 5b 27 63 61 70 61     ut_HID-IO@['capa
   1392f:	62 69 6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65     bilities']_proce
   1393f:	73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65     ssed.kll + proje
   1394f:	63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72     cts_root_keyboar
   1395f:	64 5f 75 74 69 6c 69 74 69 65 73 5f 65 72 67 6f     d_utilities_ergo
   1396f:	64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 4f     dox_controller_O
   1397f:	75 74 70 75 74 5f 55 53 42 40 5b 27 63 61 70 61     utput_USB@['capa
   1398f:	62 69 6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65     bilities']_proce
   1399f:	73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65     ssed.kll + proje
   139af:	63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72     cts_root_keyboar
   139bf:	64 5f 75 74 69 6c 69 74 69 65 73 5f 65 72 67 6f     d_utilities_ergo
   139cf:	64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 44     dox_controller_D
   139df:	65 62 75 67 5f 6c 61 74 65 6e 63 79 40 5b 27 63     ebug_latency@['c
   139ef:	61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72     apabilities']_pr
   139ff:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72     ocessed.kll + pr
   13a0f:	6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62     ojects_root_keyb
   13a1f:	6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65     oard_utilities_e
   13a2f:	72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65     rgodox_controlle
   13a3f:	72 5f 44 65 62 75 67 5f 6c 65 64 40 5b 27 63 61     r_Debug_led@['ca
   13a4f:	70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72 6f     pabilities']_pro
   13a5f:	63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f     cessed.kll + pro
   13a6f:	6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f     jects_root_keybo
   13a7f:	61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65 72     ard_utilities_er
   13a8f:	67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72     godox_controller
   13a9f:	5f 53 63 61 6e 5f 49 6e 66 69 6e 69 74 79 5f 45     _Scan_Infinity_E
   13aaf:	72 67 6f 64 6f 78 40 5b 27 73 63 61 6e 63 6f 64     rgodox@['scancod
   13abf:	65 5f 6d 61 70 27 5d 5f 70 72 6f 63 65 73 73 65     e_map']_processe
   13acf:	64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73     d.kll + projects
   13adf:	5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75     _root_keyboard_u
   13aef:	74 69 6c 69 74 69 65 73 5f 65 72 67 6f 64 6f 78     tilities_ergodox
   13aff:	5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 53 63 61 6e     _controller_Scan
   13b0f:	5f 49 6e 66 69 6e 69 74 79 5f 45 72 67 6f 64 6f     _Infinity_Ergodo
   13b1f:	78 40 5b 27 72 69 67 68 74 48 61 6e 64 27 5d 5f     x@['rightHand']_
   13b2f:	70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20     processed.kll + 
   13b3f:	70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65     projects_root_ke
   13b4f:	79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73     yboard_utilities
   13b5f:	5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c     _ergodox_control
   13b6f:	6c 65 72 5f 53 63 61 6e 5f 49 6e 66 69 6e 69 74     ler_Scan_Infinit
   13b7f:	79 5f 45 72 67 6f 64 6f 78 40 5b 27 73 6c 61 76     y_Ergodox@['slav
   13b8f:	65 31 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b     e1']_processed.k
   13b9f:	6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f     ll + projects_ro
   13baf:	6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c     ot_keyboard_util
   13bbf:	69 74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f     ities_ergodox_co
   13bcf:	6e 74 72 6f 6c 6c 65 72 5f 53 63 61 6e 5f 49 6e     ntroller_Scan_In
   13bdf:	66 69 6e 69 74 79 5f 45 72 67 6f 64 6f 78 40 5b     finity_Ergodox@[
   13bef:	27 6c 65 66 74 48 61 6e 64 27 5d 5f 70 72 6f 63     'leftHand']_proc
   13bff:	65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a     essed.kll + proj
   13c0f:	65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61     ects_root_keyboa
   13c1f:	72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65 72 67     rd_utilities_erg
   13c2f:	6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f     odox_controller_
   13c3f:	4b 65 79 62 6f 61 72 64 73 5f 64 61 72 77 69 6e     Keyboards_darwin
   13c4f:	31 38 2e 30 2e 30 2e 49 43 45 44 2d 52 2e 67 63     18.0.0.ICED-R.gc
   13c5f:	63 2e 6d 61 6b 65 40 5b 27 4d 44 45 72 67 6f 31     c.make@['MDErgo1
   13c6f:	2d 44 65 66 61 75 6c 74 2d 31 27 5d 5f 70 72 6f     -Default-1']_pro
   13c7f:	63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 6c 6f 63     cessed.kll + loc
   13c8f:	61 6c 5f 73 68 61 72 65 5f 76 69 72 74 75 61 6c     al_share_virtual
   13c9f:	65 6e 76 73 5f 4b 65 79 62 6f 61 72 64 73 2d 76     envs_Keyboards-v
   13caf:	64 78 53 49 35 64 41 5f 6c 69 62 5f 70 79 74 68     dxSI5dA_lib_pyth
   13cbf:	6f 6e 33 2e 37 5f 73 69 74 65 2d 70 61 63 6b 61     on3.7_site-packa
   13ccf:	67 65 73 5f 6b 6c 6c 5f 6c 61 79 6f 75 74 73 40     ges_kll_layouts@
   13cdf:	5b 27 73 74 64 46 75 6e 63 4d 61 70 27 5d 5f 70     ['stdFuncMap']_p
   13cef:	72 6f 63 65 73 73 65 64 2e 6b 6c 6c 00 32 3a 20     rocessed.kll.2: 
   13cff:	70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65     projects_root_ke
   13d0f:	79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73     yboard_utilities
   13d1f:	5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c     _ergodox_control
   13d2f:	6c 65 72 5f 53 63 61 6e 5f 44 65 76 69 63 65 73     ler_Scan_Devices
   13d3f:	5f 49 53 53 49 4c 65 64 40 5b 27 63 61 70 61 62     _ISSILed@['capab
   13d4f:	69 6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73     ilities']_proces
   13d5f:	73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63     sed.kll + projec
   13d6f:	74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64     ts_root_keyboard
   13d7f:	5f 75 74 69 6c 69 74 69 65 73 5f 65 72 67 6f 64     _utilities_ergod
   13d8f:	6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 53 63     ox_controller_Sc
   13d9f:	61 6e 5f 44 65 76 69 63 65 73 5f 4d 61 74 72 69     an_Devices_Matri
   13daf:	78 41 52 4d 50 65 72 69 6f 64 69 63 40 5b 27 63     xARMPeriodic@['c
   13dbf:	61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72     apabilities']_pr
   13dcf:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72     ocessed.kll + pr
   13ddf:	6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62     ojects_root_keyb
   13def:	6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65     oard_utilities_e
   13dff:	72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65     rgodox_controlle
   13e0f:	72 5f 53 63 61 6e 5f 44 65 76 69 63 65 73 5f 53     r_Scan_Devices_S
   13e1f:	54 4c 63 64 40 5b 27 63 61 70 61 62 69 6c 69 74     TLcd@['capabilit
   13e2f:	69 65 73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e     ies']_processed.
   13e3f:	6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72     kll + projects_r
   13e4f:	6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69     oot_keyboard_uti
   13e5f:	6c 69 74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63     lities_ergodox_c
   13e6f:	6f 6e 74 72 6f 6c 6c 65 72 5f 53 63 61 6e 5f 44     ontroller_Scan_D
   13e7f:	65 76 69 63 65 73 5f 55 41 52 54 43 6f 6e 6e 65     evices_UARTConne
   13e8f:	63 74 40 5b 27 63 61 70 61 62 69 6c 69 74 69 65     ct@['capabilitie
   13e9f:	73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c     s']_processed.kl
   13eaf:	6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f     l + projects_roo
   13ebf:	74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69     t_keyboard_utili
   13ecf:	74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e     ties_ergodox_con
   13edf:	74 72 6f 6c 6c 65 72 5f 4d 61 63 72 6f 5f 50 61     troller_Macro_Pa
   13eef:	72 74 69 61 6c 4d 61 70 40 5b 27 63 61 70 61 62     rtialMap@['capab
   13eff:	69 6c 69 74 69 65 73 27 5d 5f 70 72 6f 63 65 73     ilities']_proces
   13f0f:	73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65 63     sed.kll + projec
   13f1f:	74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72 64     ts_root_keyboard
   13f2f:	5f 75 74 69 6c 69 74 69 65 73 5f 65 72 67 6f 64     _utilities_ergod
   13f3f:	6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 4d 61     ox_controller_Ma
   13f4f:	63 72 6f 5f 50 69 78 65 6c 4d 61 70 40 5b 27 63     cro_PixelMap@['c
   13f5f:	61 70 61 62 69 6c 69 74 69 65 73 27 5d 5f 70 72     apabilities']_pr
   13f6f:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72     ocessed.kll + pr
   13f7f:	6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62     ojects_root_keyb
   13f8f:	6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65     oard_utilities_e
   13f9f:	72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65     rgodox_controlle
   13faf:	72 5f 4f 75 74 70 75 74 5f 48 49 44 2d 49 4f 40     r_Output_HID-IO@
   13fbf:	5b 27 63 61 70 61 62 69 6c 69 74 69 65 73 27 5d     ['capabilities']
   13fcf:	5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b     _processed.kll +
   13fdf:	20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b      projects_root_k
   13fef:	65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65     eyboard_utilitie
   13fff:	73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f     s_ergodox_contro
   1400f:	6c 6c 65 72 5f 4f 75 74 70 75 74 5f 55 53 42 40     ller_Output_USB@
   1401f:	5b 27 63 61 70 61 62 69 6c 69 74 69 65 73 27 5d     ['capabilities']
   1402f:	5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b     _processed.kll +
   1403f:	20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b      projects_root_k
   1404f:	65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65     eyboard_utilitie
   1405f:	73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f     s_ergodox_contro
   1406f:	6c 6c 65 72 5f 44 65 62 75 67 5f 6c 61 74 65 6e     ller_Debug_laten
   1407f:	63 79 40 5b 27 63 61 70 61 62 69 6c 69 74 69 65     cy@['capabilitie
   1408f:	73 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c     s']_processed.kl
   1409f:	6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f     l + projects_roo
   140af:	74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69     t_keyboard_utili
   140bf:	74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e     ties_ergodox_con
   140cf:	74 72 6f 6c 6c 65 72 5f 44 65 62 75 67 5f 6c 65     troller_Debug_le
   140df:	64 40 5b 27 63 61 70 61 62 69 6c 69 74 69 65 73     d@['capabilities
   140ef:	27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c     ']_processed.kll
   140ff:	20 2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74      + projects_root
   1410f:	5f 6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74     _keyboard_utilit
   1411f:	69 65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74     ies_ergodox_cont
   1412f:	72 6f 6c 6c 65 72 5f 53 63 61 6e 5f 49 6e 66 69     roller_Scan_Infi
   1413f:	6e 69 74 79 5f 45 72 67 6f 64 6f 78 40 5b 27 73     nity_Ergodox@['s
   1414f:	63 61 6e 63 6f 64 65 5f 6d 61 70 27 5d 5f 70 72     cancode_map']_pr
   1415f:	6f 63 65 73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72     ocessed.kll + pr
   1416f:	6f 6a 65 63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62     ojects_root_keyb
   1417f:	6f 61 72 64 5f 75 74 69 6c 69 74 69 65 73 5f 65     oard_utilities_e
   1418f:	72 67 6f 64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65     rgodox_controlle
   1419f:	72 5f 53 63 61 6e 5f 49 6e 66 69 6e 69 74 79 5f     r_Scan_Infinity_
   141af:	45 72 67 6f 64 6f 78 40 5b 27 72 69 67 68 74 48     Ergodox@['rightH
   141bf:	61 6e 64 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e     and']_processed.
   141cf:	6b 6c 6c 20 2b 20 70 72 6f 6a 65 63 74 73 5f 72     kll + projects_r
   141df:	6f 6f 74 5f 6b 65 79 62 6f 61 72 64 5f 75 74 69     oot_keyboard_uti
   141ef:	6c 69 74 69 65 73 5f 65 72 67 6f 64 6f 78 5f 63     lities_ergodox_c
   141ff:	6f 6e 74 72 6f 6c 6c 65 72 5f 53 63 61 6e 5f 49     ontroller_Scan_I
   1420f:	6e 66 69 6e 69 74 79 5f 45 72 67 6f 64 6f 78 40     nfinity_Ergodox@
   1421f:	5b 27 73 6c 61 76 65 31 27 5d 5f 70 72 6f 63 65     ['slave1']_proce
   1422f:	73 73 65 64 2e 6b 6c 6c 20 2b 20 70 72 6f 6a 65     ssed.kll + proje
   1423f:	63 74 73 5f 72 6f 6f 74 5f 6b 65 79 62 6f 61 72     cts_root_keyboar
   1424f:	64 5f 75 74 69 6c 69 74 69 65 73 5f 65 72 67 6f     d_utilities_ergo
   1425f:	64 6f 78 5f 63 6f 6e 74 72 6f 6c 6c 65 72 5f 53     dox_controller_S
   1426f:	63 61 6e 5f 49 6e 66 69 6e 69 74 79 5f 45 72 67     can_Infinity_Erg
   1427f:	6f 64 6f 78 40 5b 27 6c 65 66 74 48 61 6e 64 27     odox@['leftHand'
   1428f:	5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c 20     ]_processed.kll 
   1429f:	2b 20 70 72 6f 6a 65 63 74 73 5f 72 6f 6f 74 5f     + projects_root_
   142af:	6b 65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69     keyboard_utiliti
   142bf:	65 73 5f 65 72 67 6f 64 6f 78 5f 63 6f 6e 74 72     es_ergodox_contr
   142cf:	6f 6c 6c 65 72 5f 4b 65 79 62 6f 61 72 64 73 5f     oller_Keyboards_
   142df:	64 61 72 77 69 6e 31 38 2e 30 2e 30 2e 49 43 45     darwin18.0.0.ICE
   142ef:	44 2d 52 2e 67 63 63 2e 6d 61 6b 65 40 5b 27 4d     D-R.gcc.make@['M
   142ff:	44 45 72 67 6f 31 2d 44 65 66 61 75 6c 74 2d 32     DErgo1-Default-2
   1430f:	27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b 6c 6c     ']_processed.kll
   1431f:	20 2b 20 6c 6f 63 61 6c 5f 73 68 61 72 65 5f 76      + local_share_v
   1432f:	69 72 74 75 61 6c 65 6e 76 73 5f 4b 65 79 62 6f     irtualenvs_Keybo
   1433f:	61 72 64 73 2d 76 64 78 53 49 35 64 41 5f 6c 69     ards-vdxSI5dA_li
   1434f:	62 5f 70 79 74 68 6f 6e 33 2e 37 5f 73 69 74 65     b_python3.7_site
   1435f:	2d 70 61 63 6b 61 67 65 73 5f 6b 6c 6c 5f 6c 61     -packages_kll_la
   1436f:	79 6f 75 74 73 40 5b 27 73 74 64 46 75 6e 63 4d     youts@['stdFuncM
   1437f:	61 70 27 5d 5f 70 72 6f 63 65 73 73 65 64 2e 6b     ap']_processed.k
   1438f:	6c 6c 00                                            ll.

00014392 <tm0_guide>:
   14392:	01 00 80 03 00                                      .....

00014397 <tm10_guide>:
   14397:	01 00 80 0f 00                                      .....

0001439c <tm11_guide>:
   1439c:	01 00 80 10 00                                      .....

000143a1 <tm12_guide>:
   143a1:	01 00 80 11 00                                      .....

000143a6 <tm13_guide>:
   143a6:	01 00 80 12 00                                      .....

000143ab <tm14_guide>:
   143ab:	01 00 80 16 00                                      .....

000143b0 <tm15_guide>:
   143b0:	01 00 80 17 00                                      .....

000143b5 <tm16_guide>:
   143b5:	01 00 80 18 00                                      .....

000143ba <tm17_guide>:
   143ba:	01 00 80 19 00                                      .....

000143bf <tm18_guide>:
   143bf:	01 00 80 1a 00                                      .....

000143c4 <tm19_guide>:
   143c4:	01 00 80 1b 00                                      .....

000143c9 <tm1_guide>:
   143c9:	01 00 80 04 00                                      .....

000143ce <tm20_guide>:
   143ce:	01 00 80 1c 00                                      .....

000143d3 <tm21_guide>:
   143d3:	01 00 80 1d 00                                      .....

000143d8 <tm22_guide>:
   143d8:	01 00 80 1e 00                                      .....

000143dd <tm23_guide>:
   143dd:	01 00 80 1f 00                                      .....

000143e2 <tm24_guide>:
   143e2:	01 00 80 20 00                                      ... .

000143e7 <tm25_guide>:
   143e7:	01 00 80 21 00                                      ...!.

000143ec <tm26_guide>:
   143ec:	01 00 80 22 00                                      ...".

000143f1 <tm27_guide>:
   143f1:	01 00 80 23 00                                      ...#.

000143f6 <tm28_guide>:
   143f6:	01 00 80 24 00                                      ...$.

000143fb <tm29_guide>:
   143fb:	01 00 80 25 00                                      ...%.

00014400 <tm2_guide>:
   14400:	01 00 80 05 00                                      .....

00014405 <tm30_guide>:
   14405:	01 00 80 26 00                                      ...&.

0001440a <tm31_guide>:
   1440a:	01 00 80 27 00                                      ...'.

0001440f <tm32_guide>:
   1440f:	01 00 80 28 00                                      ...(.

00014414 <tm33_guide>:
   14414:	01 00 80 29 00                                      ...).

00014419 <tm34_guide>:
   14419:	01 00 80 2a 00                                      ...*.

0001441e <tm35_guide>:
   1441e:	01 00 80 2b 00                                      ...+.

00014423 <tm36_guide>:
   14423:	01 00 80 2c 00                                      ...,.

00014428 <tm37_guide>:
   14428:	01 00 80 2d 00                                      ...-.

0001442d <tm38_guide>:
   1442d:	01 00 80 30 00                                      ...0.

00014432 <tm39_guide>:
   14432:	01 00 80 31 00                                      ...1.

00014437 <tm3_guide>:
   14437:	01 00 80 06 00                                      .....

0001443c <tm40_guide>:
   1443c:	01 00 80 32 00                                      ...2.

00014441 <tm41_guide>:
   14441:	01 00 80 33 00                                      ...3.

00014446 <tm42_guide>:
   14446:	01 00 80 34 00                                      ...4.

0001444b <tm43_guide>:
   1444b:	01 00 80 35 00                                      ...5.

00014450 <tm44_guide>:
   14450:	01 00 80 36 00                                      ...6.

00014455 <tm45_guide>:
   14455:	01 00 80 39 00                                      ...9.

0001445a <tm46_guide>:
   1445a:	01 00 80 3a 00                                      ...:.

0001445f <tm47_guide>:
   1445f:	01 00 80 3b 00                                      ...;.

00014464 <tm48_guide>:
   14464:	01 00 80 3c 00                                      ...<.

00014469 <tm49_guide>:
   14469:	01 00 80 3d 00                                      ...=.

0001446e <tm4_guide>:
   1446e:	01 00 80 07 00                                      .....

00014473 <tm50_guide>:
   14473:	01 00 80 3e 00                                      ...>.

00014478 <tm51_guide>:
   14478:	01 00 80 3f 00                                      ...?.

0001447d <tm52_guide>:
   1447d:	01 00 80 43 00                                      ...C.

00014482 <tm53_guide>:
   14482:	01 00 80 44 00                                      ...D.

00014487 <tm54_guide>:
   14487:	01 00 80 45 00                                      ...E.

0001448c <tm55_guide>:
   1448c:	01 00 80 46 00                                      ...F.

00014491 <tm56_guide>:
   14491:	01 00 80 47 00                                      ...G.

00014496 <tm57_guide>:
   14496:	01 00 80 48 00                                      ...H.

0001449b <tm58_guide>:
   1449b:	01 00 80 49 00                                      ...I.

000144a0 <tm59_guide>:
   144a0:	01 00 80 4a 00                                      ...J.

000144a5 <tm5_guide>:
   144a5:	01 00 80 08 00                                      .....

000144aa <tm60_guide>:
   144aa:	01 00 80 4b 00                                      ...K.

000144af <tm61_guide>:
   144af:	01 00 80 4c 00                                      ...L.

000144b4 <tm62_guide>:
   144b4:	01 00 80 4d 00                                      ...M.

000144b9 <tm63_guide>:
   144b9:	01 00 80 4e 00                                      ...N.

000144be <tm64_guide>:
   144be:	01 00 80 4f 00                                      ...O.

000144c3 <tm65_guide>:
   144c3:	01 00 80 50 00                                      ...P.

000144c8 <tm66_guide>:
   144c8:	01 00 80 51 00                                      ...Q.

000144cd <tm67_guide>:
   144cd:	01 00 80 52 00                                      ...R.

000144d2 <tm68_guide>:
   144d2:	01 00 80 53 00                                      ...S.

000144d7 <tm69_guide>:
   144d7:	01 00 80 54 00                                      ...T.

000144dc <tm6_guide>:
   144dc:	01 00 80 09 00                                      .....

000144e1 <tm70_guide>:
   144e1:	01 00 80 55 00                                      ...U.

000144e6 <tm71_guide>:
   144e6:	01 00 80 56 00                                      ...V.

000144eb <tm72_guide>:
   144eb:	01 00 80 57 00                                      ...W.

000144f0 <tm73_guide>:
   144f0:	01 00 80 58 00                                      ...X.

000144f5 <tm74_guide>:
   144f5:	01 00 80 59 00                                      ...Y.

000144fa <tm75_guide>:
   144fa:	01 00 80 5a 00                                      ...Z.

000144ff <tm7_guide>:
   144ff:	01 00 80 0c 00                                      .....

00014504 <tm8_guide>:
   14504:	01 00 80 0d 00                                      .....

00014509 <tm9_guide>:
   14509:	01 00 80 0e 00                                      .....

0001450e <voteDebugCLIDict_DescEntry>:
   1450e:	53 68 6f 77 20 72 65 73 75 6c 74 73 20 6f 66 20     Show results of 
   1451e:	54 72 69 67 67 65 72 45 76 65 6e 74 20 76 6f 74     TriggerEvent vot
   1452e:	69 6e 67 2e 00 1b 5b 31 3b 35 3b 33 31 6d 45 52     ing...[1;5;31mER
   1453e:	52 4f 52 1b 5b 30 6d 20 2d 20 4e 6f 20 65 76 65     ROR.[0m - No eve
   1454e:	6e 74 20 66 6f 75 6e 64 21 20 42 75 67 21 0d 0a     nt found! Bug!..
   1455e:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
   1456e:	5b 30 6d 20 2d 20 43 6f 75 6c 64 20 6e 6f 74 20     [0m - Could not 
   1457e:	66 69 6e 64 20 65 76 65 6e 74 20 69 6e 20 65 76     find event in ev
   1458e:	65 6e 74 20 62 75 66 66 65 72 20 66 6f 72 20 61     ent buffer for a
   1459e:	63 74 69 76 61 74 65 64 20 74 72 69 67 67 65 72     ctivated trigger
   145ae:	21 20 54 68 69 73 20 69 73 20 61 20 62 75 67 21     ! This is a bug!
   145be:	0d 0a 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47 1b     ....[1;35mDEBUG.
   145ce:	5b 30 6d 20 2d 20 53 61 66 65 3a 20 00 1b 5b 31     [0m - Safe: ..[1
   145de:	3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20     ;33mWARNING.[0m 
   145ee:	2d 20 44 65 6c 61 79 65 64 20 63 61 70 61 62 69     - Delayed capabi
   145fe:	6c 69 74 79 20 73 74 61 63 6b 20 66 75 6c 6c 21     lity stack full!
   1460e:	0d 0a 00 1b 5b 31 3b 33 35 6d 44 45 42 55 47 1b     ....[1;35mDEBUG.
   1461e:	5b 30 6d 20 2d 20 55 6e 2d 73 61 66 65 3a 20 00     [0m - Un-safe: .

0001462e <CSWTCH.32>:
   1462e:	08 18 10 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f     ....[1;5;31mERRO
   1463e:	52 1b 5b 30 6d 20 2d 20 52 6f 74 61 74 69 6f 6e     R.[0m - Rotation
   1464e:	20 53 74 61 74 65 20 54 79 70 65 20 28 4c 6f 6e      State Type (Lon
   1465e:	67 20 4d 61 63 72 6f 73 29 20 2d 20 4e 6f 74 20     g Macros) - Not 
   1466e:	69 6d 70 6c 65 6d 65 6e 74 65 64 2e 2e 2e 0d 0a     implemented.....
   1467e:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
   1468e:	5b 30 6d 20 2d 20 53 74 61 74 65 20 53 63 68 65     [0m - State Sche
   1469e:	64 75 6c 69 6e 67 20 6e 6f 74 20 69 6d 70 6c 65     duling not imple
   146ae:	6d 65 6e 74 65 64 20 79 65 74 2e 2e 2e 0d 0a 00     mented yet......
   146be:	1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b     .[1;5;31mERROR.[
   146ce:	30 6d 20 2d 20 41 6e 61 6c 6f 67 20 53 74 61 74     0m - Analog Stat
   146de:	65 20 54 79 70 65 20 2d 20 4e 6f 74 20 69 6d 70     e Type - Not imp
   146ee:	6c 65 6d 65 6e 74 65 64 2e 2e 2e 0d 0a 00 1b 5b     lemented.......[
   146fe:	31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d     1;5;31mERROR.[0m
   1470e:	20 2d 20 49 6e 76 61 6c 69 64 20 53 74 61 74 65      - Invalid State
   1471e:	20 54 79 70 65 2e 20 54 68 69 73 20 69 73 20 61      Type. This is a
   1472e:	20 62 75 67 2e 0d 0a 00 20 54 72 69 67 67 65 72      bug.... Trigger
   1473e:	4d 61 63 72 6f 4c 69 73 74 5b 00 5d 00 1b 5b 31     MacroList[.]..[1
   1474e:	3b 33 30 6d 54 50 65 1b 5b 30 6d 00 20 44 52 00     ;30mTPe.[0m. DR.
   1475e:	20 5f 0d 0a 00 20 44 52 61 52 00 20 52 0d 0a 00      _... DRaR. R...
   1476e:	56 3a 49 00 56 3a 52 00 56 3a 50 00 56 3a 50 52     V:I.V:R.V:P.V:PR
   1477e:	00 56 3a 00 46 00 4e 52 00 4e 00 1b 5b 31 3b 35     .V:.F.NR.N..[1;5
   1478e:	3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20     ;31mERROR.[0m - 
   1479e:	49 6e 76 61 6c 69 64 20 63 68 61 6e 6e 65 6c 20     Invalid channel 
   147ae:	28 4c 45 44 29 3a 20 00 50 69 78 65 6c 5f 41 6e     (LED): .Pixel_An
   147be:	69 6d 61 74 69 6f 6e 43 6f 6e 74 72 6f 6c 5f 63     imationControl_c
   147ce:	61 70 61 62 69 6c 69 74 79 28 66 75 6e 63 29 00     apability(func).
   147de:	50 69 78 65 6c 5f 41 6e 69 6d 61 74 69 6f 6e 49     Pixel_AnimationI
   147ee:	6e 64 65 78 5f 63 61 70 61 62 69 6c 69 74 79 28     ndex_capability(
   147fe:	73 65 74 74 69 6e 67 69 6e 64 65 78 29 00 1b 5b     settingindex)..[
   1480e:	31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d     1;33mWARNING.[0m
   1481e:	20 2d 20 49 6e 76 61 6c 69 64 20 41 6e 69 6d 61      - Invalid Anima
   1482e:	74 69 6f 6e 53 65 74 74 69 6e 67 20 69 6e 64 65     tionSetting inde
   1483e:	78 3a 20 00 50 69 78 65 6c 5f 41 6e 69 6d 61 74     x: .Pixel_Animat
   1484e:	69 6f 6e 5f 63 61 70 61 62 69 6c 69 74 79 28 69     ion_capability(i
   1485e:	6e 64 65 78 2c 6c 6f 6f 70 73 2c 70 66 75 6e 63     ndex,loops,pfunc
   1486e:	2c 66 72 61 6d 65 64 65 6c 61 79 2c 66 72 61 6d     ,framedelay,fram
   1487e:	65 6f 70 74 69 6f 6e 2c 72 65 70 6c 61 63 65 29     eoption,replace)
   1488e:	00 50 69 78 65 6c 5f 46 61 64 65 53 65 74 5f 63     .Pixel_FadeSet_c
   1489e:	61 70 61 62 69 6c 69 74 79 28 70 72 6f 66 69 6c     apability(profil
   148ae:	65 2c 63 6f 6e 66 69 67 2c 70 65 72 69 6f 64 29     e,config,period)
   148be:	00 50 69 78 65 6c 5f 50 69 78 65 6c 5f 63 61 70     .Pixel_Pixel_cap
   148ce:	61 62 69 6c 69 74 79 28 70 69 78 65 6c 2c 63 68     ability(pixel,ch
   148de:	61 6e 2c 76 61 6c 75 65 29 00 1b 5b 31 3b 35 3b     an,value)..[1;5;
   148ee:	33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 55     31mERROR.[0m - U
   148fe:	6e 73 75 70 70 6f 72 74 65 64 20 62 75 66 66 65     nsupported buffe
   1490e:	72 20 77 69 64 74 68 0d 0a 00 1b 5b 31 3b 33 33     r width....[1;33
   1491e:	6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 41     mWARNING.[0m - A
   1492e:	6e 69 6d 61 74 69 6f 6e 20 73 74 61 63 6b 20 69     nimation stack i
   1493e:	73 20 66 75 6c 6c 2e 2e 2e 0d 0a 00 1b 5b 31 3b     s full.......[1;
   1494e:	35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d     5;31mERROR.[0m -
   1495e:	20 41 6e 69 6d 61 74 69 6f 6e 20 53 74 61 63 6b      Animation Stack
   1496e:	20 6d 65 6d 6f 72 79 20 6c 65 61 6b 2e 2e 2e 74      memory leak...t
   1497e:	68 69 73 20 69 73 20 61 20 62 75 67 21 0d 0a 00     his is a bug!...
   1498e:	1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b     .[1;5;31mERROR.[
   1499e:	30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 63 68 61     0m - Invalid cha
   149ae:	6e 6e 65 6c 3a 20 00 1b 5b 31 3b 33 33 6d 57 41     nnel: ..[1;33mWA
   149be:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 43 68 61 6e     RNING.[0m - Chan
   149ce:	53 65 74 20 55 6e 6b 6e 6f 77 6e 20 77 69 64 74     Set Unknown widt
   149de:	68 3a 20 00 20 43 68 3a 20 00 1b 5b 31 3b 33 33     h: . Ch: ..[1;33
   149ee:	6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 43     mWARNING.[0m - C
   149fe:	68 61 6e 54 6f 67 67 6c 65 20 55 6e 6b 6e 6f 77     hanToggle Unknow
   14a0e:	6e 20 77 69 64 74 68 3a 20 00 1b 5b 34 38 3b 32     n width: ..[48;2
   14a1e:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
   14a2e:	5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 72 6f     [0m - Invalid ro
   14a3e:	77 2c 63 6f 6c 75 6d 6e 20 69 6e 64 65 78 3a 20     w,column index: 
   14a4e:	00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b     ..[1;5;31mERROR.
   14a5e:	5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 53 63     [0m - Invalid Sc
   14a6e:	61 6e 43 6f 64 65 3a 20 00 1b 5b 31 3b 35 3b 33     anCode: ..[1;5;3
   14a7e:	31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 49 6e     1mERROR.[0m - In
   14a8e:	76 61 6c 69 64 20 70 6f 73 69 74 69 6f 6e 20 69     valid position i
   14a9e:	6e 64 65 78 20 28 72 65 6c 63 6f 6c 29 3a 20 00     ndex (relcol): .
   14aae:	1b 5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b     .[1;5;31mERROR.[
   14abe:	30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 70 6f 73     0m - Invalid pos
   14ace:	69 74 69 6f 6e 20 69 6e 64 65 78 20 28 72 65 6c     ition index (rel
   14ade:	72 6f 77 29 3a 20 00 1b 5b 31 3b 33 33 6d 57 41     row): ..[1;33mWA
   14aee:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 46 61 69 6c     RNING.[0m - Fail
   14afe:	65 64 20 74 6f 20 73 74 61 72 74 20 73 74 61 72     ed to start star
   14b0e:	74 69 6e 67 20 61 6e 69 6d 61 74 69 6f 6e 20 69     ting animation i
   14b1e:	6e 64 65 78 3a 20 00 1b 5b 31 3b 33 33 6d 57 41     ndex: ..[1;33mWA
   14b2e:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 49 6e 76 61     RNING.[0m - Inva
   14b3e:	6c 69 64 20 50 69 78 65 6c 45 6c 65 6d 65 6e 74     lid PixelElement
   14b4e:	20 77 69 64 74 68 20 6d 61 70 70 69 6e 67 0d 0a      width mapping..
   14b5e:	00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b     ..[1;33mWARNING.
   14b6e:	5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 77 69     [0m - Invalid wi
   14b7e:	64 74 68 20 6d 61 70 70 69 6e 67 20 66 6f 72 20     dth mapping for 
   14b8e:	3d 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49     =....[1;33mWARNI
   14b9e:	4e 47 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64     NG.[0m - Invalid
   14bae:	20 77 69 64 74 68 20 6d 61 70 70 69 6e 67 20 66      width mapping f
   14bbe:	6f 72 20 2b 3d 0d 0a 00 1b 5b 31 3b 33 33 6d 57     or +=....[1;33mW
   14bce:	41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 49 6e 76     ARNING.[0m - Inv
   14bde:	61 6c 69 64 20 77 69 64 74 68 20 6d 61 70 70 69     alid width mappi
   14bee:	6e 67 20 66 6f 72 20 2d 3d 0d 0a 00 1b 5b 31 3b     ng for -=....[1;
   14bfe:	33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d     33mWARNING.[0m -
   14c0e:	20 49 6e 76 61 6c 69 64 20 77 69 64 74 68 20 6d      Invalid width m
   14c1e:	61 70 70 69 6e 67 20 66 6f 72 20 3c 3c 3d 0d 0a     apping for <<=..
   14c2e:	00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b     ..[1;33mWARNING.
   14c3e:	5b 30 6d 20 2d 20 49 6e 76 61 6c 69 64 20 77 69     [0m - Invalid wi
   14c4e:	64 74 68 20 6d 61 70 70 69 6e 67 20 66 6f 72 20     dth mapping for 
   14c5e:	3e 3e 3d 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52     >>=....[1;33mWAR
   14c6e:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 49 6e 76 61 6c     NING.[0m - Inval
   14c7e:	69 64 20 77 69 64 74 68 20 6d 61 70 70 69 6e 67     id width mapping
   14c8e:	20 6f 6e 20 73 65 74 0d 0a 00 1b 5b 31 3b 33 33      on set....[1;33
   14c9e:	6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 55     mWARNING.[0m - U
   14cae:	6e 69 6d 70 6c 65 6d 65 6e 74 65 64 20 70 69 78     nimplemented pix
   14cbe:	65 6c 20 6d 6f 64 69 66 69 65 72 0d 0a 00 1b 5b     el modifier....[
   14cce:	31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d     1;5;31mERROR.[0m
   14cde:	20 2d 20 50 69 78 65 6c 20 54 77 65 65 6e 20 42      - Pixel Tween B
   14cee:	75 67 21 0d 0a 00 50 69 78 65 6c 4d 61 70 00 57     ug!...PixelMap.W
   14cfe:	3a 00 20 43 3a 00 20 49 3a 00                       :. C:. I:.

00014d08 <aniAddCLIDict_DescEntry>:
   14d08:	41 64 64 20 74 68 65 20 67 69 76 65 6e 20 61 6e     Add the given an
   14d18:	69 6d 61 74 69 6f 6e 20 69 64 20 74 6f 20 74 68     imation id to th
   14d28:	65 20 73 74 61 63 6b 00                             e stack.

00014d30 <aniDelCLIDict_DescEntry>:
   14d30:	52 65 6d 6f 76 65 20 74 68 65 20 67 69 76 65 6e     Remove the given
   14d40:	20 73 74 61 63 6b 20 69 6e 64 65 78 20 61 6e 69      stack index ani
   14d50:	6d 61 74 69 6f 6e 00                                mation.

00014d57 <aniStackCLIDict_DescEntry>:
   14d57:	44 69 73 70 6c 61 79 73 20 74 68 65 20 61 6e 69     Displays the ani
   14d67:	6d 61 74 69 6f 6e 20 73 74 61 63 6b 20 63 6f 6e     mation stack con
   14d77:	74 65 6e 74 73 00                                   tents.

00014d7d <chanTestCLIDict_DescEntry>:
   14d7d:	43 68 61 6e 6e 65 6c 20 74 65 73 74 2e 20 4e 6f     Channel test. No
   14d8d:	20 61 72 67 20 2d 20 6e 65 78 74 20 70 69 78 65      arg - next pixe
   14d9d:	6c 2e 20 23 20 2d 20 70 69 78 65 6c 2c 20 72 20     l. # - pixel, r 
   14dad:	2d 20 72 6f 6c 6c 2d 74 68 72 6f 75 67 68 2e 20     - roll-through. 
   14dbd:	61 20 2d 20 61 6c 6c 2c 20 73 20 2d 20 73 74 6f     a - all, s - sto
   14dcd:	70 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     p..[1;32mINFO.[0
   14ddd:	6d 20 2d 20 53 74 61 63 6b 20 53 69 7a 65 3a 20     m - Stack Size: 
   14ded:	00 20 69 6e 64 65 78 28 00 29 20 70 6f 73 28 00     . index(.) pos(.
   14dfd:	29 20 6c 6f 6f 70 73 28 00 29 20 66 72 61 6d 65     ) loops(.) frame
   14e0d:	64 65 6c 61 79 28 00 29 20 66 72 61 6d 65 6f 70     delay(.) frameop
   14e1d:	74 69 6f 6e 28 00 29 20 66 66 75 6e 63 28 00 29     tion(.) ffunc(.)
   14e2d:	20 70 66 75 6e 63 28 00 1b 5b 31 3b 33 32 6d 49      pfunc(..[1;32mI
   14e3d:	4e 46 4f 1b 5b 30 6d 20 2d 20 41 6c 6c 20 63 68     NFO.[0m - All ch
   14e4d:	61 6e 6e 65 6c 20 74 65 73 74 00 1b 5b 31 3b 33     annel test..[1;3
   14e5d:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 43 68 61     2mINFO.[0m - Cha
   14e6d:	6e 6e 65 6c 20 72 6f 6c 6c 20 74 65 73 74 00 1b     nnel roll test..
   14e7d:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
   14e8d:	20 53 74 6f 70 70 69 6e 67 20 63 68 61 6e 6e 65      Stopping channe
   14e9d:	6c 20 74 65 73 74 00 1b 5b 31 3b 33 32 6d 49 4e     l test..[1;32mIN
   14ead:	46 4f 1b 5b 30 6d 20 2d 20 43 68 61 6e 6e 65 6c     FO.[0m - Channel
   14ebd:	3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     : ..[1;32mINFO.[
   14ecd:	30 6d 20 2d 20 42 75 66 66 65 72 20 4c 69 73 74     0m - Buffer List
   14edd:	00 3a 77 69 64 74 68 28 00 29 3a 73 69 7a 65 28     .:width(.):size(
   14eed:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
   14efd:	20 2d 20 50 69 78 65 6c 20 4c 69 73 74 20 2d 20      - Pixel List - 
   14f0d:	3c 6e 75 6d 3e 5b 3c 63 68 31 3e 2c 2e 2e 2e 5d     <num>[<ch1>,...]
   14f1d:	3c 77 69 64 74 68 3e 3a 2e 2e 2e 00 1b 5b 31 3b     <width>:.....[1;
   14f2d:	33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 41 6c     32mINFO.[0m - Al
   14f3d:	6c 20 73 63 61 6e 63 6f 64 65 20 70 69 78 65 6c     l scancode pixel
   14f4d:	20 74 65 73 74 00 1b 5b 31 3b 33 32 6d 49 4e 46      test..[1;32mINF
   14f5d:	4f 1b 5b 30 6d 20 2d 20 53 63 61 6e 63 6f 64 65     O.[0m - Scancode
   14f6d:	20 70 69 78 65 6c 20 72 6f 6c 6c 20 74 65 73 74      pixel roll test
   14f7d:	00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d     ..[1;32mINFO.[0m
   14f8d:	20 2d 20 53 74 6f 70 70 69 6e 67 20 73 63 61 6e      - Stopping scan
   14f9d:	63 6f 64 65 20 70 69 78 65 6c 20 74 65 73 74 00     code pixel test.
   14fad:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
   14fbd:	2d 20 53 63 61 6e 43 6f 64 65 3a 20 00 1b 5b 31     - ScanCode: ..[1
   14fcd:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 41     ;32mINFO.[0m - A
   14fdd:	6c 6c 20 70 69 78 65 6c 20 74 65 73 74 00 1b 5b     ll pixel test..[
   14fed:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
   14ffd:	50 69 78 65 6c 20 72 6f 6c 6c 20 74 65 73 74 00     Pixel roll test.
   1500d:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
   1501d:	2d 20 53 74 6f 70 70 69 6e 67 20 70 69 78 65 6c     - Stopping pixel
   1502d:	20 74 65 73 74 00 1b 5b 31 3b 33 32 6d 49 4e 46      test..[1;32mINF
   1503d:	4f 1b 5b 30 6d 20 2d 20 45 6e 61 62 6c 65 20 61     O.[0m - Enable a
   1504d:	6c 6c 20 70 69 78 65 6c 73 00 1b 5b 31 3b 33 32     ll pixels..[1;32
   1505d:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 44 69 73 61     mINFO.[0m - Disa
   1506d:	62 6c 65 20 61 6c 6c 20 70 69 78 65 6c 73 00 1b     ble all pixels..
   1507d:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
   1508d:	20 50 69 78 65 6c 3a 20 00 1b 5b 31 3b 33 32 6d      Pixel: ..[1;32m
   1509d:	49 4e 46 4f 1b 5b 30 6d 20 2d 20 41 6c 6c 20 78     INFO.[0m - All x
   150ad:	2c 79 20 70 69 78 65 6c 20 74 65 73 74 00 1b 5b     ,y pixel test..[
   150bd:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
   150cd:	78 2c 79 20 70 69 78 65 6c 20 72 6f 6c 6c 20 74     x,y pixel roll t
   150dd:	65 73 74 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     est..[1;32mINFO.
   150ed:	5b 30 6d 20 2d 20 53 74 6f 70 70 69 6e 67 20 78     [0m - Stopping x
   150fd:	2c 79 20 70 69 78 65 6c 20 74 65 73 74 00 1b 5b     ,y pixel test..[
   1510d:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
   1511d:	48 6f 72 69 7a 6f 6e 74 61 6c 3a 20 00 1b 5b 31     Horizontal: ..[1
   1512d:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 56     ;32mINFO.[0m - V
   1513d:	65 72 74 69 63 61 6c 3a 20 00 1b 5b 31 3b 33 32     ertical: ..[1;32
   1514d:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 50 6f 73 69     mINFO.[0m - Posi
   1515d:	74 69 6f 6e 20 28 78 2c 79 29 3a 20 00 00 00        tion (x,y): ...

0001516c <pixelCLIDict>:
   1516c:	54 53 01 00 08 4d 01 00 fd 8e 00 00 5b 53 01 00     TS...M......[S..
   1517c:	30 4d 01 00 25 8f 00 00 62 53 01 00 57 4d 01 00     0M..%...bS..WM..
   1518c:	59 8f 00 00 6b 53 01 00 7d 4d 01 00 a5 92 00 00     Y...kS..}M......
   1519c:	74 53 01 00 fa 51 01 00 3d 90 00 00 7e 53 01 00     tS...Q..=...~S..
   151ac:	1d 52 01 00 a9 93 00 00 8a 53 01 00 76 52 01 00     .R.......S..vR..
   151bc:	99 91 00 00 94 53 01 00 d0 52 01 00 4d 9f 00 00     .....S...R..M...
   151cc:	a0 53 01 00 23 53 01 00 cd af 00 00 00 00 00 00     .S..#S..........
   151dc:	00 00 00 00 00 00 00 00                             ........

000151e4 <pixelCLIDictName>:
   151e4:	50 69 78 65 6c 20 4d 6f 64 75 6c 65 20 43 6f 6d     Pixel Module Com
   151f4:	6d 61 6e 64 73 00                                   mands.

000151fa <pixelListCLIDict_DescEntry>:
   151fa:	50 72 69 6e 74 73 20 6f 75 74 20 70 69 78 65 6c     Prints out pixel
   1520a:	3a 63 68 61 6e 6e 65 6c 20 6d 61 70 70 69 6e 67     :channel mapping
   1521a:	73 2e 00                                            s..

0001521d <pixelSCTestCLIDict_DescEntry>:
   1521d:	53 63 61 6e 63 6f 64 65 20 70 69 78 65 6c 20 74     Scancode pixel t
   1522d:	65 73 74 2e 20 4e 6f 20 61 72 67 20 2d 20 6e 65     est. No arg - ne
   1523d:	78 74 20 70 69 78 65 6c 2e 20 23 20 2d 20 70 69     xt pixel. # - pi
   1524d:	78 65 6c 2c 20 72 20 2d 20 72 6f 6c 6c 2d 74 68     xel, r - roll-th
   1525d:	72 6f 75 67 68 2e 20 61 20 2d 20 61 6c 6c 2c 20     rough. a - all, 
   1526d:	73 20 2d 20 73 74 6f 70 00                          s - stop.

00015276 <pixelTestCLIDict_DescEntry>:
   15276:	50 69 78 65 6c 20 74 65 73 74 2e 20 4e 6f 20 61     Pixel test. No a
   15286:	72 67 20 2d 20 6e 65 78 74 20 70 69 78 65 6c 2e     rg - next pixel.
   15296:	20 23 20 2d 20 70 69 78 65 6c 2c 20 72 20 2d 20      # - pixel, r - 
   152a6:	72 6f 6c 6c 2d 74 68 72 6f 75 67 68 2e 20 61 20     roll-through. a 
   152b6:	2d 20 61 6c 6c 2c 20 73 20 2d 20 73 74 6f 70 2c     - all, s - stop,
   152c6:	20 66 20 2d 20 66 75 6c 6c 00                        f - full.

000152d0 <pixelXYTestCLIDict_DescEntry>:
   152d0:	58 59 20 70 69 78 65 6c 20 74 65 73 74 2e 20 4e     XY pixel test. N
   152e0:	6f 20 61 72 67 20 2d 20 6e 65 78 74 20 70 69 78     o arg - next pix
   152f0:	65 6c 2e 20 23 20 2d 20 70 69 78 65 6c 2c 20 72     el. # - pixel, r
   15300:	20 2d 20 72 6f 6c 6c 2d 74 68 72 6f 75 67 68 2e      - roll-through.
   15310:	20 61 20 2d 20 61 6c 6c 2c 20 73 20 2d 20 73 74      a - all, s - st
   15320:	6f 70 00                                            op.

00015323 <rectDispCLIDict_DescEntry>:
   15323:	53 68 6f 77 20 74 68 65 20 63 75 72 72 65 6e 74     Show the current
   15333:	20 6f 75 74 70 75 74 20 6f 66 20 74 68 65 20 4d      output of the M
   15343:	43 55 20 70 69 78 65 6c 20 62 75 66 66 65 72 2e     CU pixel buffer.
   15353:	00 61 6e 69 41 64 64 00 61 6e 69 44 65 6c 00 61     .aniAdd.aniDel.a
   15363:	6e 69 53 74 61 63 6b 00 63 68 61 6e 54 65 73 74     niStack.chanTest
   15373:	00 70 69 78 65 6c 4c 69 73 74 00 70 69 78 65 6c     .pixelList.pixel
   15383:	53 43 54 65 73 74 00 70 69 78 65 6c 54 65 73 74     SCTest.pixelTest
   15393:	00 70 69 78 65 6c 58 59 54 65 73 74 00 72 65 63     .pixelXYTest.rec
   153a3:	74 44 69 73 70 00 00 00 00                          tDisp....

000153ac <Pixel_AnimationSettings>:
   153ac:	01 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00     ................

000153bc <Pixel_DisplayMapping>:
   153bc:	07 00 00 00 06 00 00 00 05 00 00 00 04 00 00 00     ................
   153cc:	03 00 00 00 02 00 00 00 01 00 00 00 00 00 00 00     ................
   153dc:	00 00 0e 00 00 00 0d 00 00 00 0c 00 00 00 0b 00     ................
   153ec:	00 00 0a 00 00 00 09 00 00 00 08 00 00 00 00 00     ................
   153fc:	00 00 00 00 14 00 00 00 13 00 00 00 12 00 00 00     ................
   1540c:	11 00 00 00 10 00 00 00 0f 00 00 00 00 00 00 00     ................
   1541c:	00 00 00 00 00 00 1d 00 00 00 1c 00 00 00 1b 00     ................
   1542c:	00 00 1a 00 00 00 19 00 00 00 18 00 00 00 17 00     ................
   1543c:	00 00 00 00 00 00 00 00 00 00 26 00 25 00 00 00     ..........&.%...
   1544c:	24 00 00 00 23 00 00 00 22 00 00 00 00 00 00 00     $...#...".......
   1545c:	00 00 00 00 16 00 00 00 15 00 00 00 00 00 00 00     ................
   1546c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   1547c:	21 00 00 00 20 00 00 00 1e 00 00 00 00 00 00 00     !... ...........
   1548c:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
   1549c:	00 00 00 00 00 00 00 00 1f 00 00 00 00 00           ..............

000154aa <Pixel_LED_DefaultFadeGroup0>:
   154aa:	01 00 02 00 03 00 04 00 05 00 06 00 07 00 08 00     ................
   154ba:	09 00 0a 00 0b 00 0c 00 0d 00 0e 00 0f 00 10 00     ................
   154ca:	11 00 12 00 13 00 14 00 15 00 16 00 17 00 18 00     ................
   154da:	19 00 1a 00 1b 00 1c 00 1d 00 1e 00 1f 00 20 00     .............. .
   154ea:	21 00 22 00 23 00 24 00 25 00 26 00                 !.".#.$.%.&.

000154f6 <Pixel_LED_DefaultFadeGroup1>:
   154f6:	00 00                                               ..

000154f8 <Pixel_LED_DefaultFadeGroups>:
   154f8:	26 00 00 00 aa 54 01 00 00 00 00 00 f6 54 01 00     &....T.......T..
   15508:	00 00 00 00 f6 54 01 00                             .....T..

00015510 <Pixel_LED_FadePeriod_Defaults>:
   15510:	00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................

00015520 <Pixel_LED_FadePeriods>:
   15520:	00 40 50 60 70 80 90 a0 b0 c0 65 76 87 98 a9 ba     .@P`p.....ev....

00015530 <Pixel_Mapping>:
   15530:	08 01 00 00 00 00 00 00 08 01 10 00 00 00 00 00     ................
   15540:	08 01 20 00 00 00 00 00 08 01 30 00 00 00 00 00     .. .......0.....
   15550:	08 01 40 00 00 00 00 00 08 01 01 00 00 00 00 00     ..@.............
   15560:	08 01 11 00 00 00 00 00 08 01 21 00 00 00 00 00     ..........!.....
   15570:	08 01 31 00 00 00 00 00 08 01 41 00 00 00 00 00     ..1.......A.....
   15580:	08 01 02 00 00 00 00 00 08 01 12 00 00 00 00 00     ................
   15590:	08 01 22 00 00 00 00 00 08 01 32 00 00 00 00 00     ..".......2.....
   155a0:	08 01 42 00 00 00 00 00 08 01 03 00 00 00 00 00     ..B.............
   155b0:	08 01 13 00 00 00 00 00 08 01 23 00 00 00 00 00     ..........#.....
   155c0:	08 01 33 00 00 00 00 00 08 01 43 00 00 00 00 00     ..3.......C.....
   155d0:	08 01 04 00 00 00 00 00 08 01 14 00 00 00 00 00     ................
   155e0:	08 01 24 00 00 00 00 00 08 01 34 00 00 00 00 00     ..$.......4.....
   155f0:	08 01 44 00 00 00 00 00 08 01 05 00 00 00 00 00     ..D.............
   15600:	08 01 15 00 00 00 00 00 08 01 25 00 00 00 00 00     ..........%.....
   15610:	08 01 35 00 00 00 00 00 08 01 45 00 00 00 00 00     ..5.......E.....
   15620:	08 01 06 00 00 00 00 00 08 01 16 00 00 00 00 00     ................
   15630:	08 01 26 00 00 00 00 00 08 01 36 00 00 00 00 00     ..&.......6.....
   15640:	08 01 07 00 00 00 00 00 08 01 17 00 00 00 00 00     ................
   15650:	08 01 27 00 00 00 00 00 08 01 37 00 00 00 00 00     ..'.......7.....

00015660 <Pixel_ScanCodeToDisplay>:
   15660:	00 00 00 00 0c 00 0a 00 08 00 06 00 04 00 02 00     ................
   15670:	00 00 00 00 00 00 1d 00 1b 00 19 00 17 00 15 00     ................
   15680:	13 00 11 00 00 00 00 00 00 00 2c 00 2a 00 28 00     ..........,.*.(.
   15690:	26 00 24 00 22 00 54 00 52 00 3f 00 3d 00 3b 00     &.$.".T.R.?.=.;.
   156a0:	39 00 37 00 35 00 33 00 64 00 74 00 62 00 60 00     9.7.5.3.d.t.b.`.
   156b0:	4c 00 4a 00 48 00 46 00 45 00                       L.J.H.F.E.

000156ba <Pixel_ScanCodeToPixel>:
   156ba:	00 00 00 00 01 00 02 00 03 00 04 00 05 00 06 00     ................
   156ca:	07 00 00 00 00 00 08 00 09 00 0a 00 0b 00 0c 00     ................
   156da:	0d 00 0e 00 00 00 00 00 00 00 0f 00 10 00 11 00     ................
   156ea:	12 00 13 00 14 00 15 00 16 00 17 00 18 00 19 00     ................
   156fa:	1a 00 1b 00 1c 00 1d 00 1e 00 1f 00 20 00 21 00     ............ .!.
   1570a:	22 00 23 00 24 00 25 00 26 00                       ".#.$.%.&.

00015714 <all_on_frame1>:
   15714:	03 00 00 00 00 00 ff 03 10 00 00 00 00 ff 00 1b     ................
   15724:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
   15734:	6d 20 2d 20 4e 6f 74 20 65 6e 6f 75 67 68 20 62     m - Not enough b
   15744:	79 74 65 73 20 69 6e 20 48 49 44 49 4f 20 62 75     ytes in HIDIO bu
   15754:	66 66 65 72 3a 20 00 20 62 79 74 65 73 20 6c 65     ffer: . bytes le
   15764:	66 74 2c 20 00 20 62 79 74 65 73 20 74 6f 74 61     ft, . bytes tota
   15774:	6c 20 00 20 62 79 74 65 73 20 72 65 71 75 65 73     l . bytes reques
   15784:	74 65 64 00 1b 5b 31 3b 35 3b 33 31 6d 45 52 52     ted..[1;5;31mERR
   15794:	4f 52 1b 5b 30 6d 20 2d 20 52 65 71 75 65 73 74     OR.[0m - Request
   157a4:	65 64 20 48 49 44 49 4f 20 62 75 66 66 65 72 20     ed HIDIO buffer 
   157b4:	70 6f 70 20 6c 61 72 67 65 72 20 74 68 61 6e 20     pop larger than 
   157c4:	65 6e 74 69 72 65 20 62 75 66 66 65 72 3a 20 00     entire buffer: .
   157d4:	46 41 49 4c 0d 0a 00 53 59 4e 43 00 1b 5b 31 3b     FAIL...SYNC..[1;
   157e4:	33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d     33mWARNING.[0m -
   157f4:	20 44 72 6f 70 70 69 6e 67 20 69 6e 63 6f 6d 69      Dropping incomi
   15804:	6e 67 20 43 6f 6e 74 69 6e 75 65 64 20 44 61 74     ng Continued Dat
   15814:	61 20 70 61 63 6b 65 74 2e 2e 2e 0d 0a 00 1b 5b     a packet.......[
   15824:	31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30 6d     1;33mWARNING.[0m
   15834:	20 2d 20 44 72 6f 70 70 69 6e 67 20 69 6e 63 6f      - Dropping inco
   15844:	6d 69 6e 67 20 44 61 74 61 20 70 61 63 6b 65 74     ming Data packet
   15854:	2c 20 6e 6f 74 20 65 6e 6f 75 67 68 20 62 75 66     , not enough buf
   15864:	66 65 72 20 73 70 61 63 65 2e 2e 2e 0d 0a 00 68     fer space......h
   15874:	65 61 64 3a 20 00 20 74 61 69 6c 3a 20 00 20 62     ead: . tail: . b
   15884:	79 74 65 73 5f 6c 65 66 74 3a 20 00 20 72 65 71     ytes_left: . req
   15894:	75 65 73 74 3a 20 00 54 4f 44 4f 21 0d 0a 00 1b     uest: .TODO!....
   158a4:	5b 31 3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30     [1;5;31mERROR.[0
   158b4:	6d 20 2d 20 48 49 44 49 4f 5f 49 64 5f 4c 69 73     m - HIDIO_Id_Lis
   158c4:	74 20 69 73 20 66 75 6c 6c 2c 20 63 61 6e 6e 6f     t is full, canno
   158d4:	74 20 72 65 67 69 73 74 65 72 20 49 64 3a 20 00     t register Id: .
   158e4:	48 49 44 2d 49 4f 00 00                             HID-IO..

000158ec <hidioCLIDict>:
   158ec:	00 00 00 00 00 00 00 00 00 00 00 00                 ............

000158f8 <hidioCLIDictName>:
   158f8:	48 49 44 2d 49 4f 20 4d 6f 64 75 6c 65 20 43 6f     HID-IO Module Co
   15908:	6d 6d 61 6e 64 73 00 4f 75 74 70 75 74 5f 66 6c     mmands.Output_fl
   15918:	61 73 68 4d 6f 64 65 28 29 00 1b 5b 31 3b 33 32     ashMode()..[1;32
   15928:	6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 45 78 74 65     mINFO.[0m - Exte
   15938:	72 6e 61 6c 20 41 76 61 69 6c 61 62 6c 65 20 43     rnal Available C
   15948:	75 72 72 65 6e 74 20 43 68 61 6e 67 65 64 2e 20     urrent Changed. 
   15958:	54 6f 74 61 6c 20 41 76 61 69 6c 61 62 6c 65 3a     Total Available:
   15968:	20 00 20 6d 41 0d 0a 00 1b 5b 31 3b 33 32 6d 49      . mA....[1;32mI
   15978:	4e 46 4f 1b 5b 30 6d 20 2d 20 43 75 72 72 65 6e     NFO.[0m - Curren
   15988:	74 20 61 76 61 69 6c 61 62 6c 65 3a 20 00 20 6d     t available: . m
   15998:	41 00                                               A.

0001599a <currentCLIDict_DescEntry>:
   1599a:	53 68 6f 77 73 20 74 68 65 20 63 75 72 72 65 6e     Shows the curren
   159aa:	74 20 6e 65 67 6f 74 69 61 74 65 64 20 63 75 72     t negotiated cur
   159ba:	72 65 6e 74 2e 00                                   rent..

000159c0 <outputCLIDict>:
   159c0:	15 5a 01 00 9a 59 01 00 05 bd 00 00 1d 5a 01 00     .Z...Y.......Z..
   159d0:	fb 59 01 00 59 bb 00 00 00 00 00 00 00 00 00 00     .Y..Y...........
   159e0:	00 00 00 00                                         ....

000159e4 <outputCLIDictName>:
   159e4:	4f 75 74 70 75 74 20 4d 6f 64 75 6c 65 20 43 6f     Output Module Co
   159f4:	6d 6d 61 6e 64 73 00                                mmands.

000159fb <outputDebugCLIDict_DescEntry>:
   159fb:	54 6f 67 67 6c 65 20 4f 75 74 70 75 74 20 44 65     Toggle Output De
   15a0b:	62 75 67 20 6d 6f 64 65 2e 00 63 75 72 72 65 6e     bug mode..curren
   15a1b:	74 00 6f 75 74 70 75 74 44 65 62 75 67 00           t.outputDebug.

00015a29 <CSWTCH.72>:
   15a29:	00 00 00 00 00 00 00 01 01 01 01 01 01 01 01 02     ................
   15a39:	02 02 02 02 02 02 02 03 03 03 03 03 03 03 03 04     ................
   15a49:	04 04 04 04 04 04 04 05 05 05 05 05 05 05 05 06     ................
   15a59:	06 06 06 06 06 06 06 07 07 07 07 07 07 07 07 08     ................
   15a69:	08 08 08 08 08 08 08 09 09 09 09 09 09 09 09 0a     ................
   15a79:	0a 0a 0a 0a 0a 0a 0a 0b 0b 0b 0b 0b 0b 0b 0b 0c     ................
   15a89:	0c 0c 0c 0c 0c 0c 0c 0d 0d 0d 0d 0d 0d 0d 0d 0e     ................
   15a99:	0e 0e 0e 0e 0e 0e 0e 0f 0f 0f 0f 0f 0f 0f 0f 10     ................
   15aa9:	10 10 10 10 10 10 10 11 11 11 11 11 11 11 11 12     ................
   15ab9:	12 12 12 12 12 12 12 13 13 13 13 13 13 13 13 14     ................
   15ac9:	14 14 14 14 14 14 14 00 00 00 00 00 00 00 00 16     ................
   15ad9:	16 16 16 16 16 16 16 17 17 17 17 17 17 17 17 18     ................
   15ae9:	18 18 18 18 18 18 18 19 19 19 19 19 19 19 19 1a     ................
   15af9:	1a 1a 1a 1a 1a 1a 1a 1b 1b 1b 1b 1b 1b 1b 1b        ...............

00015b08 <CSWTCH.73>:
   15b08:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b18:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b28:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b38:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b48:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b58:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b68:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b78:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b88:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15b98:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15ba8:	01 02 03 04 05 06 07 00 00 00 00 00 00 00 00 00     ................
   15bb8:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15bc8:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 00     ................
   15bd8:	01 02 03 04 05 06 07 00 01 02 03 04 05 06 07 4f     ...............O
   15be8:	75 74 70 75 74 5f 63 6f 6e 73 43 74 72 6c 53 65     utput_consCtrlSe
   15bf8:	6e 64 28 63 6f 6e 73 43 6f 64 65 29 00 4f 75 74     nd(consCode).Out
   15c08:	70 75 74 5f 6b 62 64 50 72 6f 74 6f 63 6f 6c 42     put_kbdProtocolB
   15c18:	6f 6f 74 28 29 00 4f 75 74 70 75 74 5f 6b 62 64     oot().Output_kbd
   15c28:	50 72 6f 74 6f 63 6f 6c 4e 4b 52 4f 28 29 00 4f     ProtocolNKRO().O
   15c38:	75 74 70 75 74 5f 6e 6f 6e 65 53 65 6e 64 28 29     utput_noneSend()
   15c48:	00 4f 75 74 70 75 74 5f 73 79 73 43 74 72 6c 53     .Output_sysCtrlS
   15c58:	65 6e 64 28 73 79 73 43 6f 64 65 29 00 4f 75 74     end(sysCode).Out
   15c68:	70 75 74 5f 74 6f 67 67 6c 65 4b 62 64 50 72 6f     put_toggleKbdPro
   15c78:	74 6f 63 6f 6c 28 29 00 4f 75 74 70 75 74 5f 75     tocol().Output_u
   15c88:	73 62 43 6f 64 65 53 65 6e 64 28 75 73 62 43 6f     sbCodeSend(usbCo
   15c98:	64 65 29 00 1b 5b 31 3b 33 34 6d 55 53 42 1b 5b     de)..[1;34mUSB.[
   15ca8:	30 6d 20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49     0m ..[1;33mWARNI
   15cb8:	4e 47 1b 5b 30 6d 20 2d 20 55 53 42 20 4b 65 79     NG.[0m - USB Key
   15cc8:	20 6c 69 6d 69 74 20 72 65 61 63 68 65 64 0d 0a      limit reached..
   15cd8:	00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b     ..[1;33mWARNING.
   15ce8:	5b 30 6d 20 2d 20 55 53 42 20 43 6f 64 65 20 6e     [0m - USB Code n
   15cf8:	6f 74 20 77 69 74 68 69 6e 20 34 2d 31 35 35 20     ot within 4-155 
   15d08:	28 30 78 34 2d 30 78 39 42 29 2c 20 31 35 37 2d     (0x4-0x9B), 157-
   15d18:	31 36 34 20 28 30 78 39 44 2d 30 78 41 34 29 2c     164 (0x9D-0xA4),
   15d28:	20 31 37 36 2d 32 32 31 20 28 30 78 42 30 2d 30      176-221 (0xB0-0
   15d38:	78 44 44 29 20 6f 72 20 32 32 34 2d 32 33 31 20     xDD) or 224-231 
   15d48:	28 30 78 45 30 2d 30 78 45 37 29 20 4e 4b 52 4f     (0xE0-0xE7) NKRO
   15d58:	20 4d 6f 64 65 3a 20 00 4f 75 74 70 75 74 5f 75      Mode: .Output_u
   15d68:	73 62 4d 6f 75 73 65 57 68 65 65 6c 28 76 65 72     sbMouseWheel(ver
   15d78:	74 2c 68 6f 72 69 29 00 4f 75 74 70 75 74 5f 75     t,hori).Output_u
   15d88:	73 62 4d 6f 75 73 65 28 6d 6f 75 73 65 42 75 74     sbMouse(mouseBut
   15d98:	74 6f 6e 2c 72 65 6c 58 2c 72 65 6c 59 29 00 1b     ton,relX,relY)..
   15da8:	5b 31 3b 33 34 6d 36 4b 52 4f 1b 5b 30 6d 20 00     [1;34m6KRO.[0m .
   15db8:	1b 5b 31 3b 33 34 6d 43 6f 6e 73 43 74 72 6c 1b     .[1;34mConsCtrl.
   15dc8:	5b 30 6d 5b 00 1b 5b 31 3b 33 34 6d 4e 4b 52 4f     [0m[..[1;34mNKRO
   15dd8:	1b 5b 30 6d 20 00 1b 5b 31 3b 33 34 6d 53 79 73     .[0m ..[1;34mSys
   15de8:	43 74 72 6c 1b 5b 30 6d 5b 00 5d 20 0d 0a 00 55     Ctrl.[0m[.] ...U
   15df8:	53 42 4f 75 74 70 75 74 50 65 72 69 00 55 53 42     SBOutputPeri.USB
   15e08:	4f 75 74 70 75 74 50 6f 6c 6c 00 1b 5b 31 3b 33     OutputPoll..[1;3
   15e18:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 55 53 42     2mINFO.[0m - USB
   15e28:	20 49 64 6c 65 20 43 6f 6e 66 69 67 3a 20 00 20      Idle Config: . 
   15e38:	6d 73 20 2d 20 00 1b 5b 31 3b 33 32 6d 49 4e 46     ms - ..[1;32mINF
   15e48:	4f 1b 5b 30 6d 20 2d 20 53 65 74 74 69 6e 67 20     O.[0m - Setting 
   15e58:	4b 65 79 62 6f 61 72 64 20 50 72 6f 74 6f 63 6f     Keyboard Protoco
   15e68:	6c 20 74 6f 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e     l to: ..[1;32mIN
   15e78:	46 4f 1b 5b 30 6d 20 2d 20 4b 65 79 62 6f 61 72     FO.[0m - Keyboar
   15e88:	64 20 50 72 6f 74 6f 63 6f 6c 3a 20 00 1b 5b 31     d Protocol: ..[1
   15e98:	3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 4c     ;32mINFO.[0m - L
   15ea8:	45 44 20 53 74 61 74 65 3a 20 00 1b 5b 31 3b 33     ED State: ..[1;3
   15eb8:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 55 53 42     2mINFO.[0m - USB
   15ec8:	20 41 64 64 72 65 73 73 3a 20 00 1b 5b 31 3b 33      Address: ..[1;3
   15ed8:	32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20 55 53 42     2mINFO.[0m - USB
   15ee8:	20 43 6f 6e 66 69 67 75 72 65 64 3a 20 00 1b 5b      Configured: ..[
   15ef8:	31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d 20     1;32mINFO.[0m - 
   15f08:	55 53 42 20 49 6e 69 74 20 54 69 6d 65 3a 20 00     USB Init Time: .

00015f18 <idleCLIDict_DescEntry>:
   15f18:	53 68 6f 77 2f 73 65 74 20 74 68 65 20 48 49 44     Show/set the HID
   15f28:	20 49 64 6c 65 20 74 69 6d 65 20 28 6d 75 6c 74      Idle time (mult
   15f38:	69 70 6c 65 73 20 6f 66 20 34 20 6d 73 29 2e 00     iples of 4 ms)..

00015f48 <kbdProtocolCLIDict_DescEntry>:
   15f48:	4b 65 79 62 6f 61 72 64 20 50 72 6f 74 6f 63 6f     Keyboard Protoco
   15f58:	6c 20 4d 6f 64 65 3a 20 30 20 2d 20 42 6f 6f 74     l Mode: 0 - Boot
   15f68:	2c 20 31 20 2d 20 4f 53 2f 4e 4b 52 4f 20 4d 6f     , 1 - OS/NKRO Mo
   15f78:	64 65 2e 00                                         de..

00015f7c <readLEDsCLIDict_DescEntry>:
   15f7c:	52 65 61 64 20 4c 45 44 20 62 79 74 65 3a 0d 0a     Read LED byte:..
   15f8c:	09 09 31 20 4e 75 6d 4c 63 6b 2c 20 32 20 43 61     ..1 NumLck, 2 Ca
   15f9c:	70 73 4c 63 6b 2c 20 34 20 53 63 72 6c 4c 63 6b     psLck, 4 ScrlLck
   15fac:	2c 20 31 36 20 4b 61 6e 61 2c 20 65 74 63 2e 00     , 16 Kana, etc..
   15fbc:	69 64 6c 65 00 6b 62 64 50 72 6f 74 6f 63 6f 6c     idle.kbdProtocol
   15fcc:	00 72 65 61 64 4c 45 44 73 00 75 73 62 41 64 64     .readLEDs.usbAdd
   15fdc:	72 00 75 73 62 43 6f 6e 66 00 75 73 62 49 6e 69     r.usbConf.usbIni
   15fec:	74 54 69 6d 65 00                                   tTime.

00015ff2 <usbAddrCLIDict_DescEntry>:
   15ff2:	53 68 6f 77 73 20 74 68 65 20 6e 65 67 6f 74 69     Shows the negoti
   16002:	61 74 65 64 20 55 53 42 20 75 6e 69 71 75 65 20     ated USB unique 
   16012:	49 64 2c 20 67 69 76 65 6e 20 74 6f 20 64 65 76     Id, given to dev
   16022:	69 63 65 20 62 79 20 68 6f 73 74 2e 00 00           ice by host...

00016030 <usbCLIDict>:
   16030:	bc 5f 01 00 18 5f 01 00 71 bf 00 00 c1 5f 01 00     ._..._..q...._..
   16040:	48 5f 01 00 81 c0 00 00 cd 5f 01 00 7c 5f 01 00     H_......._..|_..
   16050:	f1 be 00 00 d6 5f 01 00 f2 5f 01 00 31 bf 00 00     ....._..._..1...
   16060:	de 5f 01 00 98 60 01 00 dd bf 00 00 e6 5f 01 00     ._...`......._..
   16070:	c0 60 01 00 19 c0 00 00 00 00 00 00 00 00 00 00     .`..............
   16080:	00 00 00 00                                         ....

00016084 <usbCLIDictName>:
   16084:	55 53 42 20 4d 6f 64 75 6c 65 20 43 6f 6d 6d 61     USB Module Comma
   16094:	6e 64 73 00                                         nds.

00016098 <usbConfCLIDict_DescEntry>:
   16098:	53 68 6f 77 73 20 77 68 65 74 68 65 72 20 55 53     Shows whether US
   160a8:	42 20 69 73 20 63 6f 6e 66 69 67 75 72 65 64 20     B is configured 
   160b8:	6f 72 20 6e 6f 74 2e 00                             or not..

000160c0 <usbInitTimeCLIDict_DescEntry>:
   160c0:	44 69 73 70 6c 61 79 73 20 74 68 65 20 74 69 6d     Displays the tim
   160d0:	65 20 69 6e 20 6d 73 20 66 72 6f 6d 20 75 73 62     e in ms from usb
   160e0:	5f 69 6e 69 74 28 29 20 74 69 6c 6c 20 74 68 65     _init() till the
   160f0:	20 6c 61 73 74 20 73 65 74 75 70 20 63 61 6c 6c      last setup call
   16100:	2e 00 00 00                                         ....

00016104 <usb_descriptor_list>:
   16104:	00 01 00 00 15 8f ff 1f 12 00 00 00 00 02 00 00     ................
   16114:	46 8e ff 1f cf 00 00 00 00 06 00 00 2b 97 ff 1f     F...........+...
   16124:	01 00 00 00 00 0a 00 00 2c 97 ff 1f 01 00 00 00     ........,.......
   16134:	00 03 00 00 54 90 ff 1f 00 00 00 00 01 03 09 04     ....T...........
   16144:	32 91 ff 1f 00 00 00 00 02 03 09 04 76 91 ff 1f     2...........v...
   16154:	00 00 00 00 03 03 09 04 f4 91 ff 1f 00 00 00 00     ................
   16164:	04 03 09 04 08 91 ff 1f 00 00 00 00 00 22 00 00     ............."..
   16174:	27 8f ff 1f 43 00 00 00 00 21 00 00 58 8e ff 1f     '...C....!..X...
   16184:	09 00 00 00 00 22 01 00 d7 8f ff 1f 61 00 00 00     ....."......a...
   16194:	00 21 01 00 71 8e ff 1f 09 00 00 00 00 22 02 00     .!..q........"..
   161a4:	58 90 ff 1f 35 00 00 00 00 21 02 00 8a 8e ff 1f     X...5....!......
   161b4:	09 00 00 00 05 03 09 04 14 91 ff 1f 00 00 00 00     ................
   161c4:	06 03 09 04 58 91 ff 1f 00 00 00 00 07 03 09 04     ....X...........
   161d4:	50 92 ff 1f 00 00 00 00 08 03 09 04 cc 90 ff 1f     P...............
   161e4:	00 00 00 00 09 03 09 04 94 90 ff 1f 00 00 00 00     ................
   161f4:	00 22 06 00 38 90 ff 1f 1c 00 00 00 00 21 06 00     ."..8........!..
   16204:	e5 8e ff 1f 09 00 00 00 0b 03 09 04 ca 91 ff 1f     ................
   16214:	00 00 00 00 00 22 05 00 6a 8f ff 1f 6d 00 00 00     ....."..j...m...
   16224:	00 21 05 00 05 8f ff 1f 09 00 00 00 0a 03 09 04     .!..............
   16234:	4a 91 ff 1f 00 00 00 00 00 00 00 00 00 00 00 00     J...............
   16244:	00 00 00 00                                         ....

00016248 <usb_endpoint_config_table>:
   16248:	15 15 15 15 19 15 15 19 15 15 1b 5b 31 3b 33 33     ...........[1;33
   16258:	6d 57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 28     mWARNING.[0m - (
   16268:	53 45 54 5f 52 45 50 4f 52 54 2c 20 42 55 4c 4b     SET_REPORT, BULK
   16278:	29 20 55 6e 6b 6e 6f 77 6e 20 69 6e 74 65 72 66     ) Unknown interf
   16288:	61 63 65 20 2d 20 00 1b 5b 31 3b 33 33 6d 57 41     ace - ..[1;33mWA
   16298:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 55 53 42 20     RNING.[0m - USB 
   162a8:	4c 6f 77 20 50 6f 77 65 72 20 4e 65 67 6f 74 61     Low Power Negota
   162b8:	74 69 6f 6e 20 44 69 73 61 62 6c 65 64 2c 20 63     tion Disabled, c
   162c8:	6f 6e 64 69 74 69 6f 6e 20 64 65 74 65 63 74 65     ondition detecte
   162d8:	64 2e 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49 4e     d...[1;33mWARNIN
   162e8:	47 1b 5b 30 6d 20 2d 20 53 45 54 5f 46 45 41 54     G.[0m - SET_FEAT
   162f8:	55 52 45 20 2d 20 44 65 76 69 63 65 20 77 56 61     URE - Device wVa
   16308:	6c 75 65 28 00 1b 5b 31 3b 33 33 6d 57 41 52 4e     lue(..[1;33mWARN
   16318:	49 4e 47 1b 5b 30 6d 20 2d 20 43 4c 45 41 52 5f     ING.[0m - CLEAR_
   16328:	46 45 41 54 55 52 45 20 2d 20 49 6e 74 65 72 66     FEATURE - Interf
   16338:	61 63 65 20 77 56 61 6c 75 65 28 00 29 20 77 49     ace wValue(.) wI
   16348:	6e 64 65 78 28 00 1b 5b 31 3b 33 33 6d 57 41 52     ndex(..[1;33mWAR
   16358:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 28 53 45 54 5f     NING.[0m - (SET_
   16368:	46 45 41 54 55 52 45 2c 20 53 45 54 55 50 29 20     FEATURE, SETUP) 
   16378:	20 2d 20 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49      - ..[1;33mWARNI
   16388:	4e 47 1b 5b 30 6d 20 2d 20 53 45 54 5f 46 45 41     NG.[0m - SET_FEA
   16398:	54 55 52 45 20 2d 20 49 6e 74 65 72 66 61 63 65     TURE - Interface
   163a8:	20 77 56 61 6c 75 65 28 00 1b 5b 31 3b 33 33 6d      wValue(..[1;33m
   163b8:	57 41 52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 28 53     WARNING.[0m - (S
   163c8:	45 54 5f 52 45 50 4f 52 54 2c 20 53 45 54 55 50     ET_REPORT, SETUP
   163d8:	29 20 55 6e 6b 6e 6f 77 6e 20 69 6e 74 65 72 66     ) Unknown interf
   163e8:	61 63 65 20 2d 20 00 1b 5b 31 3b 35 3b 33 31 6d     ace - ..[1;5;31m
   163f8:	45 52 52 4f 52 1b 5b 30 6d 20 2d 20 55 53 42 20     ERROR.[0m - USB 
   16408:	6e 6f 74 20 63 6f 6e 66 69 67 75 72 65 64 2e 2e     not configured..
   16418:	2e 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52 4e 49     .....[1;33mWARNI
   16428:	4e 47 1b 5b 30 6d 20 2d 20 55 53 42 20 54 72 61     NG.[0m - USB Tra
   16438:	6e 73 6d 69 74 20 54 69 6d 65 6f 75 74 2e 2e 2e     nsmit Timeout...
   16448:	61 75 74 6f 2d 72 65 73 74 61 72 74 20 64 69 73     auto-restart dis
   16458:	61 62 6c 65 64 0d 0a 00 1b 5b 31 3b 33 35 6d 44     abled....[1;35mD
   16468:	45 42 55 47 1b 5b 30 6d 20 2d 20 4e 4b 52 4f 20     EBUG.[0m - NKRO 
   16478:	55 53 42 3a 20 00 1b 5b 31 3b 33 33 6d 57 41 52     USB: ..[1;33mWAR
   16488:	4e 49 4e 47 1b 5b 30 6d 20 2d 20 55 53 42 20 54     NING.[0m - USB T
   16498:	72 61 6e 73 6d 69 74 20 54 69 6d 65 6f 75 74 2e     ransmit Timeout.
   164a8:	2e 2e 0d 0a 00 1b 5b 31 3b 33 33 6d 57 41 52 4e     ......[1;33mWARN
   164b8:	49 4e 47 1b 5b 30 6d 20 2d 20 52 41 57 49 4f 20     ING.[0m - RAWIO 
   164c8:	52 78 20 2d 20 54 69 6d 65 6f 75 74 2c 20 64 72     Rx - Timeout, dr
   164d8:	6f 70 70 69 6e 67 20 70 61 63 6b 65 74 2e 00 1b     opping packet...
   164e8:	5b 31 3b 33 33 6d 57 41 52 4e 49 4e 47 1b 5b 30     [1;33mWARNING.[0
   164f8:	6d 20 2d 20 52 41 57 49 4f 20 54 78 20 2d 20 54     m - RAWIO Tx - T
   16508:	69 6d 65 6f 75 74 2c 20 64 72 6f 70 70 69 6e 67     imeout, dropping
   16518:	20 70 61 63 6b 65 74 2e 00 00 00 00 00 45 52 52      packet......ERR
   16528:	4f 52 00 31 3b 35 3b 33 31 00 1b 5b 00 22 20 69     OR.1;5;31..[." i
   16538:	73 20 6e 6f 74 20 61 20 76 61 6c 69 64 20 63 6f     s not a valid co
   16548:	6d 6d 61 6e 64 2e 2e 2e 74 79 70 65 20 1b 5b 33     mmand...type .[3
   16558:	35 6d 68 65 6c 70 1b 5b 30 6d 00 22 00 1b 5b 31     5mhelp.[0m."..[1
   16568:	3b 35 3b 33 31 6d 45 52 52 4f 52 1b 5b 30 6d 20     ;5;31mERROR.[0m 
   16578:	2d 20 53 65 72 69 61 6c 20 6c 69 6e 65 20 62 75     - Serial line bu
   16588:	66 66 65 72 20 69 73 20 66 75 6c 6c 2c 20 64 72     ffer is full, dr
   16598:	6f 70 70 69 6e 67 20 63 68 61 72 61 63 74 65 72     opping character
   165a8:	20 61 6e 64 20 72 65 73 65 74 74 69 6e 67 2e 2e      and resetting..
   165b8:	2e 0d 0a 00 1b 5b 73 0d 0a 00 1b 5b 32 4b 00 1b     .....[s....[2K..
   165c8:	5b 75 00 08 20 08 00 1b 5b 31 3b 35 3b 33 31 6d     [u.. ...[1;5;31m
   165d8:	45 52 52 4f 52 1b 5b 30 6d 20 2d 20 4d 61 78 20     ERROR.[0m - Max 
   165e8:	6e 75 6d 62 65 72 20 6f 66 20 64 69 63 74 69 6f     number of dictio
   165f8:	6e 61 72 69 65 73 20 64 65 66 69 6e 65 64 20 61     naries defined a
   16608:	6c 72 65 61 64 79 2e 2e 2e 0d 0a 00 41 52 4d 00     lready......ARM.
   16618:	43 6f 72 74 65 78 2d 4d 30 00 43 6f 72 74 65 78     Cortex-M0.Cortex
   16628:	2d 4d 33 00 43 6f 72 74 65 78 2d 4d 30 2b 00 43     -M3.Cortex-M0+.C
   16638:	6f 72 74 65 78 2d 4d 34 00 2d 2d 00                 ortex-M4.--.

00016644 <ChipVersion_eepromsize>:
   16644:	00 40 00 20 00 10 00 08 00 04 00 02 00 01 80 00     .@. ............
   16654:	40 00 20 00 ff ff ff ff ff ff ff ff ff ff 00 00     @. .............
   16664:	6d 6b 32 30 64 78 31 32 38 76 6c 66 35 00 6d 6b     mk20dx128vlf5.mk
   16674:	32 30 64 78 31 32 38 76 6c 68 37 00 6d 6b 32 30     20dx128vlh7.mk20
   16684:	64 78 31 32 38 58 58 58 58 00 6d 6b 32 30 64 78     dx128XXXX.mk20dx
   16694:	32 35 36 76 6c 68 37 00 6d 6b 32 30 64 78 32 35     256vlh7.mk20dx25
   166a4:	36 76 6d 63 37 00 6d 6b 32 30 64 78 32 35 36 58     6vmc7.mk20dx256X
   166b4:	58 58 58 00 6d 6b 32 30 64 78 58 58 58 76 6c 68     XXX.mk20dxXXXvlh
   166c4:	37 00 6d 6b 32 32 66 78 35 31 32 61 76 6c 68 31     7.mk22fx512avlh1
   166d4:	32 00 6d 6b 32 32 66 78 58 58 58 61 76 6c 68 31     2.mk22fxXXXavlh1
   166e4:	32 00                                               2.

000166e6 <ChipVersion_nvmsize>:
   166e6:	00 00 ff ff ff ff 20 00 40 00 80 00 ff ff 00 01     ...... .@.......
   166f6:	ff ff 00 02 ff ff ff ff ff ff ff ff 00 02           ..............

00016704 <ChipVersion_pflashsize>:
   16704:	ff ff ff ff ff ff 20 00 ff ff 40 00 ff ff 80 00     ...... ...@.....
   16714:	ff ff 00 01 ff ff 00 02 ff ff 00 04 ff ff 00 04     ................

00016724 <ChipVersion_ramsize>:
   16724:	ff ff 08 00 ff ff 10 00 18 00 20 00 30 00 40 00     .......... .0.@.
   16734:	60 00 80 00 ff ff 00 01 ff ff ff ff ff ff ff ff     `...............

00016744 <basicCLIDict>:
   16744:	fd 71 01 00 fd 67 01 00 21 e3 00 00 03 72 01 00     .q...g..!....r..
   16754:	0f 68 01 00 81 e5 00 00 0c 72 01 00 7f 6f 01 00     .h.......r...o..
   16764:	49 e3 00 00 16 72 01 00 e0 6f 01 00 e1 e3 00 00     I....r...o......
   16774:	1b 72 01 00 f8 6f 01 00 f9 f1 00 00 23 72 01 00     .r...o......#r..
   16784:	48 70 01 00 bd e4 00 00 27 72 01 00 de 70 01 00     Hp......'r...p..
   16794:	59 eb 00 00 30 72 01 00 29 71 01 00 d1 e5 00 00     Y...0r..)q......
   167a4:	35 72 01 00 5d 71 01 00 7d e3 00 00 3c 72 01 00     5r..]q..}...<r..
   167b4:	88 71 01 00 b9 e3 00 00 42 72 01 00 b6 71 01 00     .q......Br...q..
   167c4:	ed e4 00 00 4a 72 01 00 c6 72 01 00 11 e5 00 00     ....Jr...r......
   167d4:	4f 72 01 00 10 73 01 00 99 e7 00 00 00 00 00 00     Or...s..........
   167e4:	00 00 00 00 00 00 00 00                             ........

000167ec <basicCLIDictName>:
   167ec:	47 65 6e 65 72 61 6c 20 43 6f 6d 6d 61 6e 64 73     General Commands
   167fc:	00                                                  .

000167fd <clearCLIDict_DescEntry>:
   167fd:	43 6c 65 61 72 20 74 68 65 20 73 63 72 65 65 6e     Clear the screen
   1680d:	2e 00                                               ..

0001680f <cliDebugCLIDict_DescEntry>:
   1680f:	45 6e 61 62 6c 65 73 2f 44 69 73 61 62 6c 65 73     Enables/Disables
   1681f:	20 68 65 78 20 6f 75 74 70 75 74 20 6f 66 20 74      hex output of t
   1682f:	68 65 20 6d 6f 73 74 20 72 65 63 65 6e 74 20 63     he most recent c
   1683f:	6c 69 20 69 6e 70 75 74 2e 00 1b 5b 32 4a 1b 5b     li input...[2J.[
   1684f:	48 0d 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b     H...[1;32mINFO.[
   1685f:	30 6d 20 2d 20 48 65 78 20 64 65 62 75 67 20 6d     0m - Hex debug m
   1686f:	6f 64 65 20 64 69 73 61 62 6c 65 64 2e 2e 2e 0d     ode disabled....
   1687f:	0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30     ...[1;32mINFO.[0
   1688f:	6d 20 2d 20 48 65 78 20 64 65 62 75 67 20 6d 6f     m - Hex debug mo
   1689f:	64 65 20 65 6e 61 62 6c 65 64 2e 2e 2e 0d 0a 00     de enabled......
   168af:	1b 5b 33 38 3b 32 3b 32 35 35 3b 31 30 30 3b 30     .[38;2;255;100;0
   168bf:	6d 54 52 55 45 43 4f 4c 4f 52 1b 5b 30 6d 00 0d     mTRUECOLOR.[0m..
   168cf:	0a 1b 5b 31 3b 33 32 6d 00 1b 5b 30 6d 0d 0a 00     ..[1;32m..[0m...
   168df:	20 1b 5b 33 35 6d 00 4c 61 74 65 6e 63 79 0d 0a      .[35m.Latency..
   168ef:	00 3c 69 3e 3a 3c 6d 6f 64 75 6c 65 3e 09 3c 63     .<i>:<module>.<c
   168ff:	6f 75 6e 74 3e 09 3c 6d 69 6e 3e 09 3c 61 76 67     ount>.<min>.<avg
   1690f:	3e 09 3c 6c 61 73 74 3e 09 3c 6d 61 78 3e 00 1b     >.<last>.<max>..
   1691f:	5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20 2d     [1;32mINFO.[0m -
   1692f:	20 50 65 72 69 6f 64 20 43 6c 6f 63 6b 20 43 79      Period Clock Cy
   1693f:	63 6c 65 73 3a 20 00 1b 5b 31 3b 33 33 6d 57 41     cles: ..[1;33mWA
   1694f:	52 4e 49 4e 47 1b 5b 30 6d 20 2d 20 4e 6f 20 65     RNING.[0m - No e
   1695f:	6e 74 72 6f 70 79 20 61 76 61 69 6c 61 62 6c 65     ntropy available
   1696f:	21 0d 0a 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b     !....[1;32mINFO.
   1697f:	5b 30 6d 20 2d 20 52 61 6e 64 3a 20 00 1b 63 00     [0m - Rand: ..c.
   1698f:	1b 5b 31 3b 33 32 6d 49 4e 46 4f 1b 5b 30 6d 20     .[1;32mINFO.[0m 
   1699f:	2d 20 6e 73 20 70 65 72 20 63 79 63 6c 65 74 69     - ns per cycleti
   169af:	63 6b 3a 20 00 1b 5b 31 3b 33 32 6d 49 4e 46 4f     ck: ..[1;32mINFO
   169bf:	1b 5b 30 6d 20 2d 20 3c 73 79 73 74 69 63 6b 20     .[0m - <systick 
   169cf:	6d 73 3e 3a 3c 63 79 63 6c 65 74 69 63 6b 73 20     ms>:<cycleticks 
   169df:	73 69 6e 63 65 20 73 79 73 74 69 63 6b 3e 0d 0a     since systick>..
   169ef:	00 20 1b 5b 31 6d 52 65 76 69 73 69 6f 6e 3a 1b     . .[1mRevision:.
   169ff:	5b 30 6d 20 20 20 20 20 20 35 36 34 62 36 32 36     [0m      564b626
   16a0f:	63 66 32 38 32 32 33 33 39 62 64 62 33 63 63 30     cf2822339bdb3cc0
   16a1f:	63 35 61 61 39 62 61 33 65 35 36 62 33 38 63 32     c5aa9ba3e56b38c2
   16a2f:	32 0d 0a 00 20 1b 5b 31 6d 52 65 76 69 73 69 6f     2... .[1mRevisio
   16a3f:	6e 20 23 3a 1b 5b 30 6d 20 20 20 20 34 39 0d 0a     n #:.[0m    49..
   16a4f:	00 20 1b 5b 31 6d 56 65 72 73 69 6f 6e 3a 1b 5b     . .[1mVersion:.[
   16a5f:	30 6d 20 20 20 20 20 20 20 20 28 2b 00 3a 34 39     0m        (+.:49
   16a6f:	29 0d 0a 00 20 1b 5b 31 6d 42 72 61 6e 63 68 3a     )... .[1mBranch:
   16a7f:	1b 5b 30 6d 20 20 20 20 20 20 20 20 6d 61 73 74     .[0m        mast
   16a8f:	65 72 0d 0a 00 20 1b 5b 31 6d 54 72 65 65 20 53     er... .[1mTree S
   16a9f:	74 61 74 75 73 3a 1b 5b 30 6d 20 20 20 44 69 72     tatus:.[0m   Dir
   16aaf:	74 79 0d 0a 09 65 72 67 6f 64 6f 78 2f 63 6f 6e     ty...ergodox/con
   16abf:	74 72 6f 6c 6c 65 72 2f 4b 65 79 62 6f 61 72 64     troller/Keyboard
   16acf:	73 2f 4d 44 45 72 67 6f 31 2d 44 65 66 61 75 6c     s/MDErgo1-Defaul
   16adf:	74 2d 30 2e 6b 6c 6c 0d 0a 09 65 72 67 6f 64 6f     t-0.kll...ergodo
   16aef:	78 2f 63 6f 6e 74 72 6f 6c 6c 65 72 2f 4b 65 79     x/controller/Key
   16aff:	62 6f 61 72 64 73 2f 4d 44 45 72 67 6f 31 2d 44     boards/MDErgo1-D
   16b0f:	65 66 61 75 6c 74 2d 31 2e 6b 6c 6c 0d 0a 09 65     efault-1.kll...e
   16b1f:	72 67 6f 64 6f 78 2f 63 6f 6e 74 72 6f 6c 6c 65     rgodox/controlle
   16b2f:	72 2f 4b 65 79 62 6f 61 72 64 73 2f 4d 44 45 72     r/Keyboards/MDEr
   16b3f:	67 6f 31 2d 44 65 66 61 75 6c 74 2d 32 2e 6b 6c     go1-Default-2.kl
   16b4f:	6c 0d 0a 09 65 72 67 6f 64 6f 78 2f 63 6f 6e 74     l...ergodox/cont
   16b5f:	72 6f 6c 6c 65 72 2f 4b 65 79 62 6f 61 72 64 73     roller/Keyboards
   16b6f:	2f 65 72 67 6f 64 6f 78 2d 6c 2e 62 61 73 68 0d     /ergodox-l.bash.
   16b7f:	0a 09 65 72 67 6f 64 6f 78 2f 63 6f 6e 74 72 6f     ..ergodox/contro
   16b8f:	6c 6c 65 72 2f 4b 65 79 62 6f 61 72 64 73 2f 65     ller/Keyboards/e
   16b9f:	72 67 6f 64 6f 78 2d 72 2e 62 61 73 68 0d 0a 09     rgodox-r.bash...
   16baf:	65 72 67 6f 64 6f 78 2f 63 6f 6e 74 72 6f 6c 6c     ergodox/controll
   16bbf:	65 72 2f 63 6f 6d 70 69 6c 65 5f 63 6f 6d 6d 61     er/compile_comma
   16bcf:	6e 64 73 2e 6a 73 6f 6e 0d 0a 09 65 72 67 6f 64     nds.json...ergod
   16bdf:	6f 78 2f 63 6f 6e 74 72 6f 6c 6c 65 72 2f 74 61     ox/controller/ta
   16bef:	67 73 0d 0a 09 65 72 67 6f 64 6f 78 2f 74 6f 6d     gs...ergodox/tom
   16bff:	2d 73 65 74 75 70 2e 73 68 0d 0a 00 20 1b 5b 31     -setup.sh... .[1
   16c0f:	6d 52 65 70 6f 20 4f 72 69 67 69 6e 3a 1b 5b 30     mRepo Origin:.[0
   16c1f:	6d 20 20 20 67 69 74 40 67 69 74 68 75 62 2e 63     m   git@github.c
   16c2f:	6f 6d 3a 74 68 65 74 6f 6d 63 72 61 69 67 2f 6b     om:thetomcraig/k
   16c3f:	65 79 62 6f 61 72 64 5f 75 74 69 6c 69 74 69 65     eyboard_utilitie
   16c4f:	73 2e 67 69 74 0d 0a 00 20 1b 5b 31 6d 43 6f 6d     s.git... .[1mCom
   16c5f:	6d 69 74 20 44 61 74 65 3a 1b 5b 30 6d 20 20 20     mit Date:.[0m   
   16c6f:	32 30 31 38 2d 31 32 2d 30 31 20 31 31 3a 30 31     2018-12-01 11:01
   16c7f:	3a 30 39 20 2d 30 38 30 30 0d 0a 00 20 1b 5b 31     :09 -0800... .[1
   16c8f:	6d 43 6f 6d 6d 69 74 20 41 75 74 68 6f 72 3a 1b     mCommit Author:.
   16c9f:	5b 30 6d 20 54 6f 6d 20 43 72 61 69 67 20 3c 74     [0m Tom Craig <t
   16caf:	68 65 74 6f 6d 63 72 61 69 67 40 69 63 6c 6f 75     hetomcraig@iclou
   16cbf:	64 2e 63 6f 6d 3e 0d 0a 00 20 1b 5b 31 6d 42 75     d.com>... .[1mBu
   16ccf:	69 6c 64 20 44 61 74 65 3a 1b 5b 30 6d 20 20 20     ild Date:.[0m   
   16cdf:	20 32 30 31 38 2d 31 32 2d 30 33 20 31 37 3a 31      2018-12-03 17:1
   16cef:	36 3a 34 36 20 2d 30 38 30 30 0d 0a 00 20 1b 5b     6:46 -0800... .[
   16cff:	31 6d 42 75 69 6c 64 20 4f 53 3a 1b 5b 30 6d 20     1mBuild OS:.[0m 
   16d0f:	20 20 20 20 20 47 65 6e 65 72 69 63 0d 0a 00 20          Generic... 
   16d1f:	1b 5b 31 6d 43 6f 6d 70 69 6c 65 72 3a 1b 5b 30     .[1mCompiler:.[0
   16d2f:	6d 20 20 20 20 20 20 2f 75 73 72 2f 6c 6f 63 61     m      /usr/loca
   16d3f:	6c 2f 62 69 6e 2f 61 72 6d 2d 6e 6f 6e 65 2d 65     l/bin/arm-none-e
   16d4f:	61 62 69 2d 67 63 63 20 37 2e 33 2e 31 0d 0a 00     abi-gcc 7.3.1...
   16d5f:	20 1b 5b 31 6d 41 72 63 68 69 74 65 63 74 75 72      .[1mArchitectur
   16d6f:	65 3a 1b 5b 30 6d 20 20 61 72 6d 0d 0a 00 20 1b     e:.[0m  arm... .
   16d7f:	5b 31 6d 43 68 69 70 20 43 6f 6d 70 69 6c 65 64     [1mChip Compiled
   16d8f:	3a 1b 5b 30 6d 20 6d 6b 32 30 64 78 32 35 36 20     :.[0m mk20dx256 
   16d9f:	28 6d 6b 32 30 64 78 32 35 36 76 6c 68 37 29 0d     (mk20dx256vlh7).
   16daf:	0a 00 20 1b 5b 31 6d 43 50 55 3a 1b 5b 30 6d 20     .. .[1mCPU:.[0m 
   16dbf:	20 20 20 20 20 20 20 20 20 20 63 6f 72 74 65 78               cortex
   16dcf:	2d 6d 34 0d 0a 00 20 1b 5b 31 6d 44 65 76 69 63     -m4... .[1mDevic
   16ddf:	65 3a 1b 5b 30 6d 20 20 20 20 20 20 20 20 4b 65     e:.[0m        Ke
   16def:	79 62 6f 61 72 64 0d 0a 00 20 1b 5b 31 6d 4d 6f     yboard... .[1mMo
   16dff:	64 75 6c 65 73 3a 1b 5b 30 6d 20 20 20 20 20 20     dules:.[0m      
   16e0f:	20 53 63 61 6e 28 49 6e 66 69 6e 69 74 79 5f 45      Scan(Infinity_E
   16e1f:	72 67 6f 64 6f 78 29 20 4d 61 63 72 6f 28 50 69     rgodox) Macro(Pi
   16e2f:	78 65 6c 4d 61 70 29 20 4f 75 74 70 75 74 28 55     xelMap) Output(U
   16e3f:	53 42 29 20 44 65 62 75 67 28 66 75 6c 6c 29 0d     SB) Debug(full).
   16e4f:	0a 00 20 1b 5b 31 6d 43 50 55 20 44 65 74 65 63     .. .[1mCPU Detec
   16e5f:	74 65 64 3a 1b 5b 30 6d 20 20 00 20 1b 5b 31 6d     ted:.[0m  . .[1m
   16e6f:	43 50 55 20 49 64 3a 1b 5b 30 6d 20 20 20 20 20     CPU Id:.[0m     
   16e7f:	20 20 20 00 0d 0a 20 20 28 49 6d 70 6c 65 6d 65        ...  (Impleme
   16e8f:	6e 74 6f 72 3a 00 29 28 56 61 72 69 61 6e 74 3a     ntor:.)(Variant:
   16e9f:	00 29 28 41 72 63 68 3a 00 29 28 50 61 72 74 4e     .)(Arch:.)(PartN
   16eaf:	6f 3a 00 29 28 52 65 76 69 73 69 6f 6e 3a 00 20     o:.)(Revision:. 
   16ebf:	1b 5b 31 6d 44 65 76 69 63 65 20 49 64 3a 1b 5b     .[1mDevice Id:.[
   16ecf:	30 6d 20 20 20 20 20 00 0d 0a 20 20 28 50 69 6e     0m     ...  (Pin
   16edf:	63 6f 75 6e 74 3a 00 29 28 46 61 6d 69 6c 79 3a     count:.)(Family:
   16eef:	00 29 28 44 69 65 3a 00 29 28 52 65 76 3a 00 20     .)(Die:.)(Rev:. 
   16eff:	1b 5b 31 6d 46 6c 61 73 68 20 43 66 67 3a 1b 5b     .[1mFlash Cfg:.[
   16f0f:	30 6d 20 20 20 20 20 00 0d 0a 20 20 28 46 6c 65     0m     ...  (Fle
   16f1f:	78 4e 56 4d 3a 00 6b 42 29 28 50 46 6c 61 73 68     xNVM:.kB)(PFlash
   16f2f:	3a 00 6b 42 29 28 45 45 50 52 4f 4d 3a 00 29 28     :.kB)(EEPROM:.)(
   16f3f:	44 45 50 41 52 54 3a 00 20 1b 5b 31 6d 52 41 4d     DEPART:. .[1mRAM
   16f4f:	3a 1b 5b 30 6d 20 20 20 20 20 20 20 20 20 20 20     :.[0m           
   16f5f:	00 20 6b 42 0d 0a 00 20 1b 5b 31 6d 55 6e 69 71     . kB... .[1mUniq
   16f6f:	75 65 20 49 64 3a 1b 5b 30 6d 20 20 20 20 20 00     ue Id:.[0m     .

00016f7f <colorTestCLIDict_DescEntry>:
   16f7f:	44 69 73 70 6c 61 79 73 20 61 20 54 72 75 65 20     Displays a True 
   16f8f:	43 6f 6c 6f 72 20 41 4e 53 49 20 74 65 73 74 20     Color ANSI test 
   16f9f:	73 65 71 75 65 6e 63 65 20 74 6f 20 74 65 73 74     sequence to test
   16faf:	20 74 65 72 6d 69 6e 61 6c 2e 20 49 66 20 69 74      terminal. If it
   16fbf:	20 64 69 73 70 6c 61 79 73 20 69 6e 20 63 6f 6c      displays in col
   16fcf:	6f 72 2c 20 79 6f 75 27 72 65 20 67 6f 6f 64 2e     or, you're good.
   16fdf:	00                                                  .

00016fe0 <helpCLIDict_DescEntry>:
   16fe0:	59 6f 75 27 72 65 20 6c 6f 6f 6b 69 6e 67 20 61     You're looking a
   16ff0:	74 20 69 74 20 3a 50 00                             t it :P.

00016ff8 <latencyCLIDict_DescEntry>:
   16ff8:	53 68 6f 77 20 6c 61 74 65 6e 63 79 20 6f 66 20     Show latency of 
   17008:	73 70 65 63 69 66 69 63 20 6d 6f 64 75 6c 65 73     specific modules
   17018:	20 61 6e 64 20 72 6f 75 74 69 69 6e 65 73 2e 20      and routiines. 
   17028:	53 70 65 63 69 66 79 20 69 6e 64 65 78 20 66 6f     Specify index fo
   17038:	72 20 61 20 73 69 6e 67 6c 65 20 69 74 65 6d 00     r a single item.

00017048 <ledCLIDict_DescEntry>:
   17048:	45 6e 61 62 6c 65 73 2f 44 69 73 61 62 6c 65 73     Enables/Disables
   17058:	20 69 6e 64 69 63 61 74 6f 72 20 4c 45 44 2e 20      indicator LED. 
   17068:	54 72 79 20 61 20 63 6f 75 70 6c 65 20 74 69 6d     Try a couple tim
   17078:	65 73 20 6a 75 73 74 20 69 6e 20 63 61 73 65 20     es just in case 
   17088:	74 68 65 20 4c 45 44 20 69 73 20 69 6e 20 61 6e     the LED is in an
   17098:	20 6f 64 64 20 73 74 61 74 65 2e 0d 0a 09 09 1b      odd state......
   170a8:	5b 33 33 6d 57 61 72 6e 69 6e 67 1b 5b 30 6d 3a     [33mWarning.[0m:
   170b8:	20 4d 61 79 20 61 64 76 65 72 73 65 6c 79 20 61      May adversely a
   170c8:	66 66 65 63 74 20 73 6f 6d 65 20 6d 6f 64 75 6c     ffect some modul
   170d8:	65 73 2e 2e 2e 00                                   es....

000170de <periodicCLIDict_DescEntry>:
   170de:	53 65 74 20 74 68 65 20 6e 75 6d 62 65 72 20 6f     Set the number o
   170ee:	66 20 63 6c 6f 63 6b 20 63 79 63 6c 65 73 20 62     f clock cycles b
   170fe:	65 74 77 65 65 6e 20 70 65 72 69 6f 64 69 63 20     etween periodic 
   1710e:	73 63 61 6e 73 2e 00 1b 5b 32 4b 0d 00 1b 5b 31     scans...[2K...[1
   1711e:	3b 33 34 6d 3a 1b 5b 30 6d 20 00                    ;34m:.[0m .

00017129 <randCLIDict_DescEntry>:
   17129:	49 66 20 65 6e 74 72 6f 70 79 20 61 76 61 69 6c     If entropy avail
   17139:	61 62 6c 65 2c 20 70 72 69 6e 74 20 61 20 72 61     able, print a ra
   17149:	6e 64 6f 6d 20 33 32 2d 62 69 74 20 6e 75 6d 62     ndom 32-bit numb
   17159:	65 72 2e 00                                         er..

0001715d <reloadCLIDict_DescEntry>:
   1715d:	53 69 67 6e 61 6c 73 20 6d 69 63 72 6f 63 6f 6e     Signals microcon
   1716d:	74 72 6f 6c 6c 65 72 20 74 6f 20 72 65 66 6c 61     troller to refla
   1717d:	73 68 2f 72 65 6c 6f 61 64 2e 00                    sh/reload..

00017188 <resetCLIDict_DescEntry>:
   17188:	52 65 73 65 74 73 20 74 68 65 20 74 65 72 6d 69     Resets the termi
   17198:	6e 61 6c 20 62 61 63 6b 20 74 6f 20 69 6e 69 74     nal back to init
   171a8:	69 61 6c 20 73 65 74 74 69 6e 67 73 2e 00           ial settings..

000171b6 <restartCLIDict_DescEntry>:
   171b6:	53 65 6e 64 73 20 61 20 73 6f 66 74 77 61 72 65     Sends a software
   171c6:	20 72 65 73 74 61 72 74 2c 20 73 68 6f 75 6c 64      restart, should
   171d6:	20 62 65 20 73 69 6d 69 6c 61 72 20 74 6f 20 70      be similar to p
   171e6:	6f 77 65 72 69 6e 67 20 6f 6e 20 74 68 65 20 64     owering on the d
   171f6:	65 76 69 63 65 2e 00 63 6c 65 61 72 00 63 6c 69     evice..clear.cli
   17206:	44 65 62 75 67 00 63 6f 6c 6f 72 54 65 73 74 00     Debug.colorTest.
   17216:	68 65 6c 70 00 6c 61 74 65 6e 63 79 00 6c 65 64     help.latency.led
   17226:	00 70 65 72 69 6f 64 69 63 00 72 61 6e 64 00 72     .periodic.rand.r
   17236:	65 6c 6f 61 64 00 72 65 73 65 74 00 72 65 73 74     eload.reset.rest
   17246:	61 72 74 00 74 69 63 6b 00 76 65 72 73 69 6f 6e     art.tick.version
   17256:	00 4b 31 30 2f 31 32 00 4b 32 30 2f 32 32 00 4b     .K10/12.K20/22.K
   17266:	33 30 2f 31 31 2f 36 31 00 4b 34 30 2f 32 31 00     30/11/61.K40/21.
   17276:	4b 36 30 2f 36 32 00 4b 37 30 00 33 32 2d 70 69     K60/62.K70.32-pi
   17286:	6e 00 34 38 2d 70 69 6e 00 36 34 2d 70 69 6e 00     n.48-pin.64-pin.
   17296:	38 30 2d 70 69 6e 00 38 31 2f 31 32 31 2d 70 69     80-pin.81/121-pi
   172a6:	6e 00 31 30 30 2d 70 69 6e 00 31 34 34 2d 70 69     n.100-pin.144-pi
   172b6:	6e 00 57 4c 43 53 50 00 32 35 36 2d 70 69 6e 00     n.WLCSP.256-pin.

000172c6 <tickCLIDict_DescEntry>:
   172c6:	44 69 73 70 6c 61 79 73 20 74 68 65 20 66 75 6e     Displays the fun
   172d6:	64 61 6d 65 6e 74 61 6c 20 74 69 63 6b 20 73 69     damental tick si
   172e6:	7a 65 2c 20 61 6e 64 20 63 75 72 72 65 6e 74 20     ze, and current 
   172f6:	74 69 63 6b 73 20 73 69 6e 63 65 20 6c 61 73 74     ticks since last
   17306:	20 73 79 73 74 69 63 6b 2e 00                        systick..

00017310 <versionCLIDict_DescEntry>:
   17310:	56 65 72 73 69 6f 6e 20 69 6e 66 6f 72 6d 61 74     Version informat
   17320:	69 6f 6e 20 61 62 6f 75 74 20 74 68 69 73 20 66     ion about this f
   17330:	69 72 6d 77 61 72 65 2e 00 1b 5b 31 3b 35 3b 33     irmware...[1;5;3
   17340:	31 6d 45 52 52 4f 52 1b 5b 30 6d 20 2d 20 4e 6f     1mERROR.[0m - No
   17350:	20 6d 6f 72 65 20 6c 61 74 65 6e 63 79 20 72 65      more latency re
   17360:	73 6f 75 72 63 65 73 20 61 76 61 69 6c 61 62 6c     sources availabl
   17370:	65 2e 2e 2e 0d 0a 00                                e......

00017377 <led_pin>:
   17377:	00 05 00 00 00                                      .....
